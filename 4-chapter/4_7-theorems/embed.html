




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Theorems :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/index.html" rel="canonical" type="text/html" title="Theorems :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/index.xml" rel="alternate" type="application/rss+xml" title="Theorems :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/index.print.html" rel="alternate" type="text/html" title="Theorems :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/tele.html" rel="alternate" type="text/html" title="Theorems :: CIS 301 Textbook">
    
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1697816065" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1697816065" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1697816065" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1697816065" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1697816065" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1697816065" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1697816065" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1697816065" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1697816065" rel="stylesheet">
    
    
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-light-theme.css?1697816065" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1697816065" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1697816065" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1697816065" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1697816065"></script>
    
    
    
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1697816065" rel="stylesheet">

    
  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/embed.html">
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
    
    
    
<h2 id="definition">Definition</h2>
<p>A <em>theorem</em> in propositional logic is something that is always true with no need for premises. The truth table for a theorem is always a <em>tautology</em> &ndash; it is true for any truth assignment.</p>
<p>To express a theorem as a sequent, we write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (theorem)</span></span></code></pre></div><p>This shows that we are trying to prove our theorem with NO premises. Such a proof will always immediately begin with a subproof, as there are no premises to process.</p>
<h2 id="law-of-the-excluded-middle-revisited">Law of the excluded middle, revisited</h2>
<p>For example, the law of the excluded middle (LEM), <code>p ∨ ¬p</code>, is a theorem. We proved in section 4.5 that <code>p ∨ ¬p</code> is always true with no premises:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ p ∨ ¬ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. ¬ (p ∨ ¬ p)      assume
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. p            assume
</span></span><span style="display:flex;"><span>            5. p ∨ ¬ p      ∨i1 4
</span></span><span style="display:flex;"><span>            6. ⊥            ¬e 5 2
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        7.  ¬ p             ¬i 3
</span></span><span style="display:flex;"><span>        8.  p ∨ ¬ p         ∨i2 7
</span></span><span style="display:flex;"><span>        9.  ⊥               ¬e 8 2
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    10. p ∨ ¬ p             pbc 1
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We also see that the truth table for LEM is a tautology:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>      *
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>p | p ∨ ¬ p
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>T |   T F
</span></span><span style="display:flex;"><span>F |   T T
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>Tautology</span></span></code></pre></div><h2 id="another-example">Another example</h2>
<p>Suppose we wish to prove the following theorem of propositional logic:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p → q) → ((¬p → q) → q)</span></span></code></pre></div><p>We would need to prove the sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)</span></span></code></pre></div><p>We see that the top-level operator of what we are trying to prove is an implies operator. So, we begin our proof using the strategy for implies introduction:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Inside subproof 1, we are trying to prove <code>(¬p → q) → q</code>. The top-level operator of that statement is an implies, so we nest another subproof with the goal of using implies introduction:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. ¬p → q           assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: reach q
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use →i to conclude (¬p → q) → q
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Now we must prove <code>q</code> in subproof 3. We have available propositions <code>p → q</code> and <code>¬p → q</code> &ndash; we can see that if we had LEM (<code>p ∨ ¬p</code>) available, then we could use OR elimination to get our <code>q</code> in both cases. We insert the LEM proof into subproof 3:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. ¬p → q                   assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //Begin LEM proof, p ∨ ¬p
</span></span><span style="display:flex;"><span>            5. {
</span></span><span style="display:flex;"><span>                6. ¬ (p ∨ ¬ p)          assume
</span></span><span style="display:flex;"><span>                7. {
</span></span><span style="display:flex;"><span>                    8. p                assume
</span></span><span style="display:flex;"><span>                    9. p ∨ ¬ p          ∨i1 8
</span></span><span style="display:flex;"><span>                    10. ⊥               ¬e 9 6
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                11.  ¬ p                ¬i 7
</span></span><span style="display:flex;"><span>                12.  p ∨ ¬ p            ∨i2 11
</span></span><span style="display:flex;"><span>                13.  ⊥                  ¬e 12 6
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            14. p ∨ ¬ p                 pbc 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //End LEM proof for p ∨ ¬p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //use OR elimination on p ∨ ¬p 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: reach q
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use →i to conclude (¬p → q) → q
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Finally, we do OR elimination with <code>p ∨ ¬p</code> and tie together the rest of the proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. ¬p → q                   assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //Begin LEM proof, p ∨ ¬p
</span></span><span style="display:flex;"><span>            5. {
</span></span><span style="display:flex;"><span>                6. ¬ (p ∨ ¬ p)          assume
</span></span><span style="display:flex;"><span>                7. {
</span></span><span style="display:flex;"><span>                    8. p                assume
</span></span><span style="display:flex;"><span>                    9. p ∨ ¬ p          ∨i1 8
</span></span><span style="display:flex;"><span>                    10. ⊥               ¬e 9 6
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                11.  ¬ p                ¬i 7
</span></span><span style="display:flex;"><span>                12.  p ∨ ¬ p            ∨i2 11
</span></span><span style="display:flex;"><span>                13.  ⊥                  ¬e 12 6
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            14. p ∨ ¬ p                 pbc 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //End LEM proof for p ∨ ¬p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //use OR elimination on p ∨ ¬p, try to reach q
</span></span><span style="display:flex;"><span>            15. {
</span></span><span style="display:flex;"><span>                16. p               assume
</span></span><span style="display:flex;"><span>                17. q               →e 2 16
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            18. {
</span></span><span style="display:flex;"><span>                19. ¬ p             assume
</span></span><span style="display:flex;"><span>                20. q               →e 4 19
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            21. q                   ∨e 14 15 18
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: reach q
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use →i to conclude (¬p → q) → q
</span></span><span style="display:flex;"><span>        22. (¬p → q) → q            →i 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    23. (p → q) → ((¬p → q) → q)    →i 1
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>If we complete a truth table for <code>(p → q) → ((¬p → q) → q)</code>, we also see that it is a tautology:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>              *
</span></span><span style="display:flex;"><span>-------------------------------
</span></span><span style="display:flex;"><span>p q | (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>-------------------------------
</span></span><span style="display:flex;"><span>T T |    T    T   F  T    T
</span></span><span style="display:flex;"><span>T F |    F    T   F  T    F
</span></span><span style="display:flex;"><span>F T |    T    T   T  T    T
</span></span><span style="display:flex;"><span>F F |    T    T   T  F    T
</span></span><span style="display:flex;"><span>------------------------------
</span></span><span style="display:flex;"><span>Tautology</span></span></code></pre></div>
            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1697816065" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1697816065" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1697816065" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/embed-iframe.js?1697816065 defer"></script>
  </body>
</html>
