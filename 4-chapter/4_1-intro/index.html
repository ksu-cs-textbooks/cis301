<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments â€“ of which there are exponentially many. In this chapter, we will learn the process of natural deduction in propositional logic. This will allow us to start with a set of known facts (premises) and apply a series of rules to see if we can reach some goal conclusion."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction :: CIS 301 Textbook"><meta name=twitter:description content="While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments â€“ of which there are exponentially many. In this chapter, we will learn the process of natural deduction in propositional logic. This will allow us to start with a set of known facts (premises) and apply a series of rules to see if we can reach some goal conclusion."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/4-chapter/4_1-intro/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Introduction :: CIS 301 Textbook"><meta property="og:description" content="While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments â€“ of which there are exponentially many. In this chapter, we will learn the process of natural deduction in propositional logic. This will allow us to start with a set of known facts (premises) and apply a series of rules to see if we can reach some goal conclusion."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Propositional Logic Proofs"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-04-25T17:02:46-05:00"><meta itemprop=name content="Introduction :: CIS 301 Textbook"><meta itemprop=description content="While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments â€“ of which there are exponentially many. In this chapter, we will learn the process of natural deduction in propositional logic. This will allow us to start with a set of known facts (premises) and apply a series of rules to see if we can reach some goal conclusion."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-04-25T17:02:46-05:00"><meta itemprop=wordCount content="1210"><title>Introduction :: CIS 301 Textbook</title>
<link href=/cis301/4-chapter/4_1-intro/index.xml rel=alternate type=application/rss+xml title="Introduction :: CIS 301 Textbook"><link href=/cis301/4-chapter/4_1-intro/index.print.html rel=alternate type=text/html title="Introduction :: CIS 301 Textbook"><link href=/cis301/4-chapter/4_1-intro/tele.html rel=alternate type=text/html title="Introduction :: CIS 301 Textbook"><link href=/cis301/4-chapter/4_1-intro/embed.html rel=alternate type=text/html title="Introduction :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1736806682 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1736806682 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1736806682 rel=stylesheet><link href=/cis301/css/auto-complete.css?1736806682 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1736806682 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1736806682 rel=stylesheet><link href=/cis301/css/fonts.css?1736806682 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1736806682 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1736806682 rel=stylesheet><link href=/cis301/css/theme-auto.css?1736806682 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1736806682 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1736806682 rel=stylesheet><link href=/cis301/css/print.css?1736806682 rel=stylesheet media=print><script src=/cis301/js/variant.js?1736806682></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1736806682 rel=stylesheet></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=/cis301/4-chapter/4_1-intro/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#sequents-premises-and-conclusions>Sequents, premises, and conclusions</a></li><li><a href=#sequent-validity>Sequent validity</a><ul><li><a href=#sequent-validity-in-logika-using-truth-tables>Sequent validity in Logika using truth tables</a></li></ul></li><li><a href=#proving-sequents-using-natural-deduction>Proving sequents using natural deduction</a></li><li><a href=#logika-natural-deduction-proof-syntax>Logika natural deduction proof syntax</a></li><li><a href=#premise-justification>Premise justification</a></li><li><a href=#deduction-rules>Deduction rules</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/4-chapter/><span itemprop=name>Propositional Logic Proofs</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Introduction</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/4-chapter/4_1-intro.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/4-chapter/4_1-intro/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/4-chapter/ title="Propositional Logic Proofs (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/4-chapter/4_2-andrules/ title="AND Rules (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/4-chapter/4_1-intro/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/4-chapter/4_1-intro/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments &ndash; of which there are exponentially many. In this chapter, we will learn the process of <em>natural deduction</em> in propositional logic. This will allow us to start with a set of known facts (<em>premises</em>) and apply a series of rules to see if we can reach some goal <em>conclusion</em>. Essentially, we will be able to see whether a given conclusion necessarily follows from a set of premises.</p><p>We will use the Logika tool to check whether our proofs correctly follow our deduction rules. HOWEVER, these proofs can and do exist outside of Logika. Different settings use slightly different syntaxes for the deduction rules, but the rules and proof system are the same. We will merely use Logika to help check our work.</p><h2 id=sequents-premises-and-conclusions>Sequents, premises, and conclusions</h2><p>A <em>sequent</em> is a mathematical term for an assertion or an argument. We use the notation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>p0, p1, ..., pm âŠ¢ c</span></span></code></pre></div><p>The <em>p0, p1, &mldr;, pm</em> are called <em>premises</em> and <em>c</em> is called the <em>conclusion</em>. The <code>âŠ¢</code> is called the <em>turnstile operator</em>, and we read it as &ldquo;prove&rdquo;. The full sequent is read as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Statements p0, p1, ..., pm PROVE c</span></span></code></pre></div><p>A sequent is saying that if we accept statements <em>p0, p1, &mldr;, pm</em> as facts, then we guarantee that <em>c</em> is a fact as well.</p><p>For example, in the sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>p â†’ q , Â¬ q  âŠ¢  Â¬ p</span></span></code></pre></div><p>The premises are: <code>p â†’ q</code> and <code>Â¬q</code>, and the conclusion is <code>Â¬p</code>.</p><p>(Shortcut: we can use <code>|-</code> in place of the <code>âŠ¢</code> turnstile operator.)</p><h2 id=sequent-validity>Sequent validity</h2><p>A sequent is said to be <em>valid</em> if, for every truth assignment which make the premises true, then the conclusion is also true.</p><p>For example, consider the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>p â†’ q , Â¬q  âŠ¢  Â¬p</span></span></code></pre></div><p>To check if this sequent is valid, we must find all truth assignments for which both premises are true, and then ensure that those truth assignments also make the conclusion true.</p><h3 id=sequent-validity-in-logika-using-truth-tables>Sequent validity in Logika using truth tables</h3><p>We can use a different kind of truth table to prove the validity of a sequent in Logika:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>         *     *     *
</span></span><span class=line><span class=cl>---------------------------
</span></span><span class=line><span class=cl>p q # (p â†’: q, Â¬q) âŠ¢ Â¬p
</span></span><span class=line><span class=cl>---------------------------
</span></span><span class=line><span class=cl>T T #    T     F     F
</span></span><span class=line><span class=cl>T F #    F     T     F
</span></span><span class=line><span class=cl>F T #    T     F     T
</span></span><span class=line><span class=cl>F F #    T     T     T
</span></span><span class=line><span class=cl>---------------------------
</span></span><span class=line><span class=cl>Valid [F F]</span></span></code></pre></div><p>Notice that instead of putting just one logical formula, we put the entire sequent &ndash; the premises are in a comma-separated list inside parentheses, then the turnstile operator (which we type using the keys <code>|-</code> in Logika), and then the conclusion. We mark the top-level operator of each premise and conclusion.</p><p>Examining each row in the above truth table, we see that only the truth assignment [F F] makes both premises (<code>p â†’ q</code> and <code>Â¬q</code>) true. We look right to see that the same truth assignment also makes the conclusion (<code> Â¬p</code>) true, which means that the sequent is valid.</p><h2 id=proving-sequents-using-natural-deduction>Proving sequents using natural deduction</h2><p>Now we will turn to the next section of the course &ndash; using <em>natural deduction</em> to similarly prove the validity of sequents. Instead of filling out truth tables (which becomes cumbersome very quickly), we will apply a series of <em>deduction rules</em> to allow us to conclude new claims from our premises. In turn, we can use our deduction rules on these new claims to conclude more and more, until (hopefully) we are able to claim our conclusion. If we can do that, then our sequent was valid.</p><h2 id=logika-natural-deduction-proof-syntax>Logika natural deduction proof syntax</h2><p>We will use the following format in Logika to start a natural deduction proof for propositional logic. Each proof will be saved in a new file with a <code>.sc</code> (Scala) extension:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background type
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@pure def ProofName(variable1: B, variable2: B, ...): Unit = {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        (comma-separated list of premises with variable1, variable2, ...)  âŠ¢  (conclusion)
</span></span><span class=line><span class=cl>            Proof(
</span></span><span class=line><span class=cl>                //the actual proof steps go here
</span></span><span class=line><span class=cl>            )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Once we are inside the <code>Proof</code> element (where the above example says &ldquo;the actual proof steps go here&rdquo;), we complete a numbered series of steps. Each step includes a claim and corresponding justification, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background type
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@pure def ProofName(variable1: B, variable2: B, ...): Unit = {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        (comma-separated list of premises with variable1, variable2, ...)  âŠ¢  (conclusion)
</span></span><span class=line><span class=cl>            Proof(
</span></span><span class=line><span class=cl>                1 (     claim_a         )   by Justification_a,
</span></span><span class=line><span class=cl>                2 (     claim_b         )   by Justification_b,
</span></span><span class=line><span class=cl>                ...
</span></span><span class=line><span class=cl>                736 (   conclusion      )   by Justification_conc
</span></span><span class=line><span class=cl>            )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Each claim is given a number, and these numbers are generally in order. However, the only rule is that claim numbers be unique (they may be out of order and/or non-consecutive). Once we have justified a claim in a proof, we will refer to it as a <em>fact</em>.</p><p>We will see more details of Logika proof syntax as we progress through chapter 4.</p><h2 id=premise-justification>Premise justification</h2><p>The most basic justification for a claim in a proof is &ldquo;premise&rdquo;. This justification is used when you pull in a premise from the sequent and introduce it into your proof. All, some or none of the premises can be introduced at any time in any order. Please note that only one premise may be entered per claim.</p><p>For example, we might bring in the premises from our sequent like this (the imports, proof function definition, deduce call, and formatter changes are omitted here for readability):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     p               )   by Premise,
</span></span><span class=line><span class=cl>        2 (     q               )   by Premise,
</span></span><span class=line><span class=cl>        3 (     Â¬r              )   by Premise,
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>We could also bring in the same premise multiple times, if we wanted. We could also use non-sequential line numbers, as long as each line number was unique:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        7 (     p           )   by Premise,
</span></span><span class=line><span class=cl>        10 (    q           )   by Premise,
</span></span><span class=line><span class=cl>        2 (     Â¬r          )   by Premise,
</span></span><span class=line><span class=cl>        8 (     p           )   by Premise,
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>We could only bring in some portion of our premises, if we wanted:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     p           )   by Premise,
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>But we can only list one premise in each claim. For example, the following is not allowed:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     p, q, Â¬r           )   by Premise,      //NO! Only one premise per line.
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><h2 id=deduction-rules>Deduction rules</h2><p>The logical operators (AND, OR, NOT, IMPLIES) are a kind of language for building propositions from basic, primitive propositional atoms. For this reason, we must have laws for constructing propositions and for disassembling them. These laws are called <em>inference</em> rules or <em>deduction</em> rules. A <em>natural deduction system</em> is a set of inference rules, such that for each logical operator, there is a rule for constructing a proposition with that operator (this is called an <em>introduction rule</em>) and there is a rule for disassembling a proposition with that operator (this is called an <em>elimination rule</em>).</p><p>For the sections that follow, we will see the introduction and elimination rules for each logical operator. We will then learn how to use these deduction rules to write a formal proof showing that a sequent is valid.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/3ee7d6e929803e183bc58287cbf71613bf7528ae>Apr 25, 2024</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search><script>var contentLangs=["en"]</script><script src=/cis301/js/auto-complete.js?1736806682 defer></script><script src=/cis301/js/lunr/lunr.min.js?1736806682 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1736806682 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1736806682 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1736806682 defer></script><script src=/cis301/js/search.js?1736806682 defer></script></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/><input type=checkbox id=R-section-4dd9ea2241609372e21522ad467bdbcf aria-controls=R-subsections-4dd9ea2241609372e21522ad467bdbcf><label for=R-section-4dd9ea2241609372e21522ad467bdbcf><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/><b>0. </b>Getting Started</a><ul id=R-subsections-4dd9ea2241609372e21522ad467bdbcf class="morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/><a class=padding href=/cis301/0-chapter/0_1-toolsguide/>0.1. Tools Guide</a></li></ul></li><li data-nav-id=/cis301/1-chapter/><input type=checkbox id=R-section-17929730d34290b059d2edff1c690239 aria-controls=R-subsections-17929730d34290b059d2edff1c690239><label for=R-section-17929730d34290b059d2edff1c690239><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-17929730d34290b059d2edff1c690239 class="morespace collapsible-menu"><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/><a class=padding href=/cis301/1-chapter/1_1-logicbasics/>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/><input type=checkbox id=R-section-97391a296e58f4aff54bb6b925a2776b aria-controls=R-subsections-97391a296e58f4aff54bb6b925a2776b><label for=R-section-97391a296e58f4aff54bb6b925a2776b><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/><b>2. </b>Truth Tables</a><ul id=R-subsections-97391a296e58f4aff54bb6b925a2776b class="morespace collapsible-menu"><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/><a class=padding href=/cis301/2-chapter/2_1-opscircuits/>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/><a class=padding href=/cis301/2-chapter/2_2-logikatruth/>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/><a class=padding href=/cis301/2-chapter/2_3-satis/>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/><a class=padding href=/cis301/2-chapter/2_5-sementail/>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/><input type=checkbox id=R-section-b4e2df8934a6b804e9336da7e38d4126 aria-controls=R-subsections-b4e2df8934a6b804e9336da7e38d4126><label for=R-section-b4e2df8934a6b804e9336da7e38d4126><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-b4e2df8934a6b804e9336da7e38d4126 class="morespace collapsible-menu"><li data-nav-id=/cis301/3-chapter/3_1-propatom/><a class=padding href=/cis301/3-chapter/3_1-propatom/>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/><a class=padding href=/cis301/3-chapter/3_2-notandor/>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/><a class=padding href=/cis301/3-chapter/3_3-implies/>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/><a class=padding href=/cis301/3-chapter/3_4-equiv/>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/ class=parent><input type=checkbox id=R-section-619d3749907cd3e1af90a59cf2fcd6bd aria-controls=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd checked><label for=R-section-619d3749907cd3e1af90a59cf2fcd6bd><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd class="morespace collapsible-menu"><li data-nav-id=/cis301/4-chapter/4_1-intro/ class=active><a class=padding href=/cis301/4-chapter/4_1-intro/>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/><a class=padding href=/cis301/4-chapter/4_2-andrules/>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/><a class=padding href=/cis301/4-chapter/4_3-orrules/>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/><a class=padding href=/cis301/4-chapter/4_4-impliesrules/>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/><a class=padding href=/cis301/4-chapter/4_5-notrules/>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/><a class=padding href=/cis301/4-chapter/4_6-strategies/>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/><a class=padding href=/cis301/4-chapter/4_7-theorems/>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/><a class=padding href=/cis301/4-chapter/4_8-equivalence/>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/><input type=checkbox id=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7 aria-controls=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7><label for=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7 class="morespace collapsible-menu"><li data-nav-id=/cis301/5-chapter/5_1-motivation/><a class=padding href=/cis301/5-chapter/5_1-motivation/>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/><a class=padding href=/cis301/5-chapter/5_2-predsyntax/>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/><a class=padding href=/cis301/5-chapter/5_4-multquant/>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/><input type=checkbox id=R-section-1afc7d1d7b98dcc397b91690230bcb55 aria-controls=R-subsections-1afc7d1d7b98dcc397b91690230bcb55><label for=R-section-1afc7d1d7b98dcc397b91690230bcb55><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-1afc7d1d7b98dcc397b91690230bcb55 class="morespace collapsible-menu"><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/><a class=padding href=/cis301/6-chapter/6_1-univrules/>6.1. Rules with âˆ€</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/><a class=padding href=/cis301/6-chapter/6_2-existrules/>6.2. Rules with âˆƒ</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/><a class=padding href=/cis301/6-chapter/6_3-nested/>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/><a class=padding href=/cis301/6-chapter/6_4-equiv/>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/><a class=padding href=/cis301/6-chapter/6_5-strategies/>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/><input type=checkbox id=R-section-48461595e2f67d1468fbd78e51714428 aria-controls=R-subsections-48461595e2f67d1468fbd78e51714428><label for=R-section-48461595e2f67d1468fbd78e51714428><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/><b>7. </b>Mathematical Induction</a><ul id=R-subsections-48461595e2f67d1468fbd78e51714428 class="morespace collapsible-menu"><li data-nav-id=/cis301/7-chapter/7_1-process/><a class=padding href=/cis301/7-chapter/7_1-process/>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/><a class=padding href=/cis301/7-chapter/7_2-algebraex/>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/><a class=padding href=/cis301/7-chapter/7_3-divex/>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/><a class=padding href=/cis301/7-chapter/7_4-setex/>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/><input type=checkbox id=R-section-77afa9c6b199f7330fa5eb8966814b35 aria-controls=R-subsections-77afa9c6b199f7330fa5eb8966814b35><label for=R-section-77afa9c6b199f7330fa5eb8966814b35><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-77afa9c6b199f7330fa5eb8966814b35 class="morespace collapsible-menu"><li data-nav-id=/cis301/8-chapter/8_1-goal/><a class=padding href=/cis301/8-chapter/8_1-goal/>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/><a class=padding href=/cis301/8-chapter/8_3-assertassume/>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/><a class=padding href=/cis301/8-chapter/8_5-assignment/>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/><a class=padding href=/cis301/8-chapter/8_6-divmod/>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/><a class=padding href=/cis301/8-chapter/8_7-conditionals/>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/><input type=checkbox id=R-section-ffb46ad61395302deae4c4fa734e982a aria-controls=R-subsections-ffb46ad61395302deae4c4fa734e982a><label for=R-section-ffb46ad61395302deae4c4fa734e982a><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/><b>9. </b>Functions and Loops</a><ul id=R-subsections-ffb46ad61395302deae4c4fa734e982a class="morespace collapsible-menu"><li data-nav-id=/cis301/9-chapter/9_1-functions/><a class=padding href=/cis301/9-chapter/9_1-functions/>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/><a class=padding href=/cis301/9-chapter/9_2-recursion/>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/><a class=padding href=/cis301/9-chapter/9_3-loops/>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/><a class=padding href=/cis301/9-chapter/9_4-logikafacts/>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/><a class=padding href=/cis301/9-chapter/9_5-summary/>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/><input type=checkbox id=R-section-9e1e97bcf82568ce724d247ecac0ed85 aria-controls=R-subsections-9e1e97bcf82568ce724d247ecac0ed85><label for=R-section-9e1e97bcf82568ce724d247ecac0ed85><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-9e1e97bcf82568ce724d247ecac0ed85 class="morespace collapsible-menu"><li data-nav-id=/cis301/10-chapter/10_1-modes/><a class=padding href=/cis301/10-chapter/10_1-modes/>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/><a class=padding href=/cis301/10-chapter/10_2-intosequences/>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/><a class=padding href=/cis301/10-chapter/10_3-seqfn/>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/><a class=padding href=/cis301/10-chapter/10_4-seqloop/>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/><a class=padding href=/cis301/10-chapter/10_5-globals/>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/><a class=padding href=/cis301/10-chapter/10_6-termination/>10.6 Termination</a></li></ul></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Language</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-en value=#R-select-language-en data-url=/cis301/4-chapter/4_1-intro/ lang=en-us selected></option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class=footerVisitedLinks><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Clear History</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></div></aside><script src=/cis301/js/clipboard.min.js?1736806682 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1736806682 defer></script><script src=/cis301/js/theme.js?1736806682 defer></script></body></html>