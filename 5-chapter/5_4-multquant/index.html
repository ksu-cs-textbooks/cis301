<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Multiple Quantifiers :: CIS 301 Textbook"><meta name=twitter:description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/5-chapter/5_4-multquant/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Multiple Quantifiers :: CIS 301 Textbook"><meta property="og:description" content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Translations"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2023-12-07T13:46:44-06:00"><meta itemprop=name content="Multiple Quantifiers :: CIS 301 Textbook"><meta itemprop=description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2023-12-07T13:46:44-06:00"><meta itemprop=wordCount content="1963"><title>Multiple Quantifiers :: CIS 301 Textbook</title>
<link href=/cis301/5-chapter/5_4-multquant/index.xml rel=alternate type=application/rss+xml title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/index.print.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/tele.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/embed.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1724185194 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1724185194 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1724185194 rel=stylesheet><link href=/cis301/css/auto-complete.css?1724185194 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1724185194 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1724185194 rel=stylesheet><link href=/cis301/css/fonts.css?1724185194 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1724185194 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1724185194 rel=stylesheet><link href=/cis301/css/theme-auto.css?1724185194 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1724185194 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1724185194 rel=stylesheet><link href=/cis301/css/print.css?1724185194 rel=stylesheet media=print><script src=/cis301/js/variant.js?1724185194></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1724185194 rel=stylesheet></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=/cis301/5-chapter/5_4-multquant/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#several-of-the-same-quantifier>Several of the same quantifier</a><ul><li><a href=#prenex-form>Prenex form</a></li><li><a href=#aristotelian-form>Aristotelian form</a></li></ul></li><li><a href=#mixed-quantifiers>Mixed quantifiers</a><ul><li><a href=#systematic-translation>Systematic translation</a></li><li><a href=#follow-up-examples>Follow-up examples</a></li><li><a href=#order-matters>Order matters!</a></li></ul></li><li><a href=#precedence-with-quantifiers>Precedence with quantifiers</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/5-chapter/><span itemprop=name>Predicate Logic Translations</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Multiple Quantifiers</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/5-chapter/5_4-multQuant.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_3-singlequantifier/ title="Single Quantifier (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/ title="Predicate Logic Proofs (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=multiple-quantifiers>Multiple Quantifiers</h1><p>Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:</p><ul><li>Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers)</li><li>Translations that mix quantifiers</li></ul><p>In many of the sections, we will using the predicates below (which are over the domain of shapes):</p><ul><li><code>isCircle(x)</code> - whether shape x is a circle</li><li><code>isSquare(x)</code> - whether shape x is a square</li><li><code>isRectangle(x)</code> - whether shape x is a rectangle</li><li><code>biggerThan(x, y)</code> - whether shape x is bigger than shape y</li></ul><h2 id=several-of-the-same-quantifier>Several of the same quantifier</h2><p>First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements &ndash; either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested).</p><h3 id=prenex-form>Prenex form</h3><p>The <em>prenex form</em> of a predicate logic translation lists all the quantifiers at the beginning of the statement. This is only recommended when all the quantifiers are the same type &ndash; either all universal or all existential.</p><h4 id=prenex-example-1>Prenex example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em>. Here, we are making three claims:</p><ul><li>There exists a shape that is a circle</li><li>There exists a shape that is a square</li><li>The shape that is a circle is bigger than the shape that is a square</li></ul><p>With that in mind, we can see that we will use two existential quantifiers. We can translate the statement as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x ∃ y (isCircle(x) ∧ isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where x is a circle, y is a square, and x (which is a circle) is bigger than y (which is a square).</em></p><p>Equivalently, we could have written:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x ∃ y (isCircle(y) ∧ isSquare(x) ∧ biggerThan(y, x))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where y is a circle, x is a square, and y (which is a circle) is bigger than x (which is a square).</em></p><h4 id=prenex-example-2>Prenex example 2</h4><p>Next, suppose we wished to translate: <em>Every circle is bigger than all squares</em>. Again, we are quantifying two things &ndash; ALL circles and also ALL squares. We can see that we will need to use two universal quantifiers. We can translate the statement as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x ∀ y ((isCircle(x) ∧ isSquare(y)) → biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>For each combination (x, y) of shapes, if x is a circle and y is a square, then x (which is a circle) is bigger than y (which is a square).</em></p><h3 id=aristotelian-form>Aristotelian form</h3><p>The <em>Aristotelian form</em> of a predicate logic translation embeds the quantifiers within the translation. This format is possible for any kind of translation &ndash; whether the quantifiers are all the same type or mixed types.</p><h4 id=aristotelian-form-example-1>Aristotelian form example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x (isCircle(x) ∧ (∃ y (isSquare(y) ∧ biggerThan(x, y)))</span></span></code></pre></div><p>Which reads as: <em>There exists a shape x that is a circle and there exists a shape y that is a square, and x (which is a circle) is bigger than y (which is a square)</em>.</p><h4 id=aristotelian-form-example-2>Aristotelian form example 2</h4><p>Let&rsquo;s repeat our translation for, <em>Every circle is bigger than all rectangles</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x (isCircle(x) → (∀ y (isSquare(y) → biggerThan(x, y))))</span></span></code></pre></div><p>Which reads as: <em>For every shape x, if x is a circle, then for every shape y, if y is s square, then x (which is a circle) is bigger than y (which is a square).</em></p><h2 id=mixed-quantifiers>Mixed quantifiers</h2><p>Now, we will turn to examples that mix universal and existential quantifiers. We will see below that quantifier order matters in this case, so it is safest to translate such statements using embedded quantifiers. The embedded form can be tricky to write, so we will see a way to systematically translate any statement that needs multiple quantifiers into predicate logic (using Aristotelian form).</p><h3 id=systematic-translation>Systematic translation</h3><p>Suppose we wish to translate, <em>Every circle is bigger than at least one square</em>. We see that we are first making a claim about all circles. Without worrying about the rest of the statement, we know that for all circles, we are saying <em>something</em>. So we write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>For all circles, SOMETHING</span></span></code></pre></div><p>Trying to formalize a bit more, we assign a variable to the current circle we are describing (<code>x</code>). For each circle x, we are saying <em>something</em> about that circle. So we express SOMETHING(x) as some claim about our current circle, and write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>For each circle x, SOMETHING(x)</span></span></code></pre></div><p>We see that we will need a universal quantifier since we are talking about ALL circles, and we also follow the guide of using an implies statement to work with a for-all statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x (isCircle(x) → SOMETHING(x))</span></span></code></pre></div><p>Next, we describe what <code>SOMETHING(x)</code> means for a particular circle, <code>x</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SOMETHING(x): x is bigger than at least one square</span></span></code></pre></div><p>Trying to formalize a bit more about the square, we write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SOMETHING(x): There exists a square y, and x is bigger than y</span></span></code></pre></div><p>Now we can use an existential quantifier to describe our square, and plug in our isSquare and biggerThan predicates to have a translation for SOMETHING(x):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SOMETHING(x): ∃ y (isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Now, we can plug SOMETHING(x) into our first partial translation, <code>∀ x (isCircle(x) → SOMETHING(x))</code>. The complete translation for <em>Every circle is bigger than at least one square</em> is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x (isCircle(x) → (∃ y (isSquare(y) ∧ biggerThan(x, y))))</span></span></code></pre></div><h3 id=follow-up-examples>Follow-up examples</h3><p>In these examples, suppose our domain is animals and that we have the following predicates:</p><ul><li><code>El(x)</code>: whether animal x is an elephant</li><li><code>Hi(x)</code>: whether animal x is a hippo</li><li><code>W(x, y)</code>: whether animal x weighs more than animal y</li></ul><p>Suppose we wish to translate: <em>There is exactly one hippo.</em> We might first try saying: <code>∃ x Hi(x)</code>. But this proposition would be true even if we had 100 hippos, so we need something more restricted. What we are really trying to say is:</p><ul><li>There exists a hippo</li><li>AND, any other hippo is the same one</li></ul><p>Let&rsquo;s use our systematic approach, streamlining a few of the steps:</p><ul><li>There exists an animal x that is a hippo, and SOMETHING(x)</li><li><code>∃ x (Hi(x) ∧ SOMETHING(x))</code></li></ul><p>To translate SOMETHING(x), the claim we are making about our hippo x:</p><ul><li><code>SOMETHING(x)</code>: any other hippo is the same as x</li><li><code>SOMETHING(x)</code>: for each hippo y, x is the same as y</li><li><code>SOMETHING(x)</code>: `∀ y (Hi(y) → (x == y))</li></ul><p>Now we can put everything together to get a complete translation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x (Hi(x) ∧ (∀ y (Hi(y) → (x == y)))</span></span></code></pre></div><p>Here are a few more translations from English to predicate logic. Think about what the following statements mean, and click to reveal each answer:</p><ul><li><p><em>Every elephant is heavier than some hippo.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>∀ x (El(x) -> (∃ y (Hi(y) ^ W(x, y))))</code></p></details><br></li></ul></li><li><p><em>There is an elephant that is heavier than all hippos.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>∃ x (El(x) ^ (∀ y (Hi(y) -> W(x, y))))</code></p></details><br></li></ul></li><li><p><em>No hippo is heavier than every elephant.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>¬(∃ x (Hi(x) ^ (∀ y (El(y) -> W(x, y)))))</code></p></details><br></li></ul></li></ul><h3 id=order-matters>Order matters!</h3><p>We have learned that when dealing with mixed quantifiers, it is safest to embed them within the translation. If we put the mixed quantifiers out front of a translation, then we can accidentally include them in the wrong order and end up with an incorrect translation.</p><p>Suppose we have this predicate, over the domain of people:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>likes(x, y): whether person x likes person y</span></span></code></pre></div><p>Further suppose that liking a person is not necessarily symmetric: that just because person x likes person y does not mean that person y necessarily likes person x.</p><p>Consider these pairs of propositions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x ∀ y likes(x, y)     vs.     ∀ y ∀ x likes(x, y)  
</span></span><span class=line><span class=cl>∃ x ∃ y likes(x, y)     vs.     ∃ y ∃ x likes(x, y)</span></span></code></pre></div><p>Is there any difference between each one? No! The two versions of the first proposition both say that every person likes every other person, and the two versions of the second proposition both say that there is a person who likes another person.</p><p>But what about:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x ∃ y likes(x, y)     vs.     ∃ y ∀ x likes(x, y)</span></span></code></pre></div><p>Suppose our domain is made up of the following people:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Bob: likes Alice and James
</span></span><span class=line><span class=cl>Alice: likes Bob
</span></span><span class=line><span class=cl>James: likes Alice</span></span></code></pre></div><p>The first proposition, <code>∀ x ∃ y likes(x, y)</code>, says that all people have some person (not necessarily the same person) that they like. This would certainly be true for our domain, as every person has at least one person that they like. The second proposition, <code>∃ y ∀ x likes(x, y)</code> is saying that there is a person (the SAME person) that everyone likes. This proposition would be false for our domain, as there is no one person that is liked by everyone.</p><h2 id=precedence-with-quantifiers>Precedence with quantifiers</h2><p>In section 2.2, we discussed operator precedence for propositional logic statements. The same operator precedence holds for predicate logic statements, except that our two quantifiers (<code>∀</code> and <code>∃</code>) have the same precedence as the NOT operator. If we have a proposition with multiple quantifiers, then the quantifiers are resolved from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</p><p>Here is an updated list of operator precedence, from most important (do first) to least important (do last):</p><ol><li>Parentheses</li><li>Not operator (<code>¬</code>), universal quantifier (<code>∀</code>), existential quantifier (<code>∃</code>)</li><li>And operator, <code>∧</code></li><li>Or operator, <code>∨</code></li><li>Implies operator, <code>→</code></li></ol><p>And here is our updated list of how to resolve multiple operators with the same precedence:</p><ol><li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li><li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li><li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li><li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li><li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li><li>Multiple quantifiers &ndash; the rightmost quantifier is resolved first, working from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</li></ol><p>When we get to predicate logic proofs in Chapter 6, we will see that Logika uses a different precedence for quantifiers &ndash; there, quantifiers have the LOWEST precedence (done last) of any operator. This ends up being more forgiving than confusing, as it will accept propositions as correct that are really missing parentheses. For example, Logika will accept: <code>∃ x isMouse(x) ∧ inHouse(x)</code>. Technically, this proposition <em>should</em> be incorrect &ndash; if we correctly treat quantifiers as having a higher precedence than <code>∧</code>, then <code>inHouse(x)</code> would no longer know about the variable <code>x</code> or its quantifier.</p><p>We <em>should</em> use parentheses with quantifiers to express our intended meaning, and so we should write <code>∃ x (isMouse(x) ∧ inHouse(x))</code> instead. But if we forget the parentheses, then Logika will forgive us.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/af82a65dc1c94cb6d0310a624077a2e135001155>Dec 7, 2023</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search><script>var contentLangs=["en"]</script><script src=/cis301/js/auto-complete.js?1724185194 defer></script><script src=/cis301/js/lunr/lunr.min.js?1724185194 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1724185194 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1724185194 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1724185194 defer></script><script src=/cis301/js/search.js?1724185194 defer></script></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/><input type=checkbox id=R-section-4dd9ea2241609372e21522ad467bdbcf aria-controls=R-subsections-4dd9ea2241609372e21522ad467bdbcf><label for=R-section-4dd9ea2241609372e21522ad467bdbcf><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/><b>0. </b>Getting Started</a><ul id=R-subsections-4dd9ea2241609372e21522ad467bdbcf class="morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/><a class=padding href=/cis301/0-chapter/0_1-toolsguide/>0.1. Tools Guide</a></li></ul></li><li data-nav-id=/cis301/1-chapter/><input type=checkbox id=R-section-17929730d34290b059d2edff1c690239 aria-controls=R-subsections-17929730d34290b059d2edff1c690239><label for=R-section-17929730d34290b059d2edff1c690239><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-17929730d34290b059d2edff1c690239 class="morespace collapsible-menu"><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/><a class=padding href=/cis301/1-chapter/1_1-logicbasics/>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/><input type=checkbox id=R-section-97391a296e58f4aff54bb6b925a2776b aria-controls=R-subsections-97391a296e58f4aff54bb6b925a2776b><label for=R-section-97391a296e58f4aff54bb6b925a2776b><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/><b>2. </b>Truth Tables</a><ul id=R-subsections-97391a296e58f4aff54bb6b925a2776b class="morespace collapsible-menu"><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/><a class=padding href=/cis301/2-chapter/2_1-opscircuits/>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/><a class=padding href=/cis301/2-chapter/2_2-logikatruth/>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/><a class=padding href=/cis301/2-chapter/2_3-satis/>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/><a class=padding href=/cis301/2-chapter/2_5-sementail/>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/><input type=checkbox id=R-section-b4e2df8934a6b804e9336da7e38d4126 aria-controls=R-subsections-b4e2df8934a6b804e9336da7e38d4126><label for=R-section-b4e2df8934a6b804e9336da7e38d4126><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-b4e2df8934a6b804e9336da7e38d4126 class="morespace collapsible-menu"><li data-nav-id=/cis301/3-chapter/3_1-propatom/><a class=padding href=/cis301/3-chapter/3_1-propatom/>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/><a class=padding href=/cis301/3-chapter/3_2-notandor/>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/><a class=padding href=/cis301/3-chapter/3_3-implies/>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/><a class=padding href=/cis301/3-chapter/3_4-equiv/>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/><input type=checkbox id=R-section-619d3749907cd3e1af90a59cf2fcd6bd aria-controls=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd><label for=R-section-619d3749907cd3e1af90a59cf2fcd6bd><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd class="morespace collapsible-menu"><li data-nav-id=/cis301/4-chapter/4_1-intro/><a class=padding href=/cis301/4-chapter/4_1-intro/>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/><a class=padding href=/cis301/4-chapter/4_2-andrules/>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/><a class=padding href=/cis301/4-chapter/4_3-orrules/>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/><a class=padding href=/cis301/4-chapter/4_4-impliesrules/>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/><a class=padding href=/cis301/4-chapter/4_5-notrules/>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/><a class=padding href=/cis301/4-chapter/4_6-strategies/>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/><a class=padding href=/cis301/4-chapter/4_7-theorems/>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/><a class=padding href=/cis301/4-chapter/4_8-equivalence/>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/ class=parent><input type=checkbox id=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7 aria-controls=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7 checked><label for=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7 class="morespace collapsible-menu"><li data-nav-id=/cis301/5-chapter/5_1-motivation/><a class=padding href=/cis301/5-chapter/5_1-motivation/>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/><a class=padding href=/cis301/5-chapter/5_2-predsyntax/>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/ class=active><a class=padding href=/cis301/5-chapter/5_4-multquant/>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/><input type=checkbox id=R-section-1afc7d1d7b98dcc397b91690230bcb55 aria-controls=R-subsections-1afc7d1d7b98dcc397b91690230bcb55><label for=R-section-1afc7d1d7b98dcc397b91690230bcb55><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-1afc7d1d7b98dcc397b91690230bcb55 class="morespace collapsible-menu"><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/><a class=padding href=/cis301/6-chapter/6_1-univrules/>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/><a class=padding href=/cis301/6-chapter/6_2-existrules/>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/><a class=padding href=/cis301/6-chapter/6_3-nested/>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/><a class=padding href=/cis301/6-chapter/6_4-equiv/>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/><a class=padding href=/cis301/6-chapter/6_5-strategies/>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/><input type=checkbox id=R-section-48461595e2f67d1468fbd78e51714428 aria-controls=R-subsections-48461595e2f67d1468fbd78e51714428><label for=R-section-48461595e2f67d1468fbd78e51714428><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/><b>7. </b>Mathematical Induction</a><ul id=R-subsections-48461595e2f67d1468fbd78e51714428 class="morespace collapsible-menu"><li data-nav-id=/cis301/7-chapter/7_1-process/><a class=padding href=/cis301/7-chapter/7_1-process/>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/><a class=padding href=/cis301/7-chapter/7_2-algebraex/>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/><a class=padding href=/cis301/7-chapter/7_3-divex/>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/><a class=padding href=/cis301/7-chapter/7_4-setex/>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/><input type=checkbox id=R-section-77afa9c6b199f7330fa5eb8966814b35 aria-controls=R-subsections-77afa9c6b199f7330fa5eb8966814b35><label for=R-section-77afa9c6b199f7330fa5eb8966814b35><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-77afa9c6b199f7330fa5eb8966814b35 class="morespace collapsible-menu"><li data-nav-id=/cis301/8-chapter/8_1-goal/><a class=padding href=/cis301/8-chapter/8_1-goal/>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/><a class=padding href=/cis301/8-chapter/8_3-assertassume/>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/>8.4. Algebra and subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/><a class=padding href=/cis301/8-chapter/8_5-assignment/>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/><a class=padding href=/cis301/8-chapter/8_6-divmod/>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/><a class=padding href=/cis301/8-chapter/8_7-conditionals/>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/><input type=checkbox id=R-section-ffb46ad61395302deae4c4fa734e982a aria-controls=R-subsections-ffb46ad61395302deae4c4fa734e982a><label for=R-section-ffb46ad61395302deae4c4fa734e982a><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/><b>9. </b>Functions and Loops</a><ul id=R-subsections-ffb46ad61395302deae4c4fa734e982a class="morespace collapsible-menu"><li data-nav-id=/cis301/9-chapter/9_1-functions/><a class=padding href=/cis301/9-chapter/9_1-functions/>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/><a class=padding href=/cis301/9-chapter/9_2-recursion/>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/><a class=padding href=/cis301/9-chapter/9_3-loops/>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/><a class=padding href=/cis301/9-chapter/9_4-logikafacts/>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/><a class=padding href=/cis301/9-chapter/9_5-summary/>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/><input type=checkbox id=R-section-9e1e97bcf82568ce724d247ecac0ed85 aria-controls=R-subsections-9e1e97bcf82568ce724d247ecac0ed85><label for=R-section-9e1e97bcf82568ce724d247ecac0ed85><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-9e1e97bcf82568ce724d247ecac0ed85 class="morespace collapsible-menu"><li data-nav-id=/cis301/10-chapter/10_1-modes/><a class=padding href=/cis301/10-chapter/10_1-modes/>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/><a class=padding href=/cis301/10-chapter/10_2-intosequences/>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/><a class=padding href=/cis301/10-chapter/10_3-seqfn/>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/><a class=padding href=/cis301/10-chapter/10_4-seqloop/>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/><a class=padding href=/cis301/10-chapter/10_5-globals/>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/><a class=padding href=/cis301/10-chapter/10_6-termination/>10.6 Termination</a></li></ul></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Language</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-en value=#R-select-language-en data-url=/cis301/5-chapter/5_4-multquant/ lang=en-us selected></option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class=footerVisitedLinks><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Clear History</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></div></aside><script src=/cis301/js/clipboard.min.js?1724185194 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1724185194 defer></script><script src=/cis301/js/theme.js?1724185194 defer></script></body></html>