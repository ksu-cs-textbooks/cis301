<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements – either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested)."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Multiple Quantifiers :: CIS 301 Textbook"><meta name=twitter:description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements – either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested)."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/5-chapter/5_4-multquant/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Multiple Quantifiers :: CIS 301 Textbook"><meta property="og:description" content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements – either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Translations"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2023-12-07T13:46:44-06:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Multiple Quantifiers :: CIS 301 Textbook"><meta itemprop=description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements – either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested)."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2023-12-07T13:46:44-06:00"><meta itemprop=wordCount content="1980"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Multiple Quantifiers :: CIS 301 Textbook</title><link href=/cis301/5-chapter/5_4-multquant/index.xml rel=alternate type=application/rss+xml title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/index.print.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/tele.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/embed.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1760042406 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1760042406 defer></script><script src=/cis301/js/search-lunr.min.js?1760042406 defer></script><script src=/cis301/js/search.min.js?1760042406 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1760042406"</script><script src=/cis301/js/lunr/lunr.min.js?1760042406 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1760042406 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1760042406 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1760042406 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1760042406 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1760042406 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1760042406 rel=stylesheet><link href=/cis301/css/theme.min.css?1760042406 rel=stylesheet><link href=/cis301/css/format-html.min.css?1760042406 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/5-chapter/5_4-multquant/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["auto","light-theme","dark-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!0,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1760042406 rel=stylesheet></head><body class="mobile-support html" data-url=/cis301/5-chapter/5_4-multquant/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#several-of-the-same-quantifier>Several of the same quantifier</a><ul><li><a href=#prenex-form>Prenex form</a></li><li><a href=#aristotelian-form>Aristotelian form</a></li></ul></li><li><a href=#mixed-quantifiers>Mixed quantifiers</a><ul><li><a href=#systematic-translation>Systematic translation</a></li><li><a href=#follow-up-examples>Follow-up examples</a></li><li><a href=#order-matters>Order matters!</a></li></ul></li><li><a href=#precedence-with-quantifiers>Precedence with quantifiers</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><a itemprop=item href=/cis301/index.html><span itemprop=name>CIS 301 Textbook</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/5-chapter/index.html><span itemprop=name>Predicate Logic Translations</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Multiple Quantifiers</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/5-chapter/5_4-multQuant.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_3-singlequantifier/index.html title="Single Quantifier (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/index.html title="Predicate Logic Proofs (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 5-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=multiple-quantifiers>Multiple Quantifiers</h1><p>Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:</p><ul><li>Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers)</li><li>Translations that mix quantifiers</li></ul><p>In many of the sections, we will using the predicates below (which are over the domain of shapes):</p><ul><li><code>isCircle(x)</code> - whether shape x is a circle</li><li><code>isSquare(x)</code> - whether shape x is a square</li><li><code>isRectangle(x)</code> - whether shape x is a rectangle</li><li><code>biggerThan(x, y)</code> - whether shape x is bigger than shape y</li></ul><h2 id=several-of-the-same-quantifier>Several of the same quantifier</h2><p>First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements &ndash; either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested).</p><h3 id=prenex-form>Prenex form</h3><p>The <em>prenex form</em> of a predicate logic translation lists all the quantifiers at the beginning of the statement. This is only recommended when all the quantifiers are the same type &ndash; either all universal or all existential.</p><h4 id=prenex-example-1>Prenex example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em>. Here, we are making three claims:</p><ul><li>There exists a shape that is a circle</li><li>There exists a shape that is a square</li><li>The shape that is a circle is bigger than the shape that is a square</li></ul><p>With that in mind, we can see that we will use two existential quantifiers. We can translate the statement as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∃ x ∃ y (isCircle(x) ∧ isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where x is a circle, y is a square, and x (which is a circle) is bigger than y (which is a square).</em></p><p>Equivalently, we could have written:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∃ x ∃ y (isCircle(y) ∧ isSquare(x) ∧ biggerThan(y, x))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where y is a circle, x is a square, and y (which is a circle) is bigger than x (which is a square).</em></p><h4 id=prenex-example-2>Prenex example 2</h4><p>Next, suppose we wished to translate: <em>Every circle is bigger than all squares</em>. Again, we are quantifying two things &ndash; ALL circles and also ALL squares. We can see that we will need to use two universal quantifiers. We can translate the statement as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ x ∀ y ((isCircle(x) ∧ isSquare(y)) → biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>For each combination (x, y) of shapes, if x is a circle and y is a square, then x (which is a circle) is bigger than y (which is a square).</em></p><h3 id=aristotelian-form>Aristotelian form</h3><p>The <em>Aristotelian form</em> of a predicate logic translation embeds the quantifiers within the translation. This format is possible for any kind of translation &ndash; whether the quantifiers are all the same type or mixed types.</p><h4 id=aristotelian-form-example-1>Aristotelian form example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∃ x (isCircle(x) ∧ (∃ y (isSquare(y) ∧ biggerThan(x, y)))</span></span></code></pre></div><p>Which reads as: <em>There exists a shape x that is a circle and there exists a shape y that is a square, and x (which is a circle) is bigger than y (which is a square)</em>.</p><h4 id=aristotelian-form-example-2>Aristotelian form example 2</h4><p>Let&rsquo;s repeat our translation for, <em>Every circle is bigger than all rectangles</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ x (isCircle(x) → (∀ y (isSquare(y) → biggerThan(x, y))))</span></span></code></pre></div><p>Which reads as: <em>For every shape x, if x is a circle, then for every shape y, if y is s square, then x (which is a circle) is bigger than y (which is a square).</em></p><h2 id=mixed-quantifiers>Mixed quantifiers</h2><p>Now, we will turn to examples that mix universal and existential quantifiers. We will see below that quantifier order matters in this case, so it is safest to translate such statements using embedded quantifiers. The embedded form can be tricky to write, so we will see a way to systematically translate any statement that needs multiple quantifiers into predicate logic (using Aristotelian form).</p><h3 id=systematic-translation>Systematic translation</h3><p>Suppose we wish to translate, <em>Every circle is bigger than at least one square</em>. We see that we are first making a claim about all circles. Without worrying about the rest of the statement, we know that for all circles, we are saying <em>something</em>. So we write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>For all circles, SOMETHING</span></span></code></pre></div><p>Trying to formalize a bit more, we assign a variable to the current circle we are describing (<code>x</code>). For each circle x, we are saying <em>something</em> about that circle. So we express SOMETHING(x) as some claim about our current circle, and write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>For each circle x, SOMETHING(x)</span></span></code></pre></div><p>We see that we will need a universal quantifier since we are talking about ALL circles, and we also follow the guide of using an implies statement to work with a for-all statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ x (isCircle(x) → SOMETHING(x))</span></span></code></pre></div><p>Next, we describe what <code>SOMETHING(x)</code> means for a particular circle, <code>x</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOMETHING(x): x is bigger than at least one square</span></span></code></pre></div><p>Trying to formalize a bit more about the square, we write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOMETHING(x): There exists a square y, and x is bigger than y</span></span></code></pre></div><p>Now we can use an existential quantifier to describe our square, and plug in our isSquare and biggerThan predicates to have a translation for SOMETHING(x):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOMETHING(x): ∃ y (isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Now, we can plug SOMETHING(x) into our first partial translation, <code>∀ x (isCircle(x) → SOMETHING(x))</code>. The complete translation for <em>Every circle is bigger than at least one square</em> is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ x (isCircle(x) → (∃ y (isSquare(y) ∧ biggerThan(x, y))))</span></span></code></pre></div><h3 id=follow-up-examples>Follow-up examples</h3><p>In these examples, suppose our domain is animals and that we have the following predicates:</p><ul><li><code>El(x)</code>: whether animal x is an elephant</li><li><code>Hi(x)</code>: whether animal x is a hippo</li><li><code>W(x, y)</code>: whether animal x weighs more than animal y</li></ul><p>Suppose we wish to translate: <em>There is exactly one hippo.</em> We might first try saying: <code>∃ x Hi(x)</code>. But this proposition would be true even if we had 100 hippos, so we need something more restricted. What we are really trying to say is:</p><ul><li>There exists a hippo</li><li>AND, any other hippo is the same one</li></ul><p>Let&rsquo;s use our systematic approach, streamlining a few of the steps:</p><ul><li>There exists an animal x that is a hippo, and SOMETHING(x)</li><li><code>∃ x (Hi(x) ∧ SOMETHING(x))</code></li></ul><p>To translate SOMETHING(x), the claim we are making about our hippo x:</p><ul><li><code>SOMETHING(x)</code>: any other hippo is the same as x</li><li><code>SOMETHING(x)</code>: for each hippo y, x is the same as y</li><li><code>SOMETHING(x)</code>: `∀ y (Hi(y) → (x == y))</li></ul><p>Now we can put everything together to get a complete translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∃ x (Hi(x) ∧ (∀ y (Hi(y) → (x == y)))</span></span></code></pre></div><p>Here are a few more translations from English to predicate logic. Think about what the following statements mean, and click to reveal each answer:</p><ul><li><p><em>Every elephant is heavier than some hippo.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>∀ x (El(x) -> (∃ y (Hi(y) ^ W(x, y))))</code></p></details><br></li></ul></li><li><p><em>There is an elephant that is heavier than all hippos.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>∃ x (El(x) ^ (∀ y (Hi(y) -> W(x, y))))</code></p></details><br></li></ul></li><li><p><em>No hippo is heavier than every elephant.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>¬(∃ x (Hi(x) ^ (∀ y (El(y) -> W(x, y)))))</code></p></details><br></li></ul></li></ul><h3 id=order-matters>Order matters!</h3><p>We have learned that when dealing with mixed quantifiers, it is safest to embed them within the translation. If we put the mixed quantifiers out front of a translation, then we can accidentally include them in the wrong order and end up with an incorrect translation.</p><p>Suppose we have this predicate, over the domain of people:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>likes(x, y): whether person x likes person y</span></span></code></pre></div><p>Further suppose that liking a person is not necessarily symmetric: that just because person x likes person y does not mean that person y necessarily likes person x.</p><p>Consider these pairs of propositions:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ x ∀ y likes(x, y)     vs.     ∀ y ∀ x likes(x, y)  
</span></span><span style=display:flex><span>∃ x ∃ y likes(x, y)     vs.     ∃ y ∃ x likes(x, y)</span></span></code></pre></div><p>Is there any difference between each one? No! The two versions of the first proposition both say that every person likes every other person, and the two versions of the second proposition both say that there is a person who likes another person.</p><p>But what about:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ x ∃ y likes(x, y)     vs.     ∃ y ∀ x likes(x, y)</span></span></code></pre></div><p>Suppose our domain is made up of the following people:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Bob: likes Alice and James
</span></span><span style=display:flex><span>Alice: likes Bob
</span></span><span style=display:flex><span>James: likes Alice</span></span></code></pre></div><p>The first proposition, <code>∀ x ∃ y likes(x, y)</code>, says that all people have some person (not necessarily the same person) that they like. This would certainly be true for our domain, as every person has at least one person that they like. The second proposition, <code>∃ y ∀ x likes(x, y)</code> is saying that there is a person (the SAME person) that everyone likes. This proposition would be false for our domain, as there is no one person that is liked by everyone.</p><h2 id=precedence-with-quantifiers>Precedence with quantifiers</h2><p>In section 2.2, we discussed operator precedence for propositional logic statements. The same operator precedence holds for predicate logic statements, except that our two quantifiers (<code>∀</code> and <code>∃</code>) have the same precedence as the NOT operator. If we have a proposition with multiple quantifiers, then the quantifiers are resolved from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</p><p>Here is an updated list of operator precedence, from most important (do first) to least important (do last):</p><ol><li>Parentheses</li><li>Not operator (<code>¬</code>), universal quantifier (<code>∀</code>), existential quantifier (<code>∃</code>)</li><li>And operator, <code>∧</code></li><li>Or operator, <code>∨</code></li><li>Implies operator, <code>→</code></li></ol><p>And here is our updated list of how to resolve multiple operators with the same precedence:</p><ol><li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li><li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li><li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li><li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li><li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li><li>Multiple quantifiers &ndash; the rightmost quantifier is resolved first, working from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</li></ol><p>When we get to predicate logic proofs in Chapter 6, we will see that Logika uses a different precedence for quantifiers &ndash; there, quantifiers have the LOWEST precedence (done last) of any operator. This ends up being more forgiving than confusing, as it will accept propositions as correct that are really missing parentheses. For example, Logika will accept: <code>∃ x isMouse(x) ∧ inHouse(x)</code>. Technically, this proposition <em>should</em> be incorrect &ndash; if we correctly treat quantifiers as having a higher precedence than <code>∧</code>, then <code>inHouse(x)</code> would no longer know about the variable <code>x</code> or its quantifier.</p><p>We <em>should</em> use parentheses with quantifiers to express our intended meaning, and so we should write <code>∃ x (isMouse(x) ∧ inHouse(x))</code> instead. But if we forget the parentheses, then Logika will forgive us.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/af82a65dc1c94cb6d0310a624077a2e135001155>Dec 7, 2023</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class=default-animation><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/index.html><input type=checkbox id=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9 aria-controls=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9><label for=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/index.html><b>0. </b>Getting Started</a><ul id=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9 class=collapsible-menu><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/index.html><a class=padding href=/cis301/0-chapter/0_1-toolsguide/index.html>0.1. Tools Guide</a></li><li data-nav-id=/cis301/0-chapter/0_2-gitinstall/index.html><a class=padding href=/cis301/0-chapter/0_2-gitinstall/index.html>0.2. git Install</a></li></ul></li><li data-nav-id=/cis301/1-chapter/index.html><input type=checkbox id=R-section-cbcda2db56d129074f1e03beb13f9103 aria-controls=R-subsections-cbcda2db56d129074f1e03beb13f9103><label for=R-section-cbcda2db56d129074f1e03beb13f9103><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/index.html><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-cbcda2db56d129074f1e03beb13f9103 class=collapsible-menu><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/index.html><a class=padding href=/cis301/1-chapter/1_1-logicbasics/index.html>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/index.html><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/index.html>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/index.html><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/index.html>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/index.html><input type=checkbox id=R-section-d672bd5f3e40d734b815889ecb0b088e aria-controls=R-subsections-d672bd5f3e40d734b815889ecb0b088e><label for=R-section-d672bd5f3e40d734b815889ecb0b088e><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/index.html><b>2. </b>Truth Tables</a><ul id=R-subsections-d672bd5f3e40d734b815889ecb0b088e class=collapsible-menu><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/index.html><a class=padding href=/cis301/2-chapter/2_1-opscircuits/index.html>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/index.html><a class=padding href=/cis301/2-chapter/2_2-logikatruth/index.html>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/index.html><a class=padding href=/cis301/2-chapter/2_3-satis/index.html>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/index.html><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/index.html>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/index.html><a class=padding href=/cis301/2-chapter/2_5-sementail/index.html>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/index.html><input type=checkbox id=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73 aria-controls=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73><label for=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/index.html><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73 class=collapsible-menu><li data-nav-id=/cis301/3-chapter/3_1-propatom/index.html><a class=padding href=/cis301/3-chapter/3_1-propatom/index.html>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/index.html><a class=padding href=/cis301/3-chapter/3_2-notandor/index.html>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/index.html><a class=padding href=/cis301/3-chapter/3_3-implies/index.html>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/index.html><a class=padding href=/cis301/3-chapter/3_4-equiv/index.html>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/index.html><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/index.html>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/index.html><input type=checkbox id=R-section-a0d0660e4f5f539642b53fac77ff44c7 aria-controls=R-subsections-a0d0660e4f5f539642b53fac77ff44c7><label for=R-section-a0d0660e4f5f539642b53fac77ff44c7><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/index.html><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-a0d0660e4f5f539642b53fac77ff44c7 class=collapsible-menu><li data-nav-id=/cis301/4-chapter/4_1-intro/index.html><a class=padding href=/cis301/4-chapter/4_1-intro/index.html>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/index.html><a class=padding href=/cis301/4-chapter/4_2-andrules/index.html>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/index.html><a class=padding href=/cis301/4-chapter/4_3-orrules/index.html>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/index.html><a class=padding href=/cis301/4-chapter/4_4-impliesrules/index.html>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/index.html><a class=padding href=/cis301/4-chapter/4_5-notrules/index.html>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/index.html><a class=padding href=/cis301/4-chapter/4_6-strategies/index.html>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/index.html><a class=padding href=/cis301/4-chapter/4_7-theorems/index.html>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/index.html><a class=padding href=/cis301/4-chapter/4_8-equivalence/index.html>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/index.html><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/index.html>4.9. Soundness and Completeness</a></li></ul></li><li class=parent data-nav-id=/cis301/5-chapter/index.html><input type=checkbox id=R-section-589c35b8ff6263b7311a10a4d0fa83a9 aria-controls=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9 checked><label for=R-section-589c35b8ff6263b7311a10a4d0fa83a9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/index.html><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9 class=collapsible-menu><li data-nav-id=/cis301/5-chapter/5_1-motivation/index.html><a class=padding href=/cis301/5-chapter/5_1-motivation/index.html>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/index.html><a class=padding href=/cis301/5-chapter/5_2-predsyntax/index.html>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/index.html><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/index.html>5.3. Single Quantifier</a></li><li class=active data-nav-id=/cis301/5-chapter/5_4-multquant/index.html><a class=padding href=/cis301/5-chapter/5_4-multquant/index.html>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/index.html><input type=checkbox id=R-section-55edc31437b1ec5edead9beb4ef7d1fa aria-controls=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa><label for=R-section-55edc31437b1ec5edead9beb4ef7d1fa><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/index.html><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa class=collapsible-menu><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/index.html><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/index.html>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/index.html><a class=padding href=/cis301/6-chapter/6_1-univrules/index.html>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/index.html><a class=padding href=/cis301/6-chapter/6_2-existrules/index.html>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/index.html><a class=padding href=/cis301/6-chapter/6_3-nested/index.html>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/index.html><a class=padding href=/cis301/6-chapter/6_4-equiv/index.html>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/index.html><a class=padding href=/cis301/6-chapter/6_5-strategies/index.html>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/index.html><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/index.html>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/index.html><input type=checkbox id=R-section-cbba04bde749b4229ea56fb5a7c6a953 aria-controls=R-subsections-cbba04bde749b4229ea56fb5a7c6a953><label for=R-section-cbba04bde749b4229ea56fb5a7c6a953><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/index.html><b>7. </b>Mathematical Induction</a><ul id=R-subsections-cbba04bde749b4229ea56fb5a7c6a953 class=collapsible-menu><li data-nav-id=/cis301/7-chapter/7_1-process/index.html><a class=padding href=/cis301/7-chapter/7_1-process/index.html>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/index.html><a class=padding href=/cis301/7-chapter/7_2-algebraex/index.html>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/index.html><a class=padding href=/cis301/7-chapter/7_3-divex/index.html>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/index.html><a class=padding href=/cis301/7-chapter/7_4-setex/index.html>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/index.html><input type=checkbox id=R-section-010016ee1ce3fc8b575a95f1204dba7b aria-controls=R-subsections-010016ee1ce3fc8b575a95f1204dba7b><label for=R-section-010016ee1ce3fc8b575a95f1204dba7b><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/index.html><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-010016ee1ce3fc8b575a95f1204dba7b class=collapsible-menu><li data-nav-id=/cis301/8-chapter/8_1-goal/index.html><a class=padding href=/cis301/8-chapter/8_1-goal/index.html>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/index.html><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/index.html>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/index.html><a class=padding href=/cis301/8-chapter/8_3-assertassume/index.html>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/index.html><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/index.html>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/index.html><a class=padding href=/cis301/8-chapter/8_5-assignment/index.html>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/index.html><a class=padding href=/cis301/8-chapter/8_6-divmod/index.html>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/index.html><a class=padding href=/cis301/8-chapter/8_7-conditionals/index.html>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/index.html><input type=checkbox id=R-section-6864880b2cc643485ab906a5e309eaaf aria-controls=R-subsections-6864880b2cc643485ab906a5e309eaaf><label for=R-section-6864880b2cc643485ab906a5e309eaaf><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/index.html><b>9. </b>Functions and Loops</a><ul id=R-subsections-6864880b2cc643485ab906a5e309eaaf class=collapsible-menu><li data-nav-id=/cis301/9-chapter/9_1-functions/index.html><a class=padding href=/cis301/9-chapter/9_1-functions/index.html>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/index.html><a class=padding href=/cis301/9-chapter/9_2-recursion/index.html>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/index.html><a class=padding href=/cis301/9-chapter/9_3-loops/index.html>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/index.html><a class=padding href=/cis301/9-chapter/9_4-logikafacts/index.html>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/index.html><a class=padding href=/cis301/9-chapter/9_5-summary/index.html>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/index.html><input type=checkbox id=R-section-b363793b1b72566b579f69cd488e8039 aria-controls=R-subsections-b363793b1b72566b579f69cd488e8039><label for=R-section-b363793b1b72566b579f69cd488e8039><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/index.html><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-b363793b1b72566b579f69cd488e8039 class=collapsible-menu><li data-nav-id=/cis301/10-chapter/10_1-modes/index.html><a class=padding href=/cis301/10-chapter/10_1-modes/index.html>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/index.html><a class=padding href=/cis301/10-chapter/10_2-intosequences/index.html>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/index.html><a class=padding href=/cis301/10-chapter/10_3-seqfn/index.html>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/index.html><a class=padding href=/cis301/10-chapter/10_4-seqloop/index.html>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/index.html><a class=padding href=/cis301/10-chapter/10_5-globals/index.html>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/index.html><a class=padding href=/cis301/10-chapter/10_6-termination/index.html>10.6 Termination</a></li></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul><li class=R-variantswitcher><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.relearn.markVariant()</script></li></ul></div><div id=R-footer><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></aside><script src=/cis301/js/clipboard/clipboard.min.js?1760042406 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1760042406 defer></script><script src=/cis301/js/theme.min.js?1760042406 defer></script></body></html>