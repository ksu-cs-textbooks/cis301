<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Multiple Quantifiers :: CIS 301 Textbook"><meta name=twitter:description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/5-chapter/5_4-multquant/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Multiple Quantifiers :: CIS 301 Textbook"><meta property="og:description" content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Translations"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2023-12-07T13:46:44-06:00"><meta itemprop=name content="Multiple Quantifiers :: CIS 301 Textbook"><meta itemprop=description content="Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2023-12-07T13:46:44-06:00"><meta itemprop=wordCount content="1963"><title>Multiple Quantifiers :: CIS 301 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis301/5-chapter/5_4-multquant/ rel=canonical type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/index.xml rel=alternate type=application/rss+xml title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/tele.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/5-chapter/5_4-multquant/embed.html rel=alternate type=text/html title="Multiple Quantifiers :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1736887227 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1736887227 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1736887227 rel=stylesheet><link href=/cis301/css/auto-complete.css?1736887227 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1736887227 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1736887227 rel=stylesheet><link href=/cis301/css/fonts.css?1736887227 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1736887227 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1736887227 rel=stylesheet><link href=/cis301/css/theme-auto.css?1736887227 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1736887227 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1736887227 rel=stylesheet><link href=/cis301/css/print.css?1736887227 rel=stylesheet media=print><link href=/cis301/css/format-print.css?1736887227 rel=stylesheet><script src=/cis301/js/variant.js?1736887227></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1736887227 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis301/5-chapter/5_4-multquant/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/5-chapter/><span itemprop=name>Predicate Logic Translations</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Multiple Quantifiers</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_3-singlequantifier/ title="Single Quantifier (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/ title="Predicate Logic Proofs (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=multiple-quantifiers>Multiple Quantifiers</h1><p>Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:</p><ul><li>Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers)</li><li>Translations that mix quantifiers</li></ul><p>In many of the sections, we will using the predicates below (which are over the domain of shapes):</p><ul><li><code>isCircle(x)</code> - whether shape x is a circle</li><li><code>isSquare(x)</code> - whether shape x is a square</li><li><code>isRectangle(x)</code> - whether shape x is a rectangle</li><li><code>biggerThan(x, y)</code> - whether shape x is bigger than shape y</li></ul><h2 id=several-of-the-same-quantifier>Several of the same quantifier</h2><p>First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements &ndash; either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested).</p><h3 id=prenex-form>Prenex form</h3><p>The <em>prenex form</em> of a predicate logic translation lists all the quantifiers at the beginning of the statement. This is only recommended when all the quantifiers are the same type &ndash; either all universal or all existential.</p><h4 id=prenex-example-1>Prenex example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em>. Here, we are making three claims:</p><ul><li>There exists a shape that is a circle</li><li>There exists a shape that is a square</li><li>The shape that is a circle is bigger than the shape that is a square</li></ul><p>With that in mind, we can see that we will use two existential quantifiers. We can translate the statement as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x ∃ y (isCircle(x) ∧ isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where x is a circle, y is a square, and x (which is a circle) is bigger than y (which is a square).</em></p><p>Equivalently, we could have written:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x ∃ y (isCircle(y) ∧ isSquare(x) ∧ biggerThan(y, x))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where y is a circle, x is a square, and y (which is a circle) is bigger than x (which is a square).</em></p><h4 id=prenex-example-2>Prenex example 2</h4><p>Next, suppose we wished to translate: <em>Every circle is bigger than all squares</em>. Again, we are quantifying two things &ndash; ALL circles and also ALL squares. We can see that we will need to use two universal quantifiers. We can translate the statement as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x ∀ y ((isCircle(x) ∧ isSquare(y)) → biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>For each combination (x, y) of shapes, if x is a circle and y is a square, then x (which is a circle) is bigger than y (which is a square).</em></p><h3 id=aristotelian-form>Aristotelian form</h3><p>The <em>Aristotelian form</em> of a predicate logic translation embeds the quantifiers within the translation. This format is possible for any kind of translation &ndash; whether the quantifiers are all the same type or mixed types.</p><h4 id=aristotelian-form-example-1>Aristotelian form example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x (isCircle(x) ∧ (∃ y (isSquare(y) ∧ biggerThan(x, y)))</span></span></code></pre></div><p>Which reads as: <em>There exists a shape x that is a circle and there exists a shape y that is a square, and x (which is a circle) is bigger than y (which is a square)</em>.</p><h4 id=aristotelian-form-example-2>Aristotelian form example 2</h4><p>Let&rsquo;s repeat our translation for, <em>Every circle is bigger than all rectangles</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x (isCircle(x) → (∀ y (isSquare(y) → biggerThan(x, y))))</span></span></code></pre></div><p>Which reads as: <em>For every shape x, if x is a circle, then for every shape y, if y is s square, then x (which is a circle) is bigger than y (which is a square).</em></p><h2 id=mixed-quantifiers>Mixed quantifiers</h2><p>Now, we will turn to examples that mix universal and existential quantifiers. We will see below that quantifier order matters in this case, so it is safest to translate such statements using embedded quantifiers. The embedded form can be tricky to write, so we will see a way to systematically translate any statement that needs multiple quantifiers into predicate logic (using Aristotelian form).</p><h3 id=systematic-translation>Systematic translation</h3><p>Suppose we wish to translate, <em>Every circle is bigger than at least one square</em>. We see that we are first making a claim about all circles. Without worrying about the rest of the statement, we know that for all circles, we are saying <em>something</em>. So we write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>For all circles, SOMETHING</span></span></code></pre></div><p>Trying to formalize a bit more, we assign a variable to the current circle we are describing (<code>x</code>). For each circle x, we are saying <em>something</em> about that circle. So we express SOMETHING(x) as some claim about our current circle, and write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>For each circle x, SOMETHING(x)</span></span></code></pre></div><p>We see that we will need a universal quantifier since we are talking about ALL circles, and we also follow the guide of using an implies statement to work with a for-all statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x (isCircle(x) → SOMETHING(x))</span></span></code></pre></div><p>Next, we describe what <code>SOMETHING(x)</code> means for a particular circle, <code>x</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SOMETHING(x): x is bigger than at least one square</span></span></code></pre></div><p>Trying to formalize a bit more about the square, we write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SOMETHING(x): There exists a square y, and x is bigger than y</span></span></code></pre></div><p>Now we can use an existential quantifier to describe our square, and plug in our isSquare and biggerThan predicates to have a translation for SOMETHING(x):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SOMETHING(x): ∃ y (isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Now, we can plug SOMETHING(x) into our first partial translation, <code>∀ x (isCircle(x) → SOMETHING(x))</code>. The complete translation for <em>Every circle is bigger than at least one square</em> is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x (isCircle(x) → (∃ y (isSquare(y) ∧ biggerThan(x, y))))</span></span></code></pre></div><h3 id=follow-up-examples>Follow-up examples</h3><p>In these examples, suppose our domain is animals and that we have the following predicates:</p><ul><li><code>El(x)</code>: whether animal x is an elephant</li><li><code>Hi(x)</code>: whether animal x is a hippo</li><li><code>W(x, y)</code>: whether animal x weighs more than animal y</li></ul><p>Suppose we wish to translate: <em>There is exactly one hippo.</em> We might first try saying: <code>∃ x Hi(x)</code>. But this proposition would be true even if we had 100 hippos, so we need something more restricted. What we are really trying to say is:</p><ul><li>There exists a hippo</li><li>AND, any other hippo is the same one</li></ul><p>Let&rsquo;s use our systematic approach, streamlining a few of the steps:</p><ul><li>There exists an animal x that is a hippo, and SOMETHING(x)</li><li><code>∃ x (Hi(x) ∧ SOMETHING(x))</code></li></ul><p>To translate SOMETHING(x), the claim we are making about our hippo x:</p><ul><li><code>SOMETHING(x)</code>: any other hippo is the same as x</li><li><code>SOMETHING(x)</code>: for each hippo y, x is the same as y</li><li><code>SOMETHING(x)</code>: `∀ y (Hi(y) → (x == y))</li></ul><p>Now we can put everything together to get a complete translation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∃ x (Hi(x) ∧ (∀ y (Hi(y) → (x == y)))</span></span></code></pre></div><p>Here are a few more translations from English to predicate logic. Think about what the following statements mean, and click to reveal each answer:</p><ul><li><p><em>Every elephant is heavier than some hippo.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>∀ x (El(x) -> (∃ y (Hi(y) ^ W(x, y))))</code></p></details><br></li></ul></li><li><p><em>There is an elephant that is heavier than all hippos.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>∃ x (El(x) ^ (∀ y (Hi(y) -> W(x, y))))</code></p></details><br></li></ul></li><li><p><em>No hippo is heavier than every elephant.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>¬(∃ x (Hi(x) ^ (∀ y (El(y) -> W(x, y)))))</code></p></details><br></li></ul></li></ul><h3 id=order-matters>Order matters!</h3><p>We have learned that when dealing with mixed quantifiers, it is safest to embed them within the translation. If we put the mixed quantifiers out front of a translation, then we can accidentally include them in the wrong order and end up with an incorrect translation.</p><p>Suppose we have this predicate, over the domain of people:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>likes(x, y): whether person x likes person y</span></span></code></pre></div><p>Further suppose that liking a person is not necessarily symmetric: that just because person x likes person y does not mean that person y necessarily likes person x.</p><p>Consider these pairs of propositions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x ∀ y likes(x, y)     vs.     ∀ y ∀ x likes(x, y)  
</span></span><span class=line><span class=cl>∃ x ∃ y likes(x, y)     vs.     ∃ y ∃ x likes(x, y)</span></span></code></pre></div><p>Is there any difference between each one? No! The two versions of the first proposition both say that every person likes every other person, and the two versions of the second proposition both say that there is a person who likes another person.</p><p>But what about:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>∀ x ∃ y likes(x, y)     vs.     ∃ y ∀ x likes(x, y)</span></span></code></pre></div><p>Suppose our domain is made up of the following people:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Bob: likes Alice and James
</span></span><span class=line><span class=cl>Alice: likes Bob
</span></span><span class=line><span class=cl>James: likes Alice</span></span></code></pre></div><p>The first proposition, <code>∀ x ∃ y likes(x, y)</code>, says that all people have some person (not necessarily the same person) that they like. This would certainly be true for our domain, as every person has at least one person that they like. The second proposition, <code>∃ y ∀ x likes(x, y)</code> is saying that there is a person (the SAME person) that everyone likes. This proposition would be false for our domain, as there is no one person that is liked by everyone.</p><h2 id=precedence-with-quantifiers>Precedence with quantifiers</h2><p>In section 2.2, we discussed operator precedence for propositional logic statements. The same operator precedence holds for predicate logic statements, except that our two quantifiers (<code>∀</code> and <code>∃</code>) have the same precedence as the NOT operator. If we have a proposition with multiple quantifiers, then the quantifiers are resolved from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</p><p>Here is an updated list of operator precedence, from most important (do first) to least important (do last):</p><ol><li>Parentheses</li><li>Not operator (<code>¬</code>), universal quantifier (<code>∀</code>), existential quantifier (<code>∃</code>)</li><li>And operator, <code>∧</code></li><li>Or operator, <code>∨</code></li><li>Implies operator, <code>→</code></li></ol><p>And here is our updated list of how to resolve multiple operators with the same precedence:</p><ol><li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li><li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li><li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li><li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li><li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li><li>Multiple quantifiers &ndash; the rightmost quantifier is resolved first, working from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</li></ol><p>When we get to predicate logic proofs in Chapter 6, we will see that Logika uses a different precedence for quantifiers &ndash; there, quantifiers have the LOWEST precedence (done last) of any operator. This ends up being more forgiving than confusing, as it will accept propositions as correct that are really missing parentheses. For example, Logika will accept: <code>∃ x isMouse(x) ∧ inHouse(x)</code>. Technically, this proposition <em>should</em> be incorrect &ndash; if we correctly treat quantifiers as having a higher precedence than <code>∧</code>, then <code>inHouse(x)</code> would no longer know about the variable <code>x</code> or its quantifier.</p><p>We <em>should</em> use parentheses with quantifiers to express our intended meaning, and so we should write <code>∃ x (isMouse(x) ∧ inHouse(x))</code> instead. But if we forget the parentheses, then Logika will forgive us.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/af82a65dc1c94cb6d0310a624077a2e135001155>Dec 7, 2023</a></p></div></div><script src=/cis301/js/clipboard.min.js?1736887227 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1736887227 defer></script><script src=/cis301/js/theme.js?1736887227 defer></script></body></html>