




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Predicate Logic Translations :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/index.html" rel="canonical" type="text/html" title="Predicate Logic Translations :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/index.xml" rel="alternate" type="application/rss+xml" title="Predicate Logic Translations :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/tele.html" rel="alternate" type="text/html" title="Predicate Logic Translations :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/embed.html" rel="alternate" type="text/html" title="Predicate Logic Translations :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1695680063" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1695680063" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1695680063" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1695680063" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1695680063" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1695680063" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1695680063" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1695680063" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1695680063" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1695680063" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1695680063" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1695680063" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/format-print.css?1695680063" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1695680063" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1695680063"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1695680063"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1695680063" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/5-chapter/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/index.html"><span itemprop="name">CIS 301 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Predicate Logic Translations</span><meta itemprop="position" content="2"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 5</div>
<h1 id="predicate-logic-translations">Predicate Logic Translations</h1>


            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Predicate Logic Translations</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="motivation">Motivation</h1>

<p>In this chapter, we will learn to further decompose statements in terms of their verbs (called <em>predicates</em>) and their nouns (called <em>individuals</em>). This leads to <em>predicate logic</em> (also called <em>first-order logic</em>).</p>
<p>As a motivation of why we want more expressive power, suppose we wanted to translate the following statements to propositional logic:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>All humans are mortal.
</span></span><span style="display:flex;"><span>Socrates is a human.
</span></span><span style="display:flex;"><span>Socrates is mortal.</span></span></code></pre></div><p>Unfortunately, each statement would be a propositional atom:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: All humans are mortal.
</span></span><span style="display:flex;"><span>q: Socrates is a human.
</span></span><span style="display:flex;"><span>r: Socrates is mortal.</span></span></code></pre></div><p>But what if we wanted to prove that given the premises: &ldquo;All humans are mortal&rdquo; and &ldquo;Socrates is a human&rdquo;, that the conclusion &ldquo;Socrates is mortal&rdquo; naturally followed? This logical argument makes sense &ndash; Socrates is a human, and all such individuals are supposed to be mortal, so it should follow that Socrates is mortal. If we tried to write such a proof in propositional logic, though, we would have the sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q ⊢ r</span></span></code></pre></div><p>&hellip;and we clearly don&rsquo;t have enough information to complete this proof.</p>
<p>We need a richer language, which we will get with predicate logic.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="syntax">Syntax</h1>

<p>In this section, we will examine the syntax for translating English sentences to predicate logic. We will still create propositions (statements that are either true or false) using logical connectives (<code>∧</code>, <code>∨</code>, <code>→</code>, and <code>¬</code>), but now we will identify the following from our English sentences</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>predicates: these will be the verbs in the sentences
</span></span><span style="display:flex;"><span>individuals: these will be the nouns in the sentences
</span></span><span style="display:flex;"><span>quantifiers: these will help us specify if we mean all individuals or at least one individual</span></span></code></pre></div><h2 id="domains">Domains</h2>
<p>Predicate logic involves expressing truth about a set of individuals. But the same statement might be true for one group of individuals, but false for others. Thus, we first need to consider which set of individuals we are discussing &ndash; called the <strong>domain</strong>.</p>
<p>A domain might be the set of all humans, the set of all animals, the set of all college classes, etc.</p>
<h2 id="individuals">Individuals</h2>
<p>An <strong>individual</strong> is an element within a specified domain. For example, if our domain is the set of all people, then <code>Bob</code> might be a particular individual. If our domain is the set of all college classes, then <code>CIS301</code> might be a particular individual.</p>
<h2 id="predicates">Predicates</h2>
<p>A <strong>predicate</strong> is a function that returns a boolean. It can have one or many parameters, each of which are individuals in a particular domain. A predicate will describe a characteristic of an individual or a comparison betwen multiple individuals.</p>
<p>For example, suppose our domain is the set of people. Suppose <code>Alice</code>, <code>Bob</code>, and <code>Carla</code> are individuals in our domain. <code>Alice</code> is <code>Bob</code>&rsquo;s mother, and <code>Carla</code> is an unrelated individual. <code>Carla</code> is 5'10 and 20 years old, <code>Alice</code> is 5'5 and 35 years old, and <code>Bob</code> is 4'10 and 10 years old.</p>
<p>Suppose we have the predicates:</p>
<ul>
<li><code>isAdult(person)</code> - returns whether <code>person</code> is an adult</li>
<li><code>isMotherOf(person1, person2)</code> - returns whether <code>person1</code> is the mother of <code>person2</code></li>
<li><code>isTallerThan(person1, person2)</code> - returns whether <code>person1</code> is taller than <code>person2</code></li>
</ul>
<p>Using our individuals above, we would have that:</p>
<ul>
<li><code>isAdult(Alice)</code> is true, since <code>Alice</code> is 35 years old</li>
<li><code>isAdult(Bob)</code> is false, since <code>Bob</code> is 10 years old</li>
<li><code>isMotherOf(Alice, Bob)</code> is true, since <code>Alice</code> is <code>Bob</code>&rsquo;s mother</li>
<li><code>isMotherOf(Carla, Bob)</code> is false, since <code>Carla</code> is not <code>Bob</code>&rsquo;s mother</li>
<li><code>isTallerThan(Carla, Alice)</code> is true, since <code>Carla</code> is 5'10 and <code>Alice</code> is 5'5.</li>
</ul>
<h2 id="quantifiers">Quantifiers</h2>
<p>We will introduce two <strong>quantifiers</strong> in predicate logic, which help us make claims about a domain of individuals.</p>
<h3 id="universal-quantifier">Universal quantifier</h3>
<p>The <code>∀</code> quantifier, called the <strong>universal quantifier</strong> and read as <em>for all</em>, lets us write propositions that pertain to ALL individuals in a domain.</p>
<p><code>∀ n P(n)</code> means: for every individual <code>n</code> (in some domain), <code>P(n)</code> is true. Here, <code>n</code> is a variable that stands for a particular individual in the domain. You can think of it like a foreach loop in C#:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>foreach(type n in domain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    //P(n) is true every time
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>where <code>n</code> is initially the first individual in the domain, then <code>n</code> is the second individual in the domain, etc.</p>
<h3 id="existential-quantifier">Existential quantifier</h3>
<p>The <code>∃</code> quantifier, called the <strong>existential quantifier</strong> and read as <em>there exists</em>, lets us write propositions that pertain to AT LEAST ONE individual in a domain.</p>
<p><code>∃ n P(n)</code> means: there exists at least one individual <code>n</code> (in some domain) where <code>P(n)</code> is true. You can again think of it as a foreach loop:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>foreach(type n in domain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    //we can find at least one time where P(n) is true
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="universal-quantifier-example">Universal quantifier example</h3>
<p>For example, suppose our domain is all candy bars, and that we have the predicate <code>isSweet(bar)</code>, which returns whether <code>bar</code> is sweet. We might write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x isSweet(x)</span></span></code></pre></div><p>Which we would read as: <em>for all candy bars x, x is sweet</em>, or, more compactly, as: <em>all candy bars are sweet</em>.</p>
<h3 id="existential-quantifier-example">Existential quantifier example</h3>
<p>If instead we wrote:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x isSweet(x)</span></span></code></pre></div><p>We would read it as: <em>there exists at least one candy bar x where x is sweet</em>, or, more compactly, as <em>there exists at least one sweet candy bar</em>.</p>
<h2 id="early-examples">Early examples</h2>
<p>Suppose our domain is animals, and that we have the following two predicates:</p>
<ul>
<li><code>isDog(x)</code>: whether animal x is a dog</li>
<li><code>hasFourLegs(x)</code>: whether animal x has four legs</li>
</ul>
<p>Let&rsquo;s consider what several predicate logic statements would mean in words:</p>
<ul>
<li><code>∀ x isDog(x)</code> - translates to: <em>All animals are dogs</em>. This means that EVERY SINGLE ANIMAL in my domain is a dog (which is probably unlikely).</li>
<li><code>∃ x hasFourLegs(x)</code> - translates to: <em>There exists at least one animal that has four legs.</em></li>
</ul>
<p>Next, consider the following proposition:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isDog(x) ∧ hasFourLegs(x))</span></span></code></pre></div><p>This translates to: <em>All animals are dogs and have four legs</em>. This means that EVERY SINGLE ANIMAL in my domain is a dog and also has four legs. While it is possible that this is true depending on our domain, it is unlikely. What if our domain of animals included cats, chicken,, etc.?</p>
<p>Perhaps instead we intended to say: <em>All dogs have four legs.</em> Another way to phrase this is, &ldquo;For all animals, IF that animal is a dog, THEN it has four legs.&rdquo; We can see from the IF&hellip;THEN that we will need to use an implies statement. Here is the correct translation for <em>All dogs have four legs</em>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isDog(x) → hasFourLegs(x))</span></span></code></pre></div><p>We will usually want to use the <code>→</code> operator instead of the <code>∧</code> operator when making a claim about ALL individuals.</p>
<p>Finally, consider this proposition:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (isDog(x) → hasFourLegs(x))</span></span></code></pre></div><p>This translates to: <em>There exists an animal x, and if that animal is a dog, then it has four legs.</em> Recall that an implies statement <code>p→q</code> is true whenever <code>p</code> and <code>q</code> are both true AND whenever <code>p</code> is false. So this claim is true in two cases:</p>
<ul>
<li>If our domain includes a dog that has four legs</li>
<li>If our domain includes an animal that is not a dog</li>
</ul>
<p>We likely only meant to include the first case. In that case, we would want to say, <em>There exists a dog that has four legs</em> &ndash; here is that translation:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (isDog(x) ∧ hasFourLegs(x))</span></span></code></pre></div><p>We will usually want to use the <code>∧</code> operator instead of the <code>→</code> operator when writing a proposition about one/some individuals.</p>
<h2 id="predicates-from-math">Predicates from math</h2>
<p>All of our examples in this section involved predicates over domains like people, animals, or living things. A different domain that we are used to working with is some set of numbers: the integers, the positive numbers, the rational numbers, etc.</p>
<p>Perhaps our domain is the set of all integers. Then <code>&gt;</code> is a predicate with two parameters &ndash; <code>x &gt; y</code> is defined as whether <code>x</code> is bigger than <code>y</code>, for two integers <code>x</code> and <code>y</code>. We might write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (x + 1 &gt; x)</span></span></code></pre></div><p>Because for all integers, <code>x + 1</code> is bigger than <code>x</code>. We might also write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (x &gt; x * x * x)</span></span></code></pre></div><p>Because -4 &gt; -4 * -4 * -4, i.e., -4 &gt; -64. The same is true for any negative number.</p>
<p>Other common predicates in math are: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, and <code>!=</code>.</p>
<h2 id="quantifier-symbols">Quantifier symbols</h2>
<p>The official symbol for the universal quantifier (&ldquo;for all&rdquo;) is an upside-down A, like this: <code>∀</code>. You are welcome to substitute either a capital <code>A</code>, or with the word <code>all</code> or <code>forall</code>. This will be especially handy when we reach Chapter 6 on writing proofs in predicate logic.</p>
<p>The official symbol for the existential quantifier (&ldquo;there exists&rdquo;) is a backwards E, like this: <code>∃</code>. You are welcome to substitute either a capital <code>E</code>, or with the word <code>some</code> or <code>exists</code>.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="single-quantifier">Single Quantifier</h1>

<p>In this section, we will see how to translate simpler statements between English to predicate logic. These translations will involve a single quantifier.</p>
<h2 id="example-predicate-logic-to-english">Example: Predicate logic to English</h2>
<p>Suppose our domain is animals and that we have the following two predicates:</p>
<ul>
<li><code>isMouse(x)</code>: whether animal <code>x</code> is a mouse</li>
<li><code>inHouse(x)</code>: whether animal <code>x</code> is in the house</li>
</ul>
<p>Suppose we also have that <code>Squeaky</code> is an individual in our domain.</p>
<p>We will practice translating from predicate logic to English. Think about what the following propositions mean, and click to reveal each answer:</p>
<ul>
<li>
<p><code>isMouse(Squeaky) ∧ ¬inHouse(Squeaky)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Squeaky is a mouse, and Squeaky is not in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is a mouse".
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x isMouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is not a mouse."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x ¬isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is an animal that is not a mouse".
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "All animals are mice."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x isMouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Not all animals are mice."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x ¬isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "All animals are not mice."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (isMouse(x) → inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "All mice are in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (isMouse(x) ∧ inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Every animal is a mouse and is in the house." (We usually don't want ∧ with ∀.)
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x (isMouse(x) → inHouse(x)))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Not all mice are in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (inHouse(x) → isMouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Everything in the house is a mouse."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x (inHouse(x) → isMouse(x)))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Not everything in the house is a mouse."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x (isMouse(x) ∧ inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is a mouse in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x (isMouse(x) → inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There exists an animal, and if that animal is a mouse, then it is in the house." Recall that this statement will be true if there is an animal that is NOT a mouse (since the → would be vacuously true) as well as being true if there is a mouse in the house.
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x (isMouse(x) ∧ inHouse(x)))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is not a mouse in the house."
  </details>
  <br>
</li>
</ul>
</li>
</ul>
<h2 id="translation-guide">Translation guide</h2>
<p>When translating from English to predicate logic, you can look for particular wording in your sentences to see how to choose a quantifier and/or negation placement. We will also see that certain phrases can be translated multiple (equivalent) ways.</p>
<ul>
<li>
<p><em>Every/all/each/any</em> is translated as: <code>∀ x ...</code></p>
</li>
<li>
<p><em>Some/at least one/there exists/there is</em> is translated as: <code>∃ x ...</code></p>
</li>
<li>
<p><em>None/no/there does not exist</em> can be translated as either <code>¬(∃ x ...)</code> or <code>∀ x ¬(...)</code></p>
</li>
<li>
<p><em>Not every/not all</em> can be translated as either <code>¬(∀ x ...)</code> or <code>∃ x ¬(...)</code></p>
</li>
<li>
<p><em>Some P-ish thing is a Q-ish thing</em> is translated as: <code>∃ x (P(x) ∧ Q(x))</code></p>
</li>
<li>
<p><em>All P-ish things are Q-ish things</em> is translated as: <code>∀ x (P(x) → Q(x))</code></p>
</li>
<li>
<p><em>No P-ish thing is a Q-ish thing</em> can be translated as either <code>¬(∃ x (P(x) ∧ Q(x)))</code> or <code>∀ x ¬(P(x) → Q(x))</code></p>
</li>
<li>
<p><em>Not all P-ish things are Q-ish things</em> can be translated as either <code>¬(∀ x (P(x) → Q(x)))</code> or <code>∃ x ¬(P(x) ∧ Q(x))</code></p>
</li>
</ul>
<h2 id="demorgans-laws-for-quantifiers">DeMorgan&rsquo;s laws for quantifiers</h2>
<p>In the translation guide above, we saw that we could often translate the same statement two different ways &ndash; one way using an existential quantifier and one way using a universal quantifier. These equivalencies are another iteration of DeMorgan&rsquo;s laws, this time applied to predicate logic.</p>
<p>Suppose we have some domain, and that <code>P(x)</code> is a predicate for individuals in that domain. DeMorgan&rsquo;s laws give us the following equivalencies:</p>
<ul>
<li><code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code></li>
<li><code>¬(∀ x P(x))</code> is equivalent to <code>∃ x ¬P(x)</code></li>
</ul>
<p>In Chapter 6, we will learn to prove that these translations are indeed equivalent.</p>
<h2 id="example-english-to-predicate-logic">Example: English to predicate logic</h2>
<p>Suppose our domain is people and that we have the following two predicates:</p>
<ul>
<li><code>K(x)</code>: whether person <code>x</code> is a kid</li>
<li><code>M(x)</code>: whether person <code>x</code> likes marshmallows</li>
</ul>
<p>We will practice translating from English to predicate logic. Think about what the following sentences mean, and click to reveal each answer:</p>
<ul>
<li><em>No kids like marshmallows.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>¬(∃ x (K(x) ∧ M(x))</code>, or equivalently, <code>∀ x ¬(K(x) → M(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Not all kids like marshmallows.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>¬(∀ x (K(x) → M(x))</code>, or equivalently, <code>∃ x (K(x) ∧ ¬M(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Everyone who likes marshmallows is a kid.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∀ x (M(x) → K(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Some people who like marshmallows are not kids.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∃ x (M(x) ∧ ¬K(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Some kids don&rsquo;t like marshmallows.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∃ x (K(x) ∧ ¬M(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Anyone who doesn&rsquo;t like marshmallows is not a kid.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∀ x (¬M(x) → ¬K(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
</ul>
<h2 id="evaluating-predicate-logic-statements-on-a-toy-domain">Evaluating predicate logic statements on a toy domain</h2>
<p>Suppose we have the following toy domain of people with the following characteristics:</p>
<ul>
<li>Bob, age 10, lives in Kansas, has siblings, has brown hair</li>
<li>Jane, age 25, lives in Delaware, has no siblings, has blonde hair</li>
<li>Alice, age 66, lives in Kansas, has siblings, has gray hair</li>
<li>Joe, age 50, lives in Nebraska, has siblings, has black hair</li>
</ul>
<p>Now suppose that we have the following predicates for individuals in our domain:</p>
<ul>
<li><code>Ad(x)</code>: whether person <code>x</code> is an adult (adults are age 18 and older)</li>
<li><code>KS(x)</code>: whether person <code>x</code> lives in Kansas</li>
<li><code>Sib(x)</code>: whether person <code>x</code> has siblings</li>
<li><code>Red(x)</code>: whether person <code>x</code> has red hair</li>
</ul>
<p>We will practice evaluating predicate logic statements on our domain of people. Think about whether the following propositions would be true or false over our domain, and then click to reveal each answer:</p>
<ul>
<li>
<p><code>∀ x Ad(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "All people are adults". This is false for our domain, as we have one person (Bob) who is not an adult.
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x ¬Ad(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "All people are not adults". This is false for our domain, as we have three people (Jane, Alice, and Joe) are are adults.
  </details>
  <br>       
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x Ad(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "Not all people are adults". This is true for our domain, as we can find a person (Bob) who is not an adult.
  </details>
  <br>       
</li>
</ul>
</li>
<li>
<p><code>∀ x (KS(x) → Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "Everyone who lives in Kansas has siblings". This is true for our domain, as we have two people who live in Kansas (Bob and Alice), and both of them have siblings.
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x (¬KS(x) ∧ Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "There is a person who doesn't live in Kansas and has siblings". This is true for our domain, as Joe lives in Nebraska and has siblings.
  </details>
  <br>  
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x (KS(x) ∧ ¬Ad(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "There does not exist a person who lives in Kansas and is not an adult". This is false for our domain, as Bob lives in Kansas and is not an adult.
  <br> 
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x (Sib(x) ∧ Red(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "There does not exist a person with siblings who has red hair". This is true for our domain, as no one with siblings (Bob, Alice, or Joe) has red hair.
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (Red(x) → Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "All people with red hair have siblings". This is true for our domain, as no one has red hair. This means that the implies statement is vacuously true for every person (since `Red(x)` is false for each person), which makes the overall proposition true.
  <br> 
</li>
</ul>
</li>
<li>
<p><code>∀ x (KS(x) ∨ Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "Everyone lives in Kansas and/or has siblings". This is false for our domain -- there is one person, Jane, who doesn't live in Kansas and also doesn't have siblings.
  <br> </li>
</ul>
</li>
</ul>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="multiple-quantifiers">Multiple Quantifiers</h1>

<p>Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:</p>
<ul>
<li>Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiiers)</li>
<li>Translations that mix quantifiers</li>
</ul>
<p>In many of the sections, we will using the predicates below (which are over the domain of shapes):</p>
<ul>
<li><code>isCircle(x)</code> - whether shape x is a circle</li>
<li><code>isSquare(x)</code> - whether shape x is a square</li>
<li><code>isRectangle(x)</code> - whether shape x is a rectangle</li>
<li><code>biggerThan(x, y)</code> - whether shape x is bigger than shape y</li>
</ul>
<h2 id="several-of-the-same-quantifier">Several of the same quantifier</h2>
<p>First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements &ndash; either using prenex form (quantifiers out front) or Aristotlian form (quantifiers nested).</p>
<h3 id="prenex-form">Prenex form</h3>
<p>The <em>prenex form</em> of a predicate logic translation lists all the quantifiers at the beginning of the statement. This is only recommended when all the quantifiers are the same type &ndash; either all universal or all existential.</p>
<h4 id="prenex-example-1">Prenex example 1</h4>
<p>Suppose we wished to translate, <em>Some circle is bigger than some square</em>. Here, we are making three claims:</p>
<ul>
<li>There exists a shape that is a circle</li>
<li>There exists a shape that is a square</li>
<li>The shape that is a circle is bigger than the shape that is a square</li>
</ul>
<p>With that in mind, we can see that we will use two existential quantifiers. We can translate the statement as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∃ y (isCircle(x) ∧ isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where x is a circle, y is a square, and x (which is a circle) is bigger than y (which is a square).</em></p>
<p>Equivalently, we could have written:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∃ y (isCircle(y) ∧ isSquare(x) ∧ biggerThan(y, x))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where y is a circle, x is a square, and y (which is a circle) is bigger than x (which is a square).</em></p>
<h4 id="prenex-example-2">Prenex example 2</h4>
<p>Next, suppose we wished to translate: <em>Every circle is bigger than all squares</em>. Again, we are quantifying two things &ndash; ALL circles and also ALL squares. We can see that we will need to use two universal quantifiers. We can translate the statement as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y ((isCircle(x) ∧ isSquare(y)) → biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>For each combination (x, y) of shapes, if x is a circle and y is a square, then x (which is a circle) is bigger than y (which is a square).</em></p>
<h3 id="aristotlian-form">Aristotlian form</h3>
<p>The <em>Aristotlian form</em> of a predicate logic translation embeds the quantifiers within the translation. This format is possible for any kind of translation &ndash; whether the quantifiers are all the same type or mixed types.</p>
<h4 id="aristotlian-form-example-1">Aristotlian form example 1</h4>
<p>Suppose we wished to translate, <em>Some circle is bigger than some square</em> using Aristotlian form. We know that will will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p>
<p>We can translate the statement using Aristotlian form as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (isCircle(x) ∧ (∃ y (isSquare(y) ∧ biggerThan(x, y)))</span></span></code></pre></div><p>Which reads as: <em>There exists a shape x that is a circle and there exists a shape y that is a square, and x (which is a circle) is bigger than y (which is a square)</em>.</p>
<h4 id="aristotlian-form-example-2">Aristotlian form example 2</h4>
<p>Let&rsquo;s repeat our translation for, <em>Every circle is bigger than all rectangles</em> using Aristotlian form. We know that will will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p>
<p>We can translate the statement using Aristotlian form as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isCircle(x) → (∀ y (isSquare(y) → biggerThan(x, y))))</span></span></code></pre></div><p>Which reads as: <em>For every shape x, if x is a circle, then for every shape y, if y is s square, then x (which is a circle) is bigger than y (which is a square).</em></p>
<h2 id="mixed-quantifiers">Mixed quantifiers</h2>
<p>Now, we will turn to examples that mix universal and existential quantifiers. We will see below that quantifier order matters in this case, so it is safest to translate such statements using embedded quantifiiers. The embedded form can be tricky to write, so we will see a way to systematically translate any statement that needs multiple quantifiers into predicate logic (using Aristotlian form).</p>
<h3 id="systematic-translation">Systematic translation</h3>
<p>Suppose we wish to translate, <em>Every circle is bigger than at least one square</em>. We see that we are first making a claim about all circles. Without worrying about the rest of the statement, we know that for all circles, we are saying <em>something</em>. So we write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>For all circles, SOMETHING</span></span></code></pre></div><p>Trying to formalize a bit more, we assign a variable to the current circle we are describing (<code>x</code>). For each circle x, we are saying <em>something</em> about that circle. So we express SOMETHING(x) as some claim about our current circle, and write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>For each circle x, SOMETHING(x)</span></span></code></pre></div><p>We see that we will need a universal quantifier since we are talking about ALL circles, and we also follow the guide of using an implies statement to work with a for-all statement:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isCircle(x) → SOMETHING(x))</span></span></code></pre></div><p>Next, we describe what <code>SOMETHING(x)</code> means for a particular circle, <code>x</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>SOMETHING(x): x is bigger than at least one square</span></span></code></pre></div><p>Trying to formalize a bit more about the square, we write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>SOMETHING(x): There exists a square y, and x is bigger than y</span></span></code></pre></div><p>Now we can use an existential quantifier to describe our square, and plug in our isSquare and biggerThan predicates to have a translation for SOMETHING(x):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>SOMETHING(x): ∃ y (isSquare(y) ∧ biggerThan(x, y))</span></span></code></pre></div><p>Now, we can plug SOMETHING(x) into our first partial translation, <code>∀ x (isCircle(x) → SOMETHING(x))</code>. The complete translation for <em>Every circle is bigger than at least one square</em> is:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isCircle(x) → (∃ y (isSquare(y) ∧ biggerThan(x, y))))</span></span></code></pre></div><h3 id="follow-up-examples">Follow-up examples</h3>
<p>In these examples, suppose our domain is animals and that we have the following predicates:</p>
<ul>
<li><code>El(x)</code>: whether animal x is an elephant</li>
<li><code>Hi(x)</code>: whether animal x is a hippo</li>
<li><code>W(x, y)</code>: whether animal x weighs more than animal y</li>
</ul>
<p>Suppose we wish to translate: <em>There is exactly one hippo.</em> We might first try saying: <code>∃ x Hi(x)</code>. But this proposition would be true even if we had 100 hippos, so we need something more restricted. What we are really trying to say is:</p>
<ul>
<li>There exists a hippo</li>
<li>AND, any other hippo is the same one</li>
</ul>
<p>Let&rsquo;s use our systematic approach, streamlining a few of the steps:</p>
<ul>
<li>There exists an animal x that is a hippo, and SOMETHING(x)</li>
<li><code>∃ x (Hi(x) ∧ SOMETHING(x))</code></li>
</ul>
<p>To translate SOMETHING(x), the claim we are making about our hippo x:</p>
<ul>
<li><code>SOMETHING(x)</code>: any other hippo is the same as x</li>
<li><code>SOMETHING(x)</code>: for each hippo y, x is the same as y</li>
<li><code>SOMETHING(x)</code>: `∀ y (Hi(y) → (x == y))</li>
</ul>
<p>Now we can put everything together to get a complete translation:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Hi(x) ∧ (∀ y (Hi(y) → (x == y)))</span></span></code></pre></div><p>Here are a few more translations from English to predicate logic. Think about what the following statements mean, and click to reveal each answer:</p>
<ul>
<li>
<p><em>Every elephant is heavier than some hippo.</em></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∀ x (El(x) -&gt; (∃ y (Hi(y) ^ W(x, y))))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><em>There is an elephant that is heavier than all hippos.</em></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∃ x (El(x) ^ (∀ y (Hi(y) -&gt; W(x, y))))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><em>No hippo is heavier than every elephant.</em></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>¬(∃ x (Hi(x) ^ (∀ y (El(y) -&gt; W(x, y)))))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
</ul>
<h3 id="order-matters">Order matters!</h3>
<p>We have learned that when dealing with mixed quantifiers, it is safest to embed them within the translation. If we put the mixed quantifiers out front of a translation, then we can accidentally include them in the wrong order and end up with an incorrect translation.</p>
<p>Suppose we have this predicate, over the domain of people:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>likes(x, y): whether person x likes person y</span></span></code></pre></div><p>Further suppose that liking a person is not necessarily symmetric: that just because person x likes person y does not mean that person y necessarily likes person x.</p>
<p>Consider these pairs of propositions:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y likes(x, y)     vs.     ∀ y ∀ x likes(x, y)  
</span></span><span style="display:flex;"><span>∃ x ∃ y likes(x, y)     vs.     ∃ y ∃ x likes(x, y)</span></span></code></pre></div><p>Is there any difference between each one? No! The two versions of the first proposition both say that every person likes every other person, and the two versions of the second proposition both say that there is a person who likes another person.</p>
<p>But what about:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∃ y likes(x, y)     vs.     ∃ y ∀ x likes(x, y)</span></span></code></pre></div><p>Suppose our domain is made up of the following people:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Bob: likes Alice and James
</span></span><span style="display:flex;"><span>Alice: likes Bob
</span></span><span style="display:flex;"><span>James: likes Alice</span></span></code></pre></div><p>The first proposition, <code>∀ x ∃ y likes(x, y)</code>, says that all people have some person (not necessarily the same person) that they like. This would certainly be true for our domain, as every person has at least one person that they like. The second proposition, <code>∃ y ∀ x likes(x, y)</code> is saying that there is a person (the SAME person) that everyone likes. This proposition would be false for our domain, as there is no one person that is liked by everyone.</p>
<h2 id="precedence-with-quantifiers">Precedence with quantifiers</h2>
<p>In section 2.2, we discussed operator precedence for propositional logic statements. The same operator precedence holds for predicate logic statements, except that our two quantifiers (<code>∀</code> and <code>∃</code>) have the same precedence as the NOT operator. If we have a proposition with multiple quantifiers, then the quantifiers are resolved from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</p>
<p>Here is an updated list of operator precedence, from most important (do first) to least important (do last):</p>
<ol>
<li>Parentheses</li>
<li>Not operator (<code>¬</code>), universal quantifier (<code>∀</code>), existential quantifier (<code>∃</code>)</li>
<li>And operator, <code>∧</code></li>
<li>Or operator, <code>∨</code></li>
<li>Implies operator, <code>→</code></li>
</ol>
<p>And here is our updated list of how to resolve multiple operators with the same precedence:</p>
<ol>
<li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li>
<li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li>
<li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li>
<li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li>
<li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li>
<li>Multiple quantifiers &ndash; the rightmost quantifier is resolved first, working from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</li>
</ol>
<p>When we get to predicate logic proofs in Chapter 6, we will see that Logika uses a different precedence for quantifiers &ndash; there, quantifiers have the LOWEST precedence (done last) of any operator. This ends up being more forgiving than confusing, as it will accept propositions as correct that are really missing parentheses. For example, Logika will accept: <code>∃ x isMouse(x) ∧ inHouse(x)</code>. Technically, this proposition <em>should</em> be incorrect &ndash; if we correctly treat quantifiers as having a higher precedence than <code>∧</code>, then <code>inHouse(x)</code> would no longer know about the variable <code>x</code> or its quantifier.</p>
<p>We <em>should</em> use parentheses with quantifiers to express our intended meaning, and so we should write <code>∃ x (isMouse(x) ∧ inHouse(x))</code> instead. But if we forget the parentheses, then Logika will forgive us.</p>

            <footer class="footline">

            </footer>
          </article>

          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/dec4297d81df48b5e02e2640601321e923ab5f5b">Aug 10, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1695680063" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1695680063" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1695680063" defer></script>
  </body>
</html>
