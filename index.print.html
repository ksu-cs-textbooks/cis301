<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Julie Thornton Department of Computer Science Kansas State University
Email: juliet@ksu.edu
This is the textbook for CIS 301, Logical Foundations of Programming, at Kansas State University. It is adapted from two previous versions of the course text:
CIS 301 Lecture Notes, by Dr. David Schmidt
Logika: Programming Logics adapted from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="CIS 301 Textbook"><meta name=twitter:description content="Julie Thornton Department of Computer Science Kansas State University
Email: juliet@ksu.edu
This is the textbook for CIS 301, Logical Foundations of Programming, at Kansas State University. It is adapted from two previous versions of the course text:
CIS 301 Lecture Notes, by Dr. David Schmidt
Logika: Programming Logics adapted from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="CIS 301 Textbook"><meta property="og:description" content="Julie Thornton Department of Computer Science Kansas State University
Email: juliet@ksu.edu
This is the textbook for CIS 301, Logical Foundations of Programming, at Kansas State University. It is adapted from two previous versions of the course text:
CIS 301 Lecture Notes, by Dr. David Schmidt
Logika: Programming Logics adapted from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="CIS 301 Textbook"><meta itemprop=description content="Julie Thornton Department of Computer Science Kansas State University
Email: juliet@ksu.edu
This is the textbook for CIS 301, Logical Foundations of Programming, at Kansas State University. It is adapted from two previous versions of the course text:
CIS 301 Lecture Notes, by Dr. David Schmidt
Logika: Programming Logics adapted from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi"><meta itemprop=dateModified content="2023-08-10T14:52:41-05:00"><meta itemprop=wordCount content="64"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>CIS 301 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis301/index.html rel=canonical type=text/html title="CIS 301 Textbook"><link href=/cis301/index.xml rel=alternate type=application/rss+xml title="CIS 301 Textbook"><link href=/cis301/index.lti.js rel=alternate type=text/javascript title="CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1755885657 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1755885657 defer></script><script src=/cis301/js/search-lunr.min.js?1755885657 defer></script><script src=/cis301/js/search.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1755885657"</script><script src=/cis301/js/lunr/lunr.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1755885657 rel=stylesheet><link href=/cis301/css/theme.min.css?1755885657 rel=stylesheet><link href=/cis301/css/format-print.min.css?1755885657 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/index.html",window.relearn.relBasePath=".",window.relearn.relBaseUri="..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["auto","light-theme","dark-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!0,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1755885657 rel=stylesheet></head><body class="mobile-support print" data-url=/cis301/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><span itemprop=name>CIS 301 Textbook</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/_index.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><span class=topbar-control><i class="fa-fw fas fa-chevron-left"></i></span></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/0-chapter/index.html title="Getting Started (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable page" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=cis-301-textbook>CIS 301 Textbook</h1><p>Julie Thornton<br>Department of Computer Science<br>Kansas State University</p><p>Email: <a href=mailto:juliet@ksu.edu rel=external target=_blank>juliet@ksu.edu</a></p><p>This is the textbook for CIS 301, <em>Logical Foundations of Programming</em>, at Kansas State University. It is adapted from two previous versions of the course text:</p><ul><li><p><a href=https://people.cs.ksu.edu/~schmidt/301s14/Lectures/home.html rel=external target=_blank>CIS 301 Lecture Notes</a>, by Dr. David Schmidt</p></li><li><p><a href=http://logika.v3.sireum.org/dschmidt/ rel=external target=_blank>Logika: Programming Logics</a> adapted from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi</p></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of CIS 301 Textbook</h1><article class=default><header class=headline></header><h1 id=getting-started>Getting Started</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Getting Started</h1><article class=default><header class=headline></header><h1 id=tools-guide>Tools Guide</h1><h2 id=github-account>GitHub account</h2><p>First, you will need to create a GitHub account <a href=https://github.com/ rel=external target=_blank>here</a>. If you already have one, you can use your existing account.</p><h2 id=sireum-logika>Sireum Logika</h2><p>In CIS 301, we will use a tool called Logika, which is a verifier and a proof checker for propositional, predicate, and programming logic. You will need to install the VS Code-based Sireum IVE (Integrated Verification Environment), which contains Logika.</p><h3 id=getting-installer-script>Getting Installer Script</h3><p>Go <a href=https://sireum.org/getting-started/#latest-release-bin-codeive rel=external target=_blank>here</a> under &ldquo;VSCodium-based IVE Only&rdquo; (which is also under the &ldquo;Latest Release&rdquo; heading above) to install Logika.</p><p>Select either &ldquo;Windows&rdquo; or &ldquo;macOS/Linux&rdquo;. The instructions below should update based on your selection. Copy the command listed for your operating system.</p><h3 id=installing-and-running-sireum-logika---windows>Installing and Running Sireum Logika - Windows</h3><p>For Windows users, open a File Explorer and navigate to <code>C:\Users\&lt;yourAccountName>\Applications</code>. Select the text in the address bar like this:</p><p><a href=#R-image-c35f26f8d8efc657b9a4a76c2c605a1b class=lightbox-link><img alt="File Explorer" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/fileExplorer.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c35f26f8d8efc657b9a4a76c2c605a1b><img alt="File Explorer" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/fileExplorer.png></a></p><p>Type &ldquo;cmd&rdquo; to overwrite the selected text:</p><p><a href=#R-image-adb1d3b1194324a0b9c47a460648470e class=lightbox-link><img alt=cmd class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/cmd.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-adb1d3b1194324a0b9c47a460648470e><img alt=cmd class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/cmd.png></a></p><p>And hit Enter. It should open up a command prompt that is already in your <code>C:\Users\&lt;yourAccountName>\Applications</code> folder:</p><p><a href=#R-image-0cec44d03fdcc82d28ac8999e211d01c class=lightbox-link><img alt="Open Command Prompt" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/cmdOpen.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-0cec44d03fdcc82d28ac8999e211d01c><img alt="Open Command Prompt" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/cmdOpen.png></a></p><p>In the command prompt, paste the installer command you copied in the previous step. You should immediately see feedback that your computer is fetching Sireum Logika.</p><p>Once the installation is finished, open a file explorer and navigate to <code>C:\Users\&lt;yourAccountName>\Applications\Sireum\bin\win\vscodium</code>. In that folder, you should see the application &ldquo;CodeIVE.exe&rdquo;. Double-click that application to run it (if you see a popup that asks if you want to allow access to your computer, go ahead and choose that you want to do so).</p><p>You may find it handy to pin the &ldquo;CodeIVE.exe&rdquo; application to your taskbar. You can do so by right-clicking the &ldquo;CodeIVE.exe&rdquo; file and selecting &ldquo;Pin to taskbar&rdquo;.</p><h3 id=installation-and-running-sireum-logika---mac>Installation and Running Sireum Logika - Mac</h3><p>For Mac users, open a terminal window and paste the command you copied in the previous step. You should immediately see feedback that your computer is fetching Sireum Logika.</p><p>Once the installation is finished, go to the finder and search for &ldquo;CodeIVE&rdquo;. You should see the application &ldquo;CodeIVE.exe&rdquo; - if you run it, it will open Sireum Logika.</p><h2 id=how-to-start-homework-assignments>How to Start Homework Assignments</h2><p>To start a homework assignment (or to clone any existing repository, including homework solutions and lecture examples), first:</p><ul><li>Click to &ldquo;accept the assignment&rdquo; from the link in Canvas (if you are cloning a homework assignment or solution).</li><li>Go to the URL created for your assignment (or to the URL of the repository you want to clone).</li><li>You should be looking at a website that looks something like this:</li></ul><p><a href=#R-image-f5951749e2084a1cde8f252833139ee5 class=lightbox-link><img alt="GitHub assignment" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/gitHubAssign.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f5951749e2084a1cde8f252833139ee5><img alt="GitHub assignment" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/gitHubAssign.png></a></p><h3 id=get-repo-url>Get repo URL</h3><p>Click the Green <em>Code</em> button, so that you see something like this:</p><p><a href=#R-image-184fc83d94e52791dd0f77e66f3dd4a9 class=lightbox-link><img alt="GitHub clone" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/gitHubClone.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-184fc83d94e52791dd0f77e66f3dd4a9><img alt="GitHub clone" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/gitHubClone.png></a></p><p>Next, open Sireum VS Codium (by running the CodeIVE application). You should see:</p><p><a href=#R-image-3d2a010d95398436921d167c888f5a78 class=lightbox-link><img alt="Open Sireum" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/openSireum.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3d2a010d95398436921d167c888f5a78><img alt="Open Sireum" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/openSireum.png></a></p><p>Next, click the third icon in the column on the left side (the one that looks like a circuit and says &ldquo;Source Control&rdquo; when you hover over it). You should see:</p><p><a href=#R-image-b9fd89a30f5546ff08507da08f8390fb class=lightbox-link><img alt="Source Control" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/openSourceControl.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b9fd89a30f5546ff08507da08f8390fb><img alt="Source Control" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/openSourceControl.png></a></p><p>Click <em>Clone Repository</em>. Now you should see something like:</p><p><a href=#R-image-b70bceab181fd8db822460b7e40d130b class=lightbox-link><img alt="Clone Repository" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/getFromVCS.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b70bceab181fd8db822460b7e40d130b><img alt="Clone Repository" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/getFromVCS.png></a></p><p>Paste the URL you copied from GitHub in the textbox indicated above. Click &ldquo;Clone from URL&rdquo;.</p><p>You will then be prompted to choose a folder to clone your repository into. Navigate to a folder on your computer specifically for CIS 301 (create one if it doesn&rsquo;t exist). Create a new empty folder within that CIS 301 folder to hold this new project. Select that new folder in the selection dialog, so that you now have something like this:</p><p><a href=#R-image-3b114a78d1cce9d9cea2f3db63d275ba class=lightbox-link><img alt="Select Clone Location" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/cloneToSireum.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3b114a78d1cce9d9cea2f3db63d275ba><img alt="Select Clone Location" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/cloneToSireum.png></a></p><p>Click <em>Select as Repository Destination</em>. You should see a popup that asks if you want to open the cloned repository. Select &ldquo;Open&rdquo;. Next you should see something like:</p><p><a href=#R-image-cfec647a3c7b3649d6813db33cb955fe class=lightbox-link><img alt="Clone Result" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/clonedResult.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-cfec647a3c7b3649d6813db33cb955fe><img alt="Clone Result" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/clonedResult.png></a></p><p>If you see a popup in the bottom right that asks if you want to import a Sireum project, then click <em>Yes</em>.</p><h2 id=installing-sireum-fonts>Installing Sireum Fonts</h2><p>When you have Sireum VS Codium open, click the gear icon in the lower-right corner. Click the option that says &ldquo;Command Palette&rdquo;:</p><p><a href=#R-image-3ec317deb63dac10bdc861e80423fcf8 class=lightbox-link><img alt="Open Command Palette" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/openCommandPalette.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3ec317deb63dac10bdc861e80423fcf8><img alt="Open Command Palette" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/openCommandPalette.png></a></p><p>Type &ldquo;run&rdquo; in the resulting textbox. Click the option that says: &ldquo;Tasks: Run Task&rdquo;.</p><p><a href=#R-image-b7c541dee63fd161a36e2aa4350a9128 class=lightbox-link><img alt="Run Task" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/runTask.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b7c541dee63fd161a36e2aa4350a9128><img alt="Run Task" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/runTask.png></a></p><p>Next, click the &ldquo;sireum&rdquo; folder:</p><p><a href=#R-image-48d45cce5982421942babddb57ec5f64 class=lightbox-link><img alt="Sireum Task" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/sireumTask.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-48d45cce5982421942babddb57ec5f64><img alt="Sireum Task" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/sireumTask.png></a></p><p>Finally, click &ldquo;sireum: &ndash;install-fonts&rdquo;:</p><p><a href=#R-image-5f94833b1c3d3306b7096709df592678 class=lightbox-link><img alt="Install Fonts" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/installFonts.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-5f94833b1c3d3306b7096709df592678><img alt="Install Fonts" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/installFonts.png></a></p><p>You might be asked for the installation location of Sireum at this point &ndash; if so, it is <code>C:\Users\&lt;yourAccountName>\Applications\Sireum</code> for Windows and <code>/Users/&lt;yourAccountName>/Applications/Sireum</code> for Mac. Windows users might need to type the location directly into the address bar if you can&rsquo;t find the <code>Applications</code> folder in the file explorer.</p><p>If the new fonts (which show logic symbols instead of characters like <code>&</code> and <code>|</code>) don&rsquo;t immediately appear, try restarting Sireum VS Codium.</p><h2 id=running-logika-checker>Running Logika Checker</h2><p>When you are ready to verify a Logika truth table or proof, click the gear icon in the lower-right corner and select &ldquo;Command Palette&rdquo;:</p><p><a href=#R-image-34435bad26704c7961c2ae51ee033f83 class=lightbox-link><img alt="Open Command Palette" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/openCommandPalette.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-34435bad26704c7961c2ae51ee033f83><img alt="Open Command Palette" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/openCommandPalette.png></a></p><p>Type &ldquo;run&rdquo; in the resulting textbox. Click the option that says: &ldquo;Tasks: Run Task&rdquo;.</p><p><a href=#R-image-b27aa8d210eaad965d84f78e1a1aa4f9 class=lightbox-link><img alt="Run Task" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/runTask.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b27aa8d210eaad965d84f78e1a1aa4f9><img alt="Run Task" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/runTask.png></a></p><p>Next, click the &ldquo;sireum logika&rdquo; folder:</p><p><a href=#R-image-56c4bdd3ecb5c6b78b85a573f6a5350b class=lightbox-link><img alt="Sireum Logika" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/sireumLogika.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-56c4bdd3ecb5c6b78b85a573f6a5350b><img alt="Sireum Logika" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/sireumLogika.png></a></p><p>Finally, choose the option that says &ldquo;sireum logika: verifier (file)&rdquo;. You should see either a popup that says &ldquo;Logika verified&rdquo;, or you should see red error markings in your file indicating where the logic doesn&rsquo;t hold up. You can hover over these red error markings to get popups with more information on the error.</p><p>As a shortcut to verify a proof or truth table, you can do: <code>Ctrl-Shift-W</code> on Windows or <code>Command-Shift-W</code> on Mac.</p><p>NOTE: You might be asked to choose the installation folder of Sireum the first time you run the Logika checker. If you are, the installation folder is <code>C:\Users\&lt;yourAccountName>\Applications\Sireum</code> for Windows and <code>/Users/&lt;yourAccountName>/Applications/Sireum</code> for Mac. Windows users might need to type the location directly into the address bar if you can&rsquo;t find the <code>Applications</code> folder in the file explorer.</p><h2 id=committing-and-pushing-changes>Committing and Pushing Changes</h2><p>When you are finished working, commit and push your changes to GitHub. (I recommend doing this anytime you are at a stopping point, as well as when you are completely done.)</p><p>To do this, first save all your files (File-Save or Ctrl-S). Make sure none of the open file tabs have a solid circle next to the file name &ndash; this is an indication that they are unsaved. When everything is saved, open the integrated terminal in Code IVE by choosing View->Terminal. From there, type:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>git add .</span></span></code></pre></div><p>This will add all changes to the current commit. Then type:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>git commit -m &#34;descriptive message&#34;</span></span></code></pre></div><p>to create a local commit, where &ldquo;descriptive message&rdquo; is replaced with a message describing your changes (you DO need to include the quotations). Finally, push your local commit to your remote repository:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>git push</span></span></code></pre></div><p>If you go to your GitHub repository URL and refresh the page, you should see the latest changes.</p><p>If you have any errors using a <code>git</code> command, refer to the next section (&ldquo;git Install&rdquo; for instructions on getting the command-line version of <code>git</code>).</p><p>Homework 0 will help you test the GitHub process.</p><h2 id=using-sireum-in-the-lab-classrooms>Using Sireum in the Lab Classrooms</h2><p>Sireum IVE (with Logika) is available in the CS computer lab classrooms (DUE 1114, 1116, and 1117). To find it, open a File Explorer, then open the C:\ drive. From there, navigate to &ldquo;C:\Sireum\bin\win\vscodium&rdquo; and run the &ldquo;CodeIVE.exe&rdquo; file. This will launch Sireum as usual.</p><p>If you want to complete your assignment using multiple computers, you can:
- Clone the repo using the process above (if it is your first time working on the current assignment on this computer)
- Commit/push your changes when you are ready to leave this computer
- Do Git->Pull to get your latest changes if you come back to a different computer</p><h2 id=remote-access>Remote Access</h2><p>If you have any problems installing Sireum on your own computer, you can access it remotely from the CS department. See <a href=https://support.cs.ksu.edu/CISDocs/wiki/Remote_Access rel=external target=_blank>here</a> for information on remote access. When you connect to the department Window&rsquo;s server, you can follow the instructions above to find Sireum as you would on a lab computer.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=git-install>git Install</h1><h2 id=verify-a-git-install>Verify a git install</h2><p>You will likely already have a command-line version of <code>git</code> installed on your machine. To check, open a folder in VS Code, display the integrated terminal, and type:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>git --version</span></span></code></pre></div><p>You should see a version number printing out. If you see that, <code>git</code> is already installed.</p><p>If you see an error that <code>git</code> is unrecognized, then you will need to install it. Go <a href=https://git-scm.com/downloads rel=external target=_blank>here</a> to download and install the latest version.</p><p>Windows users may need to add the <code>git.exe</code> location to the system <code>Path</code> environment variables. Most likely, <code>git.exe</code> will be installed to <code>C:\Program Files\Git\bin</code>. Check this location, copy its address, and type &ldquo;Environment variables&rdquo; in the Windows search. Click &ldquo;Environment Variables&rdquo; and find &ldquo;Path&rdquo; under System variables. Click &ldquo;Edit&mldr;&rdquo;. Verify that <code>C:\Program Files\Git\bin</code> (or whatever your <code>git</code> location) is the last item listed. If it isn&rsquo;t, add a new entry for <code>C:\Program Files\Git\bin</code>.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=basics-and-logic-puzzles>Basics and Logic Puzzles</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Basics and Logic Puzzles</h1><article class=default><header class=headline></header><h1 id=basic-logical-reasoning>Basic Logical Reasoning</h1><h2 id=what-is-logical-reasoning>What is logical reasoning?</h2><p>Logical reasoning is an analysis of an argument according to a set of rules. In this course, we will be learning several sets of rules for more formal analysis, but for now we will informally analyze English sentences and logic puzzles. This will help us practice the careful and rigorous thinking that we will need in formal proofs and in computer science in general.</p><h2 id=premises-and-conclusions>Premises and conclusions</h2><p>A <em>premise</em> is a piece of information that we are given in a logical argument. In our reasoning, we assume premises are true &ndash; even if they make no sense!</p><p>A <em>conclusion</em> in a logical argument is a statement whose validity we are checking. Sometimes we are given a conclusion, and we are trying to see whether that conclusion makes sense when we assume our premises are true. Other times, we are asked to come up with our own (valid) conclusion that we can deduce from our premises.</p><h2 id=example>Example</h2><p>Suppose we are given the following premises:</p><ul><li>Premise 1: <em>If a person wears a red shirt, then they don&rsquo;t like pizza.</em></li><li>Premise 2: <em>Fred is wearing a red shirt.</em></li></ul><p>Given those pieces of information, can we conclude the following?</p><p><em>Fred doesn&rsquo;t like pizza.</em></p><p>Yes! We take the premises at face value and assume them to be true (even though it is kind of ridiculous that shirt color has anything to do with a dislike of pizza). The first premise PROMISES that any time we have a person with a red shirt, then that person does not like pizza. Since Fred is such a person, we can conclude that Fred doesn&rsquo;t like pizza.</p><h2 id=logical-arguments-with-or>Logical arguments with &ldquo;OR&rdquo;</h2><p>Interpreting English sentences that use the word &ldquo;or&rdquo; can be tricky &ndash; the or can either be an <em>inclusive or</em> or an <em>exclusive or</em>. In programming, we are used to using an inclusive or &ndash; a statement like <code>p || q</code> is true as long as at least one of <code>p</code> or <code>q</code> is true, even if both are true. The only time a statement like <code>p || q</code> is false is if both <code>p</code> and <code>q</code> are false.</p><p>In English, however, the word &ldquo;or&rdquo; often implies an exclusive or. If a restaurant advertises that customers can choose &ldquo;chips or fries&rdquo; as the side for their meal, they are certainly not intending that a customer demand both sides.</p><p><b>However, since this course is focused on formal logic and analyzing computer programs and not so much on resolving language ambiguity, we will adopt the stance that the word &ldquo;or&rdquo; always means <em>inclusive or</em> unless otherwise specified.</b></p><h3 id=or-example-1>Or example #1</h3><p>With that in mind, suppose we have the following premises:</p><ul><li><em>I have a dog or I have a cat.</em></li><li><em>I do not have a cat.</em></li></ul><p>What can we conclude?</p><p>The only time an &ldquo;or&rdquo; statement true is when at least one of its parts is true. Since we already know that the right side of the or (&ldquo;I have a cat&rdquo;) is false, then we can conclude that the left side MUST be true. So we conclude:</p><p><em>I have a dog.</em></p><p>In general, if you have an or statement as a premise and you also know that one side of the or is NOT true, then you can always conclude that the other side of the or IS true.</p><h3 id=or-example-2>Or example #2</h3><p>Suppose we have the following premises:</p><ul><li><em>I have a bike or I have a car.</em></li><li><em>I have a bike.</em></li></ul><p>Can we conclude anything new?</p><p>First of all, I acknowledge that the most natural interpretation of the first premise is an exclusive or &ndash; that I have EITHER a bike OR a car, but not both. I think that is how most people would naturally interpret that sentence as well. However, in this course we will always consider &ldquo;or&rdquo; to be an inclusive or, unless we specifically use words like &ldquo;but not both&rdquo;.</p><p>With that in mind, the second premise is already sufficient to make the first premise true. Since I have a bike, the statement &ldquo;I have a bike or I have a car&rdquo; is already true, whether or not I have a car. Because of this, we can&rsquo;t draw any further conclusions beyond our premises.</p><h2 id=or-example-3>Or example 3</h2><p>Suppose we have the following premises:</p><ul><li><em>I either have a bike or a car, but not both.</em></li><li><em>I have a bike.</em></li></ul><p>What can we conclude?</p><p>This is the sentence structure I will use if I mean an exclusive or &ndash; &ldquo;either p or q but not both&rdquo;.</p><p>In this setup, we CAN conclude that I do not have a car. This is because an exclusive or is FALSE when both sides are true, and I already know that one side is true (I have a bike). The only way for the first premise to be true is when I do not also have a car.</p><h2 id=logical-arguments-with-ifthen-aka-implies->Logical arguments with <em>if/then</em> (aka <em>implies</em>, â†’)</h2><p>Statements with of the form, <em>if p, then q</em> are making a promise &ndash; that if <em>p</em> is true, then they promise that <em>q</em> will also be true. We will later see this structure using the logical <em>implies</em> operator.</p><h3 id=ifthen-example-1>If/then example 1</h3><p>Suppose we have the following premises:</p><ul><li><em>If it is raining, then I will get wet.</em></li><li><em>It is raining.</em></li></ul><p>What can I conclude?</p><p>The first premises PROMISES that if it is raining, then I will get wet. Since we assume this premise is true, then we must keep the promise. Since the second premise tells us that it IS raining, then we can conclude:</p><p><em>I will get wet.</em></p><h3 id=ifthen-example-2>If/then example 2</h3><p>Suppose we have the following premises:</p><ul><li><em>If I don&rsquo;t hear my alarm, then I will be late for class.</em></li><li><em>I am late for class.</em></li></ul><p>Can we conclude anything new?</p><p>The first premise promises that if I don&rsquo;t hear my alarm, then I will be late for class. And if we knew that I didn&rsquo;t hear my alarm, then we would be able to conclude that I will be late for class (in order to keep the promise).</p><p>However, we do NOT know that I don&rsquo;t hear my alarm. All we are told is that I am late for class. I might be late for class for many reasons &ndash; maybe I got stuck in traffic, or my car broke down, or I got caught up playing a video game. We don&rsquo;t have enough information to conclude WHY I&rsquo;m late for class, and in fact we can&rsquo;t conclude anything new at at all.</p><h3 id=ifthen-example-3>If/then example 3</h3><p>Suppose we have the following premises:</p><ul><li><em>If I don&rsquo;t hear my alarm, then I will be late for class.</em></li><li><em>I&rsquo;m not late for class.</em></li></ul><p>What can we conclude?</p><p>This is a trickier example. We saw previously that the first premise promised that anytime I didn&rsquo;t hear my alarm, then I would be late for class. But we can interpret this another way &ndash; since I&rsquo;m NOT late for class, then I must have heard my alarm. After all, if I DIDN&rsquo;T hear my alarm, then I would have been late. But I&rsquo;m not late, so the opposite must be true. So we can conclude that:</p><p><em>I hear my alarm.</em></p><p>Reframing an if/then statement like that is called writing its <em>contrapositive</em>. Any time we have a statement of the form <em>if p, then q</em> then we can write the equivalent statement <em>if not q, then not p</em>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=knights-and-knaves>Knights and Knaves</h1><p>We will now move to solving several kinds of logic puzzles. While these puzzles aren&rsquo;t strictly necessary to understand the remaining course content, they require the same rigorous analysis that we will use when doing more formal truth tables and proofs. Plus, they&rsquo;re fun!</p><p>The puzzles in this section and the rest of this chapter are all either from or inspired by: <em>What is the Name of This Book?</em>, by Raymond Smullyan.</p><h2 id=island-of-knights-and-knaves>Island of Knights and Knaves</h2><p>This section will involve knights and knaves puzzles, where we meet different inhabitants of the mythical island of Knights and Knaves. Each inhabitant of this island is either a <em>knight</em> or a <em>knave</em>.</p><p>Knights ALWAYS tell the truth, and knaves ALWAYS lie.</p><h2 id=example-1>Example 1</h2><p>Can any inhabitant of the island of Knights and Knaves say, &ldquo;I&rsquo;m a knave&rdquo;?</p><details><summary><b>-â†’ Click for solution</b></summary><p>No! A knight couldn&rsquo;t make that statement, as knights always tell the truth. And a knave couldn&rsquo;t make that statement either, since it would be true &ndash; and knaves always lie.</p></details><h2 id=example-2>Example 2</h2><p>You see two inhabitants of the island of Knights and Knaves &ndash; Ava and Bob.</p><ul><li>Ava says that Bob is a knave.</li><li>Bob says, &ldquo;Neither Ava nor I are knaves.&rdquo;</li></ul><p>What types are Ava and Bob?</p><details><summary><b>-â†’ Click for solution</b></summary><p>Suppose Ava is a knight. Then her statement must be true, so Bob must be a knave. In this case, Bob&rsquo;s statement would be a lie (since he is a knave), which is what we want.</p><p>Let&rsquo;s make sure there aren&rsquo;t any other answers that work.</p><p>Suppose instead that Ava is a knave. Then her statement must be a lie, so Bob must be a knight. This would mean that Bob&rsquo;s statement should be true, but it&rsquo;s not &ndash; Ava <em>is</em> a knave.</p><p>We can conclude that Ava is a knight and Bob is a knave.</p></details><h2 id=example-3>Example 3</h2><p>If you see an &ldquo;or&rdquo; statement in a knights and knaves puzzle, assume that it means an <em>inclusive</em> or. This will match the <em>or</em> logical operator in our later truth tables and proofs, and will also match the or operator in programmimg.</p><p>You see two different inhabitants &ndash; Eve and Fred.</p><ul><li>Eve says, &ldquo;I am a knave or Fred is a knight.&rdquo;</li></ul><p>What types are Eve and Fred?</p><details><summary><b>-â†’ Click for solution</b></summary><p>Suppose first that Eve is a knight. Then her statement must be true. Since she isn&rsquo;t a knave, the only way for her statement to be true is if Fred is a knight.</p><p>Let&rsquo;s make sure there aren&rsquo;t any other answers that work.</p><p>Suppose instead that Eve is a knave. Already we are in trouble &ndash; Eve&rsquo;s statement is already true no matter what type Fred is. Since Eve would lie if she was a knave, we know she must not be knave.</p><p>We can conclude that Eve and Fred are both knights.</p></details><h2 id=example-4>Example 4</h2><p>You see three new inhabitants &ndash; Sarah, Bill, and Mae.</p><ul><li>Sarah tells you that only a knave would say that Bill is a knave.</li><li>Bill claims that it&rsquo;s false that Mae is a knave.</li><li>Mae tells you, &ldquo;Bill would tell you that I am a knave.&rdquo;</li></ul><p>What types are Sarah, Bill, and Mae?</p><details><summary><b>-â†’ Click for solution</b></summary><p>Before starting on this puzzle, it might help to rephrase Sarah&rsquo;s and Bill&rsquo;s statements. Sarah&rsquo;s statement that only a knave would say that Bill is knave is really saying that it is FALSE that Bill is a knave (since knaves lie). Another way to say it&rsquo;s false that Bill is a knave is to say that Bill is a knight. Similarly, we can rewrite Bill&rsquo;s statemnet to say that Mae is a knight.</p><p>Now we have the following statements:</p><ul><li>Sarah tells you that Bill is a knight.</li><li>Bill claims that Mae is a knight.</li><li>Mae tells you, &ldquo;Bill would tell you that I am a knave.&rdquo;</li></ul><p>Suppose Sarah is a knight. Then her statement is true, so Bill must also be a knight. This would mean Bill&rsquo;s statement would also be true, so Mae is a knight as well. But Mae says that Bill would say she&rsquo;s a knave, and that&rsquo;s not true &ndash; Bill would truthfully say that Mae is a knight.</p><p>Suppose instead that Sarah is a knave. Then her statement is false, so Bill must be a knave. This would make Bill&rsquo;s claim false as well, so Mae must be a knave. Mae knows that Bill would say she was a knight (since Bill is a knave, and would lie), and if Mae was a knave then she would indeed lie and say that Bill would say she was a knave.</p><p>We can conclude that all three are knaves.</p></details><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=other-puzzles>Other Puzzles</h1><p>We will look at a variety of other logic puzzles, each of which involve some statements being false and some statements being true.</p><h2 id=lion-and-unicorn>Lion and Unicorn</h2><p>The setup for a Lion and Unicorn puzzle can vary, but the idea is that both Lion and Unicorn have specific days that they tell only lies, and other specific days that they only tell the truth.</p><p>Here is one example:</p><blockquote><p>Lion always lies on Mondays, Tuesdays, and Wednesdays.<br>Lion always tells the truth on other days.<br>Unicorn always lies on Thursdays, Fridays, and Saturdays, and always tells the truth on other days.<br><br>On Sunday, everyone tells the truth.<br><br>Lion says: &ldquo;Yesterday was one of my lying days."<br>Unicorn says: &ldquo;Yesterday was one of my lying days, too.&rdquo;<br><br>What day is it?</p></blockquote><details><summary><b>-â†’ Click for solution</b></summary><p>To solve this puzzle, we consider what Lion&rsquo;s and Unicorn&rsquo;s statements would mean on each different day of the week.</p><ul><li><p>Suppose it is Sunday. Then Lion&rsquo;s statement would be a lie (Lion does not lie on Saturday), and yet Lion is supposed to be telling the truth on Sunday.</p></li><li><p>Suppose it is Monday. Then both Lion&rsquo;s and Unicorn&rsquo;s statements would be lies, since they both told the truth yesterday (Sunday).</p></li><li><p>Suppose it is either Tuesday or Wednesday. Then Lion&rsquo;s statement would be true &ndash; but Lion is supposed to lie on both Tuesday and Wednesday.</p></li><li><p>Suppose it is Thursday. Then Lion&rsquo;s statement would be true (Wednesday was one of their lying days), which is good since Lion is supposed to be telling the truth on Thursdays. Similarly, Unicorn&rsquo;s statement would be false (Unicorn does not lie on Thursdays), which works out since Unicorn DOES lie on Thursdays.</p></li><li><p>Suppose it is either Friday or Saturday. Then Lion&rsquo;s statement would be a lie (Lion doesn&rsquo;t lie on either Thursday or Friday), but Lion should be telling the truth on Friday and Saturday.</p></li></ul><p>We can conclude that it must be Thursday.</p></details><h2 id=tweedledee-and-tweedledum>Tweedledee and Tweedledum</h2><p>The Tweedledee and Tweedledum puzzles originate from <em>Through the Looking-glass and What Alice Found There</em>, by Lewis Carroll. There are different versions of these puzzles as well, but all of them involve the identical twin creatures, Tweedledee and Tweedledum. Like with Lion and Unicorn, there are different days on which Tweedledee and Tweedledum either only lie or only tell the truth (and often one creature is lying while the other is telling the truth).</p><h3 id=example-1>Example 1</h3><p>Consider this puzzle:</p><blockquote><p>Tweedledee and Tweedledum are identical. You know that one of them lies Mon/Tues/Wed,and that the other lies Thurs/Fri/Sat. (They tell the truth on non-lying days.)<br><br>You don&rsquo;t know which is which.<br><br>You see both of them together.<br>The first one says: &ldquo;I&rsquo;m Tweedledum."<br>The second one says: &ldquo;I&rsquo;m Tweedledee.&rdquo;<br><br>Which is which? What day is it?</p></blockquote><details><summary><b>-â†’ Click for solution</b></summary><p>Answer: Since the two creatures gave different answers, we can conclude that they must both be lying or both telling the truth. (Otherwise, both creatures would give you the same name.) Sunday is the only such day.</p><p>Each is telling the truth, so the first twin is Tweedledum and the second is Tweedledee.</p></details><h3 id=example-2>Example 2</h3><p>Consider a second puzzle, with the same setup as to which days each twin lies and tells the truth.</p><blockquote><p>You know that either Tweedledum or Tweedledee has lost a rattle. You find it, and want to return it to the correct one. You don&rsquo;t know what day it is, but are sure that it isn&rsquo;t Sunday (so one must be lying and one must be telling the truth).<br><br>The first one says: &ldquo;Tweedledee owns the rattle.&rdquo;<br><br>The second one says: &ldquo;I&rsquo;m Tweedledee Â¬&rdquo;<br><br>Who gets the rattle?</p></blockquote><details><summary><b>-â†’ Click for solution</b></summary><p>To solve this puzzle, we can explore the possibilities for each twin lying or telling the truth.</p><p>Suppose the first twin is telling the truth. Since it isn&rsquo;t Sunday, we know the second twin must be lying. If the second twin&rsquo;s statement is a lie, then the second is Tweedledum. Since the first twin is telling the truth, then they are Tweedledee (and the owner of the rattle).</p><p>Suppose instead that the first twin is lying. Again, since it isn&rsquo;t Sunday, we know the second twin must be telling the truth. This would make the second twin Tweedledee, and the first twin Tweedledum. It would also mean that TweedleDUM owns the rattle (since the first statement is a lie), which is the first twin.</p><p>We don&rsquo;t have enough information to determine which twin is which, but it doesn&rsquo;t matter &ndash; in both cases, the first twin is the owner of the rattle.</p></details><h2 id=portias-caskets>Portia&rsquo;s Caskets</h2><p>This type of puzzle originates from <em>The Merchant of Venice</em>, by William Shakespeare. In the play, Portia&rsquo;s father devised riddles to test potential suitors for his daughter.</p><p>Here is one such puzzle:</p><blockquote><p>There are three caskets â€“ one gold, one silver, and one lead. One of the caskets contains a portrait (of Portia). Each casket has a message on it, and you know that at most one of the messages is true.<br><br>Gold casket message: &ldquo;The portrait is in this casket.&rdquo;
Silver casket message: &ldquo;The portrait is not in this casket.&rdquo;
Lead casket message: &ldquo;The portrait is not in the gold casket.&rdquo;<br><br>Where is the portrait?</p></blockquote><details><summary><b>-â†’ Click for solution</b></summary><p>To solve this puzzle, we recognize that there are only three possibilities &ndash; the portrait must be in either the gold casket, the silver casket, or the lead casket. We consider the implications of each:</p><p>Suppose the portrait is in the gold casket. Then the messages on both the gold and silver caskets would be true. This isn&rsquo;t possible, as we know that at most one of the messages is true.</p><p>Suppose instead that the portait is in the silver casket. Then the messages on the gold and silver caskets would be false, and the message on the lead casket would be true. Only one message is true, so this is a possibility.</p><p>Finally, suppose the portrait is in the lead casket. Then the messages on all three caskets would be true, so this isn&rsquo;t possible.</p><p>We conclude that the portrait must be in the silver casket.</p></details><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=truth-tables>Truth Tables</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Truth Tables</h1><article class=default><header class=headline></header><h1 id=operators-and-circuits>Operators and Circuits</h1><p>In this chapter, we review basic notions about gates and learn the relationship between circuits and assignment-based computer programs. This sets the stage for analyzing modern programs.</p><h2 id=logical-operators>Logical operators</h2><p>There are four basic logic gates, with corresponding logical operators:</p><table><thead><tr><th>Meaning</th><th>Logical Operator</th><th>Logic Gate</th></tr></thead><tbody><tr><td>p AND q</td><td><code>p âˆ§ q</code></td><td><a href=#R-image-ba880d8b3a37c3e0bdecf8b2427c3036 class=lightbox-link><img alt="AND gate" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/AND.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ba880d8b3a37c3e0bdecf8b2427c3036><img alt="AND gate" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/AND.png></a></td></tr><tr><td>p OR q</td><td><code>p âˆ¨ q</code></td><td><a href=#R-image-c2d0a3e6d254cfd3d93a2efdf8ad35ac class=lightbox-link><img alt="OR gate" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/OR.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c2d0a3e6d254cfd3d93a2efdf8ad35ac><img alt="OR gate" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/OR.png></a></td></tr><tr><td>NOT p</td><td><code>Â¬p</code></td><td><a href=#R-image-d836a6aab98e401973f14d124845e034 class=lightbox-link><img alt="NOT gate" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/NOT.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-d836a6aab98e401973f14d124845e034><img alt="NOT gate" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/NOT.png></a></td></tr><tr><td>p IMPLIES q</td><td><code>p â†’ q</code></td><td><a href=#R-image-3db42fca5b4a599a070aba90ba872612 class=lightbox-link><img alt="IMPLIES gate" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/IMPLIES.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3db42fca5b4a599a070aba90ba872612><img alt="IMPLIES gate" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/IMPLIES.png></a></td></tr></tbody></table><p>In the above drawings, the input wires are labelled with the names P and Q. The output that is computed is emitted from the rightmost wire which exits the gate. For these simple gates, it is possible to exhaustively test every permutation of potential inputs and summarize results in a table, called a truth table.</p><p>Let&rsquo;s examine the AND gate. The AND gate emits a high voltage (1) exactly when high voltages are sensed at input wires P and Q; otherwise low voltage (0) is emitted. The gate&rsquo;s physical behavior is summarized by in the following table:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>AND: P Q |
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>     1 1 | 1
</span></span><span style=display:flex><span>     1 0 | 0
</span></span><span style=display:flex><span>     0 1 | 0
</span></span><span style=display:flex><span>     0 0 | 0</span></span></code></pre></div><h2 id=truth-tables>Truth tables</h2><p>For the remainder of this course, we will use T (read &ldquo;true&rdquo;) for 1 and F (read &ldquo;false&rdquo;) for 0. This is because we will examine applications that go far beyond circuit theory and base-two arithmetic. Here are the truth tables for the AND, OR, NOT and IMPLIES gates:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>AND: P Q |
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>     T T | T
</span></span><span style=display:flex><span>     T F | F
</span></span><span style=display:flex><span>     F T | F
</span></span><span style=display:flex><span>     F F | F
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>OR: P Q |
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>     T T | T
</span></span><span style=display:flex><span>     T F | T
</span></span><span style=display:flex><span>     F T | T
</span></span><span style=display:flex><span>     F F | F
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NOT: P |
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>     T | F
</span></span><span style=display:flex><span>     T | T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IMPLIES: P Q |
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>         T T | T
</span></span><span style=display:flex><span>         T F | F
</span></span><span style=display:flex><span>         F T | T
</span></span><span style=display:flex><span>         F F | T</span></span></code></pre></div><p>A few comments:</p><ul><li><p>The OR gate is inclusive &ndash; as long as one of its inputs is true, then its output is true.</p></li><li><p>You might be confused by the IMPLIES gate. We&rsquo;ll cover it in detail below.</p></li><li><p>In the next section, we will learn to write our truth tables in a slightly different format so they can be automatically checked by Sireum Logika.</p></li></ul><h2 id=implies-operator>Implies operator</h2><p>The implies operator can be difficult to understand. It helps to think of it as a promise: we write <code>P â†’ Q</code>, but we mean <em>If <code>P</code> is true, then I promise that <code>Q</code> will also be true.</em> If we BREAK our promise (i.e., if <code>P</code> is true but <code>Q</code> is false), then the output of an implies gate is false. In <em>every other situation</em>, the output of the implies gate is true.</p><p>As a reminder, here is the truth table for the implies operator, â†’ :</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>P Q | P â†’ Q
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>T T |   T
</span></span><span style=display:flex><span>T F |   F
</span></span><span style=display:flex><span>F T |   T
</span></span><span style=display:flex><span>F F |   T</span></span></code></pre></div><p>It is likely clear why <code>P â†’ Q</code> is true when both <code>P</code> and <code>Q</code> are true &ndash; in this situation, we have kept our promise.</p><p>It is also easy to understand why <code>P â†’ Q</code> is false when <code>P</code> is true and <code>Q</code> is false. Here, we have broken our promise &ndash; <code>P</code> happened, but <code>Q</code> did not.</p><p>In the other two cases for <code>P â†’ Q</code> we have that <code>P</code> is false (and <code>Q</code> is either true or false). Here, <code>P â†’ Q</code> is true simply because we haven&rsquo;t broken our promise. In these cases, the implication is said to be <em>vacuously true</em> because we have no evidence to prove that it is false.</p><h2 id=circuits>Circuits</h2><p>We can also compose the gates to define new operations.</p><p>For example, this circuit:</p><p><a href=#R-image-ed6821797d2e0339007f5f5c35723ee4 class=lightbox-link><img alt="circuit combo" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/circuit1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ed6821797d2e0339007f5f5c35723ee4><img alt="circuit combo" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/circuit1.png></a></p><p>Written <code>Â¬(P âˆ§ Q)</code>, defines this computation of outputs:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>P Q | Â¬(P âˆ§ Q)
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>T T | F
</span></span><span style=display:flex><span>T F | T
</span></span><span style=display:flex><span>F T | T
</span></span><span style=display:flex><span>F F | T</span></span></code></pre></div><p>We can work out the outputs in stages, like this:</p><p><a href=#R-image-81a25cea6eb5666d5a9107f4ae6d26b0 class=lightbox-link><img alt="circuit stages" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/NotLogikaTT.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-81a25cea6eb5666d5a9107f4ae6d26b0><img alt="circuit stages" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/NotLogikaTT.png></a></p><p>We begin by writing the value of each set of inputs on the left, under their corresponding symbol on the right. Next we apply the operator (gate) with the highest precedence (covered in <em>Operator Precedence</em> in the next section). In our case the <code>()</code> make the AND ( <code>âˆ§</code> ) symbol the highest.</p><p>A truth assignment is a unique permutation of the possible inputs for a system. For the <code>âˆ§</code>-gate, it is a 2-variable sequence. Considering the first row we see we have <code>T âˆ§ T</code>. Looking that up in the <code>âˆ§</code>-gate truth table we see the result is also &ldquo;T&rdquo;, and we record that under the <code>âˆ§</code> symbol. We do the same thing all the other truth assignments.</p><p>After the initial transcribing of the truth values under their respective variables, we look up the truth-values in the gate tables, not the variables. Also observe that while <code>âˆ§</code> is symmetric &ndash; i.e. <code>T âˆ§ F</code> and <code>F âˆ§ T</code> are both false &ndash; the IMPLIES gate is not.</p><p>Now we look up the value under the <code>âˆ§</code> symbol in the Â¬ gate table. In the first row we see that the truth assignment for the first row, &ldquo;T&rdquo;, is &ldquo;F&rdquo; and record it under the <code>Â¬</code> symbol. Do this for every row and we are done.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=truth-tables-in-logika>Truth Tables in Logika</h1><p>Now that we&rsquo;ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.</p><h2 id=operator-precedence>Operator precedence</h2><p>Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.</p><p>Here is the precedence of the logical operators, from most important (do first) to least important (do last):</p><ol><li>Parentheses</li><li>Not operator, <code>Â¬</code></li><li>And operator, <code>âˆ§</code></li><li>Or operator, <code>âˆ¨</code></li><li>Implies operator, <code>â†’</code></li></ol><p>For example, in the statement <code>(p âˆ¨ q) âˆ§ Â¬p</code>, we would evaluate the operators in the following order:</p><ol><li>The parentheses (which would resolve the <code>(p âˆ¨ q)</code> expression)</li><li>The not, <code>Â¬</code></li><li>The and, <code>âˆ§</code></li></ol><p>Sometimes we have more than one of the same operator in a single statement. For example: <code>p âˆ¨ q âˆ¨ r</code>. Different operators have different rules for resolving multiple occurrences:</p><ol><li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li><li>Multiple not ( <code>Â¬</code> ) operators &ndash; the rightmost <code>Â¬</code> is resolved first, working from right to left. For example, <code>Â¬Â¬p</code> is equivalent to <code>Â¬(Â¬p)</code>.</li><li>Multiple and ( <code>âˆ§</code> ) operators &ndash; the leftmost <code>âˆ§</code> is resolved first, working from left to right. For example, <code>p âˆ§ q âˆ§ r</code> is equivalent to <code>(p âˆ§ q) âˆ§ r</code>.</li><li>Multiple or ( <code>âˆ¨</code> ) operators &ndash; the leftmost <code>âˆ¨</code> is resolved first, working from left to right. For example, <code>p âˆ¨ q âˆ¨ r</code> is equivalent to <code>(p âˆ¨ q) âˆ¨ r</code>.</li><li>Multiple implies ( <code>â†’</code> ) operators &ndash; the rightmost <code>â†’</code> is resolved first, working from right to left. For example, <code>p â†’ q â†’ r</code> is equivalent to <code>p â†’ (q â†’ r)</code>.</li></ol><h2 id=top-level-operator>Top-level operator</h2><p>In a logical statement, the <em>top-level operator</em> is the operator that is applied last (after following the precedence rules above).</p><p>For example, in the statement:</p><p><code>p âˆ¨ q â†’ Â¬p âˆ§ r</code></p><p>We would evaluate first the <code>Â¬</code>, then the <code>âˆ§</code>, then the <code>âˆ¨</code>, and lastly the <code>â†’</code>. Thus the <code>â†’</code> is the top-level operator.</p><h2 id=classifying-truth-tables>Classifying truth tables</h2><p>In our study of logic, it will be convenient to characterize logical formula with a description of their truth tables. We will classify each logical formula in one of three ways:</p><ul><li><em>Tautology</em> - when all truth assignments for a logical formula are true</li><li><em>Contradictory</em> - when all truth assignments for a logical formula are false</li><li><em>Contingent</em> - when some truth assignments for a logical formula are true and some are false.</li></ul><p>For example, <code>p âˆ¨ Â¬ p</code> is a <em>tautology</em>. Whether <code>p</code> is true or false, <code>p âˆ¨ Â¬ p</code> is always true.</p><p>On the other hand, <code>p âˆ§ Â¬ p</code> is <em>contradictory</em>. Whether <code>p</code> is true or false, <code>p âˆ§ Â¬ p</code> is always false.</p><p>Finally, something like <code>p âˆ¨ q</code> is <em>contingent</em>. When <code>p</code> and <code>q</code> are both false, then <code>p âˆ¨ q</code> is false. However, <code>p âˆ¨ q</code> is true in every other case.</p><p>If all truth assignments for a logical formula are True, the formula is said to be a tautology.</p><h2 id=logika-syntax>Logika syntax</h2><p>From this point forward, the course will expect you to use Logika formatted truth tables. The Logika truth table for the formula <code>Â¬(p âˆ§ q)</code> is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>p q # !(p &amp; q)
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>T T # F T T T
</span></span><span style=display:flex><span>T F # T T F F
</span></span><span style=display:flex><span>F T # T F F T
</span></span><span style=display:flex><span>F F # T F F F
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T F] [F T] [F F]
</span></span><span style=display:flex><span>F: [T T]</span></span></code></pre></div><p>Logika truth tables have standard format (syntax) and semantic meanings. All elements of the truth table must be included to be considered correct.</p><ol><li><p>The first line should have a single asterisk (*) over the top-level operator in the formula.</p></li><li><p>Next is a line of - (minus sign) characters, which must be at least as long as the third line to avoid getting errors.</p></li><li><p>The third line contains <code>variables | formula</code>. As Logika uses some capital letters as reserved words, you should use lower-case letters as variable names. Additionally, variables should be listed alphabetically.</p></li><li><p>The fourth line is another row of -, which is the same length as the second line.</p></li><li><p>Next come the truth assignments. Under the variables, list all possible combinations of T and F. Start with all T and progress linearly to all F. (T and F must be capitalized.)
After the Truth assignments is another row of -. Using each truth assignment, fill in truth assignments (T or F) under each operator in the formula in order of precedence (with the top-level operator applied last). Optionally, you can fill in the values for each variable under the forumla (as in the example above). However, it is only required that you fill in the truth assignments under each operator. Be careful to line up the truth assignments DIRECTLY below each operator, as Logika will reject truth tables that aren&rsquo;t carefully lined up.</p></li><li><p>Under the truth assignments, put another line of - (minus sign) characters, which should be the same length as the second line.</p></li><li><p>Finally, classify the formula as either <code>Tautology</code> (if everything under the top-level operator is T), <code>Contradictory</code> (if everything under the top-level operator is F), or <code>Contingent</code> (if there is a mix of T and F under the top-level operator). If the formula is contingent, you must also list which truth assignments made the formula true (i.e., which truth assignments made the top-level operator T) and which truth assignments made the formula false. Follow the image above for the syntax of how to list the truth assignments for contingent examples.</p></li></ol><h2 id=logical-operators-in-logika>Logical operators in Logika</h2><p>You may notice that the example above appears to use the <code>!</code> operator for NOT and the <code>&</code> operator for AND. However, what is shown above demonstrates what we TYPE into Logika, and not what is actually displayed. If we copy and paste the example into a new Logika file, it will look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>p q # Â¬(p âˆ§ q)
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>T T # F T T T
</span></span><span style=display:flex><span>T F # T T F F
</span></span><span style=display:flex><span>F T # T F F T
</span></span><span style=display:flex><span>F F # T F F F
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T F] [F T] [F F]
</span></span><span style=display:flex><span>F: [T T]</span></span></code></pre></div><p>Here is a summary of what keys to type in Logika for each traditional logical operator:</p><table><thead><tr><th>Logical operator</th><th>What to TYPE in Logika</th><th>What you will SEE in Logika</th></tr></thead><tbody><tr><td>NOT</td><td><code>!</code></td><td><code>Â¬</code></td></tr><tr><td>OR</td><td><code>|</code></td><td><code>âˆ¨</code></td></tr><tr><td>AND</td><td><code>&</code></td><td><code>âˆ§</code></td></tr><tr><td>IMPLIES</td><td><code>->:</code></td><td><code>â†’:</code></td></tr></tbody></table><p>In the remainder of this book, my examples will be of what you will SEE in Logika.</p><h2 id=logika-mishandling-of-implies-operator>Logika mishandling of implies operator</h2><p>While the correct order of operations for logical operations is NOT, AND, OR, IMPLIES (from highest precedence to lowest precedence), the Logika tool does not handle the precedence of the implies operator correctly. The characters used for the implies operator in Logika are <code>->:</code> &ndash; however, since Logika takes advantage of Scala&rsquo;s operator precedence, this means that it interprets an implies operation as having the same (higher) precedence as a minus operation. In this class, we will always use parentheses to force the implies to have the correct precedence.</p><p>This incorrect precedence will only be present in our unit on truth tables &ndash; other proofs in Logika will use a different operator for implies (<code>__>:</code>) to avoid the issue of being interpreted as a minus operation. (We cannot use <code>__>:</code> in truth tables as the rendering makes the column alignment unclear.)</p><h2 id=example>Example</h2><p>Suppose we want to write a Logika truth table for:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q) â†’ Â¬r</span></span></code></pre></div><p>First, we make sure we have a new file in Sireum with the <code>.logika</code> extension. Then, we construct this truth table shell:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p âˆ§ q) â†’: Â¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #
</span></span><span style=display:flex><span>T T F #
</span></span><span style=display:flex><span>T F T #
</span></span><span style=display:flex><span>T F F #
</span></span><span style=display:flex><span>F T T #
</span></span><span style=display:flex><span>F T F #
</span></span><span style=display:flex><span>F F T #
</span></span><span style=display:flex><span>F F F #
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>In the table above, we noticed that the <code>â†’</code> operator was the top-level operator according to our operator precedence rules.</p><p>Next, we fill in the output for the corresponding truth assignment under each operator, from highest precedence to lowest precedence. First, we evaluate the parentheses, which have the highest precedence. For example, we put a <code>T</code> under the <code>âˆ§</code> in the first row, as <code>p</code> and <code>q</code> are both <code>T</code> in that row, and <code>T âˆ§ T</code> is <code>T</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p âˆ§ q) â†’: Â¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T
</span></span><span style=display:flex><span>T T F #    T
</span></span><span style=display:flex><span>T F T #    F
</span></span><span style=display:flex><span>T F F #    F
</span></span><span style=display:flex><span>F T T #    F
</span></span><span style=display:flex><span>F T F #    F
</span></span><span style=display:flex><span>F F T #    F
</span></span><span style=display:flex><span>F F F #    F
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>In this example, we are only filling in under each operator (instead of also transcribing over each variable value), but either approach is acceptable.</p><p>Next, we fill in under the Â¬ operator, which has the next-highest precedence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p âˆ§ q) â†’: Â¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T       F
</span></span><span style=display:flex><span>T T F #    T       T
</span></span><span style=display:flex><span>T F T #    F       F
</span></span><span style=display:flex><span>T F F #    F       T
</span></span><span style=display:flex><span>F T T #    F       F
</span></span><span style=display:flex><span>F T F #    F       T
</span></span><span style=display:flex><span>F F T #    F       F
</span></span><span style=display:flex><span>F F F #    F       T
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>Then, we fill in under our top-level operator, the <code>â†’</code>. Notice that we must line up the <code>T/F</code> values under the <code>â†’</code> in the <code>â†’:</code> symbol. For example, we put a <code>F</code> under the <code>â†’:</code> on the first row, as <code>(p âˆ§ q)</code> is <code>T</code> there and <code>Â¬r</code> is <code>F</code>, and we know that <code>Tâ†’F</code> is <code>F</code> because it describes a broken promise.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p âˆ§ q) â†’: Â¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T    F  F
</span></span><span style=display:flex><span>T T F #    T    T  T
</span></span><span style=display:flex><span>T F T #    F    T  F
</span></span><span style=display:flex><span>T F F #    F    T  T
</span></span><span style=display:flex><span>F T T #    F    T  F
</span></span><span style=display:flex><span>F T F #    F    T  T
</span></span><span style=display:flex><span>F F T #    F    T  F
</span></span><span style=display:flex><span>F F F #    F    T  T
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>Lastly, we examine the list of outputs under the top-level operator. We see that some truth assignments made the formula true, and that others (one) made the formula false. Thus, the formula is contingent. We label it as such, and list which truth assignments made the formula true and which made it false:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p âˆ§ q) â†’: Â¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T    F  F
</span></span><span style=display:flex><span>T T F #    T    T  T
</span></span><span style=display:flex><span>T F T #    F    T  F
</span></span><span style=display:flex><span>T F F #    F    T  T
</span></span><span style=display:flex><span>F T T #    F    T  F
</span></span><span style=display:flex><span>F T F #    F    T  T
</span></span><span style=display:flex><span>F F T #    F    T  F
</span></span><span style=display:flex><span>F F F #    F    T  T
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T F] [T F T] [T F F] [F T T] [F T F] [F F T] [F F F]
</span></span><span style=display:flex><span>F: [T T T]</span></span></code></pre></div><p>If you typed everything correctly and run a Logika check (<code>Ctrl-Shift-W</code> in Windows and <code>Command-Shift-W</code> on Mac), you should see a popup in Sireum logika that says: &ldquo;Logika Verified&rdquo; (yours will not have the purple checkmark, but will have the same text)</p><p><a href=#R-image-6f2f5080bb0fbb9421ea233f9c0b3985 class=lightbox-link><img alt="truth table verified" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/ttVerified.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6f2f5080bb0fbb9421ea233f9c0b3985><img alt="truth table verified" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/ttVerified.png></a></p><p>If you instead see red error markings, hover over them and read the explanations &ndash; it means there are errors in your truth table.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=satisfiability>Satisfiability</h1><p>We say that a logical statement is <em>satisfiable</em> when there exists at least one truth assignment that makes the overall statement true.</p><p>In our Logika truth tables, this corresponds to statements that are either <em>contingent</em> or a <em>tautology</em>. (<em>Contradictory</em> statements are NOT satisfiable.)</p><p>For example, consider the following truth tables:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>          *
</span></span><span style=display:flex><span>-----------------------
</span></span><span style=display:flex><span>p q r # p â†’: q V Â¬r âˆ§ p
</span></span><span style=display:flex><span>-----------------------
</span></span><span style=display:flex><span>T T T #   T    T F  F
</span></span><span style=display:flex><span>T T F #   T    T T  T
</span></span><span style=display:flex><span>T F T #   F    F F  F
</span></span><span style=display:flex><span>T F F #   T    T T  T
</span></span><span style=display:flex><span>F T T #   T    T F  F
</span></span><span style=display:flex><span>F T F #   T    T T  F
</span></span><span style=display:flex><span>F F T #   T    F F  F
</span></span><span style=display:flex><span>F F F #   T    F T  F
</span></span><span style=display:flex><span>------------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T T] [T T F] [T F F] [F T T] [F T F] [F F T] [F F F]
</span></span><span style=display:flex><span>F: [T F T]</span></span></code></pre></div><p>And</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>------------
</span></span><span style=display:flex><span>p # p V Â¬p 
</span></span><span style=display:flex><span>------------
</span></span><span style=display:flex><span>T #   T F
</span></span><span style=display:flex><span>F #   T T
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>Tautology</span></span></code></pre></div><p>Both of these statements are satisfiable, as they have at least one (or more than one) truth assignment that makes the overall statement true.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logical-equivalence>Logical Equivalence</h1><p>Two (or more) logical statements are said to be <em>logically equivalent</em> IFF (if and only if, â†”) they have the same truth value for every truth assignment; i.e., their truth tables evaluate exactly the same. (We sometimes refer to this as <em>semantic equivalence</em>.)</p><p>An example of logically equivalent statements are <code>q âˆ§ p</code> and <code>p âˆ§ (q âˆ§ p)</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>         *
</span></span><span style=display:flex><span>--------------
</span></span><span style=display:flex><span>p q # (p âˆ§ q)
</span></span><span style=display:flex><span>--------------
</span></span><span style=display:flex><span>T T #    T 
</span></span><span style=display:flex><span>T F #    F 
</span></span><span style=display:flex><span>F T #    F 
</span></span><span style=display:flex><span>F F #    F 
</span></span><span style=display:flex><span>---------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T]
</span></span><span style=display:flex><span>F: [F F] [F T] [T F]</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>         *
</span></span><span style=display:flex><span>-------------------
</span></span><span style=display:flex><span>p q #  p âˆ§ (q âˆ§ p)
</span></span><span style=display:flex><span>-------------------
</span></span><span style=display:flex><span>T T #    T    T 
</span></span><span style=display:flex><span>T F #    F    F 
</span></span><span style=display:flex><span>F T #    F    F 
</span></span><span style=display:flex><span>F F #    F    F 
</span></span><span style=display:flex><span>--------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T : [T T]
</span></span><span style=display:flex><span>F : [F F] [F T] [T F]</span></span></code></pre></div><p>In these examples, notice that exactly the same set of truth assignments makes both statements true, and that exactly the same set of truth assignments makes both statements false.</p><p>Finding equivalent logical statements of fewer gates (states) is important to several fields. In computer science, fewer states can lead to less memory, fewer operations and smaller programs. In computer engineering, fewer gates means fewer circuits less power and less heat.</p><h2 id=common-equivalences>Common equivalences</h2><p>We can similarly use truth tables to show the following common logical equivalences:</p><ul><li>Double negative: <code>Â¬ Â¬ p</code> and <code>p</code></li><li>Contrapositive: <code>p â†’ q</code> and <code>Â¬ q â†’ Â¬ p</code></li><li>Expressing an implies using an OR: <code>p â†’ q</code> and <code>Â¬ p âˆ¨ q</code></li><li>One of DeMorgan&rsquo;s laws: <code>Â¬ (p âˆ§ q)</code> and <code>( Â¬ p âˆ¨ Â¬ q)</code></li><li>Another of DeMorgan&rsquo;s laws: <code>Â¬ (p âˆ¨ q)</code> and <code>( Â¬ p âˆ§ Â¬ q)</code></li></ul><h2 id=expressing-additional-operators>Expressing additional operators</h2><p>The bi-implication (<code>â†”</code>) and exclusive or (<code>âŠ•</code>) operators are not directly used in this course. However, we can simulate both operators using a combination of <code>Â¬</code>, <code>âˆ§</code>, <code>âˆ¨</code>, and <code>â†’</code>:</p><ul><li><code>p â†” q</code>, which means &ldquo;p if and only if q&rdquo;, can be expressed as <code>(p â†’ q) âˆ§ (q â†’ p)</code></li><li><code>p âŠ• q</code>, which means &ldquo;p exclusive or q&rdquo;, can be expressed as <code>(p âˆ¨ q) âˆ§ Â¬(p âˆ§ q)</code></li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=semantic-entailment>Semantic Entailment</h1><h2 id=definition>Definition</h2><p>We say a set of premises, <code>p1</code>, <code>p2</code>, &mldr;, <code>pn</code> semantically entail a conclusion <code>c</code>, and we write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p1, p2, ..., pn âŠ¨ c</span></span></code></pre></div><p>if whenever we have a truth assignment that makes <code>p1</code>, <code>p2</code>, &mldr;, <code>pn</code> all true, then <code>c</code> is also true for that truth assignment.</p><p>(Note: we can use the ASCII replacement <code>|=</code> instead of the Unicode <code>âŠ¨</code>, if we want.)</p><h2 id=showing-semantic-entailment>Showing semantic entailment</h2><p>Suppose we have premises <code>p âˆ§ q</code> and <code>p â†’ r</code>. We want to see if these premises necessarily entail the conclusion <code>r âˆ§ q</code>.</p><p>First, we could make truth tables for each premise (being sure to list the variables <code>p</code>, <code>q</code> and <code>r</code> in each case, as that is the overall set of variables in the problem):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//truth table for premise, p âˆ§ q
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # p âˆ§ q
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #   T
</span></span><span style=display:flex><span>T T F #   T
</span></span><span style=display:flex><span>T F T #   F
</span></span><span style=display:flex><span>T F F #   F
</span></span><span style=display:flex><span>F T T #   F
</span></span><span style=display:flex><span>F T F #   F
</span></span><span style=display:flex><span>F F T #   F
</span></span><span style=display:flex><span>F F F #   F
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T T] [T T F]
</span></span><span style=display:flex><span>F: [T F T] [T F F] [F T T] [F T F] [F F T] [F F F]</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//truth table for premise, p â†’ r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # p â†’: r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #   T
</span></span><span style=display:flex><span>T T F #   F
</span></span><span style=display:flex><span>T F T #   T
</span></span><span style=display:flex><span>T F F #   F
</span></span><span style=display:flex><span>F T T #   T
</span></span><span style=display:flex><span>F T F #   T
</span></span><span style=display:flex><span>F F T #   T
</span></span><span style=display:flex><span>F F F #   T
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T T] [T F T] [F T T] [F T F] [F F T] [F F F]
</span></span><span style=display:flex><span>F: [T T F] [T F F]</span></span></code></pre></div><p>Now, we notice that the truth assignment <code>[T T T]</code> is the only one that makes both premises true. Next, we make a truth table for our potential conclusion, <code>r âˆ§ q</code> (again, being sure to include all variables used in the problem):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//truth table for potential conclusion, r âˆ§ q
</span></span><span style=display:flex><span>          *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # r âˆ§ q
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #   T
</span></span><span style=display:flex><span>T T F #   F
</span></span><span style=display:flex><span>T F T #   F
</span></span><span style=display:flex><span>T F F #   F
</span></span><span style=display:flex><span>F T T #   T
</span></span><span style=display:flex><span>F T F #   F
</span></span><span style=display:flex><span>F F T #   F
</span></span><span style=display:flex><span>F F F #   F
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T T] [F T T]
</span></span><span style=display:flex><span>F: [T T F] [T F T] [T F F] [F T F] [F F T] [F F F]</span></span></code></pre></div><p>Here, we notice that the truth assignment <code>[T T T]</code> makes the conclusion true as well. So we see that whenever there is a truth assignment that makes all of our premises true, then that same truth assignment also makes our conclusion true.</p><p>Thus, <code>p âˆ§ q</code> and <code>p â†’ r</code> semantically entail the conclusion <code>r âˆ§ q</code>, and we can write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p âˆ§ q, p â†’ r âŠ¨ r âˆ§ q</span></span></code></pre></div><h2 id=semantic-entailment-with-one-truth-table>Semantic entailment with one truth table</h2><p>The process of making separate truth tables for each premise and the conclusion, and then examining each one to see if any truth assignment that makes all the premises true also makes the conclusion true, is fairly tedious.</p><p>We are trying to show that IF each premise is true, THEN we promise the conclusion is true. This sounds exactly like an IMPLIES statement, and in fact that is what we can use to simplify our process. If we are trying to show that <code>p1</code>, <code>p2</code>, &mldr;, <code>pn</code> semantically entail a conclusion <code>c</code> (i.e., that <code>p1, p2, ..., pn âŠ¨ c</code>), then we can instead create ONE truth table for the statement:</p><p><code>(p1 âˆ§ p2 âˆ§ ... âˆ§ pn) â†’ c</code></p><p>If this statement is a tautology (which would mean that anytime all the premises were true, then the conclusion was also true), then we would also have that the premises semantically entail the conclusion.</p><p>In our previous example, we create a truth table for the statement <code>(p âˆ§ q) âˆ§ (p â†’ r) â†’ r âˆ§ q</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                           *
</span></span><span style=display:flex><span>--------------------------------------
</span></span><span style=display:flex><span>p q r # (p âˆ§ q) âˆ§ (p â†’: r) â†’: r âˆ§ q
</span></span><span style=display:flex><span>--------------------------------------
</span></span><span style=display:flex><span>T T T #    T    T    T     T    T
</span></span><span style=display:flex><span>T T F #    T    F    F     T    F
</span></span><span style=display:flex><span>T F T #    F    F    T     T    F
</span></span><span style=display:flex><span>T F F #    F    F    F     T    F
</span></span><span style=display:flex><span>F T T #    F    F    T     T    T 
</span></span><span style=display:flex><span>F T F #    F    F    T     T    F
</span></span><span style=display:flex><span>F F T #    F    F    T     T    F
</span></span><span style=display:flex><span>F F F #    F    F    T     T    F
</span></span><span style=display:flex><span>---------------------------------------
</span></span><span style=display:flex><span>Tautology</span></span></code></pre></div><p>Then we see that it is indeed a tautology.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=propositional-logic-translations>Propositional Logic Translations</h1><p>A <em>propositional logic statement</em> is a set of <em>propositional atoms</em> (statements with no logical connectives that can be true or false) connected by logical operators.</p><p>In this chapter, we will see how to translate English sentences into such propositional logic statements, which will resemble the logical statements (like <code>p âˆ§ q â†’ r</code>) we saw when working with truth tables. These statements are also called <em>propositions</em>.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Propositional Logic Translations</h1><article class=default><header class=headline></header><h1 id=propositional-atoms>Propositional Atoms</h1><h2 id=definition>Definition</h2><p>A <em>propositional atom</em> is statement that is either true or false, and that contains no logical connectives (like and, or, not, if/then).</p><h2 id=examples-of-propositional-atoms>Examples of propositional atoms</h2><p>For example, the following are propositional atoms:</p><ul><li>My shirt is red.</li><li>It is sunny.</li><li>Pigs can fly.</li><li>I studied for the test.</li></ul><h2 id=examples-of-what-are-not-propositional-atoms>Examples of what are NOT propositional atoms</h2><p>Propositional atoms should not contain any logical connectives. If they did, this would mean we could have further subdivided the statement into multiple propositional atoms that could be joined with logical operators. For example, the following are NOT propositional atoms:</p><ul><li>It is not summer. (<em>contains a not</em>)</li><li>Bob has brown hair and brown eyes. (<em>contains an and</em>)</li><li>I walk to school unless it rains. (<em>contains the word <code>unless</code>, which has if&mldr;then information</em>)</li></ul><p>Propositional atoms also must be either true or false &ndash; they cannot be questions, commands, or sentence fragments. For example, the following are NOT propositional atoms:</p><ul><li>What time is it? (<em>contains a question - not a true/false statement</em>)</li><li>Go to the front of the line. (<em>contains a command - not a true/false statement</em>)</li><li>Fluffy cats (<em>contains a sentence fragment - not a true/false statement</em>)</li></ul><h2 id=identifying-propositional-atoms>Identifying propositional atoms</h2><p>If we are given several sentences, we identify its propositional atoms by finding the key statements that can be either true or false. We further ensure that these statements do not contain any logical connectives (and, or, not, if/then information) - if they do, we break the statement down further. We then assign letters to each proposition.</p><p>For example, if we have the sentences:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>My jacket is red and green. I only wear my jacket when it is snowing. It did not snow today.</span></span></code></pre></div><p>Then we identify the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: My jacket is red
</span></span><span style=display:flex><span>q: My jacket is green
</span></span><span style=display:flex><span>r: I wear my jacket
</span></span><span style=display:flex><span>s: It is snowing
</span></span><span style=display:flex><span>t: It snowed today</span></span></code></pre></div><p>Notice that the first sentence, &ldquo;My jacket is red and green&rdquo;, contained the logical connective &ldquo;and&rdquo;. Thus, we broke that idea into its components, and got propositions <code>p</code> and <code>q</code>. The second sentence, &ldquo;I only wear my jacket when it is snowing&rdquo;, contained if/then information about when I would wear my jacket. We broke that sentence into two parts as well, and got propositions <code>r</code> and <code>s</code>. Finally, the last sentence, &ldquo;It did not snow today&rdquo;, contained the logical connective &ldquo;not&rdquo; &ndash; so we removed it and kept the remaining information for proposition <code>t</code>.</p><p>Each propositional atom is a true/false statement, just as is required.</p><p>In the next section, we will see how to complete our translation from English to propositional logic by connecting our propositional atoms with logical operators.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=not-and-or-translations>NOT, AND, OR Translations</h1><p>Now that we have seen how to identify propositional atoms in English sentences, we will learn how to connect these propositions with logical operators in order to complete the process of translating from English to propositional logic.</p><h2 id=not-translations>NOT translations</h2><p>When you see the word &ldquo;not&rdquo; and the prefixes &ldquo;un-&rdquo; and &ldquo;ir-&rdquo;, those should be replaced with a NOT operator.</p><h3 id=example-1>Example 1</h3><p>For example, if we have the sentence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>I am not going to work today.</span></span></code></pre></div><p>Then we would first identify the propositional atom:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: I am going to work today</span></span></code></pre></div><p>and would then use a NOT operator to express the negation. Our full translation to propositional logic would be: <code>Â¬p</code></p><h3 id=example-2>Example 2</h3><p>As another example, suppose we have the sentence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>My sweater is irreplaceable.</span></span></code></pre></div><p>We would identify the propositional atom:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: My sweater is replaceable.</span></span></code></pre></div><p>And again, our complete translation would be: <code>Â¬p</code></p><h2 id=and-translations>AND translations</h2><p>When you see the words &ldquo;and&rdquo;, &ldquo;but&rdquo;, &ldquo;however&rdquo;, &ldquo;moreover&rdquo;, &ldquo;nevertheless&rdquo;, etc., then the English sentence is expressing a conjunction of ideas. When translating to propositional logic, all of these words should be replaced with a logical AND operator.</p><p>It might seem strange that the sentences &ldquo;It is cold and it is sunny&rdquo; and &ldquo;It is cold but it is sunny&rdquo; should be translated the same way &ndash; but really, both sentences are expressing two facts:</p><ol><li>It is cold</li><li>It is sunny</li></ol><p>Using &ldquo;but&rdquo; instead of &ldquo;and&rdquo; in English adds a subtle comparison of the first fact to the second fact, but such nuances are beyond the capabilities of propositional logic (and are somewhat ambiguous anyway).</p><h3 id=example-1-1>Example 1</h3><p>Suppose we want to translate the following sentence to propositional logic:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>I like cake but I don&#39;t like cupcakes.</span></span></code></pre></div><p>We would first identify two propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: I like cake
</span></span><span style=display:flex><span>q: I like cupcakes</span></span></code></pre></div><p>We would then translate the clause &ldquo;I don&rsquo;t like cupcakes&rdquo; to <code>Â¬q</code>, and then would translate the connective &ldquo;but&rdquo; to a logical AND operator. We would finish with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p âˆ§  Â¬q</span></span></code></pre></div><h3 id=example-2-1>Example 2</h3><p>Suppose we want to translate the following sentence to propositional logic:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>The school doesn&#39;t have both a pool and a track.</span></span></code></pre></div><p>We would first identify two propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: The school has a pool
</span></span><span style=display:flex><span>q: The school has a track</span></span></code></pre></div><p>We would then see that we are really taking the sentence, &ldquo;The school has a pool and a track&rdquo; and negating it, which leaves us with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Â¬(p âˆ§ q)</span></span></code></pre></div><h2 id=or-translations>OR translations</h2><p>When you see the word &ldquo;or&rdquo; in a sentence, or some other clear disjunction of statements, then you will translate it to a logical OR operator. Because the word &ldquo;or&rdquo; in English can be ambiguous, We first need to determine whether the &ldquo;or&rdquo; is <em>inclusive</em> (in which case we would replace it with a regular OR operator) or <em>exclusive</em> (in which case we need to add a clause to explicitly express that both statements cannot be true).</p><p>As we saw in <a href=https://textbooks.cs.ksu.edu/cis301/1-chapter/1_1-logicbasics/ rel=external target=_blank>section 1.1</a>, the word &ldquo;or&rdquo; in an English sentence is usually meant to be exclusive. However, because the logical OR is <em>INclusive</em>, and since the purpose of this class is not to have you wrestle with subtleties of the English language, then you can assume that an &ldquo;or&rdquo; in a sentence is <em>inclusive</em> unless clearly stated otherwise.</p><h3 id=inclusive-or-statements>Inclusive OR statements</h3><p>Suppose we want to translate the following sentence to propositional logic:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>You watch a movie and/or eat a snack.</span></span></code></pre></div><p>We would first identify two propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: You watch a movie
</span></span><span style=display:flex><span>q: You eat a snack</span></span></code></pre></div><p>The &ldquo;and/or&rdquo; in our sentence makes it extremely clear that the intent is an inclusive or, since the sentence is true if you both watch a movie and eat a snack. This leaves us with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p V q</span></span></code></pre></div><h3 id=exclusive-or-statements>Exclusive OR statements</h3><p>In this class, if the meaning of &ldquo;or&rdquo; in a sentence is meant to be exclusive, then the sentence will clearly state that the two statements aren&rsquo;t both true.</p><p>For example, suppose we want to translate the following sentence to propositional logic:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>On Saturday, Jane goes for a run or plays basketball, but not both.</span></span></code></pre></div><p>We would first identify two propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: Jane goes for a run on Saturday
</span></span><span style=display:flex><span>q: Jane plays basketball on Saturday</span></span></code></pre></div><p>We then apply our equivalence for simulating an exclusive or operator, which we saw in <a href=https://textbooks.cs.ksu.edu/cis301/2-chapter/2_4-logicalequiv/ rel=external target=_blank>section 2.4</a>. This leaves us with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p V q) âˆ§  Â¬(p âˆ§ q)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=implies-translations>Implies Translations</h1><p>In this section, we will learn when to use an implies (â†’) operator when translating from English to propositional logic. In general, you will want to use an implies operator any time a sentence is making a promise &ndash; if one thing happens, then we promise that another thing will happen. The trick is to figure out the direction of the promise &ndash; promising that if p happens, then q will happen is subtly different from promising that if q happens, then p will happen.</p><p>Look for the words &ldquo;if&rdquo;, &ldquo;only if&rdquo;, &ldquo;unless&rdquo;, &ldquo;except&rdquo;, and &ldquo;provided&rdquo; as clues that the propositional logic translation will use an implies operator.</p><h2 id=if-p-then-q-statements>IF p THEN q statements</h2><p>An &ldquo;IF p THEN q&rdquo; statement is promising that if <code>p</code> is true, then we can infer that <code>q</code> is also true. (It is making NO claims about what we can infer if we know <code>q</code> is true.)</p><p>For example, consider the following sentence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>If it is hot today, then I&#39;ll get ice cream.</span></span></code></pre></div><p>We first identify the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: It is hot today
</span></span><span style=display:flex><span>q: I&#39;ll get ice cream</span></span></code></pre></div><p>To determine the order of the implication, we think about what is being promised &ndash; if it is hot, then we can infer that ice cream will happen. But if we get ice cream, then we have no idea what the weather is like. It might be hot, but it might also be cold and I just decided to get ice cream anyway. Thus we finish with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p â†’ q</span></span></code></pre></div><p>Alternatively, if we don&rsquo;t get ice cream, we can be certain that it wasn&rsquo;t hot &ndash; since we are promsied that if it is hot, then we will get ice cream. So an equivalent translation is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Â¬q â†’  Â¬p</span></span></code></pre></div><p>(This form is called the <em>contrapositive</em>, which we learned about it in <a href=https://textbooks.cs.ksu.edu/cis301/2-chapter/2_4-logicalequiv/ rel=external target=_blank>section 2.4</a>). We&rsquo;ll study it and other equivalent translations more in the next section.)</p><h2 id=p-if-q-statements>p IF q statements</h2><p>A &ldquo;p IF q&rdquo; statement is promising that if <code>q</code> is true, then we can infer that <code>p</code> is also true. (It is making NO claims about what we can infer if we know <code>p</code> is true.) Equivalent ways of expressing the same promise are &ldquo;p PROVIDED q&rdquo; and &ldquo;p WHEN q&rdquo;.</p><p>For example, consider the following sentence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>You can login to a CS lab computer if you have a CS account.</span></span></code></pre></div><p>We first identify the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: You can login to a CS lab computer
</span></span><span style=display:flex><span>q: You have a CS account</span></span></code></pre></div><p>To determine the order of the implication, we think about what conditions need to be met in order for me to be promised that I can login. We see that if we have a CS account, then we are promised to be able to login. Thus we finish with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>q â†’ p</span></span></code></pre></div><p>In this example, if we knew we could login to a CS lab computer, we wouldn&rsquo;t be certain that we had a CS account. There might be other reasons we can login &ndash; maybe you can use your eID account instead, for example.</p><p>Alternatively, if we can&rsquo;t login, we can be certain that we don&rsquo;t have a CS account. After all, we are guaranteed to be able to login if we do have a CS account. So another valid translation is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Â¬p â†’  Â¬q</span></span></code></pre></div><h2 id=p-only-if-q>p ONLY IF q</h2><p>A &ldquo;p ONLY IF q&rdquo; statement is promising that the only time <code>p</code> happens is when <code>q</code> also happens. So if <code>p</code> does happen, it must be the case that <code>q</code> did too (since <code>p</code> can&rsquo;t happen without <code>q</code> happening too).</p><p>For example, consider the following sentence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Wilma eats cookies only if Evelyn makes them.</span></span></code></pre></div><p>We first identify the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: Wilma eats cookies
</span></span><span style=display:flex><span>q: Evelyn makes cookies</span></span></code></pre></div><p>What conditions need to be met for Wilma to eat cookies? If Wilma is eating cookies, Evelyn must have made cookies &ndash; after all, we know that Wilma only eats Evelyn&rsquo;s cookies. Thus we finish with the following translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p â†’ q</span></span></code></pre></div><p>Equivalently, we are certain that if Evelyn DOESN&rsquo;T make cookies, then Wilma won&rsquo;t eat them &ndash; since she only eats Evelyn&rsquo;s cookies. We can also write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Â¬q â†’  Â¬p</span></span></code></pre></div><p>However, if we know that Evelyn makes cookies, we can&rsquo;t be sure that Wilma will eat them. We know she won&rsquo;t eat any other kind of cookie, but maybe Wilma is full today and won&rsquo;t even eat Evelyn&rsquo;s cookies&mldr;we can&rsquo;t be sure.</p><h2 id=p-unless-b-p-except-if-q>p UNLESS b, p EXCEPT IF q</h2><p>The statements &ldquo;p UNLESS q&rdquo; and &ldquo;p EXCEPT IF q&rdquo; are equivalent&mldr;and both can sometimes be ambiguous. For example, consider the following sentence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>I will bike to work unless it is raining.</span></span></code></pre></div><p>We first identify the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: I will bike to work
</span></span><span style=display:flex><span>q: It is raining</span></span></code></pre></div><p>Next, we consider what exactly is being promised:</p><ul><li><em>If it isn&rsquo;t raining, will I bike to work?</em> Â  YES Â¬ I promise to bike to work whenever it isn&rsquo;t raining.</li><li><em>If I don&rsquo;t bike to work, is it raining?</em> Â  YES Â¬ I always bike when it&rsquo;s not raining, so if I don&rsquo;t bike, it must be raining.</li><li><em>If it&rsquo;s raining, will I necessarily not bike to work?</em> Â  Well, maybe? Some people might interpret the sentence as saying I&rsquo;ll get to work in another way if it&rsquo;s raining, and others might think no promise has been made if it is raining.</li><li><em>If I bike to work, is it necessarily not raining?</em> Â  Again, maybe? It&rsquo;s not clear if I&rsquo;m promising to only bike in non-rainy weather.</li></ul><p>As we did with ambiguous OR statements, we will establish a rule in this class for intrepeting &ldquo;unless&rdquo; statements that will let us resolve ambiguity.</p><p><strong>If you see the word <em>unless</em> when you are doing a translation, replace it with the words <em>unless possibly if</em>.</strong></p><p>If we rephrase the sentence as:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>I will bike to work *unless possibly if* it is raining.</span></span></code></pre></div><p>We see that there is clearly NO promise about whether I will bike in the rain. I might, or I might not &ndash; but the only thing that I am promising is that I <em>will</em> bike if it is <em>not</em> raining, or that IF it&rsquo;s not raining, THEN I will bike. With that in mind, we can complete our translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Â¬q â†’ p</span></span></code></pre></div><p>Equivalently, if we don&rsquo;t bike, then we are certain that it must be raining &ndash; since we have promised to ride our bike every other time. We can also write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> Â¬p â†’ q</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=equivalent-translations>Equivalent Translations</h1><p>As we saw in <a href=https://textbooks.cs.ksu.edu/cis301/2-chapter/2_4-logicalequiv/ rel=external target=_blank>section 2.4</a>), two logical statements are said to be <em>logically equivalent</em> if and only if they have the same truth value for every truth assignment.</p><p>We can extend this idea to our propositional logic translations &ndash; two (English) statements are said to be <em>equivalent</em> iff they have the same underlying meaning, and iff their translations to propositional logic are logically equivalent.</p><h2 id=common-equivalences-revisited>Common equivalences, revisited</h2><p>We previously identified the following common logical equivalences:</p><ul><li>Double negative: <code>Â¬ Â¬ p</code> and <code>p</code></li><li>Contrapositive: <code>p â†’ q</code> and <code>Â¬ q â†’ Â¬ p</code></li><li>Expressing an implies using an OR: <code>p â†’ q</code> and <code>Â¬ p âˆ¨ q</code></li><li>One of DeMorgan&rsquo;s laws: <code>Â¬ (p âˆ§ q)</code> and <code>( Â¬ p âˆ¨ Â¬ q)</code></li><li>Another of DeMorgan&rsquo;s laws: <code>Â¬ (p âˆ¨ q)</code> and <code>( Â¬ p âˆ§ Â¬ q)</code></li></ul><h2 id=equivalence-example-1>Equivalence example 1</h2><p>Suppose we have the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: I get cold
</span></span><span style=display:flex><span>q: It is summer</span></span></code></pre></div><p>Consider the following three statements:</p><ul><li><em>I get cold except possibly if it is summer.</em></li><li><em>If it&rsquo;s not summer, then I get cold.</em></li><li><em>I get cold or it is summer.</em></li></ul><p>We translate each sentence to propositional logic:</p><ul><li><p><em>I get cold except possibly if it is summer.</em></p><ul><li><code>p â†’ Â¬q</code></li><li>Meaning: I promise that if I get cold, then it must not be summer&mldr;because I am always cold when it&rsquo;s not summer.</li></ul></li><li><p><em>If it&rsquo;s not summer, then I get cold.</em></p><ul><li><code>Â¬q â†’ p</code></li><li>Meaning: I promise that anytime it isn&rsquo;t summer, then I will get cold.</li></ul></li><li><p><em>I get cold or it is summer.</em></p><ul><li><code>p V q</code></li><li>Meaning: I&rsquo;m either cold or it&rsquo;s summer&mldr;because my being cold is true every time it isn&rsquo;t summer.</li></ul></li></ul><p>As we can see, each of these statements is expressing the same idea.</p><h2 id=equivalence-example-2>Equivalence example 2</h2><p>Suppose we have the following propositional atoms:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: I eat chips
</span></span><span style=display:flex><span>q: I eat fries</span></span></code></pre></div><p>Consider the following two statements:</p><ul><li><em>I don&rsquo;t eat both chips and fries.</em></li><li><em>I don&rsquo;t eat chips and/or I don&rsquo;t eat fries.</em></li></ul><p>We translate each sentence to propositional logic:</p><ul><li><p><em>I don&rsquo;t eat both chips and fries.</em></p><ul><li><code>Â¬(p âˆ§ q)</code></li></ul></li><li><p><em>I don&rsquo;t eat chips and/or I don&rsquo;t eat fries.</em></p><ul><li><code>Â¬p V Â¬q</code></li></ul></li></ul><p>These statements are clearly expressing the same idea &ndash; if it&rsquo;s not the case that I eat both, then it&rsquo;s also true that there is at least one of the foods that I don&rsquo;t eat. This is an application of one of DeMorgan&rsquo;s laws: that <code>Â¬ (p âˆ§ q)</code> is equivalent to <code>( Â¬ p âˆ¨ Â¬ q)</code>.</p><p>If we were to create truth tables for both <code>Â¬(p âˆ§ q)</code> and <code>Â¬p V Â¬q</code>, we would see that they are <em>logically equivalent</em> (that the same truth assignments make each statement true).</p><h2 id=equivalence-example-3>Equivalence example 3</h2><p>Using the same propositional atoms as example 2, we consider two more statements:</p><ul><li><em>I don&rsquo;t eat chips or fries.</em></li><li><em>I don&rsquo;t eat chips and I don&rsquo;t eat fries.</em></li></ul><p>We translate each sentence to propositional logic:</p><ul><li><p><em>I don&rsquo;t eat chips or fries.</em></p><ul><li><code>Â¬(p V q)</code></li></ul></li><li><p><em>I don&rsquo;t eat chips and I don&rsquo;t eat fries.</em></p><ul><li><code>Â¬p âˆ§ Â¬q</code></li></ul></li></ul><p>These propositions are clearly expressing the same idea &ndash; I have two foods (chips and fries), and I don&rsquo;t eat either one. This demonstrates another of DeMorgan&rsquo;s laws: that <code>Â¬ (p âˆ¨ q)</code> is equivalent to <code>( Â¬ p âˆ§ Â¬ q)</code>. If we were to create truth tables for each proposition, we would see that they are logically equivalent as well.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=knights-and-knaves-revisited>Knights and Knaves, revisited</h1><p>Recall the Knights and Knaves puzzles from <a href=https://textbooks.cs.ksu.edu/cis301/1-chapter/1_2-knightsknaves/ rel=external target=_blank>section 1.2</a>. In addition to solving these puzzle by hand, we can devise a strategy to first translate a Knights and Knaves puzzle to propositional logic, and then solve the puzzle using a truth table.</p><h2 id=identifying-propositional-atoms>Identifying propositional atoms</h2><p>To translate a Knights and Knaves puzzle to propositional logic, we first create a propositional atom for each person that represented whether that person was a knight. For example, if our puzzle included the people &ldquo;Adam&rdquo;, &ldquo;Bob&rdquo;, and &ldquo;Carly&rdquo;, then we might create propositional atoms <code>a</code>, <code>b</code>, and <code>c</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a: Adam is a knight
</span></span><span style=display:flex><span>b: Bob is a knight
</span></span><span style=display:flex><span>c: Carly is a knight</span></span></code></pre></div><h2 id=translating-statements>Translating statements</h2><p>Once we have our propositional atoms, we can translate each statement in the puzzle to propositional logic. For each one, we want to capture that the statement is true IF AND ONLY IF the person speaking is a knight. (That way, the statement would be false whenever the person was not a knight &ndash; i.e., when they were a knave.) We recall that we can express <em>if and only if</em> using a conjunction of implications. So if we want to write <code>p if and only if q</code>, then we can say <code>(p â†’ q) âˆ§ (q â†’ p)</code>.</p><p>As an example, suppose we have the following statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Adam says: Bob is a knight and Carly is a knave.</span></span></code></pre></div><p>Adam&rsquo;s statement should be true if and only if he is a knight, so we can translate it as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(a â†’ (b âˆ§  Â¬c)) âˆ§ ((b âˆ§  Â¬c) â†’ a)</span></span></code></pre></div><p>Which reads as:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>If I am a knight, then Bob is a knight and Carly is a knave. Also, if Bob is a knight and Carly is a knave, then I am a knight.</span></span></code></pre></div><p>We repeat this process for each statement in the puzzle. Finally, since we solve a Knights and Knaves puzzle by finding a truth assignment (i.e., assignment of who is a knight and who is a knave) that works for ALL statements, then we finish by AND-ing together our translations for each speaker. When we fill in the truth table for our final combined proposition, then a valid solution to the puzzle is any truth assignment that makes the overall proposition true. If it was a well-made puzzle, then there should only be one such truth assignment.</p><h2 id=full-example>Full example</h2><p>Suppose we meet two people on the Island of Knights and Knaves &ndash; Ava and Bob.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Ava says, &#34;Bob and I are not the same&#34;.
</span></span><span style=display:flex><span>Bob says, &#34;Of Ava and I, exactly one is a knight.&#34;</span></span></code></pre></div><p>We first create a propositional atom for each person:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a: Ava is a knight
</span></span><span style=display:flex><span>b: Bob is a knight</span></span></code></pre></div><p>Then, we translate each statement:</p><ul><li><em>Bob and I are not the same</em><ul><li>Translation: <code>(a â†’ (a âˆ§ Â¬b V Â¬a âˆ§ b)) âˆ§ ((a âˆ§ Â¬b V Â¬a âˆ§ b) â†’ a)</code></li><li>Meaning: If Ava is a knight, then either Ava is a knight and Bob is a knave, or Ava is a knave and Bob is a knight (so they aren&rsquo;t the same type). Also, if Ava and Bob aren&rsquo;t the same type, then Ava must be a knight (because her statement would be true).</li></ul></li><li><em>Bob says, &ldquo;Of Ava and I, exactly one is a knight.</em><ul><li>Bob is really saying the same thing as Ava&mldr;if exactly one is a knight, then either Ava is a knight and Bob is a knave, or Ava is a knave and Bob is a knight.</li><li>Translation: <code>(b â†’ (a âˆ§ Â¬b V Â¬a âˆ§ b)) âˆ§ ((a âˆ§ Â¬b V Â¬a âˆ§ b) â†’ b)</code></li></ul></li></ul><p>We combine our translations for Ava and Bob and end up with the following propositional logic statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(a â†’ (a âˆ§ Â¬b V Â¬a âˆ§ b)) âˆ§ ((a âˆ§ Â¬b V Â¬a âˆ§ b) â†’ a) âˆ§ (b â†’ (a âˆ§ Â¬b V Â¬a âˆ§ b)) âˆ§ ((a âˆ§ Â¬b V Â¬a âˆ§ b) â†’ b)`</span></span></code></pre></div><p>We then complete the truth table for that proposition:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                                                                                  *
</span></span><span style=display:flex><span>---------------------------------------------------------------------------------------------------------------
</span></span><span style=display:flex><span>a b | (a â†’: (a âˆ§ Â¬b V Â¬a âˆ§ b)) âˆ§ ((a âˆ§ Â¬b V Â¬a âˆ§ b) â†’: a) âˆ§ (b â†’:(a âˆ§ Â¬b V Â¬a âˆ§ b)) âˆ§ ((a âˆ§ Â¬b V Â¬a âˆ§ b) â†’: b)
</span></span><span style=display:flex><span>---------------------------------------------------------------------------------------------------------------
</span></span><span style=display:flex><span>T T |    F     F F  F F  F     F     F F  F F  F    T     F    F    F  F F F  F     F     F  F F  F  F   T
</span></span><span style=display:flex><span>T F |    T     T T  T F  F     T     T T  T F  F    T     T    T    T  T T F  F     F     T  T T  F  F   F
</span></span><span style=display:flex><span>F T |    T     F F  T T  T     F     F F  T T  T    F     F    T    F  F T T  T     F     F  F T  T  T   T
</span></span><span style=display:flex><span>F F |    T     F T  F T  F     T     F T  F T  F    T     T    T    F  T F T  F     T     F  T F  T  F   T
</span></span><span style=display:flex><span>---------------------------------------------------------------------------------------------------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [F F]
</span></span><span style=display:flex><span>F: [T T] [T F] [F T]</span></span></code></pre></div><p>And we see that there is only one truth assignment that satisfies the proposition &ndash; <code>[F F]</code>, which corresponds to Ava being a knave and Bob being a knave.</p><h2 id=conclusion>Conclusion</h2><p>As you can see, solving a Knights and Knaves problem by translating each statement to propositional logic is a tedious process. We ended up with a very involved final formula that made filling in the truth table somewhat arduous. Such problems are usually much simpler to solve by hand &ndash; but this process demonstrates that we <em>can</em> apply a systematic approach to solve Knights and Knaves problems with translations and truth tables.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=propositional-logic-proofs>Propositional Logic Proofs</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Propositional Logic Proofs</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments &ndash; of which there are exponentially many. In this chapter, we will learn the process of <em>natural deduction</em> in propositional logic. This will allow us to start with a set of known facts (<em>premises</em>) and apply a series of rules to see if we can reach some goal <em>conclusion</em>. Essentially, we will be able to see whether a given conclusion necessarily follows from a set of premises.</p><p>We will use the Logika tool to check whether our proofs correctly follow our deduction rules. HOWEVER, these proofs can and do exist outside of Logika. Different settings use slightly different syntaxes for the deduction rules, but the rules and proof system are the same. We will merely use Logika to help check our work.</p><h2 id=sequents-premises-and-conclusions>Sequents, premises, and conclusions</h2><p>A <em>sequent</em> is a mathematical term for an assertion or an argument. We use the notation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p0, p1, ..., pm âŠ¢ c</span></span></code></pre></div><p>The <em>p0, p1, &mldr;, pm</em> are called <em>premises</em> and <em>c</em> is called the <em>conclusion</em>. The <code>âŠ¢</code> is called the <em>turnstile operator</em>, and we read it as &ldquo;prove&rdquo;. The full sequent is read as:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Statements p0, p1, ..., pm PROVE c</span></span></code></pre></div><p>A sequent is saying that if we accept statements <em>p0, p1, &mldr;, pm</em> as facts, then we guarantee that <em>c</em> is a fact as well.</p><p>For example, in the sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p â†’ q , Â¬ q  âŠ¢  Â¬ p</span></span></code></pre></div><p>The premises are: <code>p â†’ q</code> and <code>Â¬q</code>, and the conclusion is <code>Â¬p</code>.</p><p>(Shortcut: we can use <code>|-</code> in place of the <code>âŠ¢</code> turnstile operator.)</p><h2 id=sequent-validity>Sequent validity</h2><p>A sequent is said to be <em>valid</em> if, for every truth assignment which make the premises true, then the conclusion is also true.</p><p>For example, consider the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p â†’ q , Â¬q  âŠ¢  Â¬p</span></span></code></pre></div><p>To check if this sequent is valid, we must find all truth assignments for which both premises are true, and then ensure that those truth assignments also make the conclusion true.</p><h3 id=sequent-validity-in-logika-using-truth-tables>Sequent validity in Logika using truth tables</h3><p>We can use a different kind of truth table to prove the validity of a sequent in Logika:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>         *     *     *
</span></span><span style=display:flex><span>---------------------------
</span></span><span style=display:flex><span>p q # (p â†’: q, Â¬q) âŠ¢ Â¬p
</span></span><span style=display:flex><span>---------------------------
</span></span><span style=display:flex><span>T T #    T     F     F
</span></span><span style=display:flex><span>T F #    F     T     F
</span></span><span style=display:flex><span>F T #    T     F     T
</span></span><span style=display:flex><span>F F #    T     T     T
</span></span><span style=display:flex><span>---------------------------
</span></span><span style=display:flex><span>Valid [F F]</span></span></code></pre></div><p>Notice that instead of putting just one logical formula, we put the entire sequent &ndash; the premises are in a comma-separated list inside parentheses, then the turnstile operator (which we type using the keys <code>|-</code> in Logika), and then the conclusion. We mark the top-level operator of each premise and conclusion.</p><p>Examining each row in the above truth table, we see that only the truth assignment [F F] makes both premises (<code>p â†’ q</code> and <code>Â¬q</code>) true. We look right to see that the same truth assignment also makes the conclusion (<code> Â¬p</code>) true, which means that the sequent is valid.</p><h2 id=proving-sequents-using-natural-deduction>Proving sequents using natural deduction</h2><p>Now we will turn to the next section of the course &ndash; using <em>natural deduction</em> to similarly prove the validity of sequents. Instead of filling out truth tables (which becomes cumbersome very quickly), we will apply a series of <em>deduction rules</em> to allow us to conclude new claims from our premises. In turn, we can use our deduction rules on these new claims to conclude more and more, until (hopefully) we are able to claim our conclusion. If we can do that, then our sequent was valid.</p><h2 id=logika-natural-deduction-proof-syntax>Logika natural deduction proof syntax</h2><p>We will use the following format in Logika to start a natural deduction proof for propositional logic. Each proof will be saved in a new file with a <code>.sc</code> (Scala) extension:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background type
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@pure def ProofName(variable1: B, variable2: B, ...): Unit = {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        (comma-separated list of premises with variable1, variable2, ...)  âŠ¢  (conclusion)
</span></span><span style=display:flex><span>            Proof(
</span></span><span style=display:flex><span>                //the actual proof steps go here
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Once we are inside the <code>Proof</code> element (where the above example says &ldquo;the actual proof steps go here&rdquo;), we complete a numbered series of steps. Each step includes a claim and corresponding justification, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background type
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@pure def ProofName(variable1: B, variable2: B, ...): Unit = {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        (comma-separated list of premises with variable1, variable2, ...)  âŠ¢  (conclusion)
</span></span><span style=display:flex><span>            Proof(
</span></span><span style=display:flex><span>                1 (     claim_a         )   by Justification_a,
</span></span><span style=display:flex><span>                2 (     claim_b         )   by Justification_b,
</span></span><span style=display:flex><span>                ...
</span></span><span style=display:flex><span>                736 (   conclusion      )   by Justification_conc
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Each claim is given a number, and these numbers are generally in order. However, the only rule is that claim numbers be unique (they may be out of order and/or non-consecutive). Once we have justified a claim in a proof, we will refer to it as a <em>fact</em>.</p><p>We will see more details of Logika proof syntax as we progress through chapter 4.</p><h2 id=premise-justification>Premise justification</h2><p>The most basic justification for a claim in a proof is &ldquo;premise&rdquo;. This justification is used when you pull in a premise from the sequent and introduce it into your proof. All, some or none of the premises can be introduced at any time in any order. Please note that only one premise may be entered per claim.</p><p>For example, we might bring in the premises from our sequent like this (the imports, proof function definition, deduce call, and formatter changes are omitted here for readability):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p               )   by Premise,
</span></span><span style=display:flex><span>        2 (     q               )   by Premise,
</span></span><span style=display:flex><span>        3 (     Â¬r              )   by Premise,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We could also bring in the same premise multiple times, if we wanted. We could also use non-sequential line numbers, as long as each line number was unique:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        7 (     p           )   by Premise,
</span></span><span style=display:flex><span>        10 (    q           )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬r          )   by Premise,
</span></span><span style=display:flex><span>        8 (     p           )   by Premise,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We could only bring in some portion of our premises, if we wanted:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p           )   by Premise,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>But we can only list one premise in each claim. For example, the following is not allowed:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, q, Â¬r)  âŠ¢  (p âˆ§ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p, q, Â¬r           )   by Premise,      //NO! Only one premise per line.
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=deduction-rules>Deduction rules</h2><p>The logical operators (AND, OR, NOT, IMPLIES) are a kind of language for building propositions from basic, primitive propositional atoms. For this reason, we must have laws for constructing propositions and for disassembling them. These laws are called <em>inference</em> rules or <em>deduction</em> rules. A <em>natural deduction system</em> is a set of inference rules, such that for each logical operator, there is a rule for constructing a proposition with that operator (this is called an <em>introduction rule</em>) and there is a rule for disassembling a proposition with that operator (this is called an <em>elimination rule</em>).</p><p>For the sections that follow, we will see the introduction and elimination rules for each logical operator. We will then learn how to use these deduction rules to write a formal proof showing that a sequent is valid.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=and-rules>AND Rules</h1><p>In this section, we will see the deduction rules for the AND operator.</p><h2 id=and-introduction>AND introduction</h2><p>Clearly, when both <code>p</code> and <code>q</code> are facts, then so is the proposition <code>p âˆ§ q</code>. This makes logical sense &ndash; if two propositions are independently true, then their conjunction (AND) must also be true. The AND introduction rule, <code>AndI</code>, formalizes this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>        P   Q   
</span></span><span style=display:flex><span>AndI :  ---------   
</span></span><span style=display:flex><span>        P âˆ§ Q</span></span></code></pre></div><p>We will use the format above when introducing each of our natural deduction rules:</p><ul><li><code>P</code> and <code>Q</code> are not necessarily individual variables &ndash; they are placeholders for some propositional statement, which may itself involve several logical operators.</li><li>On the left side is the rule name (in this case, <code>AndI</code>)</li><li>On the top of the right side we see what we already need to have established as facts in order to use this rule (in this case, <code>P</code> and also <code>Q</code> ). These facts can appear anywhere in our scope of the proof, in whatever order. (For now, all previous lines in the proof will be within our scope, but this will change when we get to more complex rules that involve subproofs).</li><li>On the bottom of the right side, we see what we can claim by using that proof rule.</li></ul><p>Here is a simple example of a proof that uses <code>AndI</code>. It proves that if propositional atoms <code>p</code>, <code>q</code>, and <code>r</code> are all true, then the proposition <code>r âˆ§ (q âˆ§ p)</code> is also true:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, q, r)  âŠ¢  (r âˆ§ (q âˆ§ p))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p              )   by Premise,
</span></span><span style=display:flex><span>        2 (     q              )   by Premise,
</span></span><span style=display:flex><span>        3 (     r              )   by Premise,
</span></span><span style=display:flex><span>        4 (     q âˆ§ p          )   by AndI(2, 1),
</span></span><span style=display:flex><span>        5 (     r âˆ§ (q âˆ§ p)    )   by AndI(3, 4)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>You can read line 4 like this: &ldquo;from the fact <code>q</code> stated on line 2 and the fact <code>p</code> stated on line 1, we deduce <code>q âˆ§ p</code> by applying the <code>AndI</code> rule&rdquo;. Lines 4 and 5 construct new facts from the starting facts (premises) on lines 1-3.</p><p>Note that if I had instead tried:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, q, r)  âŠ¢  (r âˆ§ (q âˆ§ p))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p              )   by Premise,
</span></span><span style=display:flex><span>        2 (     q              )   by Premise,
</span></span><span style=display:flex><span>        3 (     r              )   by Premise,
</span></span><span style=display:flex><span>        4 (     q âˆ§ p          )   by AndI(1, 2),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Then line 4 would not have been accepted. The line numbers cited after the <code>AndI</code> rule must match the order of the resulting AND statement. The left-hand side of our resulting AND statement must correspond to the first line number in <code>AndI</code> justification, and the right-hand side of our resulting AND statement must correspond to the second line number in the justification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    4 (     p           )   by (some justification),
</span></span><span style=display:flex><span>    5 (     q	        )   by (some justification),
</span></span><span style=display:flex><span>    6 (     p â‹€ q       )   by AndI(4, 5), 
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    9 (     q â‹€ p       )   by AndI(5, 4),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><h2 id=and-elimination>AND elimination</h2><p>The idea of the AND elimination rules is that if we have a proposition <code>p â‹€ q</code> as a fact, then we can separately claim both <code>p</code> and <code>q</code> as individual facts. After all, the only time <code>p â‹€ q</code> is true in a truth table is when both <code>p</code> and <code>q</code> are individually true. There are two AND elimination rules &ndash; <code>AndE1</code> and <code>AndE2</code>. <code>AndE1</code> allows us to claim that the left (first) side of an AND statement is individually true, and <code>AndE2</code> allows us to do the same with the right (second) side. Here is the formalization of each rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>        P âˆ§ Q                   P âˆ§ Q
</span></span><span style=display:flex><span>AndE1 : ---------      AndE2 : ---------
</span></span><span style=display:flex><span>          P                       Q</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>AndE1</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q)  âŠ¢  (p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ q          )   by Premise,
</span></span><span style=display:flex><span>        2 (     p              )   by AndE1(1)
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can read the justification <code>AndE1(1)</code> as: AND-elimination 1 from line 1, or &ldquo;take the AND statement on line 1 and extract its first (left) side&rdquo;.</p><p>Here is a simple example showing the syntax of the <code>âˆ§e2</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q)  âŠ¢  (q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ q          )   by Premise,
</span></span><span style=display:flex><span>        2 (     q              )   by AndE2(1)
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can read the justification <code>AndE2(1)</code> as: AND-elimination 2 from line 1, or &ldquo;take the AND statement on line 1 and extract its second (right) side&rdquo;.</p><h2 id=example-1>Example 1</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ§ r)) âŠ¢ (r âˆ§ p)</span></span></code></pre></div><p>Whenever we approach a proof, a good first strategy is to see what we can extract from the premises. If we have a premise that is an AND statement, then we can use <code>AndE1</code> and then <code>AndE2</code> to extract both its left and right side as separate claims. So we start our proof like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ§ r)) âŠ¢  (r âˆ§ p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ (q âˆ§ r)        )       by Premise,
</span></span><span style=display:flex><span>        2 (     p                  )       by AndE1(1),
</span></span><span style=display:flex><span>        3 (     q âˆ§ r              )       by AndE2(1),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>But now we have a new AND statement as a claim &ndash; <code>q âˆ§ r</code>. We can again use both <code>AndE1</code> and <code>AndE2</code> to extract each side separately:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ§ r)) âŠ¢  (r âˆ§ p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ (q âˆ§ r)        )       by Premise,
</span></span><span style=display:flex><span>        2 (     p                  )       by AndE1(1),
</span></span><span style=display:flex><span>        3 (     q âˆ§ r              )       by AndE2(1),
</span></span><span style=display:flex><span>        4 (     q                  )       by AndE1(3),
</span></span><span style=display:flex><span>        5 (     r                  )       by AndE2(3),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Now that we have done all we can with our premises and the resulting statements, we examine our conclusion. Whenever our conclusion is a conjunction (AND statement), we know that we must separately show both the left side and the right side of that conclusion. Then, we can use <code>AndI</code> to put those sides together into our goal AND statement.</p><p>In this example, we have already proved both sides of our goal AND statement &ndash; <code>r</code> (from line 5) and <code>p</code> (from line 2). All that remains is to use <code>AndI</code> to put them together:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ§ r)) âŠ¢  (r âˆ§ p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ (q âˆ§ r)        )       by Premise,
</span></span><span style=display:flex><span>        2 (     p                  )       by AndE1(1),
</span></span><span style=display:flex><span>        3 (     q âˆ§ r              )       by AndE2(1),
</span></span><span style=display:flex><span>        4 (     q                  )       by AndE1(3),
</span></span><span style=display:flex><span>        5 (     r                  )       by AndE2(3),
</span></span><span style=display:flex><span>        6 (     r âˆ§ p              )       by AndI(5, 2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=example-2>Example 2</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q âˆ§ r, a âˆ§ (t âˆ¨ s)) âŠ¢ (q âˆ§ (t âˆ¨ s))</span></span></code></pre></div><p>We again try to use AND-elimination to extract what we can from our premises. We might try something like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q âˆ§ r, a âˆ§ (t âˆ¨ s)) âŠ¢ (q âˆ§ (t âˆ¨ s))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ q âˆ§ r          )       by Premise,
</span></span><span style=display:flex><span>        2 (     a âˆ§ (t âˆ¨ s)        )       by Premise,
</span></span><span style=display:flex><span>        3 (     p                  )       by AndE1(1),        //NO! Won&#39;t work.
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>However, we get into trouble when we try to use <code>AndE1</code> to extract the left side of the premise <code>p âˆ§ q âˆ§ r</code>. The problem has to do with operator precedence &ndash; we recall that <code>âˆ§</code> operators are processed from left to right, which means that <code>p âˆ§ q âˆ§ r</code> is equivalent to <code>(p âˆ§ q) âˆ§ r</code>. By reminding ourselves of the &ldquo;hidden parentheses&rdquo;, we see that when we use <code>AndE1</code> on the premise <code>p âˆ§ q âˆ§ r</code>, we extract <code>p âˆ§ q</code>. Similarly, <code>AndE2</code> will extract <code>r</code>.</p><p>We try again to extract what we can from our premises:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q âˆ§ r, a âˆ§ (t âˆ¨ s)) âŠ¢ (q âˆ§ (t âˆ¨ s))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ q âˆ§ r          )       by Premise,
</span></span><span style=display:flex><span>        2 (     a âˆ§ (t âˆ¨ s)        )       by Premise,
</span></span><span style=display:flex><span>        3 (     p âˆ§ q              )       by AndE1(1),   
</span></span><span style=display:flex><span>        4 (     r                  )       by AndE2(1),
</span></span><span style=display:flex><span>        5 (     a                  )       by AndE1(2),
</span></span><span style=display:flex><span>        6 (     t âˆ¨ s              )       by AndE2(2),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>As before, we look at our resulting claims &ndash; we see a <code>p âˆ§ q</code>, and we know that we can use AND elimination again to extract both sides. Now we have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q âˆ§ r, a âˆ§ (t âˆ¨ s)) âŠ¢ (q âˆ§ (t âˆ¨ s))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ q âˆ§ r          )       by Premise,
</span></span><span style=display:flex><span>        2 (     a âˆ§ (t âˆ¨ s)        )       by Premise,
</span></span><span style=display:flex><span>        3 (     p âˆ§ q              )       by AndE1(1),   
</span></span><span style=display:flex><span>        4 (     r                  )       by AndE2(1),
</span></span><span style=display:flex><span>        5 (     a                  )       by AndE1(2),
</span></span><span style=display:flex><span>        6 (     t âˆ¨ s              )       by AndE2(2),
</span></span><span style=display:flex><span>        7 (     p                  )       by AndE1(3),
</span></span><span style=display:flex><span>        8 (     q                  )       by AndE2(3),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Now, we look at what we are trying to prove &ndash; <code>q âˆ§ (t âˆ¨ s)</code>. Since its top-level operator is the AND, we know that we must separately prove <code>q</code> and <code>t âˆ¨ s</code>. Then, we can use AND introduction to put the two pieces together to match our conclusion. We see that we already have <code>q</code> on line 8 and <code>t âˆ¨ s</code> on line 6, so we add our final line to finish the proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ q âˆ§ r, a âˆ§ (t âˆ¨ s)) âŠ¢ (q âˆ§ (t âˆ¨ s))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ q âˆ§ r          )       by Premise,
</span></span><span style=display:flex><span>        2 (     a âˆ§ (t âˆ¨ s)        )       by Premise,
</span></span><span style=display:flex><span>        3 (     p âˆ§ q              )       by AndE1(1),   
</span></span><span style=display:flex><span>        4 (     r                  )       by AndE2(1),
</span></span><span style=display:flex><span>        5 (     a                  )       by AndE1(2),
</span></span><span style=display:flex><span>        6 (     t âˆ¨ s              )       by AndE2(2),
</span></span><span style=display:flex><span>        7 (     p                  )       by AndE1(3),
</span></span><span style=display:flex><span>        8 (     q                  )       by AndE2(3),
</span></span><span style=display:flex><span>        9 (     q âˆ§ (t âˆ¨ s)        )       by AndI(8, 6)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>You might notice that lines 5 and 7 were not needed, as both <code>p</code> and <code>a</code> were not part of the conclusion. That&rsquo;s true &ndash; we could have eliminated those steps. However, it&rsquo;s a good idea to extract as much information as possible while you are getting used to doing these proofs &ndash; it doesn&rsquo;t hurt to have extra claims, and you may find that you end up needing them.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=or-rules>OR Rules</h1><p>In this section, we will see the deduction rules for the OR operator.</p><h2 id=or-introduction>OR introduction</h2><p>If we know that a proposition <code>P</code> is true, then it will also be the case that both <code>P âˆ¨ Q</code> and <code>Q âˆ¨ P</code> are also true. It doesn&rsquo;t matter what <code>Q</code> is &ndash; it might even be something that is know to be false. Because <code>P</code> is true, it will make the overall OR statement true as well.</p><p>There are two OR introduction rules &ndash; <code>OrI1</code> and <code>OrI2</code>. <code>OrI1</code> allows us to claim an OR statement with some previous fact on the left (first) side, and <code>OrI2</code> allows us to do the same with the right (second) side. Here is the formalization of each rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>          P                   Q     
</span></span><span style=display:flex><span>OrI1 : --------    OrI2 :  -------- 
</span></span><span style=display:flex><span>        P âˆ¨ Q               P âˆ¨ Q </span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>OrI1</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p) âŠ¢ (p âˆ¨ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p          )       by Premise,
</span></span><span style=display:flex><span>        2 (     p âˆ¨ q      )       by OrI1(1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can read the justification <code>OrI(1)</code> as: OR introduction 1 from line 1, or &ldquo;create a OR statement that puts the claim from line 1 on the first (left) side, and puts something new on the second side&rdquo;.</p><p>Here is a simple example showing the syntax of the <code>OrI2</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p) âŠ¢ (q âˆ¨ p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p          )       by Premise,
</span></span><span style=display:flex><span>        2 (     q âˆ¨ p      )       by OrI2(1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can read the justification <code>OrI2(1)</code> as: OR introduction 2 from line 1, or &ldquo;create a OR statement that puts the claim from line 1 on the second (right) side, and puts something new on the first side&rdquo;.</p><h2 id=or-elimination>OR elimination</h2><p>The OR elimination rule is used when we have an OR statement of the form <code>P âˆ¨ Q</code>, and we wish to use it to extract new information. In real life, we call the rule &ldquo;case analysis&rdquo;. For example, say that you have either 12 quarters in your pocket or 30 dimes in your pocket. In either case, you can buy a $3.00 coffee. Why? You do a case analysis:</p><ul><li>In the case you have 12 quarters, that totals $3.00, and you can buy the coffee;</li><li>In the case you have 30 dimes, that totals $3.00, and you can buy the coffee.</li></ul><p>So, in both cases, you can buy the coffee.</p><p>We can formalize the idea behind the OR elimination rule as follows:</p><ul><li>In order for the OR statement <code>P âˆ¨ Q</code> to be true, at least one of <code>P</code> and <code>Q</code> must be individually true</li><li>If we are able to reach some conclusion <code>R</code> if we assume <code>P</code> is true, and we are able to reach the SAME conclusion <code>R</code> if we assume <code>Q</code> is true&mldr;</li><li>&mldr;Then no matter what, <code>R</code> will be true.</li></ul><h3 id=subproofs>Subproofs</h3><p>OR elimination will be our first proof rule that uses subproofs. Subproofs are tools for case analysis or what-if excursions, used to support justification for later claims. In propositional logic, they will always contain one assumption. This assumption is a proposition whose scope is limited to the subproof. The syntax of a subproof in Logika looks like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(premises) âŠ¢ (conclusion)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        5 (     fact_A             )   by Justification_A,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        17 SubProof(
</span></span><span style=display:flex><span>            18 Assume(  fact_D  ),
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            25 (    fact_G        )   by (some justification using claim 5)   //this is OK
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        45 (    fact_R            )   by (some justification using claim 25)  //this is NOT OK
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Opening and closing parentheses, <code>(...)</code>, that are attached to &ldquo;Proof&rdquo; and &ldquo;SubProof&rdquo; elements define the scope of claims. The SubProof elements are given a claim number when they are opened, but no justification. Closing parenthesis for ending proofs and subproofs are not given claim numbers. The use of parentheses in this manner is analogous to the use of curly brackets use to define scope in Java, C# and C.</p><p>In the example above, the subproof starting on line 17 creates an environment where fact_D is true. The justification used on claim number 25, which uses claim 15, is valid. The scope of claim 5 includes subproof 17.</p><p>However, the justification for line number 45 is invalid. Fact_G on line number 25 was proven true in an environment where fact_D is true (ie subproof 17). That environment ends (falls out of scope) when the closing parenthesis for the subproof is reached. This happens before line 45.</p><p>Only specific deduction rules allow you to close a scope and create a new claim based on that subproof in the enclosing (outer) scope. These rules always take a subproof (i.e &ldquo;17&rdquo;) as part of the justification.</p><h3 id=syntax>Syntax</h3><p>Here is the OR elimination rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                    SubProof(              SubProof(
</span></span><span style=display:flex><span>                        Assume ( P ),           Assume ( Q ),
</span></span><span style=display:flex><span>      P âˆ¨ Q             ...                     ...
</span></span><span style=display:flex><span>                        R                       R
</span></span><span style=display:flex><span>                    ),                     ),
</span></span><span style=display:flex><span>OrE : -----------------------------------------------------------
</span></span><span style=display:flex><span>                         R</span></span></code></pre></div><p>In order to use the <code>OrE</code> rule, we must have three things:</p><ul><li>An OR statement of the form <code>P âˆ¨ Q</code></li><li>A subproof that begins by assuming the left side of the OR statement (<code>P</code>) and ends with some claim <code>R</code></li><li>A subproof that begins by assuming the right side of the OR statement (<code>Q</code>) and ends with the same claim <code>R</code></li></ul><p>If we have all three parts, we can use the <code>OrE</code> and cite the OR statement and both subproofs to claim that <code>R</code> is true no matter what.</p><p>Here is a simple example showing the syntax of the <code>OrE</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ¨ q) âŠ¢ (q âˆ¨ p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ¨ q          )           by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume (  p  ),
</span></span><span style=display:flex><span>            4 (     q âˆ¨ p      )           by OrI2(3)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        5 SubProof(
</span></span><span style=display:flex><span>            6 Assume (  q   ),
</span></span><span style=display:flex><span>            7 (     q âˆ¨ p      )           by OrI1(6)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        8 (     q âˆ¨ p          )           by OrE(1, 2, 5)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Here, we have the OR statement <code>p âˆ¨ q</code>. We then have two subproofs where we separately assume that the two sides or the OR are true. The first subproof on line 2 starts by assuming the left side of the OR, <code>p</code>. It then uses OR introduction to reach the goal conclusion, <code>q âˆ¨ p</code>. After reaching our goal, we end the first subproof and immediately start a second subproof. In the second subproof, we assume that the the right side of our OR statement is true, <code>q</code>. We then use the other form of OR introduction to reach the SAME conclusion as we did in the first subproof &ndash; <code>q âˆ¨ p</code>. We end the second subproof and can now use <code>âˆ¨e</code> to state that our conclusion <code>q âˆ¨ p</code> must be true no matter what. After all, we knew that at least one of <code>p</code> or <code>q</code> was true, and we were able to reach the conclusion <code>q âˆ¨ p</code> in both cases.</p><p>When using the justification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>OrE(1, 2, 5)</span></span></code></pre></div><p>The first line number corresponds to our original OR statement (line 1 with <code>p âˆ¨ q</code> for us), the second line number corresponds to the subproof where we assumed the first (left) side of that OR statement (line 2 for us, which starts the subproof where we assumed <code>p</code>), and the third line number corresponds to the subproof where we assumed the second (right) side of that OR statement (line 5 for us, which starts the subproof where we assumed <code>q</code>)</p><p>This proof shows that the OR operator is commutative.</p><h2 id=example-1>Example 1</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ¨ r)) âŠ¢ ((p âˆ§ q) âˆ¨ (p âˆ§ r))</span></span></code></pre></div><p>As we have done before, we start by extracting whatever we can from our premises:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ¨ r)) âŠ¢ ((p âˆ§ q) âˆ¨ (p âˆ§ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ (q âˆ¨ r)        )   by Premise,
</span></span><span style=display:flex><span>        2 (     p                  )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     q âˆ¨ r              )   by AndE2(1),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Next, we look at what we are trying to prove, and see that its top-level operator is an OR. If we already had either side of our goal OR statement (i.e., either <code>p âˆ§ q</code> or <code>p âˆ§ r</code>), then we could use <code>AndI</code> to create the desired proposition. This isn&rsquo;t the case for us, though, so we need to use a different strategy.</p><p>The next consideration when we want to prove an OR statement is whether we have another OR statement, either as a premise or a fact we have already established. If we do, then we can attempt to use OR elimination with that OR statement to build our goal conclusion (<code>(p âˆ§ q) âˆ¨ (p âˆ§ r)</code>). We have the OR statement <code>q âˆ¨ r</code> available, so we&rsquo;ll try to use OR elimination &ndash; we&rsquo;ll have a subproof where we assume <code>q</code> and try to reach <code>(p âˆ§ q) âˆ¨ (p âˆ§ r)</code>, and then a subproof where we assume <code>r</code> and try to reach <code>(p âˆ§ q) âˆ¨ (p âˆ§ r)</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ§ (q âˆ¨ r)) âŠ¢ ((p âˆ§ q) âˆ¨ (p âˆ§ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ§ (q âˆ¨ r)            )   by Premise,
</span></span><span style=display:flex><span>        2 (     p                      )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     q âˆ¨ r                  )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume(  q  ),
</span></span><span style=display:flex><span>            6 (     p âˆ§ q              )   by AndI(2,5),
</span></span><span style=display:flex><span>            7 (     (p âˆ§ q) âˆ¨ (p âˆ§ r)  )   by OrI1(6)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        8 SubProof(
</span></span><span style=display:flex><span>            9 Assume(  r  ),
</span></span><span style=display:flex><span>            10 (    p âˆ§ r             )   by AndI(2,9),
</span></span><span style=display:flex><span>            11 (    (p âˆ§ q) âˆ¨ (p âˆ§ r) )   by OrI2(10)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        12 (  (p âˆ§ q) âˆ¨ (p âˆ§ r)     )   by OrE(3, 4, 8)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can make our final claim:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>12 (  (p âˆ§ q) âˆ¨ (p âˆ§ r)     )   by OrE(3, 4, 8)</span></span></code></pre></div><p>Because we had an OR statement on line 3 (<code>q âˆ¨ r</code>), assumed the left side of that OR (<code>q</code>) in subproof 4 and reached the conclusion of <code>(p âˆ§ q) âˆ¨ (p âˆ§ r)</code>, and then assumed the right side of our OR (<code>r</code>) in subproof 8 and reached the SAME conclusion of <code>(p âˆ§ q) âˆ¨ (p âˆ§ r)</code>.</p><h2 id=example-2>Example 2</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>((p âˆ¨ q) âˆ§ (p âˆ¨ r)) âŠ¢ (p âˆ¨ (q âˆ§ r))</span></span></code></pre></div><p>Note that this is the same as the previous example, but the premises are switched with the conclusion. If we prove this direction too, we will have shown that <code>(p âˆ¨ q) âˆ§ (p âˆ¨ r)</code> is equivalent to <code>p âˆ¨ (q âˆ§ r)</code>. We&rsquo;ll learn more about this process in section 4.8.</p><p>We start by pulling in our premises and extracting whatever information we can:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>((p âˆ¨ q) âˆ§ (p âˆ¨ r)) âŠ¢ (p âˆ¨ (q âˆ§ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     (p âˆ¨ q) âˆ§ (p âˆ¨ r)      )   by Premise,
</span></span><span style=display:flex><span>        2 (     p âˆ¨ q                  )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     p âˆ¨ r                  )   by AndE2(1),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We see that the top-level operator of our conclusion (<code>p âˆ¨ (q âˆ§ r)</code>) is an OR, so we apply the same strategy we did in the previous example &ndash; we see if we have an OR statement already available as a claim, and then try to use OR elimination on it to build to our conclusion in both subproofs. In this case, though, we have TWO or statements &ndash; <code>p âˆ¨ q</code> and <code>p âˆ¨ r</code>. We will see that it doesn&rsquo;t matter which of these we choose, so let&rsquo;s pick the first one &ndash; <code>p âˆ¨ q</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>((p âˆ¨ q) âˆ§ (p âˆ¨ r)) âŠ¢ (p âˆ¨ (q âˆ§ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     (p âˆ¨ q) âˆ§ (p âˆ¨ r)       )   by Premise,
</span></span><span style=display:flex><span>        2 (     p âˆ¨ q                   )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     p âˆ¨ r                   )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume(  p  ),
</span></span><span style=display:flex><span>            6 (     p âˆ¨ (q âˆ§ r)         )   by OrI1(5)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        7 SubProof(
</span></span><span style=display:flex><span>            8 Assume(   q               ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //what do we do now?
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We are able to finish the first subproof, but it&rsquo;s not clear what to do in the second subproof. We assume <code>q</code>, and know we have the goal of reaching the same conclusion as we did in the first subproof, <code>p âˆ¨ (q âˆ§ r)</code>&mldr;but we don&rsquo;t have enough information yet to get there. The only piece of information that we haven&rsquo;t used that might help us is our second OR statement &ndash; <code>p âˆ¨ r</code>. We are already inside a subproof, but we can still nest other subproofs &ndash; just as we can nest conditional statements in computer programs.</p><p>We start on a nested OR elimination approach with <code>p âˆ¨ r</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>((p âˆ¨ q) âˆ§ (p âˆ¨ r)) âŠ¢ (p âˆ¨ (q âˆ§ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     (p âˆ¨ q) âˆ§ (p âˆ¨ r)       )   by Premise,
</span></span><span style=display:flex><span>        2 (     p âˆ¨ q                   )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     p âˆ¨ r                   )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume(  p  ),
</span></span><span style=display:flex><span>            6 (     p âˆ¨ (q âˆ§ r)         )   by OrI1(5)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        7 SubProof(
</span></span><span style=display:flex><span>            8 Assume(  q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //start OR elimination with p âˆ¨ r
</span></span><span style=display:flex><span>            9 SubProof(
</span></span><span style=display:flex><span>                10 Assume(  p  ),
</span></span><span style=display:flex><span>                11 (    p âˆ¨ (q âˆ§ r)     )   by OrI1(10)         
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            12 SubProof(
</span></span><span style=display:flex><span>                13 Assume(  r  ),
</span></span><span style=display:flex><span>                14 (    q âˆ§ r           )   by AndI(8, 13),
</span></span><span style=display:flex><span>                15 (    p âˆ¨ (q âˆ§ r)     )   by OrI2(14)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            16 (    p âˆ¨ (q âˆ§ r)         )   by OrE(3, 9, 12)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        17 (    p âˆ¨ (q âˆ§ r)             )   by OrE(2, 4, 7)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Note that we use the âˆ¨e rule twice &ndash; on line 16 to tie together subproofs 9 and 12 (where we processed the OR statement <code>p âˆ¨ r</code>), and on line 17 to tie together subproofs 4 and 7 (where we processed the OR statement <code>p âˆ¨ q</code>).</p><p>When we first started this problem, we mentioned that it didn&rsquo;t matter which OR statement we chose to work with &ndash; <code>p âˆ¨ q</code> or <code>p âˆ¨ r</code>. Indeed, we could have chosen <code>p âˆ¨ r</code> instead &ndash; but we would end up nesting another OR elimination for <code>p âˆ¨ q</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>((p âˆ¨ q) âˆ§ (p âˆ¨ r)) âŠ¢ (p âˆ¨ (q âˆ§ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     (p âˆ¨ q) âˆ§ (p âˆ¨ r)      )   by Premise,
</span></span><span style=display:flex><span>        2 (     p âˆ¨ q                  )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     p âˆ¨ r                  )   by AndE2(1),
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        //OR elimination for p âˆ¨ r
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume(  p  ),
</span></span><span style=display:flex><span>            6 (     p âˆ¨ (q âˆ§ r)        )   by OrI1(5)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        7 SubProof(
</span></span><span style=display:flex><span>            8 Assume(  r  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //start OR elimination with p âˆ¨ q
</span></span><span style=display:flex><span>            9 SubProof(
</span></span><span style=display:flex><span>                10 Assume(  p  ),
</span></span><span style=display:flex><span>                11 (    p âˆ¨ (q âˆ§ r)   )   by OrI1(10)         
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            12 SubProof(
</span></span><span style=display:flex><span>                13 Assume(  q  ),
</span></span><span style=display:flex><span>                14 (    q âˆ§ r         )   by AndI(13, 8),
</span></span><span style=display:flex><span>                15 (    p âˆ¨ (q âˆ§ r)   )   by OrI2(14)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            16 (    p âˆ¨ (q âˆ§ r)       )   by OrE(2, 9, 12)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        17 (    p âˆ¨ (q âˆ§ r)           )   by OrE(3, 4, 7)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=implies-rules>Implies Rules</h1><p>In this section, we will see the deduction rules for the implies operator.</p><p>Note that in our Logika proofs, the implies operator is typed as <code>__>:</code> but is rendered as <code>â†’</code>.</p><h2 id=implies-elimination>Implies elimination</h2><p>Remember that <code>â†’</code> is a kind of logical &ldquo;if-then&rdquo;. Here, we understand <code>p â†’ q</code> to mean that <code>p</code> holds knowledge sufficient to deduce <code>q</code> â€“ so, whenever <code>p</code> is proved to be a fact, then <code>p â†’ q</code> enables <code>q</code> to be proved a fact, too. This is the implies elimination rule, <code>ImplyE</code>, and we can formalize it like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>            P â†’ Q    P
</span></span><span style=display:flex><span> ImplyE :  ------------
</span></span><span style=display:flex><span>                Q</span></span></code></pre></div><p>Here is a simple example of a proof that shows the syntax of the <code>ImplyE</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(a, a â†’ b) âŠ¢ (b)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     a          )   by Premise,
</span></span><span style=display:flex><span>        2 (     a â†’ b      )   by Premise,
</span></span><span style=display:flex><span>        3 (     b          )   by ImplyE(2, 1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Note that when we use <code>ImplyE</code>, we first list the line number of the implies statement, and then list the line number that contains the left side of that implies statement. The <code>ImplyE</code> allows us to claim the right side of that implies statement.</p><h2 id=implies-introduction>Implies introduction</h2><p>The idea behind the next deduction rule, implies introduction, is that we would be introducing a new implies statement of the form <code>P â†’ Q</code>. In order to do this, we must be able to show our logical &ldquo;if-then&rdquo; &ndash; that IF <code>P</code> exists, THEN we promise that <code>Q</code> will also exist. We do this by way of a subproof where we assume <code>P</code>. If we can reach <code>Q</code> by the end of that subproof, we will have shown that anytime <code>P</code> is true, then <code>Q</code> is also true. We will be able to close the subproof by introducing <code>P â†’ Q</code> with the <code>ImplyI</code> rule. We can formalize the rule like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>           SubProof(
</span></span><span style=display:flex><span>              Assume(  P  ),
</span></span><span style=display:flex><span>              ...
</span></span><span style=display:flex><span>              Q
</span></span><span style=display:flex><span>           ),
</span></span><span style=display:flex><span>ImplyI : -------------- 
</span></span><span style=display:flex><span>              P â†’ Q </span></span></code></pre></div><p>Here is a simple example of a proof that shows the syntax of the <code>ImplyI</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(a â†’ b, b â†’ c) âŠ¢ (a â†’ c)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     a â†’ b           )   by Premise,
</span></span><span style=display:flex><span>        2 (     b â†’ c           )   by Premise,
</span></span><span style=display:flex><span>        3 SubProof(
</span></span><span style=display:flex><span>            //we want to prove a â†’ c, so we start by assuming a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            4 Assume(  a  ),
</span></span><span style=display:flex><span>            5 (     b           )   by ImplyE(1, 4),
</span></span><span style=display:flex><span>            6 (     c           )   by ImplyE(2, 5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //...and try to end with c
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //then we can conclude that anytime a is true, then c is also true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        7 (     a â†’ c           )   by ImplyI(3)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Note that when we use <code>ImplyI</code>, we list the line number of the subproof we just finished. We must have started that subproof by assuming the left side of the implies statement we are introducing, and ended that subproof with the right side of the implies statement we are introducing.</p><h2 id=example-1>Example 1</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r)) âŠ¢ ((q âˆ§ p) â†’ r)</span></span></code></pre></div><p>We start by listing our premise:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r)) âŠ¢ ((q âˆ§ p) â†’ r)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ (q â†’ r)        )   by Premise,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can&rsquo;t extract any information from the premise, so we shift to examining our conclusion. The top-level operator of our conclusion is an implies statement, so this tells us that we will need to use the <code>ImplyI</code> rule. We want to prove <code>(q âˆ§ p) â†’ r</code>, so we need to show that whenever <code>q âˆ§ p</code> is true, then <code>r</code> is also true. We open a subproof and assume the left side of our goal implies statement (<code>q âˆ§ p</code>). If we can reach <code>r</code> by the end of the subproof, then we can use <code>ImplyI</code> to conclude <code>(q âˆ§ p) â†’ r</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r)) âŠ¢ ((q âˆ§ p) â†’ r)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ (q â†’ r)        )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  q âˆ§ p  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: get to r
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (q âˆ§ p) â†’ r
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Now we can complete the proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r)) âŠ¢ ((q âˆ§ p) â†’ r)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ (q â†’ r)        )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  q âˆ§ p  ),
</span></span><span style=display:flex><span>            4 (     q              )   by AndE1(3),
</span></span><span style=display:flex><span>            5 (     p              )   by AndE2(3),
</span></span><span style=display:flex><span>            6 (     q â†’ r          )   by ImplyE(1, 5),
</span></span><span style=display:flex><span>            7 (     r              )   by ImplyE(6, 4)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: get to r
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //use ImplyI to conclude (q âˆ§ p) â†’ r
</span></span><span style=display:flex><span>        8 (     (q âˆ§ p) â†’ r        )   by ImplyI(2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=example-2>Example 2</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r) âŠ¢ (p â†’ q) â†’ (p â†’ r))</span></span></code></pre></div><p>We see that we will have no information to extract from the premises. The top-level operator is an implies statement, so we start a subproof to introduce that implies statement. In our subproof, we will assume the left side of our goal implies statement (<code>p â†’ q</code>) and will try to reach the right side of our goal (<code>p â†’ r</code>):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r) âŠ¢ (p â†’ q) â†’ (p â†’ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ (q â†’ r)            )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //goal: get to p â†’ r
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ (p â†’ r)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We can see that our goal is to reach <code>p â†’ r</code> in our subproof &ndash; so we see that we need to introduce another implies statement. This tells us that we need to nest another subproof &ndash; in this one, we&rsquo;ll assume the left side of our <em>current</em> goal implies statement (<code>p</code>), and then try to reach the right side of that current goal (<code>r</code>). Then, we&rsquo;d be able to finish that inner subproof by using <code>ImplyI</code> to conclude <code>p â†’ r</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r) âŠ¢ (p â†’ q) â†’ (p â†’ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ (q â†’ r)            )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            4 SubProof(
</span></span><span style=display:flex><span>                5 Assume(  p  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //goal: get to r
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            //use ImplyI to conclude p â†’ r
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //goal: get to p â†’ r
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ (p â†’ r)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Now we can complete the proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ (q â†’ r) âŠ¢ (p â†’ q) â†’ (p â†’ r))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ (q â†’ r)             )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            4 SubProof(
</span></span><span style=display:flex><span>                5 Assume(  p  ),
</span></span><span style=display:flex><span>                6 (     q               )   by ImplyE(3, 5),
</span></span><span style=display:flex><span>                7 (     q â†’ r           )   by ImplyE(1, 5),
</span></span><span style=display:flex><span>                8 (     r               )   by ImplyE(7, 6)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //goal: get to r
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            //use ImplyI to conclude p â†’ r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            9 (     p â†’ r               )   by ImplyI(4)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //goal: get to p â†’ r
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ (p â†’ r)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        10 (    (p â†’ q) â†’ (p â†’ r)       )   by ImplyI(2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=example-3>Example 3</h2><p>Here is one more example, where we see we can nest an <code>ImplyI</code> subproof and a <code>OrE</code> subproof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ r, q â†’ r) âŠ¢ ((p âˆ¨ q) â†’ r)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ r              )   by Premise,
</span></span><span style=display:flex><span>        2 (     q â†’ r              )   by Premise,
</span></span><span style=display:flex><span>        3 SubProof(
</span></span><span style=display:flex><span>            //assume p âˆ¨ q, try to get to r 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            4 Assume(  p âˆ¨ q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //nested subproof for OR elimination on p âˆ¨ q
</span></span><span style=display:flex><span>            //try to get to r in both cases
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            5 SubProof(
</span></span><span style=display:flex><span>                6 Assume(  p  ),
</span></span><span style=display:flex><span>                7 (     r          )   by ImplyE(1, 6)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            8 SubProof(
</span></span><span style=display:flex><span>                9 Assume(  q  ),
</span></span><span style=display:flex><span>                10 (    r          )   by ImplyE(2, 9)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            11 (    r              )   by OrE(4, 5, 8)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: get to r
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p âˆ¨ q) â†’ r
</span></span><span style=display:flex><span>        12 (    (p âˆ¨ q) â†’ r        )   by ImplyI(3)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=negation-rules>Negation Rules</h1><p>In this section, we will see the deduction rules for the NOT operator. In this section, we will introduce the notion of a <em>contradiction</em>, which occurs when, for some proposition <code>P</code>, we have proved both the facts <code>P</code> and <code>Â¬ P</code>. This indicates that we are in an impossible situation, and often means that we have made a bad previous assumption. In Logika, we use an <code>F</code> (&ldquo;false&rdquo;) as a claim to indiciate that we&rsquo;ve reached a contradiction. In other texts, you sometime see the symbol <code>âŠ¥</code> (which means &ldquo;bottom operator&rdquo;) for a contradiction.</p><h2 id=negation-elimination>Negation elimination</h2><p>The negation elimination rule allows you to claim that you have reached a contradiction. We can formalize the rule like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>        P   Â¬P
</span></span><span style=display:flex><span>NegE : -----------
</span></span><span style=display:flex><span>           F</span></span></code></pre></div><p>Here is a simple example of a proof that shows the syntax of the `NegE rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(q, Â¬q) âŠ¢ (F)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     q       )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬q      )   by Premise,
</span></span><span style=display:flex><span>        3 (     F       )   by NegE(1, 2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We use the <code>NegE</code> rule when we have facts for both <code>P</code> and <code>Â¬P</code> for some proposition <code>P</code>. When we use the justification, we first list the line number of the claim for <code>P</code> (line 1, in our case) and then the line number of the claim for <code>Â¬P</code> (line 2, in our case).</p><p>Sometimes, the proposition <code>P</code> itself has a NOT operator. Consider this example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬q, Â¬Â¬q) âŠ¢ (F)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬q      )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬Â¬q     )   by Premise,
</span></span><span style=display:flex><span>        3 (     F       )   by NegE(1, 2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Here, our proposition <code>P</code> is the claim <code>Â¬q</code>, and our proposition that is of the form <code>Â¬P</code> is the claim <code>Â¬Â¬q</code>.</p><h2 id=negation-introduction>Negation introduction</h2><p>The negation introduction rule allows us to introduce a NOT operation. If assuming some proposition <code>P</code> leads to a contradiction, then we must have made a bad assumption &ndash; <code>P</code> must NOT be true after all. We can then introduce the fact <code>Â¬P</code>. We can formalize the negation introduction rule like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>        SubProof(
</span></span><span style=display:flex><span>            Assume ( P ),
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            F
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>NegI : --------------
</span></span><span style=display:flex><span>           Â¬P</span></span></code></pre></div><p>Here is a simple example of a proof that shows the syntax of the <code>NegI</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p,  q â†’ Â¬p)  âŠ¢  (Â¬q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p           )       by Premise,
</span></span><span style=display:flex><span>        2 (     q â†’ Â¬p      )       by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        3 SubProof(
</span></span><span style=display:flex><span>            4 Assume (  q  ) ,
</span></span><span style=display:flex><span>            5 (     Â¬p      )       by ImplyE(2, 4),
</span></span><span style=display:flex><span>            6 (     F       )       by NegE(1, 5)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        7 (     Â¬q          )       by NegI(3)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Note that the negation introduction rule involves a subproof &ndash; if we wish to prove <code>Â¬P</code> for some proposition <code>P</code>, then we start a subproof where we assume <code>P</code>. If we are able to reach a contradiciton on the last line of that subproof, then we can use the <code>NegI</code> rule after the subproof ends to claim that our assumption was bad and that it is actually <code>Â¬P</code> that is true. When we use <code>Â¬i</code> as a justification, we list the line number corresponding to this subproof.</p><h2 id=bottom-elimination>Bottom elimination</h2><p>There is a special law for reasoning forwards from an impossible situation â€” the âŠ¥e law â€” which says, in the case of a contradiction, everything becomes a fact. (That is, &ldquo;if False is a fact, so is everything else Â¬&rdquo;.) This rule is called &ldquo;bottom elimination&rdquo;, and is written as <code>BottomE</code>. Here is a formalization of the rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>              F
</span></span><span style=display:flex><span>BottomE :  ------  for any proposition, Q, at all
</span></span><span style=display:flex><span>              Q</span></span></code></pre></div><p>Here is a simple example of a proof that shows the syntax of the <code>BottomE</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p, Â¬p)  âŠ¢ (q)
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     p       )       by Premise,
</span></span><span style=display:flex><span>    2 (     Â¬p      )       by Premise,
</span></span><span style=display:flex><span>    3 (     F       )       by NegE(1, 2),
</span></span><span style=display:flex><span>    4 (     q       )       by BottomE(3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that when we use <code>BottomE</code> as the justification, we list the line number of where we reached a contradiction (<code>F</code>).</p><p>The bottom elimination rule works well with case analysis, where we discover that one case is impossible. Here is a classic example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p âˆ¨ q, Â¬p) âŠ¢ (q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p âˆ¨ q       )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬p          )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        3 SubProof(
</span></span><span style=display:flex><span>            4 Assume(  p  ),
</span></span><span style=display:flex><span>            5 (     F       )   by NegE(4, 2),
</span></span><span style=display:flex><span>            6 (     q       )   by BottomE(5)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        7 SubProof(
</span></span><span style=display:flex><span>            8 Assume(  q  )
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        9 (     q           )   by OrE(1, 3, 7)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Considering the premise, <code>p âˆ¨ q</code>, we analyze our two cases by starting OR elimination. The first case, where <code>p</code> holds true, is impossible, because it causes a contradiction. The <code>BottomE</code>-rule lets us gracefully prove <code>q</code> in this &ldquo;impossible case&rdquo;. (You can read lines 4-6 as saying, &ldquo;in the case when <code>p</code> might hold true, there is a contradiction, and in such an impossible situation, we can deduce whatever we like, so we deduce <code>q</code> to finish this impossible case&rdquo;.)</p><p>The second case, that <code>q</code> holds true, is the only realistic case, and it immediately yields the conclusion. The proof finishes the two-case analysis with the <code>OrE</code> rule.</p><h2 id=proof-by-contradiction>Proof by contradiction</h2><p>The proof by contraction rule, <code>PbC</code>, says that when assuming <code>Â¬P</code> leads to a contradiction for some proposition <code>P</code>, then we made a bad assumption and thus <code>P</code> must be true. It is very similar to the <code>NegI</code> rule, except <code>PbC</code> has us assuming <code>Â¬P</code> and eventually concluding <code>P</code>, while the <code>NegI</code> rule has us assuming <code>P</code> and eventually concluding <code>Â¬P</code>.</p><p>Here is a formalization of <code>PbC</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>        SubProof(
</span></span><span style=display:flex><span>             Assume( Â¬P ),
</span></span><span style=display:flex><span>             ...
</span></span><span style=display:flex><span>             F   
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>PbC:   --------------------
</span></span><span style=display:flex><span>               P</span></span></code></pre></div><p>And here is an example that demonstrates the syntax of the rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬Â¬p) âŠ¢ (p)
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     Â¬Â¬p         )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 SubProof(
</span></span><span style=display:flex><span>        3 Assume (  Â¬p  ),
</span></span><span style=display:flex><span>        4 (     F       )   by NegE(3, 1)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    5 (     p           )   by PbC(2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>When we use the <code>PbC</code> rule as a justification for a claim <code>P</code>, we cite the line number of the subproof where we assumed <code>Â¬P</code> and ended in a contradiction.</p><h2 id=example-1>Example 1</h2><p>Suppose we want to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬p âˆ§ Â¬q) âŠ¢ (Â¬(p âˆ¨ q))</span></span></code></pre></div><p>We start by listing our premise, and extracting the two sides of the AND statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬p âˆ§ Â¬q) âŠ¢ (Â¬(p âˆ¨ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬p âˆ§ Â¬q     )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬p          )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     Â¬q          )   by AndE2(1),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Next, we see that our conclusion has the form NOT (something), so this tells us that we will need to introduce a NOT (using the <code>NegI</code> rule). In fact, ANY time we wish to prove a proposition of the form NOT (something), we will always use the <code>NegI</code> rule. (We will discuss proof strategies in detail in the next section.) Since we want to prove <code>Â¬(p âˆ¨ q)</code>, then we open a subproof where we assume <code>p âˆ¨ q</code>. If we can end that subproof with a contradiction, then we can use <code>NeEgI</code> afterwards to conclude <code>Â¬(p âˆ¨ q)</code>.</p><p>We know that we want this proof structure:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬p âˆ§ Â¬q) âŠ¢ (Â¬(p âˆ¨ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬p âˆ§ Â¬q     )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬p          )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     Â¬q          )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume (  p âˆ¨ q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //want to reach a contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //will use NegI to conclude Â¬(p âˆ¨ q)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We know we must reach a contradiction in our subproof. We see that we have claims <code>Â¬p</code>, <code>Â¬q</code>, and <code>p âˆ¨ q </code>. Since at least one of <code>p âˆ¨ q </code>is true, and since either one would yield a contradiction with one of <code>Â¬p</code> or <code>Â¬q</code>, then we start on OR elimination:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬p âˆ§ Â¬q) âŠ¢ (Â¬(p âˆ¨ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬p âˆ§ Â¬q     )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬p          )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     Â¬q          )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume (  p âˆ¨ q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //OR elimination subproofs on p âˆ¨ q
</span></span><span style=display:flex><span>            6 SubProof(
</span></span><span style=display:flex><span>                7 Assume(  p  ),
</span></span><span style=display:flex><span>                8 (     F       )   by NegE(7, 2)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            9 SubProof(
</span></span><span style=display:flex><span>                10 Assume(  q  ),
</span></span><span style=display:flex><span>                11 (    F       )   by NegE(10, 3)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //use OrE rule to tie together subproofs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //want to reach a contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //will use NegI to conclude Â¬(p âˆ¨ q)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We see that both OR elimination subproofs ended with a contradiction (<code>F</code>). Just like any other use of <code>OrE</code>, we restate that common conclusion after the two subproofs. We knew at least one of <code>p</code> or <code>q</code> were true, and both ended in a contradiction &ndash; so the contradiction holds no matter what:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬p âˆ§ Â¬q) âŠ¢ (Â¬(p âˆ¨ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬p âˆ§ Â¬q     )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬p          )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     Â¬q          )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume (  p âˆ¨ q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //OR elimination subproofs on p âˆ¨ q
</span></span><span style=display:flex><span>            6 SubProof(
</span></span><span style=display:flex><span>                7 Assume(  p  ),
</span></span><span style=display:flex><span>                8 (     F       )   by NegE(7, 2)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            9 SubProof(
</span></span><span style=display:flex><span>                10 Assume(  q  ),
</span></span><span style=display:flex><span>                11 (    F       )   by NegE(10, 3)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //use OrE rule to tie together subproofs
</span></span><span style=display:flex><span>            12 (        F       )   by OrE(5, 6 , 8)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //want to reach a contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //will use NegI to conclude Â¬(p âˆ¨ q)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>All that remains is the use the <code>NegI</code> rule to finish subproof 4, as that subproof ended with a contradiction:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬p âˆ§ Â¬q) âŠ¢ (Â¬(p âˆ¨ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬p âˆ§ Â¬q     )   by Premise,
</span></span><span style=display:flex><span>        2 (     Â¬p          )   by AndE1(1),
</span></span><span style=display:flex><span>        3 (     Â¬q          )   by AndE2(1),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume (  p âˆ¨ q  ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //OR elimination subproofs on p âˆ¨ q
</span></span><span style=display:flex><span>            6 SubProof(
</span></span><span style=display:flex><span>                7 Assume(  p  ),
</span></span><span style=display:flex><span>                8 (     F       )   by NegE(7, 2)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            9 SubProof(
</span></span><span style=display:flex><span>                10 Assume(  q  ),
</span></span><span style=display:flex><span>                11 (    F       )   by NegE(10, 3)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //use OrE rule to tie together subproofs
</span></span><span style=display:flex><span>            12 (        F       )   by OrE(5, 6 , 8)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //want to reach a contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //will use NegI to conclude Â¬(p âˆ¨ q)
</span></span><span style=display:flex><span>        13 (        Â¬(p âˆ¨ q)    )   by NegI(4)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=example-2>Example 2</h2><p>When doing propositional logic translations, we learned that <code>p â†’ q</code> is equivalent to its <em>contrapositive</em>, <code>Â¬q â†’ Â¬p</code>. We will prove one direction of this equivalence (to show two statements are <em>provably equivalent,</em> which we will see in section 4.8, we would need to prove both directions):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ q) âŠ¢ (Â¬q â†’ Â¬p)</span></span></code></pre></div><p>We notice that the top-level operator of our conclusion is an IMPLIES operator, so we know that we need to introduce an implies operator. We saw in the previous section that the blueprint for introducing an implies operator is with a subproof: assume the left side of the goal implies statement, and try to reach the right side of the goal implies statement by the end of the subproof.</p><p>We have this proof structure:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ q) âŠ¢ (Â¬q â†’ Â¬p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ q       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  Â¬q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: reach Â¬p
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use â†’i to conclude Â¬q â†’ Â¬p
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We see that our goal in the subproof is the show Â¬p &ndash; if we could do that, then we could tie together that subproof with the â†’i rule. Since our intermediate goal is to prove NOT (something), then we use our strategy for negation introduction as an inner subproof. We finish the proof as shown:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ q) âŠ¢ (Â¬q â†’ Â¬p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ q       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  Â¬q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //use Â¬i strategy to prove Â¬p
</span></span><span style=display:flex><span>            4 SubProof(
</span></span><span style=display:flex><span>                5 Assume(  p  ),
</span></span><span style=display:flex><span>                6 (     q       )   by ImplyE(1, 5),
</span></span><span style=display:flex><span>                7 (     F       )   by NegE(6, 3)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            8 (     Â¬p          )   by NegI(4)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: reach Â¬p
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use â†’i to conclude Â¬q â†’ Â¬p
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        9 (     Â¬q â†’ Â¬p         )   by ImplyI(2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=example-3>Example 3</h2><p>Suppose we want to prove the sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬(Â¬p âˆ¨ Â¬q)) âŠ¢ (p âˆ§ q)</span></span></code></pre></div><p>We see that there is nothing to extract from our premise, and that the top-level operator of the conclusion (<code>p âˆ§ q</code>) is an AND. We see that we will need to introduce an AND statement &ndash; but the only way we can create <code>p âˆ§ q</code> is to separately prove both <code>p</code> and <code>q</code>.</p><p>It is not immediately clear how to prove either <code>p</code> or <code>q</code>. We will discuss proof strategies in more detail in the next section, but <code>PbC</code> is a good fallback option if you don&rsquo;t have a clear path for how to prove something and some of the claims in the proof involve negation. Since we wish to prove <code>p</code>, then will will assume <code>Â¬p</code> in a subproof. If we can reach a contradiction, then we can use <code>PbC</code> to conclude <code>p</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬(Â¬p âˆ¨ Â¬q)) âŠ¢ (p âˆ§ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬(Â¬p âˆ¨ Â¬q)      )       by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  Â¬p  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use PbC to conclude p
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //similarly prove q
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //use AndI to conclude p âˆ§ q
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>In subproof 2, we know we need to end with a contradiction. The only propositions we have to work with are <code>Â¬(Â¬p âˆ¨ Â¬q)</code> and <code>Â¬p</code>. But if we use <code>OrI1</code> with <code>Â¬p</code>, then we could have <code>Â¬p âˆ¨ Â¬q</code> &ndash; and then we could claim a contradiction. We complete the proof as shown (using the same strategy to prove <code>q</code>):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬(Â¬p âˆ¨ Â¬q)) âŠ¢ (p âˆ§ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬(Â¬p âˆ¨ Â¬q)      )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  Â¬p  ),
</span></span><span style=display:flex><span>            4 (     Â¬p âˆ¨ Â¬q     )   by OrI1(3),
</span></span><span style=display:flex><span>            5 (     F           )   by NegE(4, 1) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use PbC to conclude p
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        6 (     p               )   by PbC(2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //similarly prove q
</span></span><span style=display:flex><span>        7 SubProof(
</span></span><span style=display:flex><span>            8 Assume(  Â¬q  ),
</span></span><span style=display:flex><span>            9 (     Â¬p âˆ¨ Â¬q     )   by OrI2(8),
</span></span><span style=display:flex><span>            10 (    F           )   by NegE(9, 1) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        11 (        q           )   by PbC(7),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //use AndI to conclude p âˆ§ q
</span></span><span style=display:flex><span>        12 (        p âˆ§ q       )   by AndI(6, 11)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=law-of-the-excluded-middle>Law of the excluded middle</h2><p>The <em>law of the excluded middle (LEM)</em> is famous consequence of <code>PbC</code>: from no starting premises at all, we can prove <code>p âˆ¨ Â¬ p</code> for any proposition we can imagine:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ (p âˆ¨ Â¬p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 SubProof(
</span></span><span style=display:flex><span>            2 Assume(  Â¬(p âˆ¨ Â¬p)  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            3 SubProof(
</span></span><span style=display:flex><span>                4 Assume(  p  ),
</span></span><span style=display:flex><span>                5 (     p âˆ¨ Â¬ p         )   by OrI1(4),
</span></span><span style=display:flex><span>                6 (     F               )   by NegE(5, 2)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            7 (     Â¬p                  )   by NegI(3),
</span></span><span style=display:flex><span>            8 (     p âˆ¨ Â¬p              )   by OrI2(7),
</span></span><span style=display:flex><span>            9 (     F                   )   By NegE(8, 2)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        10 (        p âˆ¨ Â¬p              )   By PbC(1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>In other proofs involving negation and no clear path forward, it is sometimes useful to first derive LEM (this is possible since no premises are needed). If we have the claim <code>p âˆ¨ Â¬ p</code> in a proof, then we can use OR elimination where we separately assume <code>p</code> and then <code>Â¬ p</code> to try to reach the same conclusion. Here is one such example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ q) âŠ¢ (Â¬p âˆ¨ q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ q       )   by Premise,
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        // start of previous p âˆ¨ Â¬ p proof
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  Â¬(p âˆ¨ Â¬p)  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            4 SubProof(
</span></span><span style=display:flex><span>                5 Assume(  p  ),
</span></span><span style=display:flex><span>                6 (     p âˆ¨ Â¬ p         )   by OrI1(5),
</span></span><span style=display:flex><span>                7 (     F               )   by NegE(6, 3)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            8 (     Â¬p                  )   by NegI(4),
</span></span><span style=display:flex><span>            9 (     p âˆ¨ Â¬p              )   by OrI2(8),
</span></span><span style=display:flex><span>            10 (    F                   )   By NegE(9, 3)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        11 (        p âˆ¨ Â¬p              )   By PbC(2),  // conclusion of p âˆ¨ Â¬ p proof
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        12 SubProof(
</span></span><span style=display:flex><span>            13 Assume(  p  ),
</span></span><span style=display:flex><span>            14 (        q               )   By ImplyE(1, 13), 
</span></span><span style=display:flex><span>            15 (        Â¬p âˆ¨ q          )   By OrI2(14)      
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        16 SubProof(
</span></span><span style=display:flex><span>            17 Assume(  Â¬p  ),
</span></span><span style=display:flex><span>            18 (        Â¬p âˆ¨ q          )   By OrI1(17)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        19 (        Â¬p âˆ¨ q              )   By OrE(11, 12, 16)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary-and-strategies>Summary and Strategies</h1><p>When examining more complex propositional logic sequents, it can be challenging to know where to start. In this section, we summarize all available rules in propositional logic, and discuss stratgies for approaching proofs.</p><h2 id=and-rules>AND rules</h2><p>Rule summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>         P   Q                  P âˆ§ Q                  P âˆ§ Q  
</span></span><span style=display:flex><span>AndI :  ---------     AndE1 : ----------     AndE2 : ---------- 
</span></span><span style=display:flex><span>         P âˆ§ Q                    P                      Q</span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     p       )		by (...),
</span></span><span style=display:flex><span>    y (     q	    )       by (...),
</span></span><span style=display:flex><span>    z (     p âˆ§ q   )       by AndI(x, y),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     p âˆ§ q   )		by (...),
</span></span><span style=display:flex><span>    y (     p	    )       by AndE1(x),
</span></span><span style=display:flex><span>    z (     q       )       by AndE2(y),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><h2 id=or-rules>OR rules</h2><p>Rule summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                                                           SubProof(                SubProof(
</span></span><span style=display:flex><span>                                                                Assume ( P ),           Assume (Q ),
</span></span><span style=display:flex><span>                                                 P âˆ¨ Q          ...                     ...
</span></span><span style=display:flex><span>                                                                R      ... R   }        R
</span></span><span style=display:flex><span>           P                   Q                           ),                       ),
</span></span><span style=display:flex><span>OrI1 : ---------    OrI2 : ----------      OrE : ------------------------------------------------------- 
</span></span><span style=display:flex><span>        P âˆ¨ Q               P âˆ¨ Q                                     R</span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     p       )		by (...),
</span></span><span style=display:flex><span>    y (     p âˆ¨ q   )       by OrI1(x),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     q       )		by (...),
</span></span><span style=display:flex><span>    y (     p âˆ¨ q   )       by OrI2(x),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    a (     p âˆ¨ q       )   by (...),
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    b SubProof(
</span></span><span style=display:flex><span>        c Assume(  p  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        d (     r       )   by (...)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    f SubProof(
</span></span><span style=display:flex><span>        g Assume(  q  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        h (     r       )   by (...)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    i (     r           )   by OrE(a, b, f),</span></span></code></pre></div><h2 id=implies-rules>Implies rules</h2><p>Rule summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                                     SubProof(
</span></span><span style=display:flex><span>                                        Assume( P ),
</span></span><span style=display:flex><span>                                        ...
</span></span><span style=display:flex><span>                                        Q 
</span></span><span style=display:flex><span>           P â†’ Q    P                ),
</span></span><span style=display:flex><span> ImplyE : -------------     ImplyI : ----------------    
</span></span><span style=display:flex><span>           Q                           P â†’ Q   </span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     p â†’ q   )   by (...),	
</span></span><span style=display:flex><span>    y (     p       )   by (...),     
</span></span><span style=display:flex><span>    z (     q       )   by ImplyE(x, y),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    a SubProof(
</span></span><span style=display:flex><span>        b Assume(  p  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        c (     q       )   by (...)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    d (     p â†’ q       )   by ImplyI(a),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><h2 id=negation-rules>Negation rules</h2><p>Rule summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                  
</span></span><span style=display:flex><span>        P   Â¬P     
</span></span><span style=display:flex><span>NegE : ----------  
</span></span><span style=display:flex><span>          F   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SubProof(
</span></span><span style=display:flex><span>            Assume ( P ),
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            F
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>NegI : --------------
</span></span><span style=display:flex><span>           Â¬P     
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              F
</span></span><span style=display:flex><span>BottomE :  ------  for any proposition, Q, at all
</span></span><span style=display:flex><span>              Q
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SubProof(
</span></span><span style=display:flex><span>             Assume( Â¬P ),
</span></span><span style=display:flex><span>             ...
</span></span><span style=display:flex><span>             F   
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>PbC:   --------------------
</span></span><span style=display:flex><span>               P</span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     p       )   by (...),  
</span></span><span style=display:flex><span>    y (     Â¬p      )   by (...),
</span></span><span style=display:flex><span>    z (     F       )   by NegE(x, y),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    a SubProof(
</span></span><span style=display:flex><span>        b Assume(  p  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        c (     F       )   by (...)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    d (     Â¬p          )   by NegI(a),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    x (     F       )   by (...),
</span></span><span style=display:flex><span>    y (     q       )   by BottomE(x),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    a SubProof(
</span></span><span style=display:flex><span>        b Assume(  Â¬p  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        c (     F       )   by (...)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    d (     p           )   by PbC(a),
</span></span><span style=display:flex><span>    ...</span></span></code></pre></div><h2 id=strategies>Strategies</h2><ol><li>Write down all premises first. Can you extract anything from the premises?<ul><li>If you have <code>pâˆ§q</code>, use <code>AndE1</code> to extract <code>p</code> by itself and then <code>AndE2</code> to extract <code>q</code> by itself.</li><li>If you have <code>pâ†’q</code> and <code>p</code>, use <code>ImplyE</code> to get <code>q</code>.</li><li>If you have <code>p</code> and <code>Â¬p</code>, use <code>NegE</code> to claim a contradiction, <code>F</code>.</li></ul></li><li>Look at the top-level operator of what you are trying to prove.<ul><li><p>Are you trying to prove something of the form <code>pâ†’q</code>?</p><ul><li>Use <code>ImplyI</code>. Open a subproof, assume <code>p</code>, and get to <code>q</code> by the end of the subproof. After the subproof, use <code>ImplyI</code> to conclude <code>pâ†’q</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>Â¬p</code>?</p><ul><li>Use <code>NegI</code>. Open a subproof, assume <code>p</code>, and get a contradiction, <code>F</code>, by the end of the subproof. After the subproof, use <code>NegI</code> to conclude <code>Â¬p</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p âˆ§ q</code>?</p><ul><li>Try to prove <code>p</code> by itself and then <code>q</code> by itself. Afterward, use <code>AndI</code> to conclude <code>p âˆ§ q</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p âˆ¨ q</code>?</p><ul><li>See if you have either <code>p</code> or <code>q</code> by itself &ndash; if you do, use either <code>OrI1</code> or <code>OrI2</code> to conclude <code>p âˆ¨ q</code>.</li></ul></li></ul></li><li>You&rsquo;ll need to nest the approaches from step 2. Once you are in a subproof, think about what you are <em>trying to prove by the end of that subproof</em>. Follow the strategy in step 2 to prove your current goal, nesting subproofs as needed. As you work, stop and scan the propositions that you have available. See if you can extract anything from them as you did for the premises in step 1.</li><li>No match, or still stuck?<ul><li>Do you have an OR statement available? Try using OR elimination to prove your goal conclusion.</li><li>Do your propositions have NOT operators, but don&rsquo;t fit the form for using <code>Â¬i</code>? Try using <code>PbC</code>. If you are trying to prove something of the form <code>p</code>, open a subproof, assume <code>Â¬p</code>, and try to reach a contradiction by the end of the subproof. Afterward, use <code>PbC</code> to conclude <code>p</code>.</li><li>As a last resort, try pasting in the proof for the law of the excluded middle (see section 4.5). Then use OR elimination on <code>p âˆ¨ Â¬p</code>.</li></ul></li></ol><p>Proofs can be quite challenging. You might follow one approach, get stuck, and not be able to make progress. If this happens, backtrack and follow a different approach. If you are using Logika to verify your work, make sure it does not mark any lines in the proof in red â€“ this means that you&rsquo;ve made an invalid conclusion along the way, or that your justification for a particular line doesn&rsquo;t follow the expected format. Try to fix these errors before continuing on with the proof.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=theorems>Theorems</h1><h2 id=definition>Definition</h2><p>A <em>theorem</em> in propositional logic is something that is always true with no need for premises. The truth table for a theorem is always a <em>tautology</em> &ndash; it is true for any truth assignment.</p><p>To express a theorem as a sequent, we write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ (theorem)</span></span></code></pre></div><p>This shows that we are trying to prove our theorem with NO premises. Such a proof will always immediately begin with a subproof, as there are no premises to process.</p><h2 id=law-of-the-excluded-middle-revisited>Law of the excluded middle, revisited</h2><p>For example, the law of the excluded middle (LEM), <code>p âˆ¨ Â¬p</code>, is a theorem. We proved in section 4.5 that <code>p âˆ¨ Â¬p</code> is always true with no premises:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ (p âˆ¨ Â¬p)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 SubProof(
</span></span><span style=display:flex><span>            2 Assume(  Â¬(p âˆ¨ Â¬p)  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            3 SubProof(
</span></span><span style=display:flex><span>                4 Assume(  p  ),
</span></span><span style=display:flex><span>                5 (     p âˆ¨ Â¬ p         )   by OrI1(4),
</span></span><span style=display:flex><span>                6 (     F               )   by NegE(5, 2)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            7 (     Â¬p                  )   by NotI(3),
</span></span><span style=display:flex><span>            8 (     p âˆ¨ Â¬p              )   by OrI2(7),
</span></span><span style=display:flex><span>            9 (     F                   )   By NegE(8, 2)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        10 (        p âˆ¨ Â¬p              )   By PbC(1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We also see that the truth table for LEM is a tautology:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>p # p âˆ¨ Â¬p
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>T #   T F
</span></span><span style=display:flex><span>F #   T T
</span></span><span style=display:flex><span>-------------
</span></span><span style=display:flex><span>Tautology</span></span></code></pre></div><h2 id=another-example>Another example</h2><p>Suppose we wish to prove the following theorem of propositional logic:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)</span></span></code></pre></div><p>We would need to prove the sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ ((p â†’ q) â†’ ((Â¬p â†’ q) â†’ q))</span></span></code></pre></div><p>We see that the top-level operator of what we are trying to prove is an implies operator. So, we begin our proof using the strategy for implies introduction:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ ((p â†’ q) â†’ ((Â¬p â†’ q) â†’ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 SubProof(
</span></span><span style=display:flex><span>            2 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: reach (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Inside subproof 1, we are trying to prove <code>(Â¬p â†’ q) â†’ q</code>. The top-level operator of that statement is an implies, so we nest another subproof with the goal of using implies introduction:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ ((p â†’ q) â†’ ((Â¬p â†’ q) â†’ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 SubProof(
</span></span><span style=display:flex><span>            2 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            3 SubProof(
</span></span><span style=display:flex><span>                4 Assume(  Â¬p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //goal: reach q
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //use ImplyI to conclude (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: reach (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Now we must prove <code>q</code> in subproof 3. We have available propositions <code>p â†’ q</code> and <code>Â¬p â†’ q</code> &ndash; we can see that if we had LEM (<code>p âˆ¨ Â¬p</code>) available, then we could use OR elimination to get our <code>q</code> in both cases. We insert the LEM proof into subproof 3:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ ((p â†’ q) â†’ ((Â¬p â†’ q) â†’ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 SubProof(
</span></span><span style=display:flex><span>            2 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            3 SubProof(
</span></span><span style=display:flex><span>                4 Assume(  Â¬p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //Begin LEM proof, p âˆ¨ Â¬p
</span></span><span style=display:flex><span>                5 SubProof(
</span></span><span style=display:flex><span>                    6 Assume(  Â¬(p âˆ¨ Â¬p)  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    7 SubProof(
</span></span><span style=display:flex><span>                        8 Assume(  p  ),
</span></span><span style=display:flex><span>                        9 (     p âˆ¨ Â¬ p             )   by OrI1(8),
</span></span><span style=display:flex><span>                        10 (    F                   )   by NegE(9, 6)
</span></span><span style=display:flex><span>                    ),
</span></span><span style=display:flex><span>                    11 (        Â¬p                  )   by NotI(7),
</span></span><span style=display:flex><span>                    12 (        p âˆ¨ Â¬p              )   by OrI2(11),
</span></span><span style=display:flex><span>                    13 (        F                   )   By NegE(12, 4)
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                14 (        p âˆ¨ Â¬p                  )   By PbC(5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //End LEM proof for p âˆ¨ Â¬p
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //goal: reach q
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //use ImplyI to conclude (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: reach (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Finally, we do OR elimination with <code>p âˆ¨ Â¬p</code> and tie together the rest of the proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âŠ¢ ((p â†’ q) â†’ ((Â¬p â†’ q) â†’ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 SubProof(
</span></span><span style=display:flex><span>            2 Assume(  p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            3 SubProof(
</span></span><span style=display:flex><span>                4 Assume(  Â¬p â†’ q  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //Begin LEM proof, p âˆ¨ Â¬p
</span></span><span style=display:flex><span>                5 SubProof(
</span></span><span style=display:flex><span>                    6 Assume(  Â¬(p âˆ¨ Â¬p)  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    7 SubProof(
</span></span><span style=display:flex><span>                        8 Assume(  p  ),
</span></span><span style=display:flex><span>                        9 (     p âˆ¨ Â¬ p             )   by OrI1(8),
</span></span><span style=display:flex><span>                        10 (    F                   )   by NegE(9, 6)
</span></span><span style=display:flex><span>                    ),
</span></span><span style=display:flex><span>                    11 (        Â¬p                  )   by NotI(7),
</span></span><span style=display:flex><span>                    12 (        p âˆ¨ Â¬p              )   by OrI2(11),
</span></span><span style=display:flex><span>                    13 (        F                   )   By NegE(12, 4)
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                14 (        p âˆ¨ Â¬p                  )   By PbC(5),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //End LEM proof for p âˆ¨ Â¬p
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //use OR elimination on p âˆ¨ Â¬p, try to reach q
</span></span><span style=display:flex><span>                15 SubProof(
</span></span><span style=display:flex><span>                    16 Assume(  p  ),
</span></span><span style=display:flex><span>                    17 (        q               )   By ImplyE(2, 16)
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                18 SubProof(
</span></span><span style=display:flex><span>                    19 Assume(  Â¬p  ),
</span></span><span style=display:flex><span>                    20 (        q               )   By ImplyE(4, 19)
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                21 (        q                   )   By OrE(14, 15, 18)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                //goal: reach q
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //use ImplyI to conclude (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>            22 (        (Â¬p â†’ q) â†’ q            )   By ImplyI(3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //goal: reach (Â¬p â†’ q) â†’ q
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use ImplyI to conclude (p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        23 (        (p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)    )   By ImplyI(1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>If we complete a truth table for <code>(p â†’ q) â†’ ((Â¬p â†’ q) â†’ q)</code>, we also see that it is a tautology:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>               *
</span></span><span style=display:flex><span>-----------------------------------
</span></span><span style=display:flex><span>p q # (p â†’: q) â†’: ((Â¬p â†’: q) â†’: q)
</span></span><span style=display:flex><span>-----------------------------------
</span></span><span style=display:flex><span>T T #    T     T    F  T     T
</span></span><span style=display:flex><span>T F #    F     T    F  T     F
</span></span><span style=display:flex><span>F T #    T     T    T  T     T
</span></span><span style=display:flex><span>F F #    T     T    T  F     T
</span></span><span style=display:flex><span>----------------------------------
</span></span><span style=display:flex><span>Tautology</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=equivalence>Equivalence</h1><p>In this section, we will revisit the notion of equivalence. In chapter 2, we saw how we could use truth tables to show that two logical formulae are equivalent. Here, we will see that we can also show they are equivalent using our natural deduction proof rules.</p><h2 id=semantic-equivalence>Semantic equivalence</h2><p>We saw in section 2.4 that two (or more) logical statements <code>S1</code> and <code>S2</code> were said to be <em>semantically equivalent</em> if and only if:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>S1 âŠ¨ S2</span></span></code></pre></div><p>and</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>S2 âŠ¨ S1</span></span></code></pre></div><p>As a reminder, the <code>S1 âŠ¨ S2</code> means <em><code>S1</code> semantically entails <code>S2</code></em>, which means that every truth assignment that satisfies <code>S1</code> also satisfies <code>S2</code>.</p><p>Semantic equivalence between <code>S1</code> and <code>S2</code> means that each proposition semantically entails the other &ndash; that <code>S1</code> and <code>S2</code> have the same truth value for every truth assignment; i.e., their truth tables evaluate exactly the same.</p><h3 id=showing-semantic-equivalence-with-two-truth-tables>Showing semantic equivalence with two truth tables</h3><p>For example, if we wished to show that the propositions <code>p â†’ Â¬q</code> and <code>Â¬ (p âˆ§ q)</code> were semantically equivalent, then we could create truth tables for each proposition:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>        *
</span></span><span style=display:flex><span>--------------
</span></span><span style=display:flex><span>p q # p â†’: Â¬q
</span></span><span style=display:flex><span>--------------
</span></span><span style=display:flex><span>T T #   F  F
</span></span><span style=display:flex><span>T F #   T  T
</span></span><span style=display:flex><span>F T #   T  F
</span></span><span style=display:flex><span>F F #   T  T
</span></span><span style=display:flex><span>--------------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T F] [F T] [F F]
</span></span><span style=display:flex><span>F: [T T]</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>----------------
</span></span><span style=display:flex><span>p q # Â¬(p âˆ§ q)
</span></span><span style=display:flex><span>----------------
</span></span><span style=display:flex><span>T T # F   T
</span></span><span style=display:flex><span>T F # T   F
</span></span><span style=display:flex><span>F T # T   F
</span></span><span style=display:flex><span>F F # T   F
</span></span><span style=display:flex><span>----------------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T F] [F T] [F F]
</span></span><span style=display:flex><span>F: [T T]</span></span></code></pre></div><p>We see that the same set of truth assignments, <code>[T F] [F T] [F F]</code>, satisfies both <code>p â†’: Â¬q</code> and <code>Â¬(p âˆ§ q)</code>.</p><h3 id=showing-semantic-equivalence-with-one-truth-table>Showing semantic equivalence with one truth table</h3><p>To show that propositions <code>S1</code> and <code>S2</code> are semantically equivalent, we need to show that if <code>S1</code> is true, then so is <code>S2</code>, and that if <code>S2</code> is true, then so is <code>S1</code>. Instead of comparing the truth tables of both <code>S1</code> and <code>S2</code>, we could instead express our requirements as a bi-implication: <code>S1 â†” S2</code>. To express a bi-implication operator, we can use a conjunction of two implications: <code>(S1 â†’ S2) âˆ§ (S2 â†’ S1)</code>. If this conjunction is a tautology, then we know that if one proposition is true, then the other one is too &ndash; that <code>S1</code> and <code>S2</code> are semantically equivalent.</p><p>Below, we show that <code>p â†’: Â¬q</code> and <code>Â¬(p âˆ§ q)</code> are semantically equivalent using one truth table:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                              *
</span></span><span style=display:flex><span>-------------------------------------------------------
</span></span><span style=display:flex><span>p q # ((p â†’: Â¬q) â†’: Â¬(p âˆ§ q)) âˆ§ (Â¬(p âˆ§ q) â†’: (p â†’: Â¬q))
</span></span><span style=display:flex><span>-------------------------------------------------------
</span></span><span style=display:flex><span>T T #     F  F    T F   T     T  F   T    T     F  F 
</span></span><span style=display:flex><span>T F #     T  T    T T   F     T  T   F    T     T  T
</span></span><span style=display:flex><span>F T #     T  F    T T   F     T  T   F    T     T  F
</span></span><span style=display:flex><span>F F #     T  T    T T   F     T  T   F    T     T  T
</span></span><span style=display:flex><span>-------------------------------------------------------
</span></span><span style=display:flex><span>Tautology</span></span></code></pre></div><h2 id=provable-equivalence>Provable equivalence</h2><p>Two propositional logic statements <code>S1</code> and <code>S2</code> are <em>provably equivalent</em> if and only if we can prove both of the following sequents:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(S1) âŠ¢ (S2)</span></span></code></pre></div><p>and</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(S2) âŠ¢ (S1)</span></span></code></pre></div><p>We can also write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(S2) âŸ› (S1)</span></span></code></pre></div><p>For example, suppose we wish to show that the propositions <code>p â†’ Â¬q</code> and <code>Â¬(p âˆ§ q)</code> are provably equivalent. We must prove the following sequents:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ Â¬q) âŠ¢ (Â¬(p âˆ§ q))</span></span></code></pre></div><p>and</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬(p âˆ§ q)) âŠ¢ (p â†’ Â¬q)</span></span></code></pre></div><p>We complete both proofs below:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p â†’ Â¬q) âŠ¢ (Â¬(p âˆ§ q))
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     p â†’ Â¬q      )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume(  p âˆ§ q  ),
</span></span><span style=display:flex><span>            4 (     p       )   by AndE1(3),
</span></span><span style=display:flex><span>            5 (     q       )   by AndE2(3),
</span></span><span style=display:flex><span>            6 (     Â¬q      )   by ImplyE(1, 4),
</span></span><span style=display:flex><span>            7 (     F       )   by NegE(5, 6)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        8 (     Â¬(p âˆ§ q)    )   by NegI(2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(Â¬(p âˆ§ q)) âŠ¢ (p â†’ Â¬q)
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     Â¬(p âˆ§ q)            )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        2 SubProof(
</span></span><span style=display:flex><span>            3 Assume (  p  ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            4 SubProof(
</span></span><span style=display:flex><span>                5 Assume(  q  ),
</span></span><span style=display:flex><span>                6 (     p âˆ§ q       )   by AndI(3, 5),
</span></span><span style=display:flex><span>                7 (     F           )   by NegE(6, 1)
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            8 (     Â¬q              )   by NegI(4)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        9 (     p â†’ Â¬q              )   by ImplyI(2)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=soundness-and-completeness>Soundness and Completeness</h1><p>Section 4.8 showed us that we can prove two statements are <em>semantically equivalent</em> with truth tables and <em>provably equivalent</em> with deduction proofs. Does it matter which approach we use? Will there ever be a time when two statements are semantically equivalent but not provably equivalent, or vice versa? Will there ever be a time when a set of premises semantically entails a conclusion, but that the premises do not prove (using our deduction proofs) the conclusion, or vice versa?</p><p>These questions lead us to the notions of <em>soundness</em> and <em>completeness</em>. Formal treatment of both concepts is beyond the scope of this course, but we will introduce both definitions and a rough idea of the proofs of soundness and completeness in propositional logic.</p><h2 id=soundness>Soundness</h2><p>A proof system is <em>sound</em> if everything that is provable is actually true. Propositional logic is sound if when we use deduction rules to prove that <code>(P1, P2, ..., Pn) âŠ¢ (C)</code> (that a set of premises proves a conclusion) then we can also use a truth table to show that <code>P1, P2, ..., Pn âŠ¨ C</code> (that a set of premises semantically entails a conclusion).</p><p><strong>Propositional logic is, in fact, sound.</strong></p><p>To get an idea of the proof, consider the <code>AndE1</code> deduction rule. It allows us to directly prove:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(P âˆ§ Q) âŠ¢ (P)</span></span></code></pre></div><p>I.e., if we have <code>P âˆ§ Q</code> as a premise or as a claim in part of a proof, then we can use <code>AndE1</code> to conclude <code>P</code>. We must also show that:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>P âˆ§ Q âŠ¨ P</span></span></code></pre></div><p>I.e., that any time <code>P âˆ§ Q</code> is true in a truth table, then <code>P</code> is also true. And of course, we can examine the truth table for <code>P âˆ§ Q</code>, and see that it is only true in the cases that <code>P</code> is also true.</p><p>Consider the <code>AndI</code> deduction rule next. It allows us to directly prove:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(P, Q) âŠ¢ (P âˆ§ Q)</span></span></code></pre></div><p>I.e., if we have both <code>P</code> and <code>Q</code> as premises or claims in part of a proof, then we can use <code>AndI</code> to conclude <code>P âˆ§ Q</code>. We must also show that:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>P, Q âŠ¨ P âˆ§ Q</span></span></code></pre></div><p>I.e., that any time both <code>P</code> and <code>Q</code> are true in a truth table, then <code>P âˆ§ Q</code> is also true. And of course, we can examine the truth table for <code>P âˆ§ Q</code> and see that whenever <code>P</code> and <code>Q</code> are true, then <code>P âˆ§ Q</code> is also true.</p><p>To complete the soundness proof, we would need to examine the rest of our deduction rules in a similar process. We would then use an approach called <em>mathematical induction</em> (which we will see for other applications in Chapter 7) to extend the idea to a proof that applies multiple deduction rules in a row.</p><h2 id=completeness>Completeness</h2><p>A proof system is <em>complete</em> if everything that is true can be proved. Propositional logic is complete if when we can use a truth table to show that <code>P1, P2, ..., Pn âŠ¨ C</code>, then we can also use deduction rules to prove that <code>(P1, P2, ..., Pn) âŠ¢ (C)</code>.</p><p><strong>Propositional logic is also complete.</strong></p><p>We assume that <code>P1, P2, ..., Pn âŠ¨ C</code>, and we consider the truth table for <code>(P1 âˆ§ P2 âˆ§ ... âˆ§ Pn) â†’ C</code> (since that will be a tautology whenever <code>P1, P2, ..., Pn âŠ¨ C</code>). In order to show propositional logic is complete, we must show that we can use our deduction rules to prove <code>(P1, P2, ..., Pn) âŠ¢ (C)</code>.</p><p>The idea is to use LEM for each propositional atom <code>A</code> to obtain <code>A âˆ¨ Â¬A</code> (corresponding to the truth assignments in the <code>(P1 âˆ§ P2 âˆ§ ... âˆ§ Pn) â†’ C</code> truth table). We then use OR elimination on each combination of truth assignments, with separate cases for each logical operator being used.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=predicate-logic-translations>Predicate Logic Translations</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Predicate Logic Translations</h1><article class=default><header class=headline></header><h1 id=motivation>Motivation</h1><p>In this chapter, we will learn to further decompose statements in terms of their verbs (called <em>predicates</em>) and their nouns (called <em>individuals</em>). This leads to <em>predicate logic</em> (also called <em>first-order logic</em>).</p><p>As a motivation of why we want more expressive power, suppose we wanted to translate the following statements to propositional logic:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>All humans are mortal.
</span></span><span style=display:flex><span>Socrates is a human.
</span></span><span style=display:flex><span>Socrates is mortal.</span></span></code></pre></div><p>Unfortunately, each statement would be a propositional atom:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p: All humans are mortal.
</span></span><span style=display:flex><span>q: Socrates is a human.
</span></span><span style=display:flex><span>r: Socrates is mortal.</span></span></code></pre></div><p>But what if we wanted to prove that given the premises: &ldquo;All humans are mortal&rdquo; and &ldquo;Socrates is a human&rdquo;, that the conclusion &ldquo;Socrates is mortal&rdquo; naturally followed? This logical argument makes sense &ndash; Socrates is a human, and all such individuals are supposed to be mortal, so it should follow that Socrates is mortal. If we tried to write such a proof in propositional logic, though, we would have the sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>p, q âŠ¢ r</span></span></code></pre></div><p>&mldr;and we clearly don&rsquo;t have enough information to complete this proof.</p><p>We need a richer language, which we will get with predicate logic.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=syntax>Syntax</h1><p>In this section, we will examine the syntax for translating English sentences to predicate logic. We will still create propositions (statements that are either true or false) using logical connectives (<code>âˆ§</code>, <code>âˆ¨</code>, <code>â†’</code>, and <code>Â¬</code>), but now we will identify the following from our English sentences</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>predicates: these will be the verbs in the sentences
</span></span><span style=display:flex><span>individuals: these will be the nouns in the sentences
</span></span><span style=display:flex><span>quantifiers: these will help us specify if we mean all individuals or at least one individual</span></span></code></pre></div><h2 id=domains>Domains</h2><p>Predicate logic involves expressing truth about a set of individuals. But the same statement might be true for one group of individuals, but false for others. Thus, we first need to consider which set of individuals we are discussing &ndash; called the <strong>domain</strong>.</p><p>A domain might be the set of all humans, the set of all animals, the set of all college classes, etc.</p><h2 id=individuals>Individuals</h2><p>An <strong>individual</strong> is an element within a specified domain. For example, if our domain is the set of all people, then <code>Bob</code> might be a particular individual. If our domain is the set of all college classes, then <code>CIS301</code> might be a particular individual.</p><h2 id=predicates>Predicates</h2><p>A <strong>predicate</strong> is a function that returns a boolean. It can have one or many parameters, each of which are individuals in a particular domain. A predicate will describe a characteristic of an individual or a comparison between multiple individuals.</p><p>For example, suppose our domain is the set of people. Suppose <code>Alice</code>, <code>Bob</code>, and <code>Carla</code> are individuals in our domain. <code>Alice</code> is <code>Bob</code>&rsquo;s mother, and <code>Carla</code> is an unrelated individual. <code>Carla</code> is 5'10 and 20 years old, <code>Alice</code> is 5'5 and 35 years old, and <code>Bob</code> is 4'10 and 10 years old.</p><p>Suppose we have the predicates:</p><ul><li><code>isAdult(person)</code> - returns whether <code>person</code> is an adult</li><li><code>isMotherOf(person1, person2)</code> - returns whether <code>person1</code> is the mother of <code>person2</code></li><li><code>isTallerThan(person1, person2)</code> - returns whether <code>person1</code> is taller than <code>person2</code></li></ul><p>Using our individuals above, we would have that:</p><ul><li><code>isAdult(Alice)</code> is true, since <code>Alice</code> is 35 years old</li><li><code>isAdult(Bob)</code> is false, since <code>Bob</code> is 10 years old</li><li><code>isMotherOf(Alice, Bob)</code> is true, since <code>Alice</code> is <code>Bob</code>&rsquo;s mother</li><li><code>isMotherOf(Carla, Bob)</code> is false, since <code>Carla</code> is not <code>Bob</code>&rsquo;s mother</li><li><code>isTallerThan(Carla, Alice)</code> is true, since <code>Carla</code> is 5'10 and <code>Alice</code> is 5'5.</li></ul><h2 id=quantifiers>Quantifiers</h2><p>We will introduce two <strong>quantifiers</strong> in predicate logic, which help us make claims about a domain of individuals.</p><h3 id=universal-quantifier>Universal quantifier</h3><p>The <code>âˆ€</code> quantifier, called the <strong>universal quantifier</strong> and read as <em>for all</em>, lets us write propositions that pertain to ALL individuals in a domain.</p><p><code>âˆ€ n P(n)</code> means: for every individual <code>n</code> (in some domain), <code>P(n)</code> is true. Here, <code>n</code> is a variable that stands for a particular individual in the domain. You can think of it like a foreach loop in C#:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>foreach(type n in domain)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    //P(n) is true every time
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>where <code>n</code> is initially the first individual in the domain, then <code>n</code> is the second individual in the domain, etc.</p><h3 id=existential-quantifier>Existential quantifier</h3><p>The <code>âˆƒ</code> quantifier, called the <strong>existential quantifier</strong> and read as <em>there exists</em>, lets us write propositions that pertain to AT LEAST ONE individual in a domain.</p><p><code>âˆƒ n P(n)</code> means: there exists at least one individual <code>n</code> (in some domain) where <code>P(n)</code> is true. You can again think of it as a foreach loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>foreach(type n in domain)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    //we can find at least one time where P(n) is true
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=universal-quantifier-example>Universal quantifier example</h3><p>For example, suppose our domain is all candy bars, and that we have the predicate <code>isSweet(bar)</code>, which returns whether <code>bar</code> is sweet. We might write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x isSweet(x)</span></span></code></pre></div><p>Which we would read as: <em>for all candy bars x, x is sweet</em>, or, more compactly, as: <em>all candy bars are sweet</em>.</p><h3 id=existential-quantifier-example>Existential quantifier example</h3><p>If instead we wrote:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x isSweet(x)</span></span></code></pre></div><p>We would read it as: <em>there exists at least one candy bar x where x is sweet</em>, or, more compactly, as <em>there exists at least one sweet candy bar</em>.</p><h2 id=early-examples>Early examples</h2><p>Suppose our domain is animals, and that we have the following two predicates:</p><ul><li><code>isDog(x)</code>: whether animal x is a dog</li><li><code>hasFourLegs(x)</code>: whether animal x has four legs</li></ul><p>Let&rsquo;s consider what several predicate logic statements would mean in words:</p><ul><li><code>âˆ€ x isDog(x)</code> - translates to: <em>All animals are dogs</em>. This means that EVERY SINGLE ANIMAL in my domain is a dog (which is probably unlikely).</li><li><code>âˆƒ x hasFourLegs(x)</code> - translates to: <em>There exists at least one animal that has four legs.</em></li></ul><p>Next, consider the following proposition:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x (isDog(x) âˆ§ hasFourLegs(x))</span></span></code></pre></div><p>This translates to: <em>All animals are dogs and have four legs</em>. This means that EVERY SINGLE ANIMAL in my domain is a dog and also has four legs. While it is possible that this is true depending on our domain, it is unlikely. What if our domain of animals included cats, chickens, etc.?</p><p>Perhaps instead we intended to say: <em>All dogs have four legs.</em> Another way to phrase this is, &ldquo;For all animals, IF that animal is a dog, THEN it has four legs.&rdquo; We can see from the IF&mldr;THEN that we will need to use an implies statement. Here is the correct translation for <em>All dogs have four legs</em>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x (isDog(x) â†’ hasFourLegs(x))</span></span></code></pre></div><p>We will usually want to use the <code>â†’</code> operator instead of the <code>âˆ§</code> operator when making a claim about ALL individuals.</p><p>Finally, consider this proposition:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x (isDog(x) â†’ hasFourLegs(x))</span></span></code></pre></div><p>This translates to: <em>There exists an animal x, and if that animal is a dog, then it has four legs.</em> Recall that an implies statement <code>pâ†’q</code> is true whenever <code>p</code> and <code>q</code> are both true AND whenever <code>p</code> is false. So this claim is true in two cases:</p><ul><li>If our domain includes a dog that has four legs</li><li>If our domain includes an animal that is not a dog</li></ul><p>We likely only meant to include the first case. In that case, we would want to say, <em>There exists a dog that has four legs</em> &ndash; here is that translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x (isDog(x) âˆ§ hasFourLegs(x))</span></span></code></pre></div><p>We will usually want to use the <code>âˆ§</code> operator instead of the <code>â†’</code> operator when writing a proposition about one/some individuals.</p><h2 id=predicates-from-math>Predicates from math</h2><p>All of our examples in this section involved predicates over domains like people, animals, or living things. A different domain that we are used to working with is some set of numbers: the integers, the positive numbers, the rational numbers, etc.</p><p>Perhaps our domain is the set of all integers. Then <code>>=</code> is a predicate with two parameters &ndash; <code>x >= y</code> is defined as whether <code>x</code> is greater than or equal to <code>y</code>, for two integers <code>x</code> and <code>y</code>. We might write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x (x + 1 &gt;= x)</span></span></code></pre></div><p>Because for all integers, <code>x + 1</code> is greater than or equal to <code>x</code>. We might also write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x (x &gt;= x * x * x)</span></span></code></pre></div><p>Because -4 >= -4 * -4 * -4, i.e., -4 >= -64. The same is true for any negative number.</p><p>Other common predicates in math are: <code>&lt;</code>, <code>></code>, <code>&lt;=</code>, <code>==</code>, and <code>!=</code>.</p><h2 id=quantifier-symbols>Quantifier symbols</h2><p>The official symbol for the universal quantifier (&ldquo;for all&rdquo;) is an upside-down A, like this: <code>âˆ€</code>. You are welcome to substitute either a capital <code>A</code>, or with the word <code>all</code> or <code>forall</code>. This will be especially handy when we reach Chapter 6 on writing proofs in predicate logic.</p><p>The official symbol for the existential quantifier (&ldquo;there exists&rdquo;) is a backwards E, like this: <code>âˆƒ</code>. You are welcome to substitute either a capital <code>E</code>, or with the word <code>some</code> or <code>exists</code>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=single-quantifier>Single Quantifier</h1><p>In this section, we will see how to translate simpler statements between English to predicate logic. These translations will involve a single quantifier.</p><h2 id=example-predicate-logic-to-english>Example: Predicate logic to English</h2><p>Suppose our domain is animals and that we have the following two predicates:</p><ul><li><code>isMouse(x)</code>: whether animal <code>x</code> is a mouse</li><li><code>inHouse(x)</code>: whether animal <code>x</code> is in the house</li></ul><p>Suppose we also have that <code>Squeaky</code> is an individual in our domain.</p><p>We will practice translating from predicate logic to English. Think about what the following propositions mean, and click to reveal each answer:</p><ul><li><p><code>isMouse(Squeaky) âˆ§ Â¬inHouse(Squeaky)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "Squeaky is a mouse, and Squeaky is not in the house."</details><br></li></ul></li><li><p><code>âˆƒ x isMouse(x)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "There is a mouse".</details><br></li></ul></li><li><p><code>Â¬(âˆƒ x isMouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "There is not a mouse."</details><br></li></ul></li><li><p><code>âˆƒ x Â¬isMouse(x)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "There is an animal that is not a mouse".</details><br></li></ul></li><li><p><code>âˆ€ x isMouse(x)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "All animals are mice."</details><br></li></ul></li><li><p><code>Â¬(âˆ€ x isMouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "Not all animals are mice."</details><br></li></ul></li><li><p><code>âˆ€ x Â¬isMouse(x)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "All animals are not mice."</details><br></li></ul></li><li><p><code>âˆ€ x (isMouse(x) â†’ inHouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "All mice are in the house."</details><br></li></ul></li><li><p><code>âˆ€ x (isMouse(x) âˆ§ inHouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "Every animal is a mouse and is in the house." (We usually don't want âˆ§ with âˆ€.)</details><br></li></ul></li><li><p><code>Â¬(âˆ€ x (isMouse(x) â†’ inHouse(x)))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "Not all mice are in the house."</details><br></li></ul></li><li><p><code>âˆ€ x (inHouse(x) â†’ isMouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "Everything in the house is a mouse."</details><br></li></ul></li><li><p><code>Â¬(âˆ€ x (inHouse(x) â†’ isMouse(x)))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "Not everything in the house is a mouse."</details><br></li></ul></li><li><p><code>âˆƒ x (isMouse(x) âˆ§ inHouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "There is a mouse in the house."</details><br></li></ul></li><li><p><code>âˆƒ x (isMouse(x) â†’ inHouse(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "There exists an animal, and if that animal is a mouse, then it is in the house." Recall that this statement will be true if there is an animal that is NOT a mouse (since the â†’ would be vacuously true) as well as being true if there is a mouse in the house.</details><br></li></ul></li><li><p><code>Â¬(âˆƒ x (isMouse(x) âˆ§ inHouse(x)))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>--> "There is not a mouse in the house."</details><br></li></ul></li></ul><h2 id=translation-guide>Translation guide</h2><p>When translating from English to predicate logic, you can look for particular wording in your sentences to see how to choose a quantifier and/or negation placement. We will also see that certain phrases can be translated multiple (equivalent) ways.</p><ul><li><p><em>Every/all/each/any</em> is translated as: <code>âˆ€ x ...</code></p></li><li><p><em>Some/at least one/there exists/there is</em> is translated as: <code>âˆƒ x ...</code></p></li><li><p><em>None/no/there does not exist</em> can be translated as either <code>Â¬(âˆƒ x ...)</code> or <code>âˆ€ x Â¬(...)</code></p></li><li><p><em>Not every/not all</em> can be translated as either <code>Â¬(âˆ€ x ...)</code> or <code>âˆƒ x Â¬(...)</code></p></li><li><p><em>Some P-ish thing is a Q-ish thing</em> is translated as: <code>âˆƒ x (P(x) âˆ§ Q(x))</code></p></li><li><p><em>All P-ish things are Q-ish things</em> is translated as: <code>âˆ€ x (P(x) â†’ Q(x))</code></p></li><li><p><em>No P-ish thing is a Q-ish thing</em> can be translated as either <code>Â¬(âˆƒ x (P(x) âˆ§ Q(x)))</code> or <code>âˆ€ x (P(x) â†’ Â¬Q(x))</code></p></li><li><p><em>Not all P-ish things are Q-ish things</em> can be translated as either <code>Â¬(âˆ€ x (P(x) â†’ Q(x)))</code> or <code>âˆƒ x (P(x) âˆ§ Â¬Q(x))</code></p></li></ul><h2 id=demorgans-laws-for-quantifiers>DeMorgan&rsquo;s laws for quantifiers</h2><p>In the translation guide above, we saw that we could often translate the same statement two different ways &ndash; one way using an existential quantifier and one way using a universal quantifier. These equivalencies are another iteration of DeMorgan&rsquo;s laws, this time applied to predicate logic.</p><p>Suppose we have some domain, and that <code>P(x)</code> is a predicate for individuals in that domain. DeMorgan&rsquo;s laws give us the following equivalencies:</p><ul><li><code>Â¬(âˆƒ x P(x))</code> is equivalent to <code>âˆ€ x Â¬P(x)</code></li><li><code>Â¬(âˆ€ x P(x))</code> is equivalent to <code>âˆƒ x Â¬P(x)</code></li></ul><p>In Chapter 6, we will learn to prove that these translations are indeed equivalent.</p><h2 id=example-english-to-predicate-logic>Example: English to predicate logic</h2><p>Suppose our domain is people and that we have the following two predicates:</p><ul><li><code>K(x)</code>: whether person <code>x</code> is a kid</li><li><code>M(x)</code>: whether person <code>x</code> likes marshmallows</li></ul><p>We will practice translating from English to predicate logic. Think about what the following sentences mean, and click to reveal each answer:</p><ul><li><em>No kids like marshmallows.</em><ul><li><details><summary><b>Click here for solution</b></summary><p><code>Â¬(âˆƒ x (K(x) âˆ§ M(x))</code>, or equivalently, <code>âˆ€ x (K(x) â†’ Â¬M(x))</code></p></details><br></li></ul></li><li><em>Not all kids like marshmallows.</em><ul><li><details><summary><b>Click here for solution</b></summary><p><code>Â¬(âˆ€ x (K(x) â†’ M(x))</code>, or equivalently, <code>âˆƒ x (K(x) âˆ§ Â¬M(x))</code></p></details><br></li></ul></li><li><em>Everyone who likes marshmallows is a kid.</em><ul><li><details><summary><b>Click here for solution</b></summary><p><code>âˆ€ x (M(x) â†’ K(x))</code></p></details><br></li></ul></li><li><em>Some people who like marshmallows are not kids.</em><ul><li><details><summary><b>Click here for solution</b></summary><p><code>âˆƒ x (M(x) âˆ§ Â¬K(x))</code></p></details><br></li></ul></li><li><em>Some kids don&rsquo;t like marshmallows.</em><ul><li><details><summary><b>Click here for solution</b></summary><p><code>âˆƒ x (K(x) âˆ§ Â¬M(x))</code></p></details><br></li></ul></li><li><em>Anyone who doesn&rsquo;t like marshmallows is not a kid.</em><ul><li><details><summary><b>Click here for solution</b></summary><p><code>âˆ€ x (Â¬M(x) â†’ Â¬K(x))</code></p></details><br></li></ul></li></ul><h2 id=evaluating-predicate-logic-statements-on-a-toy-domain>Evaluating predicate logic statements on a toy domain</h2><p>Suppose we have the following toy domain of people with the following characteristics:</p><ul><li>Bob, age 10, lives in Kansas, has siblings, has brown hair</li><li>Jane, age 25, lives in Delaware, has no siblings, has blonde hair</li><li>Alice, age 66, lives in Kansas, has siblings, has gray hair</li><li>Joe, age 50, lives in Nebraska, has siblings, has black hair</li></ul><p>Now suppose that we have the following predicates for individuals in our domain:</p><ul><li><code>Ad(x)</code>: whether person <code>x</code> is an adult (adults are age 18 and older)</li><li><code>KS(x)</code>: whether person <code>x</code> lives in Kansas</li><li><code>Sib(x)</code>: whether person <code>x</code> has siblings</li><li><code>Red(x)</code>: whether person <code>x</code> has red hair</li></ul><p>We will practice evaluating predicate logic statements on our domain of people. Think about whether the following propositions would be true or false over our domain, and then click to reveal each answer:</p><ul><li><p><code>âˆ€ x Ad(x)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "All people are adults". This is false for our domain, as we have one person (Bob) who is not an adult.</details><br></li></ul></li><li><p><code>âˆ€ x Â¬Ad(x)</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "All people are not adults". This is false for our domain, as we have three people (Jane, Alice, and Joe) are are adults.</details><br></li></ul></li><li><p><code>Â¬(âˆ€ x Ad(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "Not all people are adults". This is true for our domain, as we can find a person (Bob) who is not an adult.</details><br></li></ul></li><li><p><code>âˆ€ x (KS(x) â†’ Sib(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "Everyone who lives in Kansas has siblings". This is true for our domain, as we have two people who live in Kansas (Bob and Alice), and both of them have siblings.</details><br></li></ul></li><li><p><code>âˆƒ x (Â¬KS(x) âˆ§ Sib(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "There is a person who doesn't live in Kansas and has siblings". This is true for our domain, as Joe lives in Nebraska and has siblings.</details><br></li></ul></li><li><p><code>Â¬(âˆƒ x (KS(x) âˆ§ Â¬Ad(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "There does not exist a person who lives in Kansas and is not an adult". This is false for our domain, as Bob lives in Kansas and is not an adult.<br></li></ul></li><li><p><code>Â¬(âˆƒ x (Sib(x) âˆ§ Red(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "There does not exist a person with siblings who has red hair". This is true for our domain, as no one with siblings (Bob, Alice, or Joe) has red hair.<br></li></ul></li><li><p><code>âˆ€ x (Red(x) â†’ Sib(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "All people with red hair have siblings". This is true for our domain, as no one has red hair. This means that the implies statement is vacuously true for every person (since `Red(x)` is false for each person), which makes the overall proposition true.<br></li></ul></li><li><p><code>âˆ€ x (KS(x) âˆ¨ Sib(x))</code></p><ul><li><details><summary><b>Click here for solution</b></summary>This proposition translates as, "Everyone lives in Kansas and/or has siblings". This is false for our domain -- there is one person, Jane, who doesn't live in Kansas and also doesn't have siblings.<br></li></ul></li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=multiple-quantifiers>Multiple Quantifiers</h1><p>Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:</p><ul><li>Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers)</li><li>Translations that mix quantifiers</li></ul><p>In many of the sections, we will using the predicates below (which are over the domain of shapes):</p><ul><li><code>isCircle(x)</code> - whether shape x is a circle</li><li><code>isSquare(x)</code> - whether shape x is a square</li><li><code>isRectangle(x)</code> - whether shape x is a rectangle</li><li><code>biggerThan(x, y)</code> - whether shape x is bigger than shape y</li></ul><h2 id=several-of-the-same-quantifier>Several of the same quantifier</h2><p>First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements &ndash; either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested).</p><h3 id=prenex-form>Prenex form</h3><p>The <em>prenex form</em> of a predicate logic translation lists all the quantifiers at the beginning of the statement. This is only recommended when all the quantifiers are the same type &ndash; either all universal or all existential.</p><h4 id=prenex-example-1>Prenex example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em>. Here, we are making three claims:</p><ul><li>There exists a shape that is a circle</li><li>There exists a shape that is a square</li><li>The shape that is a circle is bigger than the shape that is a square</li></ul><p>With that in mind, we can see that we will use two existential quantifiers. We can translate the statement as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x âˆƒ y (isCircle(x) âˆ§ isSquare(y) âˆ§ biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where x is a circle, y is a square, and x (which is a circle) is bigger than y (which is a square).</em></p><p>Equivalently, we could have written:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x âˆƒ y (isCircle(y) âˆ§ isSquare(x) âˆ§ biggerThan(y, x))</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where y is a circle, x is a square, and y (which is a circle) is bigger than x (which is a square).</em></p><h4 id=prenex-example-2>Prenex example 2</h4><p>Next, suppose we wished to translate: <em>Every circle is bigger than all squares</em>. Again, we are quantifying two things &ndash; ALL circles and also ALL squares. We can see that we will need to use two universal quantifiers. We can translate the statement as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x âˆ€ y ((isCircle(x) âˆ§ isSquare(y)) â†’ biggerThan(x, y))</span></span></code></pre></div><p>Which reads: <em>For each combination (x, y) of shapes, if x is a circle and y is a square, then x (which is a circle) is bigger than y (which is a square).</em></p><h3 id=aristotelian-form>Aristotelian form</h3><p>The <em>Aristotelian form</em> of a predicate logic translation embeds the quantifiers within the translation. This format is possible for any kind of translation &ndash; whether the quantifiers are all the same type or mixed types.</p><h4 id=aristotelian-form-example-1>Aristotelian form example 1</h4><p>Suppose we wished to translate, <em>Some circle is bigger than some square</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x (isCircle(x) âˆ§ (âˆƒ y (isSquare(y) âˆ§ biggerThan(x, y)))</span></span></code></pre></div><p>Which reads as: <em>There exists a shape x that is a circle and there exists a shape y that is a square, and x (which is a circle) is bigger than y (which is a square)</em>.</p><h4 id=aristotelian-form-example-2>Aristotelian form example 2</h4><p>Let&rsquo;s repeat our translation for, <em>Every circle is bigger than all rectangles</em> using Aristotelian form. We know that we will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p><p>We can translate the statement using Aristotelian form as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x (isCircle(x) â†’ (âˆ€ y (isSquare(y) â†’ biggerThan(x, y))))</span></span></code></pre></div><p>Which reads as: <em>For every shape x, if x is a circle, then for every shape y, if y is s square, then x (which is a circle) is bigger than y (which is a square).</em></p><h2 id=mixed-quantifiers>Mixed quantifiers</h2><p>Now, we will turn to examples that mix universal and existential quantifiers. We will see below that quantifier order matters in this case, so it is safest to translate such statements using embedded quantifiers. The embedded form can be tricky to write, so we will see a way to systematically translate any statement that needs multiple quantifiers into predicate logic (using Aristotelian form).</p><h3 id=systematic-translation>Systematic translation</h3><p>Suppose we wish to translate, <em>Every circle is bigger than at least one square</em>. We see that we are first making a claim about all circles. Without worrying about the rest of the statement, we know that for all circles, we are saying <em>something</em>. So we write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>For all circles, SOMETHING</span></span></code></pre></div><p>Trying to formalize a bit more, we assign a variable to the current circle we are describing (<code>x</code>). For each circle x, we are saying <em>something</em> about that circle. So we express SOMETHING(x) as some claim about our current circle, and write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>For each circle x, SOMETHING(x)</span></span></code></pre></div><p>We see that we will need a universal quantifier since we are talking about ALL circles, and we also follow the guide of using an implies statement to work with a for-all statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x (isCircle(x) â†’ SOMETHING(x))</span></span></code></pre></div><p>Next, we describe what <code>SOMETHING(x)</code> means for a particular circle, <code>x</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOMETHING(x): x is bigger than at least one square</span></span></code></pre></div><p>Trying to formalize a bit more about the square, we write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOMETHING(x): There exists a square y, and x is bigger than y</span></span></code></pre></div><p>Now we can use an existential quantifier to describe our square, and plug in our isSquare and biggerThan predicates to have a translation for SOMETHING(x):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>SOMETHING(x): âˆƒ y (isSquare(y) âˆ§ biggerThan(x, y))</span></span></code></pre></div><p>Now, we can plug SOMETHING(x) into our first partial translation, <code>âˆ€ x (isCircle(x) â†’ SOMETHING(x))</code>. The complete translation for <em>Every circle is bigger than at least one square</em> is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x (isCircle(x) â†’ (âˆƒ y (isSquare(y) âˆ§ biggerThan(x, y))))</span></span></code></pre></div><h3 id=follow-up-examples>Follow-up examples</h3><p>In these examples, suppose our domain is animals and that we have the following predicates:</p><ul><li><code>El(x)</code>: whether animal x is an elephant</li><li><code>Hi(x)</code>: whether animal x is a hippo</li><li><code>W(x, y)</code>: whether animal x weighs more than animal y</li></ul><p>Suppose we wish to translate: <em>There is exactly one hippo.</em> We might first try saying: <code>âˆƒ x Hi(x)</code>. But this proposition would be true even if we had 100 hippos, so we need something more restricted. What we are really trying to say is:</p><ul><li>There exists a hippo</li><li>AND, any other hippo is the same one</li></ul><p>Let&rsquo;s use our systematic approach, streamlining a few of the steps:</p><ul><li>There exists an animal x that is a hippo, and SOMETHING(x)</li><li><code>âˆƒ x (Hi(x) âˆ§ SOMETHING(x))</code></li></ul><p>To translate SOMETHING(x), the claim we are making about our hippo x:</p><ul><li><code>SOMETHING(x)</code>: any other hippo is the same as x</li><li><code>SOMETHING(x)</code>: for each hippo y, x is the same as y</li><li><code>SOMETHING(x)</code>: `âˆ€ y (Hi(y) â†’ (x == y))</li></ul><p>Now we can put everything together to get a complete translation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ x (Hi(x) âˆ§ (âˆ€ y (Hi(y) â†’ (x == y)))</span></span></code></pre></div><p>Here are a few more translations from English to predicate logic. Think about what the following statements mean, and click to reveal each answer:</p><ul><li><p><em>Every elephant is heavier than some hippo.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>âˆ€ x (El(x) -> (âˆƒ y (Hi(y) ^ W(x, y))))</code></p></details><br></li></ul></li><li><p><em>There is an elephant that is heavier than all hippos.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>âˆƒ x (El(x) ^ (âˆ€ y (Hi(y) -> W(x, y))))</code></p></details><br></li></ul></li><li><p><em>No hippo is heavier than every elephant.</em></p><ul><li><details><summary><b>Click here for solution</b></summary><p><code>Â¬(âˆƒ x (Hi(x) ^ (âˆ€ y (El(y) -> W(x, y)))))</code></p></details><br></li></ul></li></ul><h3 id=order-matters>Order matters!</h3><p>We have learned that when dealing with mixed quantifiers, it is safest to embed them within the translation. If we put the mixed quantifiers out front of a translation, then we can accidentally include them in the wrong order and end up with an incorrect translation.</p><p>Suppose we have this predicate, over the domain of people:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>likes(x, y): whether person x likes person y</span></span></code></pre></div><p>Further suppose that liking a person is not necessarily symmetric: that just because person x likes person y does not mean that person y necessarily likes person x.</p><p>Consider these pairs of propositions:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x âˆ€ y likes(x, y)     vs.     âˆ€ y âˆ€ x likes(x, y)  
</span></span><span style=display:flex><span>âˆƒ x âˆƒ y likes(x, y)     vs.     âˆƒ y âˆƒ x likes(x, y)</span></span></code></pre></div><p>Is there any difference between each one? No! The two versions of the first proposition both say that every person likes every other person, and the two versions of the second proposition both say that there is a person who likes another person.</p><p>But what about:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ x âˆƒ y likes(x, y)     vs.     âˆƒ y âˆ€ x likes(x, y)</span></span></code></pre></div><p>Suppose our domain is made up of the following people:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Bob: likes Alice and James
</span></span><span style=display:flex><span>Alice: likes Bob
</span></span><span style=display:flex><span>James: likes Alice</span></span></code></pre></div><p>The first proposition, <code>âˆ€ x âˆƒ y likes(x, y)</code>, says that all people have some person (not necessarily the same person) that they like. This would certainly be true for our domain, as every person has at least one person that they like. The second proposition, <code>âˆƒ y âˆ€ x likes(x, y)</code> is saying that there is a person (the SAME person) that everyone likes. This proposition would be false for our domain, as there is no one person that is liked by everyone.</p><h2 id=precedence-with-quantifiers>Precedence with quantifiers</h2><p>In section 2.2, we discussed operator precedence for propositional logic statements. The same operator precedence holds for predicate logic statements, except that our two quantifiers (<code>âˆ€</code> and <code>âˆƒ</code>) have the same precedence as the NOT operator. If we have a proposition with multiple quantifiers, then the quantifiers are resolved from right to left. For example, <code>âˆƒ y âˆ€ x likes(x, y)</code> should be interpreted as <code>âˆƒ y (âˆ€ x likes(x, y))</code>.</p><p>Here is an updated list of operator precedence, from most important (do first) to least important (do last):</p><ol><li>Parentheses</li><li>Not operator (<code>Â¬</code>), universal quantifier (<code>âˆ€</code>), existential quantifier (<code>âˆƒ</code>)</li><li>And operator, <code>âˆ§</code></li><li>Or operator, <code>âˆ¨</code></li><li>Implies operator, <code>â†’</code></li></ol><p>And here is our updated list of how to resolve multiple operators with the same precedence:</p><ol><li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li><li>Multiple not ( <code>Â¬</code> ) operators &ndash; the rightmost <code>Â¬</code> is resolved first, working from right to left. For example, <code>Â¬Â¬p</code> is equivalent to <code>Â¬(Â¬p)</code>.</li><li>Multiple and ( <code>âˆ§</code> ) operators &ndash; the leftmost <code>âˆ§</code> is resolved first, working from left to right. For example, <code>p âˆ§ q âˆ§ r</code> is equivalent to <code>(p âˆ§ q) âˆ§ r</code>.</li><li>Multiple or ( <code>âˆ¨</code> ) operators &ndash; the leftmost <code>âˆ¨</code> is resolved first, working from left to right. For example, <code>p âˆ¨ q âˆ¨ r</code> is equivalent to <code>(p âˆ¨ q) âˆ¨ r</code>.</li><li>Multiple implies ( <code>â†’</code> ) operators &ndash; the rightmost <code>â†’</code> is resolved first, working from right to left. For example, <code>p â†’ q â†’ r</code> is equivalent to <code>p â†’ (q â†’ r)</code>.</li><li>Multiple quantifiers &ndash; the rightmost quantifier is resolved first, working from right to left. For example, <code>âˆƒ y âˆ€ x likes(x, y)</code> should be interpreted as <code>âˆƒ y (âˆ€ x likes(x, y))</code>.</li></ol><p>When we get to predicate logic proofs in Chapter 6, we will see that Logika uses a different precedence for quantifiers &ndash; there, quantifiers have the LOWEST precedence (done last) of any operator. This ends up being more forgiving than confusing, as it will accept propositions as correct that are really missing parentheses. For example, Logika will accept: <code>âˆƒ x isMouse(x) âˆ§ inHouse(x)</code>. Technically, this proposition <em>should</em> be incorrect &ndash; if we correctly treat quantifiers as having a higher precedence than <code>âˆ§</code>, then <code>inHouse(x)</code> would no longer know about the variable <code>x</code> or its quantifier.</p><p>We <em>should</em> use parentheses with quantifiers to express our intended meaning, and so we should write <code>âˆƒ x (isMouse(x) âˆ§ inHouse(x))</code> instead. But if we forget the parentheses, then Logika will forgive us.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=predicate-logic-proofs>Predicate Logic Proofs</h1><p>Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as <em>first order logic</em>.</p><p>As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules. However, these new rules also exist outside of Logika, and we could express the same proofs with our rules in a different environment or on paper &ndash; the concepts are the same.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Predicate Logic Proofs</h1><article class=default><header class=headline></header><h1 id=logika-predicate-logic-proof-syntax>Logika Predicate Logic Proof Syntax</h1><p>We will use the following format in Logika to start a natural deduction proof for predicate logic. Each proof will be saved in a new file with a <code>.sc</code> (Scala) extension:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background type
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@pure def ProofName[T](pred1: T =&gt; B @pure, pred2: T =&gt; B @pure, ..., indiv1: T, indiv2: T, ...): Unit = {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        //@formatter:off
</span></span><span style=display:flex><span>        (comma-separated list of premises with variable1, variable2, ...)  âŠ¢  (conclusion)
</span></span><span style=display:flex><span>            Proof(
</span></span><span style=display:flex><span>                //the actual proof steps go here
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        //@formatter:on
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here, <code>T</code> is the type of elements in our domain. Usually, we will just use <code>T</code> to denote a generic type (much like generics in Java and C#), but occasionally we will use specific types like <code>Z</code> (which means &ldquo;integer&rdquo;). Next, <code>pred1</code>, <code>pred2</code>, etc. are the predicates for our proofs. The <code>T => B</code> means that they take an element in our domain as a parameter (which has type <code>T</code>) and return a boolean (which has type <code>B</code>). Finally, <code>indiv1</code>, <code>indiv2</code>, etc. are specific individuals within our domain, each of which have type <code>T</code>.</p><p>A proof function like the example above can have as many or few predicates and individuals as are needed for the proof.</p><p>As was the case with propositional logic, the examples in this chapter will omit the imports, proof function definition, deduce call, and formatter changes are omitted here for readability. We will start each example with the sequent followed by the Proof call.</p><h2 id=for-all-statements-in-logika>For all statements in Logika</h2><p>The syntax of a statement like <code>âˆ€ x P(x)</code> in Logika is a little different, since we must specify that each <code>x</code> is an element in our domain. When we are using Logika to do a predicate logic proof, we express <code>âˆ€ x P(x)</code> as:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ ((x: T) =&gt; P(x))</span></span></code></pre></div><p>The above statement is saying, &ldquo;for all x that are of the type T, P(x) is true&rdquo;.</p><p>We can alternatively use curly braces instead of standard parentheses to surround our predicate:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ {(x: T) =&gt; P(x)}</span></span></code></pre></div><p>Such statements can be a pain to type out manually, so there is a way to insert them using a template. If you right-click where you wish to write a predicate logic statement, you can select <em>Slang->Insert Template->Forall</em>. This will insert the statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€((ID: TYPE) =&gt; CLAIM)</span></span></code></pre></div><p>You can type your variable name (often <code>x</code>, <code>y</code>, etc.) in place of <code>ID</code>, the domain type (usually <code>T</code>) in place of <code>TYPE</code>, and your claim (with predicates and propositional logic operators) in place of <code>CLAIM</code>.</p><p>Finally, you can type the keyboard shortcut <em>Ctrl+Shift+, A</em> to insert a for all statement.</p><h2 id=there-exists-statements-in-logika>There exists statements in Logika</h2><p>Statements with existential quantifiers like <code>âˆƒ x P(x)</code> must also be treated differently. When we are using Logika to do a predicate logic proof, we express <code>âˆƒ x P(x)</code> as:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ ((x: T) =&gt; P(x))</span></span></code></pre></div><p>The above statement is saying, &ldquo;there exists an x with type T where P(x) is true&rdquo;.</p><p>We can alternatively use curly braces instead of standard parentheses to surround our predicate:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ {(x: T) =&gt; P(x)}</span></span></code></pre></div><p>Such statements can be a pain to type out manually, so there is a way to insert them using a template. If you right-click where you wish to write a predicate logic statement, you can select <em>Slang->Insert Template->Exists</em>. This will insert the statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆƒ((ID: TYPE) =&gt; CLAIM)</span></span></code></pre></div><p>You can type your variable name (often <code>x</code>, <code>y</code>, etc.) in place of <code>ID</code>, the domain type (usually <code>T</code>) in place of <code>TYPE</code>, and your claim (with predicates and propositional logic operators) in place of <code>CLAIM</code>.</p><p>Finally, you can type the keyboard shortcut <em>Ctrl+Shift+, E</em> to insert a there exists statement.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=rules-with->Rules with âˆ€</h1><p>Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers &ndash; an &ldquo;introduction rule and an &ldquo;elimination&rdquo; rule.</p><p>In this section, we will see the two inference rules for the universal (âˆ€) quantifier.</p><h2 id=for-all-elimination>For all elimination</h2><p>For all elimination allows us to take a claim that uses a universal quantifier &ndash; a statement about ALL individuals in a domain &ndash; and make the same statement about a specific individual in the domain. After all, if the statement is true for ALL individuals, then it follows that it should be true for a particular individual. We can formalize the rule as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>           âˆ€ ((x: T) =&gt; P(x))
</span></span><span style=display:flex><span>AllE[T]:  ---------------------
</span></span><span style=display:flex><span>                   P(v)     where v is a particular individual in the domain (i.e, v has type T)</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>AllE[T]</code> rule. It shows that given the premises: <em>All humans are mortal</em> and <em>Socrates is a human</em>, that we can prove that <em>Socrates is mortal</em>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (   âˆ€ ((x: T) =&gt; (isHuman(x) â†’ isMortal(x))),  
</span></span><span style=display:flex><span>        isHuman(Socrates)    
</span></span><span style=display:flex><span>    ) 
</span></span><span style=display:flex><span>âŠ¢ 
</span></span><span style=display:flex><span>    (   
</span></span><span style=display:flex><span>        isMortal(Socrates) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€ ((x: T) =&gt; (isHuman(x) â†’ isMortal(x)))        )   by Premise,
</span></span><span style=display:flex><span>    2 (     isHuman(Socrates)                               )   by Premise,
</span></span><span style=display:flex><span>    3 (     isHuman(Socrates) â†’ isMortal(Socrates)          )   by AllE[T](1),
</span></span><span style=display:flex><span>    4 (     isMortal(Socrates)                              )   by ImplyE(3, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We can read the justification <code>AllE[T](1)</code> as: &ldquo;for all elimination of the for all statement on line 1.</p><p>While our <code>AllE[T]</code> justification does not mention the particular individual that was plugged in to the for all statement (<em>Socrates</em>, in this case), it is required that whatever individual we plug in has already been show to be of type <code>T</code>. This is done by accepting the individual as a parameter of type <code>T</code> to the proof function. The full proof function would look like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@pure def socMortal[T](isHuman: T =&gt; B @pure, isMortal: T =&gt; B @pure, Socrates: T): Unit = {
</span></span><span style=display:flex><span>    Deduce (
</span></span><span style=display:flex><span>        (   
</span></span><span style=display:flex><span>            âˆ€ ((x: T) =&gt; (isHuman(x) â†’ isMortal(x))),  
</span></span><span style=display:flex><span>            isHuman(Socrates)    
</span></span><span style=display:flex><span>        ) 
</span></span><span style=display:flex><span>        âŠ¢ 
</span></span><span style=display:flex><span>        (   
</span></span><span style=display:flex><span>            isMortal(Socrates) 
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        Proof(
</span></span><span style=display:flex><span>            1 (     âˆ€ ((x: T) =&gt; (isHuman(x) â†’ isMortal(x)))      )   by Premise,
</span></span><span style=display:flex><span>            2 (     isHuman(Socrates)                             )   by Premise,
</span></span><span style=display:flex><span>            3 (     isHuman(Socrates) â†’ isMortal(Socrates)        )   by AllE[T](1),
</span></span><span style=display:flex><span>            4 (     isMortal(Socrates)                            )   by ImplyE(3, 2)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>In similar examples of <code>AllE[T]</code>, it is assumed that the named individual was accepted as a parameter of type <code>T</code> to the proof function.</p><h2 id=for-all-introduction>For all introduction</h2><p>If we can show that a property of the form <code>P(a)</code> holds for an arbitrary member <code>a</code> of a domain, then we can use for all introduction to conclude that the property must hold for ALL individuals in the domain &ndash; i.e., that <code>âˆ€ x P(x)</code> (which we write in Logika as <code>âˆ€ ((x: T) => P(x))</code>). We can formalize the rule as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>            Let (   (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>                ... 
</span></span><span style=display:flex><span>                P(a)  
</span></span><span style=display:flex><span>            )),
</span></span><span style=display:flex><span>AllI[T] : -------------------------------
</span></span><span style=display:flex><span>                 âˆ€ ((x: T) =&gt; P(x)) </span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>AllI[T]</code> rule: &ldquo;Everyone is healthy; everyone is happy. Therefore, everyone is both healthy and happy.&rdquo;:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (   
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; isHealthy(x)), âˆ€((y: T) =&gt; isHappy(y))
</span></span><span style=display:flex><span>    )  
</span></span><span style=display:flex><span>âŠ¢  
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((z: T) =&gt; isHealthy(z) âˆ§ isHappy(z))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof (
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; isHealthy(x))               )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((y: T) =&gt; isHappy(y))                 )   by Premise,
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    3 Let ((a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 (     isHealthy(a)                        )   by AllE[T](1),
</span></span><span style=display:flex><span>        5 (     isHappy(a)                          )   by AllE[T](2),
</span></span><span style=display:flex><span>        6 (     isHealthy(a) âˆ§ isHappy(a)           )   by AndI(4, 5)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    7 (     âˆ€((z: T) =&gt; isHealthy(z) âˆ§ isHappy(z))  )   by AllI[T](3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>If we wish to introduce a for all statement, the pattern is:</p><ul><li><p>Open a subproof where you introduce an arbitrary/fresh individual in the domain with &ldquo;Let&rdquo; (in the example above, we used <code>a</code>). It MUST be a name that we have not used elsewhere in the proof. The idea is that your individual could have been anyone/anything in the domain.</p></li><li><p>When you introduce the individual with &ldquo;Let&rdquo; and then open the subproof, you do NOT include a justification on that line</p></li><li><p>If you have other for all statements available within the scope of the subproof, then it is often useful to use <code>AllE[T]</code> to plug your fresh individual into them. After all, if those statements are true for ALL individuals, then they are also true for your fresh individual.</p></li><li><p>If you are trying to prove something of the form <code>âˆ€ ((x: T) => P(x))</code>, then you need to reach <code>P(a)</code> by the end of the subproof. You need to show that your goal for all statement holds for your fresh individual. In our case, we wished to prove <code>âˆ€((z: T) => isHealthy(z) âˆ§ isHappy(z))</code>, so we reached <code>isHealthy(a) âˆ§ isHappy(a)</code> by the end of the subproof.</p></li><li><p>After the subproof, you can use <code>âˆ€i</code> to introduce a for-all statement for your last claim in the subproof &ndash; that since the individual could have been anyone, then the proposition holds for ALL individuals. The <code>âˆ€i</code> justification needs the line number of the subproof.</p></li><li><p>When you use <code>AllI[T]</code>, it does not matter what variable you introduce into the for all statement. In the example above, we introduced <code>âˆ€((z: T)</code> &ndash; but that was only to match the goal conclusion in the proof. We could have instead introduced <code>âˆ€((x: T)</code>, <code>âˆ€((y: T)</code>, <code>âˆ€((people T)</code>, etc. We would use whatever variable we chose in the rest of that proposition &ndash; i.e., <code>âˆ€((z: T) => isHealthy(z) âˆ§ isHappy(z))</code>, or <code>âˆ€((people: T) => isHealthy(people) âˆ§ isHappy(people))</code>, etc.</p></li></ul><h2 id=examples>Examples</h2><p>In this section, we will look at additional proofs involving the universal quantifier.</p><h3 id=example-1>Example 1</h3><p>Suppose we wish to prove that, given the following premises in the domain of people:</p><ul><li>All students have a phone and/or a laptop</li><li>Everyone is a student</li></ul><p>Then we can conclude:</p><ul><li>Everyone has a phone and/or a laptop</li></ul><p>First, we identify the following predicates:</p><ul><li><code>isStudent(x)</code> - whether person x is a student</li><li><code>hasPhone(x)</code> - whether person x has a phone</li><li><code>hasLaptop(x)</code> = whether person x has a laptop</li></ul><p>Then, we can translate our premises and goal conclusion to predicate logic:</p><ul><li><em>All students have a phone and/or a laptop</em> translates to: <code>âˆ€ x (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x))</code></li><li><em>Everyone is a student</em> translates to: <code>âˆ€ x isStudent(x)</code></li><li><em>Everyone has a phone and/or a laptop</em> translates to: <code>âˆ€ x (hasPhone(x) âˆ¨ hasLaptop(x))</code></li></ul><p>We need to prove the following sequent (where we rewrite the above predicate logic statements in our Logika format):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x))), 
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; isStudent(x))
</span></span><span style=display:flex><span>    ) 
</span></span><span style=display:flex><span>âŠ¢ 
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>As with our previous example, we see that we are trying to prove a for-all statement (<code>âˆ€((y: T) => (hasPhone(y) âˆ¨ hasLaptop(y)))</code>). This means we will need to open a subproof and introduce a fresh individual &ndash; perhaps <code>bob</code>. By the end of the subproof, we must show that our goal for-all statement holds for that individual &ndash; that <code>hasPhone(bob) âˆ¨ hasLaptop(bob)</code>. We start the proof as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x))), 
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; isStudent(x))
</span></span><span style=display:flex><span>    ) 
</span></span><span style=display:flex><span>âŠ¢ 
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof (
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x)))        )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; isStudent(x))                                       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (bob: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        //goal: hasPhone(bob) âˆ¨ hasLaptop(bob)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    //use AllI to conclude âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We have two available for-all statements within the subproof &ndash; <code>âˆ€((x: T) => (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x)))</code> and <code>âˆ€((x: T) => isStudent(x))</code>. Since those propositions hold for all individuals, they also hold for <code>bob</code>. We use <code>AllE[T]</code> to plug in <code>bob</code> to those two propositions:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x))), 
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; isStudent(x))
</span></span><span style=display:flex><span>    ) 
</span></span><span style=display:flex><span>âŠ¢ 
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof (
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x)))        )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; isStudent(x))                                       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (bob: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 (     isStudent(bob) â†’ hasPhone(bob) âˆ¨ hasLaptop(bob)             )   by AllE[T](1),
</span></span><span style=display:flex><span>        5 (     isStudent(bob)                                              )   by AllE[T](2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: hasPhone(bob) âˆ¨ hasLaptop(bob)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    //use AllI to conclude âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Line 5 is an implies statement the form <code>p â†’ q</code>, and line 6 is a statement of the form <code>p</code>. Thus we can use <code>â†’e</code> to conclude <code>hasPhone(bob) âˆ¨ hasLaptop(bob)</code> (the &ldquo;q&rdquo; in that statement) &ndash; which is exactly what we needed to end the subproof. All that remains is to apply our <code>AlI</code> rule after the subproof. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x))), 
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; isStudent(x))
</span></span><span style=display:flex><span>    ) 
</span></span><span style=display:flex><span>âŠ¢ 
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof (
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (isStudent(x) â†’ hasPhone(x) âˆ¨ hasLaptop(x)))        )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; isStudent(x))                                       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (bob: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 (     isStudent(bob) â†’ hasPhone(bob) âˆ¨ hasLaptop(bob)             )   by AllET(1),
</span></span><span style=display:flex><span>        5 (     isStudent(bob)                                              )   by AllE[T](2),
</span></span><span style=display:flex><span>        6 (     hasPhone(bob) âˆ¨ hasLaptop(bob)                              )   by ImplyE(4, 5)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    7 (     âˆ€((y: T) =&gt; (hasPhone(y) âˆ¨ hasLaptop(y)))                       )   by AllI[T](3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h3 id=example-2>Example 2</h3><p>Next, suppose we wish to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (S(x) â†’ Pz(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬D(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We again see that the top-level operator of what we are trying to prove is a universal quantifier. We use our strategy to open a subproof with a fresh individual (maybe <code>a</code>), and plug that individual into any available for-all statements. Since we wish to prove <code>âˆ€((x: T) => Â¬S(x))</code>, then we will want to reach <code>Â¬S(a)</code> by the end of the subproof. Here is a sketch:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (S(x) â†’ Pz(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬D(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (S(x) â†’ Pz(x)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))      )   by Premise,
</span></span><span style=display:flex><span>    3 (     âˆ€((x: T) =&gt; Â¬D(x))              )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    4 Let ((a: T) =&gt; SubProof (
</span></span><span style=display:flex><span>        5 (     S(a) â†’ Pz(a)                )   by AllE[T](1),
</span></span><span style=display:flex><span>        6 (     Pz(a) â†’ D(a)                )   by AllE[T](2),
</span></span><span style=display:flex><span>        7 (     Â¬D(a)                       )   by AllE[T](3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: Â¬S(a)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use AllI[T] to conclude âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Now, we see that our goal is to reach <code>Â¬S(a)</code> by the end of the subproof &ndash; so we need to prove something whose top-level operator is a NOT. We recall that we have a strategy to prove NOT(something) from propositional logic &ndash; we open a subproof, assuming <em>something</em> (<code>S(a)</code>, in our case), try to get a contradiction, and use negation introduction after the subproof to conclude NOT (something) (<code>Â¬S(a)</code> for us). Here is the strategy:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (S(x) â†’ Pz(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬D(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (S(x) â†’ Pz(x)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))      )   by Premise,
</span></span><span style=display:flex><span>    3 (     âˆ€((x: T) =&gt; Â¬D(x))              )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    4 Let ((a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        5 (     S(a) â†’ Pz(a)                )   by AllE[T](1),
</span></span><span style=display:flex><span>        6 (     Pz(a) â†’ D(a)                )   by AllE[T](2),
</span></span><span style=display:flex><span>        7 (     Â¬D(a)                       )   by AllE[T](3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        8 SubProof(
</span></span><span style=display:flex><span>            10 Assume( S(a) ),
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //goal: contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use NegI to conclude Â¬S(a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: Â¬S(a)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use AllI[T] to conclude âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We can complete the proof as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (S(x) â†’ Pz(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬D(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (S(x) â†’ Pz(x)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; (Pz(x) â†’ D(x))      )   by Premise,
</span></span><span style=display:flex><span>    3 (     âˆ€((x: T) =&gt; Â¬D(x))              )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    4 Let ((a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        5 (     S(a) â†’ Pz(a)                )   by AllE[T](1),
</span></span><span style=display:flex><span>        6 (     Pz(a) â†’ D(a)                )   by AllE[T](2),
</span></span><span style=display:flex><span>        7 (     Â¬D(a)                       )   by AllE[T](3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        8 SubProof(
</span></span><span style=display:flex><span>            10 Assume( S(a) ),
</span></span><span style=display:flex><span>            11 (    Pz(a)                   )   by ImplyE(5, 10),
</span></span><span style=display:flex><span>            12 (    D(a)                    )   by ImplyE(6, 11),
</span></span><span style=display:flex><span>            13 (    F                       )   by NegE(12, 7)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            //goal: contradiction
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        //use Â¬i to conclude Â¬S(a)
</span></span><span style=display:flex><span>        14 (    Â¬S(a)                       )   by NegI(8)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: Â¬S(a)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use AllI[T] to conclude âˆ€((x: T) =&gt; Â¬S(x))
</span></span><span style=display:flex><span>    15 (    âˆ€((x: T) =&gt; Â¬S(x))              )   by AllI[T](4)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=rules-with->Rules with âˆƒ</h1><p>In this section, we will see the two inference rules for the existential (âˆƒ) quantifier.</p><h2 id=exists-introduction>Exists introduction</h2><p>We can use the exists introduction rule, <code>ExistsI[T]</code>, when we have a proposition of the form <code>P(a)</code> for an arbitrary member <code>a</code> of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                   P(d)         where  d  is an individual of type T
</span></span><span style=display:flex><span>ExistsI[T]: ---------------------
</span></span><span style=display:flex><span>              âˆƒ((x: T) =&gt; P(x))</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>ExistsI[T]</code> rule (where <em>Socrates</em> is a parameter of type <code>T</code> to our proof function):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   isHuman(Socrates)   ) âŠ¢ (   âˆƒ((x: T) =&gt; isHuman(x))  )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span style=display:flex><span>        2 (     âˆƒ((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>When we use the <code>ExistsI[T]</code> rule to justify a claim like <code>âˆƒ((x: T) => P(x))</code>, we include the line number of where the proposition held for a particular individual. In the proof above, we claim <code>âˆƒ((x: T) => isHuman(x))</code> with justification <code>ExistsI[T](1)</code> &ndash; line 1 corresponds to <code>isHuman(Socrates)</code>, where our <code>âˆƒ((x: T) => isHuman(x))</code> proposition held for a particular individual. The full proof function, which shows how <em>Socrates</em> can be accepted as a parameter of type <code>T</code>, is here:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@pure def ExistsExample[T](isHuman: T =&gt; B @pure, Socrates: T): Unit = {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        (   isHuman(Socrates)   ) âŠ¢ (   âˆƒ((x: T) =&gt; isHuman(x))  )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        Proof(
</span></span><span style=display:flex><span>            1 (     isHuman(Socrates)       )   by Premise,
</span></span><span style=display:flex><span>            2 (     âˆƒ((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Note that we can use the <code>ExistsI[T]</code> rule to introduce any variable, not just <code>x</code>. You can choose which variable to introduce based on the variables used in the conclusion. For example, the following proof is also valid:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   isHuman(Socrates)   ) âŠ¢ (   âˆƒ((z: T) =&gt; isHuman(z))  )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span style=display:flex><span>        2 (     âˆƒ((z: T) =&gt; isHuman(z)) )   by ExistsI[T](1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=exists-elimination>Exists elimination</h2><p>Since the <code>ExistsI[T]</code>-rule constructs propositions that begin with <code>âˆƒ</code>, the <code>ExistsE[T]</code>-rule (exists elimination) disassembles propositions that begin with <code>âˆƒ</code>.</p><p>Here is a quick example (where our domain is living things):</p><ul><li>All humans are mortal</li><li>Someone is human</li><li>Therefore, someone is mortal</li></ul><p>We don&rsquo;t know the name of the human, but it does not matter. Since ALL humans are mortal and SOMEONE is human, then our anonymous human must be mortal. The steps will go like this:</p><ul><li><p>Since &ldquo;someone is human&rdquo; and since we do not know his/her name, we will just make up our own name for them â€“ &ldquo;Jane&rdquo;. So, we assume that &ldquo;Jane is human&rdquo;.</p></li><li><p>We use the logic rules we already know to prove that &ldquo;Jane is mortal&rdquo;.</p></li><li><p>Therefore, SOMEONE is mortal and their name does not matter.</p></li></ul><p>This approach is coded into the last logic law, <code>ExistsE[T]</code> (exists elimination).</p><p>Suppose we have a premise of the form <code>âˆƒ((x: T) => P(x))</code>. Since we do not know the name of the individual &ldquo;hidden&rdquo; behind the <code>âˆƒ(x: T)</code>, we make up a name for it, say <code>a</code>, and discuss what must follow from the assumption that <code>P(a)</code> holds true. Here is the formalization of the <code>ExistsE[T]</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                                        Let ((a: T) =&gt; SubProof(          // where  a  is a new, fresh name
</span></span><span style=display:flex><span>                                             Assume( P(a) ),              // a  MUST NOT appear in  Q
</span></span><span style=display:flex><span>                âˆƒ((x: T) =&gt; P(x))            ...
</span></span><span style=display:flex><span>                                             Q         
</span></span><span style=display:flex><span>                                        )),             
</span></span><span style=display:flex><span>ExistsE[T]: ----------------------------------------------------
</span></span><span style=display:flex><span>                     Q</span></span></code></pre></div><p>That is, if we can deduce <code>Q</code> from <code>P(a)</code>, and we do not mention <code>a</code> within <code>Q</code>, then it means <code>Q</code> can be deduced no matter what name the hidden individual has. So, <code>Q</code> follows from <code>âˆƒ((x: T) => P(x))</code>.</p><p>We can work the previous example, with <code>ExistsE[T]</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>All humans are mortal
</span></span><span style=display:flex><span>Someone is human
</span></span><span style=display:flex><span>Therefore, someone is mortal</span></span></code></pre></div><p>We make up the name, <code>jane</code>, for the human whose name we do not know:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((h: T) =&gt; (isHuman(h) â†’ isMortal(h))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; isHuman(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((y: T) =&gt; (isMortal(y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((h: T) =&gt; (isHuman(h) â†’ isMortal(h)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆƒ((x: T) =&gt; isHuman(x))                     )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (jane: T) =&gt; SubProof (
</span></span><span style=display:flex><span>        4 Assume(   isHuman(jane)                       ),
</span></span><span style=display:flex><span>        5 (         isHuman(jane) â†’ isMortal(jane)      )   by AllE[T](1),
</span></span><span style=display:flex><span>        6 (         isMortal(jane)                      )   by ImplyE(5, 4)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    7 (     âˆƒ((y: T) =&gt; (isMortal(y)))                  )   by ExistsE[T](2, 3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Line 3 proposes the name <code>jane</code> for our subproof and line 4 makes the assumption <code>isHuman(jane)</code> (based on the premise <code>âˆƒ((x: T) => isHuman(x))</code>). The subproof leads to Line 6, which says that someone is mortal. (We never learned the individual&rsquo;s name!) Since Line 6 does not explicitly mention the made-up name, <code>jane</code>, we use Line 7 to repeat Line 6 â€“ without knowing the name of the individual &ldquo;hiding&rdquo; inside Line 2, we made a subproof that proves the result, anyway. This is how <code>ExistsE[T]</code> works.</p><p>Note that when we use the <code>ExistsE[T]</code> rule as a justification we include first the line number of the there exists statement that we processed (by naming the hidden individual) in the previous subproof, and then the line number of that subproof. In the example above, we say <code>ExistsE[T](2, 3)</code> because line 2 includes the there-exists statement we processed (<code>âˆƒ âˆƒ((x: T) => isHuman(x))</code>) in the previous subproof and line 3 is the subproof.</p><p>When using <code>ExistsE[T]</code>, the previous subproof must begin with introducing a name for a hidden individual in a there-exists statement and then immediately make an assumption that substitutes the name into the there exists statement. The last line in the subproof should contain NO mention of the chosen name. Whatever we claim on the last line in the subproof, we must claim EXACTLY the same thing immediately afterwards when we use the <code>ExistsE[T]</code> rule.</p><p>You are welcome to use any name for the hidden individual &ndash; not just <code>jane</code> or <code>a</code>. The only restriction is that you cannot have used the name anywhere else in the proof.</p><h2 id=examples>Examples</h2><p>In this section, we will look at other proofs involving the existential quantifier.</p><h3 id=example-1>Example 1</h3><p>Suppose we wish to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)))  ) âŠ¢ (   âˆƒ((x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)  )</span></span></code></pre></div><p>We will begin as we did previously: by introducing an alias for our person that is either an adult or a kid (say, <code>alice</code>):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)))  ) âŠ¢ (   âˆƒ((x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)) )       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        3 Assume(   Adult(alice) âˆ¨ Kid(alice)       ),
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        //goal: get to our conclusion, âˆƒ( (x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ( (x: T) =&gt; Kid(x)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>To finish our proof, we can use OR elimination on <code>Adult(alice) âˆ¨ Kid(alice)</code>, and then <code>ExistsE[T]</code> afterwards to restate our conclusion. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)))  ) âŠ¢ (   âˆƒ((x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)) )                   )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        3 Assume(   Adult(alice) âˆ¨ Kid(alice)                   ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume (  Adult(alice)                            ),
</span></span><span style=display:flex><span>            6 (     âˆƒ((x: T) =&gt; Adult(x)                        )   by ExistsI[T](5),
</span></span><span style=display:flex><span>            7 (     âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)   )   by OrI1(6)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        8 SubProof(
</span></span><span style=display:flex><span>            9 Assume (  Kid(alice)                              ),
</span></span><span style=display:flex><span>            10 (    âˆƒ((x: T) =&gt; Kid(x)                          )   by ExistsI[T](9),
</span></span><span style=display:flex><span>            11 (    âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)   )   by OrI2(10)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        12 (    âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)       )   by OrE(3, 4, 8)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        //goal: get to our conclusion, âˆƒ( (x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ( (x: T) =&gt; Kid(x)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    13 (        âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)       )   by ExistsE[T](1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h3 id=example-2>Example 2</h3><p>Suppose we wish to prove the following (in the domain of living things):</p><ul><li>All bunnies are fluffy</li><li>There is a fast bunny</li><li>Therefore, there is a creature that is fast and fluffy</li></ul><p>We can translate our premises and desired conclusion to predicate logic, and write the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Since we are trying to prove a claim about some individual, it makes sense that we would start the process of an <code>ExistsE[T]</code> subproof where we introduce an alias (<code>thumper</code>) for the fast bunny. We will try to reach the conclusion by the end of that subproof. Here is the setup:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x)))       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 Assume(   Fast(thumper) âˆ§ Bunny(thumper)  ),
</span></span><span style=display:flex><span>        5 (         Fast(thumper)                   )   by AndE1(4),
</span></span><span style=display:flex><span>        6 (         Bunny(thumper)                  )   by AndE2(4),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>To finish our subproof, we see that we have a proposition about all creatures (<code>âˆ€((x: T) => (Bunny(x) â†’ Fluffy(x)))</code>) and that we are working with an individual creature (<code>thumper</code>). We can use <code>AllE[T]</code> to prove <code>Bunny(thumper) â†’ Fluffy(thumper)</code>. After that, we have a few more manipulations using propositional logic rules, our <code>ExistsI[T]</code> rule to transition our claim from being about our alias <code>thumper</code> to being about an unnamed individual, and then our <code>ExistsE[T]</code> rule to pull our final claim out of the subproof. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x)))         )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x)))           )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 Assume(   Fast(thumper) âˆ§ Bunny(thumper)      ),
</span></span><span style=display:flex><span>        5 (         Fast(thumper)                       )   by AndE1(4),
</span></span><span style=display:flex><span>        6 (         Bunny(thumper)                      )   by AndE2(4),
</span></span><span style=display:flex><span>        7 (         Bunny(thumper) â†’ Fluffy(thumper)    )   by AllE[T](1),
</span></span><span style=display:flex><span>        8 (         Fluffy(thumper)                     )   by ImplyE(7, 6),
</span></span><span style=display:flex><span>        9 (         Fast(thumper) âˆ§ Fluffy(thumper)     )   by AndI(5, 8),
</span></span><span style=display:flex><span>        10 (        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))  )   by ExistsI[T](9)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    11 (    âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))          )   by ExistsE[T](2, 3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=nested-quantifiers>Nested Quantifiers</h1><p>Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that <code>âˆ€ x âˆ€ y P(x, y)</code> is equivalent to <code>âˆ€ x (âˆ€ y P(x, y))</code>.</p><p>//&lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;COME UP WITH DIFFERENT EXAMPLE 1!!!!!&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-></p><h2 id=example-1>Example 1</h2><p>Suppose we wish to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y)))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Since we wish to prove a for-all statement, <code>âˆ€((x: T) => (SOMETHING)</code>, we know we must start with our for all introduction template:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y)))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y))))       )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //need: âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //want to use AllI[T] to conclude âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>But now we see that we want to prove ANOTHER for-all statement, <code>âˆ€((y: T) => Q(a, y))</code>. So we again use our for all introduction strategy in a nested subproof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y)))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y))))       )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span style=display:flex><span>        4 ( (b: T) =&gt; SubProof(
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //need: Q(a, b)
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        //want to use AllI[T] to conclude âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //need: âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //want to use AllI[T] to conclude âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Now, in subproof 4, we see that we must use <code>AllE[T]</code> on our both of our premises to work towards our goal of <code>Q(a, b)</code>. We have two available individuals &ndash; <code>a</code> and <code>b</code>. When we use <code>AllE[T]</code>, we must eliminate the OUTER (top-level) quantifier and its variable. In the case of the premise <code>âˆ€((x: T) => âˆ€((y: T) => (P(x, y) â†’ Q(x, y))))</code>, we see that we must eliminate the <code>âˆ€((x: T) ...)</code>. Since the <code>x</code> is the first parameter in <code>Q(x, y)</code>, and since we are hoping to reach <code>Q(a, b)</code> by the end of subproof 4, we can see that we need to plug in the <code>a</code> for the <code>x</code> so that it will be in the desired position. We make a similar substitution with <code>AllE[T]</code> on our second premise:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y)))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y))))       )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span style=display:flex><span>        4 ( (b: T) =&gt; SubProof(
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            5 (     âˆ€(y: T) =&gt; (P(a, y) â†’ Q(a, y)))             )   by AllE[T](1),
</span></span><span style=display:flex><span>            6 (     âˆ€(y: T) =&gt; P(a, y)                          )   by AllE[T](2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //need: Q(a, b)
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        //want to use AllI[T] to conclude âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //need: âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //want to use AllI[T] to conclude âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that on line 5, we could NOT have used <code>AllE[T]</code> to eliminate the <code>âˆ€(y: T)</code> in <code>âˆ€((x: T) => âˆ€((y: T) => (P(x, y) â†’ Q(x, y)))) </code>, as it was not the top-level operator.</p><p>Next, we apply <code>AllE[T]</code> again to our results on lines 5 and 6, this time plugging in <code>b</code> for <code>y</code> in both cases. This leaves us with <code>P(a, b) â†’ Q(a, b)</code> and <code>P(a, b)</code>. We can use implies elimination to reach our goal of <code>Q(a, b)</code>, and then all that remains ais to use <code>AllI[T]</code> twice as planned to wrap up the two subproofs. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y)))),
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; (P(x, y) â†’ Q(x, y))))       )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span style=display:flex><span>        4 ( (b: T) =&gt; SubProof(
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            5 (     âˆ€(y: T) =&gt; (P(a, y) â†’ Q(a, y))              )   by AllE[T](1),
</span></span><span style=display:flex><span>            6 (     âˆ€(y: T) =&gt; P(a, y)                          )   by AllE[T](2),
</span></span><span style=display:flex><span>            7 (     P(a, b) â†’ Q(a, b)                           )   by AllE[T](5),
</span></span><span style=display:flex><span>            8 (     P(a, b)                                     )   by ALlE[T](6),
</span></span><span style=display:flex><span>            9 (     Q(a, b)                                     )   by ImplyE(7, 8)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //need: Q(a, b)
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        //want to use AllI[T] to conclude âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>        10 (    âˆ€((y: T) =&gt; Q(a, y))                            )   by AllI[T](4)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //need: âˆ€((y: T) =&gt; Q(a, y))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //want to use AllI[T] to conclude âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))
</span></span><span style=display:flex><span>    11 (    âˆ€((x: T) =&gt; âˆ€((y: T) =&gt; Q(x, y)))                   )   by AllI[T](3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h2 id=example-2>Example 2</h2><p>Suppose we have the predicate <code>IsBossOf(x, y)</code> in the domain of people, which describes whether person <code>x</code> is the boss of person <code>y</code>. We wish to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; âˆ€((y: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>You can read the premise as &ldquo;There is a person that is everyone&rsquo;s boss&rdquo;. From this statement, we are trying to prove the conclusion: &ldquo;All people have a boss&rdquo;. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; âˆ€((y: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆƒ((x: T) =&gt; âˆ€((y: T) =&gt; IsBossOf(x, y)))            )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        3 Assume(   âˆ€((y: T) =&gt; IsBossOf(a, y)                  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 Let ( (b: T) =&gt; SubProof(
</span></span><span style=display:flex><span>            5 (         IsBossOf(a, b)                          )   by AllE[T](3),
</span></span><span style=display:flex><span>            6 (         âˆƒ((x: T) =&gt; IsBossOf(x, b))             )   by ExistsI[T](5)
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        7 (   âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))          )   by AllI[T](4)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    8 (   âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))              )  by ExistsE[T](1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>In the above proof, we let <code>a</code> be our made-up name for the boss-of-everyone. So, we have the assumption that <code>âˆ€((y: T) => IsBossOf(a, y))</code>. Next, we let <code>b</code> be &ldquo;anybody at all&rdquo; who we might examine in the domain of people. The proof exposes that the boss of &ldquo;anybody at all&rdquo; in the domain must always be <code>a</code>. <code>AllI[T]</code> and then <code>ExistsE[T]</code> finish the proof.</p><p>Here is the proof worked again, with the subproofs swapped:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; âˆ€((y: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆƒ((x: T) =&gt; âˆ€((y: T) =&gt; IsBossOf(x, y)))            )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (b: T) =&gt; SubProof(
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        3 Let ( (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>            4 Assume(   âˆ€((y: T) =&gt; IsBossOf(a, y))             ),
</span></span><span style=display:flex><span>            5 (         IsBossOf(a, b)                          )   by AllE[T](4),
</span></span><span style=display:flex><span>            6 (         âˆƒ((x: T) =&gt; IsBossOf(x, b))             )   by ExistsI[T](5)
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        7 (       âˆƒ((x: T) =&gt; IsBossOf(x, b))                   )   by ExistsE[T](1, 3)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    8 (   âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))              )  by AllI[T](2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Can we prove the converse? That is, if everyone has a boss, then there is one boss who is the boss of everyone? NO. We can try, but we get stuck:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; âˆ€((y: T) =&gt; IsBossOf(x, y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((y: T) =&gt; âˆƒ((x: T) =&gt; IsBossOf(x, y)))            )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        3 (     âˆƒ((x: T) =&gt; IsBossOf(x, a))                     )   by AllE[T](1),
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        4 Let ( (b: T) =&gt; SubProof(
</span></span><span style=display:flex><span>            5 (     Assume (    IsBossOf(b, a)                  ),
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        6 (     âˆ€((y: T) =&gt; IsBossOf(b, y))                     )   AllI[T](4),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //STEP 6 IS INVALID -- we cannot refer to b after the end of the subproof
</span></span><span style=display:flex><span>        //where it was introduced
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    //...can&#39;t finish
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We see that the &ldquo;block structure&rdquo; of the proofs warns us when we are making invalid deductions.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=equivalence>Equivalence</h1><p>In Chapter 5, we saw DeMorgan&rsquo;s laws for quantifiers &ndash; that if we have some domain, and if <code>P(x)</code> is a predicate for individuals in that domain, then the following statements are equivalent:</p><ul><li><code>Â¬(âˆƒ x P(x))</code> is equivalent to <code>âˆ€ x Â¬P(x)</code></li><li><code>Â¬(âˆ€ x P(x))</code> is equivalent to <code>âˆƒ x Â¬P(x)</code></li></ul><p>The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic &ndash; we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.</p><h2 id=example---how-to-prove-equivalence>Example - how to prove equivalence</h2><p>For example, to prove that <code>Â¬(âˆƒ x P(x))</code> is equivalent to <code>âˆ€ x Â¬P(x)</code>, we must prove the sequents:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        Â¬(âˆƒ((x: T) =&gt; P(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬P(x))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>and</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬P(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        Â¬(âˆƒ((x: T) =&gt; P(x)))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>We prove both directions below:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        Â¬(âˆƒ((x: T) =&gt; P(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬P(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     Â¬(âˆƒ((x: T) =&gt; P(x)))        ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        3 SubProof(
</span></span><span style=display:flex><span>            4 Assume (  P(a)  ),
</span></span><span style=display:flex><span>            5 (     âˆƒ((x: T) =&gt; P(x))   ) by ExistsI[T](3),
</span></span><span style=display:flex><span>            6 (     F                   ) by NegE(4, 1)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        7 (     Â¬P(a)                   ) by NegI(3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    8 (  âˆ€((x: T) =&gt; Â¬P(x))             ) by AllI[T](2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>And:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; Â¬P(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        Â¬(âˆƒ((x: T) =&gt; P(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; Â¬P(x))          )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 SubProof(
</span></span><span style=display:flex><span>        3 Assume (  âˆƒ((x: T) =&gt; P(x))   ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 Let ( (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>            5 Assume (  P(a)  ),
</span></span><span style=display:flex><span>            6 (     Â¬P(a)               )   by AllE[T](1),
</span></span><span style=display:flex><span>            7 (     F                   )   by NegE(5, 6),
</span></span><span style=display:flex><span>        )),
</span></span><span style=display:flex><span>        8 (     F                       )   By ExistsE[T](3, 4)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    9 (     Â¬(âˆƒ((x: T) =&gt; P(x)))        )   by NegI(2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h2 id=more-extensive-list-of-equivalences>More extensive list of equivalences</h2><p>Here is a more extensive list of equivalences in predicate logic. The remaining proofs are left as exercises for the reader:</p><ul><li><code>Â¬(âˆƒ x P(x))</code> is equivalent to <code>âˆ€ x Â¬P(x)</code></li><li><code>Â¬(âˆ€ x P(x))</code> is equivalent to <code>âˆƒ x Â¬P(x)</code></li><li><code>âˆ€ x (P(x) â†’ Â¬Q(x))</code> is equivalent to <code>Â¬(âˆƒ x P(x) âˆ§ Q(x))</code></li><li><code>âˆ€ x âˆ€ y P(x, y)</code> is equivalent to <code>âˆ€ y âˆ€ x P(x, y)</code></li><li><code>âˆƒ x âˆƒ y P(x, y)</code> is equivalent to <code>âˆƒ y âˆƒ x P(x, y)</code></li><li><code>Q âˆ§ (âˆ€ x P(x))</code> is equivalent to <code>âˆ€ x (Q âˆ§ P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li><li><code>Q v (âˆ€ x P(x))</code> is equivalent to <code>âˆ€ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li><li><code>Q âˆ§ (âˆƒ x P(x))</code> is equivalent to <code>âˆƒ x (Q âˆ§ P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li><li><code>Q V (âˆƒ x P(x))</code> is equivalent to <code>âˆƒ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary-and-strategies>Summary and Strategies</h1><p>In this section, we summarize all available rules in propositional logic, and discuss strategies for approaching proofs.</p><h2 id=rules-with-universal-quantifier->Rules with universal quantifier (<code>âˆ€</code>)</h2><p>Rule summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>           âˆ€ ((x: T) =&gt; P(x))
</span></span><span style=display:flex><span>AllE[T]:  ---------------------
</span></span><span style=display:flex><span>                   P(v)     where v is a particular individual in the domain (i.e, v has type T)</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>            Let (   (a: T) =&gt; SubProof(
</span></span><span style=display:flex><span>                ... 
</span></span><span style=display:flex><span>                P(a)  
</span></span><span style=display:flex><span>            )),
</span></span><span style=display:flex><span>AllI[T] : -------------------------------
</span></span><span style=display:flex><span>                 âˆ€ ((x: T) =&gt; P(x)) </span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>( 
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    r (     âˆ€ ((x: T) =&gt; P(x))      )   by SomeJustification,
</span></span><span style=display:flex><span>    s (     P(v)                    )   by AllE[T](r),      //where v has been previously shown to have type T    
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>( 
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    r Let (  (a: T) =&gt; SubProof(    //where a is a fresh, previously unused, individual
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        t (     P(a)            )   by SomeJustification
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    u (     âˆ€ ((x: T) =&gt; P(x))  )   by AllI[T](r),
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h2 id=rules-with-existential-quantifier->Rules with existential quantifier (<code>âˆƒ</code>)</h2><p>Rule summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                   P(d)         where  d  is an individual of type T
</span></span><span style=display:flex><span>ExistsI[T]: ---------------------
</span></span><span style=display:flex><span>              âˆƒ((x: T) =&gt; P(x))</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                                        Let ((a: T) =&gt; SubProof(          // where  a  is a new, fresh name
</span></span><span style=display:flex><span>                                             Assume( P(a) ),              // a  MUST NOT appear in  Q
</span></span><span style=display:flex><span>                âˆƒ((x: T) =&gt; P(x))            ...
</span></span><span style=display:flex><span>                                             Q         
</span></span><span style=display:flex><span>                                        )),             
</span></span><span style=display:flex><span>ExistsE[T]: ----------------------------------------------------
</span></span><span style=display:flex><span>                     Q</span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    r (     P(d)                )   by SomeJustification,   //where d has been shown to have type T
</span></span><span style=display:flex><span>    s (     âˆƒ((x: T) =&gt; P(x))   )   by ExistsI[T](r),
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    b (     âˆƒ((x: T) =&gt; P(x))       )   by SomeJustification,
</span></span><span style=display:flex><span>    c Let ( (a: T) =&gt; SubProof(     //where a is a previously unused individual
</span></span><span style=display:flex><span>        d Assume(  P(a)  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        f (     Q                   )   by SomeJustification    //where a does NOT appear in Q
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    g (     Q                       )   by ExistsE[T](b, c),
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h2 id=reminder-propositional-logic-rules-are-still-available>Reminder: propositional logic rules are still available</h2><p>When doing proofs in predicate logic, remember that all the deduction rules from propositional logic are still available. You will often want to use the same strategies we saw there &ndash; not introduction to prove a NOT, implies introduction to create an implies statement, OR elimination to process an OR statement, etc.</p><p>However, keep in mind that propositional logic rules can only be used on claims without quantifiers as their top-level operator. For example, if we have the statement <code>âˆ€ ( x: T) => (S(x) âˆ§ Pz(x)) )</code>, then we cannot use <code>AndE</code> &ndash; the top-level operator is a universal quantifier, and the <code>âˆ§</code> statement is &ldquo;bound up&rdquo; in that quantifier. We would only be able to use <code>AndE</code> after we had used <code>AllE[T]</code> to eliminate the quantifier.</p><h2 id=strategies>Strategies</h2><ol><li><p>Write down all premises first. Can you extract anything from the premises?</p><ul><li>If you have a for-all statement and an available individual, use <code>AndE[T]</code> to plug that individual into the for-all statement.</li><li>If you have <code>pâˆ§q</code>, use <code>AndE1</code> to extract <code>p</code> by itself and then <code>AndE2</code> to extract <code>q</code> by itself.</li><li>If you have <code>p â†’: q</code> and <code>p</code>, use <code>ImplyE</code> to get <code>q</code>.</li><li>If you have <code>p</code> and <code>Â¬p</code>, use <code>NegE</code> to claim a contradiction, <code>F</code>.</li></ul></li><li><p>Look at the top-level operator of what you are trying to prove.</p><ul><li><p>Are you trying to prove something of the form <code>âˆ€ ((x: T) => P(x))</code>?</p><ul><li>Use <code>AllI[T]</code>. Open a subproof, introduce a fresh <code>a</code>, and get to <code>P(a)</code> by the end of the subproof. After the subproof, use <code>AllI[T]</code> to conclude <code>âˆ€ ((x: T) => P(x))</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>âˆƒ((x: T) => P(x))</code>?</p><ul><li>You will often have another there-exists (<code>âˆƒ</code>) statement available as a premise or previous claim. Open a subproof, and assume an alias for the individual in your there-exists statement. Get to <code>âˆƒ((x: T) => P(x))</code> by the last line of the subproof. After the subproof, use <code>ExistsE[T]</code> to restate <code>âˆƒ((x: T) => P(x))</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p â†’: q</code>?</p><ul><li>Use <code>ImplyI</code>. Open a subproof, assume <code>p</code>, and get to <code>q</code> by the end of the subproof. After the subproof, use <code>ImplyI</code> to conclude <code>p â†’: q</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>Â¬p</code>?</p><ul><li>Use <code>NegI</code>. Open a subproof, assume <code>p</code>, and get a contradiction, <code>F</code>, by the end of the subproof. After the subproof, use <code>NegI</code> to conclude <code>Â¬p</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p âˆ§ q</code>?</p><ul><li>Try to prove <code>p</code> by itself and then <code>q</code> by itself. Afterward, use <code>AndI</code> to conclude <code>p âˆ§ q</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p âˆ¨ q</code>?</p><ul><li>See if you have either <code>p</code> or <code>q</code> by itself &ndash; if you do, use either <code>OrI1</code> or <code>OrI2</code> to conclude <code>p âˆ¨ q</code>.</li></ul></li></ul></li><li><p>You&rsquo;ll need to nest the approaches from step 2. Once you are in a subproof, think about what you are <em>trying to prove by the end of that subproof</em>. Follow the strategy in step 2 to prove your current goal, nesting subproofs as needed. As you work, stop and scan the claims that you have available. See if you can extract anything from them as you did for the premises in step 1.</p></li><li><p>No match, or still stuck?</p><ul><li>Do you have a there-exists statement available? Try using <code>ExistsE[T]</code> to reach your goal.</li><li>Do you have an OR statement available? Try using OR elimination to prove your goal conclusion.</li><li>Do your statements have NOT operators, but don&rsquo;t fit the form for using <code>Â¬i</code>? Try using <code>PbC</code>. If you are trying to prove something of the form <code>p</code>, open a subproof, assume <code>Â¬p</code>, and try to reach a contradiction by the end of the subproof. Afterward, use <code>PbC</code> to conclude <code>p</code>.</li><li>As a last resort, try pasting in the proof for the law of the excluded middle (see section 4.5). Then use OR elimination on <code>p âˆ¨ Â¬p</code>.</li></ul></li></ol><p>Think of doing a proof as solving a maze, and of all our deduction rules as possible directions you can turn. If you have claims that match a deduction rule, then you can try applying the rule (i.e, &ldquo;turning that direction&rdquo;). As you work, you may apply more and more rules until the proof falls into place (you exit the maze)&mldr;or, you might get stuck. If this happens, it doesn&rsquo;t mean that you have done anything <em>wrong</em> &ndash; it just means that you have reached a dead end and need to try something else. You backtrack, and try a different approach instead (try turning in a different direction).</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=soundness-and-completeness>Soundness and Completeness</h1><h2 id=soundness-and-completeness-definitions>Soundness and completeness definitions</h2><p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p><h2 id=interpretations>Interpretations</h2><p>When we write statements in logic, we use predicates and function symbols (e.g., <code>âˆ€ i (i * 2) > i</code>). An interpretation gives the meaning of:</p><ul><li><p>The underlying domain â€“ what set of elements it names</p></li><li><p>Each function symbol â€“ what answers it computes from its parameters from the domain</p></li><li><p>Each predicate â€“ which combinations of arguments from the domain lead to true answers and false answers</p></li></ul><h3 id=interpretation-example---integers>Interpretation example - integers</h3><p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>></code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p><p>The standard interpretation of arithmetic is that:</p><ul><li><p><code>int</code> names the set of all integers</p></li><li><p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p></li><li><p><code>=</code> and <code>></code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p></li></ul><p>With this interpretation of arithmetic, we can interpret statements. For example,<code>âˆ€ i (i * 2) > i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>âˆƒ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p><p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>></code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>></code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n > m</code>.</p><p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 > 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p><p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p><h3 id=interpretation-example---predicates>Interpretation example - predicates</h3><p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p><p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p><h2 id=valid-sequents-in-predicate-logic>Valid sequents in predicate logic</h2><blockquote><p>A sequent, <code>P_1, P_2, ..., P_n âŠ¢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &mldr;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p></blockquote><h2 id=soundness-and-completeness-in-predicate-logic>Soundness and completeness in predicate logic</h2><p>We can then define soundness and completeness for predicate logic:</p><blockquote><p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n âŠ¢ Q</code>, then the sequent is valid (in all possible interpretations)</p></blockquote><blockquote><p><em>completeness:</em> When <code>P_1, P_2, ..., P_n âŠ¢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p></blockquote><p>Note that, if <code>P_1, P_2, ..., P_n âŠ¢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>></code>, and <code>=</code>. No appropriate rule set was devised.</p><p>In the early 20th century, Kurt GÃ¶del showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. GÃ¶del showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p><p>GÃ¶delâ€™s construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p><p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program that will tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=mathematical-induction>Mathematical Induction</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Mathematical Induction</h1><article class=default><header class=headline></header><h1 id=induction-process>Induction Process</h1><p><em>Mathematical induction</em> allows us to prove that every nonnegative integer satisfies a certain property. In this chapter, we will use mathematical induction to prove several mathematical claims. When we reach the next several chapters on programming logic, we will see that mathematical induction is very similar to the process of proving correctness for programs with loops.</p><h2 id=domino-effect>Domino effect</h2><p>To prove that a property <span class="math align-center">$P(n)$</span> is true for an arbitrary nonnegative integer <span class="math align-center">$n$</span> using mathematical induction, we must show two things:</p><ol><li><p><strong>Base case</strong>. We must prove that <span class="math align-center">$P(n)$</span> is true for the smallest possible value of <span class="math align-center">$n$</span>. Usually this is <span class="math align-center">$n = 0$</span> or <span class="math align-center">$n = 1$</span>, but occasionally we will define a property for all values greater than or equal to 2, or some bigger number.</p></li><li><p><strong>Inductive step</strong>. We assume the <em>inductive hypothesis</em> &ndash; that <span class="math align-center">$P(k)$</span> holds for some arbitrary nonnegative integer <span class="math align-center">$k$</span>. Then, we must show that the property still holds for <span class="math align-center">$k + 1$</span>. In other words, we must prove that <span class="math align-center">$P(k) \rightarrow P(k + 1)$</span> &ndash; that IF <span class="math align-center">$P(k)$</span> holds for some arbitrary nonnegative integer <span class="math align-center">$k$</span>, THEN <span class="math align-center">$P(k + 1)$</span> holds as well.</p></li></ol><p>How do these two steps prove anything at all? Suppose we are proving that a property holds for all positive integers <span class="math align-center">$n$</span>. In the base case, we prove that the property holds when <span class="math align-center">$n = 1$</span>. Proving the inductive step allows us to say that whenever the property holds for some number, then it also holds for the number right after that. Since we already know the the property holds when <span class="math align-center">$n = 1$</span>, then the inductive step allows us to infer that the property still holds when <span class="math align-center">$n = 2$</span>. And at that point we know the property holds for <span class="math align-center">$n = 2$</span>, so the inductive step again allows us to infer that the property holds for <span class="math align-center">$n = 3$</span>, etc.</p><p>Think of mathematical inductive like a line of dominoes. The &ldquo;base case&rdquo; tells us that the first domino will fall, and the &ldquo;inductive step&rdquo; tells us that if one domino falls, then the one right after it will fall as well. From these two pieces, we can conclude that the entire line of dominoes will fall (i.e., that the property will hold for the entire set of numbers).</p><h2 id=summation-property>Summation property</h2><p>There is a well-known formula for adding all positive integers up to some bound, <span class="math align-center">$n$</span>:</p><span class="math align-center">$$
\begin{aligned}
1 + 2 + ... + n = \dfrac{n(n+1)}{2}
\end{aligned}
$$</span><br><br><p>To see how this works, suppose <span class="math align-center">$n = 3$</span>. We have that <span class="math align-center">$1 + 2 + 3 = 6$</span>, and also that <span class="math align-center">$\dfrac{3(3+1)}{2} = 6$</span>.</p><p>Suppose instead that <span class="math align-center">$n = 7$</span>. We have that <span class="math align-center">$1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$</span>, and also that <span class="math align-center">$\dfrac{7(7+1)}{2} = 28$</span>.</p><h2 id=first-induction-proof>First induction proof</h2><p>Let <span class="math align-center">$P(n)$</span> be the equation:</p><span class="math align-center">$$
\begin{aligned}
1 + 2 + ... + n = \dfrac{n(n+1)}{2}
\end{aligned}
$$</span><p>We wish to use mathematical induction to prove that <span class="math align-center">$P(n)$</span> holds for all positive integers <span class="math align-center">$n$</span>.</p><br><br><p>We will refer to <span class="math align-center">$1 + 2 + ... + n$</span> as <span class="math align-center">$LHS(n)$</span> and we will refer to <span class="math align-center">$\dfrac{n(n+1)}{2}$</span> as <span class="math align-center">$RHS(n)$</span>. To prove that <span class="math align-center">$P(n)$</span> holds for some positive integer <span class="math align-center">$n$</span>, we must prove that <span class="math align-center">$LHS(n) = RHS(n)$</span>.</p><h3 id=base-case>Base case</h3><p>We must prove that <span class="math align-center">$P(n)$</span> holds for the smallest positive integer, <span class="math align-center">$n = 1$</span>, that is, that <span class="math align-center">$LHS(1) = RHS(1)$</span>. The sum of all integers from 1 to 1 is just 1, so we have that <span class="math align-center">$LHS(1) = 1$</span>. We also have that:</p><span class="math align-center">$$
\begin{aligned}
RHS(1) = \dfrac{1(1+1)}{2} = 1
\end{aligned}
$$</span><br><p>We have that <span class="math align-center">$LHS(1) = RHS(1)$</span>. Thus <span class="math align-center">$P(1)$</span> is true, so the base case holds.</p><h3 id=inductive-step>Inductive step</h3><p>We assume the inductive hypothesis - that <span class="math align-center">$P(k)$</span> holds for some arbitrary positive integer <span class="math align-center">$k$</span>. In other words, we assume that <span class="math align-center">$LHS(k) = RHS(k)$</span> for our arbitrary <span class="math align-center">$k$</span>. We must prove that <span class="math align-center">$P(k+1)$</span> also holds &ndash; i.e., that <span class="math align-center">$LHS(k+1) = RHS(k+1)$</span>. We have that:</p><span class="math align-center">$$
LHS(k+1) = 1 + 2 + ... + k + (k + 1) \tag{1}
$$
$$
= LHS(k) + (k + 1) \tag{2}
$$
$$
= RHS(k) + (k + 1) \tag{3}
$$
$$
= \dfrac{k(k+1)}{2} + (k + 1) \tag{4}
$$
$$
= \dfrac{k(k+1) + 2(k+1)}{2} \tag{5}
$$
$$
= \dfrac{(k+1)(k + 2)}{2} \tag{6}
$$
$$
= \dfrac{(k+1)((k + 1) + 1)}{2} \tag{7}
$$
$$
= RHS(k+1) \tag{8}
$$</span><p>Thus <span class="math align-center">$LHS(k+1) = RHS(k+1)$</span>, so we have proved <span class="math align-center">$P(k+1)$</span>. The inductive step holds.</p><p><br><br></p><p>We conclude that for all positive integers <span class="math align-center">$n$</span>, <span class="math align-center">$P(n)$</span> holds &ndash; that is, that:</p><span class="math align-center">$$
\begin{aligned}
1 + 2 + ... + n = \dfrac{n(n+1)}{2}
\end{aligned}
$$</span><h2 id=inductive-step-explanation>Inductive step explanation</h2><p>In line 2 of the proof above we saw that <span class="math align-center">$1 + 2 + ... + k$</span> was really <span class="math align-center">$LHS(k)$</span>, so we made that substitution. Then in line 3, we used our inductive hypothesis - that <span class="math align-center">$LHS(k) = RHS(k)$</span>, and substituted <span class="math align-center">$RHS(k)$</span> for <span class="math align-center">$LHS(k)$</span>. Since we had that <span class="math align-center">$RHS(k) = \dfrac{k(k+1)}{2}$</span>, we made that substitution on line 4.</p><p>From lines 5 to 7, we did algebraic manipulations to combine our terms and work towards the form of <span class="math align-center">$RHS(k+1)$</span>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=algebra-example>Algebra example</h1><p>Claim: The sum of the first <span class="math align-center">$n$</span> odd numbers is <span class="math align-center">$n^2$</span>. We will refer to this claim as <span class="math align-center">$P(n)$</span>.</p><h3 id=try-it-out>Try it out</h3><p>Before proving <span class="math align-center">$P(n)$</span> with mathematical induction, let&rsquo;s see if the property holds for some sample values. The sum of the first 3 odd numbers is <span class="math align-center">$1 + 3 + 5 = 9$</span>. We also have that <span class="math align-center">$3^2 = 9$</span>.</p><p>The sum of the first 7 odd numbers is <span class="math align-center">$1 + 3 + 5 + 7 + 9 + 11 + 13 = 49$</span>. We also have that <span class="math align-center">$7^2 = 49$</span>.</p><p>Another way to express the sum of the first <span class="math align-center">$n$</span> odd numbers is: <span class="math align-center">$1 + 3 + ... + (2n - 1)$</span>. For example, when <span class="math align-center">$n$</span> is 4, we have that <span class="math align-center">$2n - 1 = 7$</span>. The sum of the first <span class="math align-center">$4$</span> odd numbers is <span class="math align-center">$1 + 3 + 5 + 7$</span>.</p><h3 id=induction-proof>Induction proof</h3><p>We wish to use mathematical induction to prove that <span class="math align-center">$P(n)$</span> holds for all positive integers <span class="math align-center">$n$</span> That is, that the sum of the first <span class="math align-center">$n$</span> odd numbers is <span class="math align-center">$n^2$</span>:</p><span class="math align-center">$$
\begin{aligned}
1 + 3 + ... + (2n - 1) = n^2
\end{aligned}
$$</span><br><br><p>We will refer to <span class="math align-center">$1 + 3 + ... + (2n - 1)$</span> as <span class="math align-center">$LHS(n)$</span> and we will refer to <span class="math align-center">$n^2$</span> as <span class="math align-center">$RHS(n)$</span>. To prove that <span class="math align-center">$P(n)$</span> holds for some positive integer <span class="math align-center">$n$</span>, we must prove that <span class="math align-center">$LHS(n) = RHS(n)$</span>.</p><h4 id=base-case>Base case</h4><p>We must prove that <span class="math align-center">$P(n)$</span> holds for the smallest positive integer, <span class="math align-center">$n = 1$</span>, that is, that <span class="math align-center">$LHS(1) = RHS(1). $</span> The sum the first 1 odd integer is just 1, so we have that <span class="math align-center">$LHS(1) = 1$</span>. We also have that <span class="math align-center">$RHS(1) = 1^2 = 1$</span>.</p><p>We have that <span class="math align-center">$LHS(1) = RHS(1)$</span>. Thus <span class="math align-center">$P(1)$</span> is true, so the base case holds.</p><h4 id=inductive-step>Inductive step</h4><p>We assume the inductive hypothesis - that <span class="math align-center">$P(k)$</span> holds for some arbitrary positive integer <span class="math align-center">$k$</span>. In other words, we assume that <span class="math align-center">$LHS(k) = RHS(k)$</span> for our arbitrary <span class="math align-center">$k$</span>. We must prove that <span class="math align-center">$P(k+1)$</span> also holds &ndash; i.e., that <span class="math align-center">$LHS(k+1) = RHS(k+1)$</span>. We have that:</p><span class="math align-center">$$
LHS(k+1) = 1 + 3 + ... + (2k - 1) + (2(k + 1) - 1) \tag{1}
$$
$$
= LHS(k) + (2(k + 1) - 1) \tag{2}
$$
$$
= RHS(k) + (2(k + 1) - 1) \tag{3}
$$
$$
= k^2 + (2(k + 1) - 1) \tag{4}
$$
$$
= k^2 + 2k + 2 - 1 \tag{5}
$$
$$
= k^2 + 2k + 1 \tag{6}
$$
$$
= (k+1)^2 \tag{7}
$$
$$
= RHS(k+1) \tag{8}
$$</span><p>Thus <span class="math align-center">$LHS(k+1) = RHS(k+1)$</span>, so we have proved <span class="math align-center">$P(k+1)$</span>. The inductive step holds.</p><p><br><br></p><p>We conclude that for all positive integers <span class="math align-center">$n$</span>, <span class="math align-center">$P(n)$</span> holds &ndash; that is, that:</p><span class="math align-center">$$
\begin{aligned}
1 + 3 + ... + (2n - 1) = n^2
\end{aligned}
$$</span><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=divisibility-example>Divisibility example</h1><p>Claim: If <span class="math align-center">$n$</span> is a positive integer, then <span class="math align-center">$6^{n} - 1$</span> is divisible by 5. We will refer to this claim as <span class="math align-center">$P(n)$</span>.</p><h3 id=try-it-out>Try it out</h3><p>Before proving <span class="math align-center">$P(n)$</span> with mathematical induction, let&rsquo;s see if the property holds for some sample values. When <span class="math align-center">$n = 3$</span> we have that <span class="math align-center">$6^{3} - 1 = 216 - 1 = 215$</span>. Since <span class="math align-center">$215$</span> ends with a 5, it is clearly divisible by 5.</p><p>As another test, suppose <span class="math align-center">$n = 5$</span>. We have that <span class="math align-center">$6^{5} - 1 = 7776 - 1 = 7775$</span>, which is also divisible by 5.</p><h3 id=induction-proof>Induction proof</h3><p>We wish to use mathematical induction to prove that <span class="math align-center">$P(n)$</span> holds for all positive integers <span class="math align-center">$n$</span>. That is, that <span class="math align-center">$6^{n} - 1$</span> is divisible by 5.</p><h4 id=base-case>Base case</h4><p>We must prove that <span class="math align-center">$P(n)$</span> holds for the smallest positive integer, <span class="math align-center">$n = 1$</span>, that is, that <span class="math align-center">$6^{1} - 1$</span> is divisible by 5. We have that <span class="math align-center">$6^{1} - 1 = 6 - 1 = 5$</span> is divisible by 5, so <span class="math align-center">$P(1)$</span> is true. The base case holds.</p><h4 id=inductive-step>Inductive step</h4><p>We assume the inductive hypothesis - that <span class="math align-center">$P(k)$</span> holds for some arbitrary positive integer <span class="math align-center">$k$</span>. In other words, we assume that <span class="math align-center">$6^{k} - 1$</span> is divisible by 5 for our arbitrary <span class="math align-center">$k$</span>. We must prove that <span class="math align-center">$P(k+1)$</span> also holds &ndash; i.e., that <span class="math align-center">$6^{k+1} - 1$</span> is also divisible by 5. We have that:</p><span class="math align-center">$$
6^{k+1} - 1 = 6(6^{k}) - 1 \tag{1}
$$
$$
= 6(6^{k}) - 6 + 5 \tag{2}
$$
$$
= 6(6^{k} - 1) + 5 \tag{3}
$$</span><p>Since <span class="math align-center">$6^{k} - 1$</span> is divisible by 5 from our inductive hypothesis, any multiple of it is also divisible by 5. Thus, <span class="math align-center">$6(6^{k} - 1)$</span> is divisible by 5. Adding 5 to a number that is a multiple of 5 yields another multiple of 5. Thus <span class="math align-center">$6(6^{k} - 1) + 5$</span> is divisible by 5, we have proved <span class="math align-center">$P(k+1)$</span>. The inductive step holds.</p><p><br><br></p><p>We conclude that for all positive integers <span class="math align-center">$n$</span>, <span class="math align-center">$P(n)$</span> holds &ndash; that is, that <span class="math align-center">$6^{n} - 1$</span> is divisible by 5.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=set-example>Set example</h1><p>Claim: If <span class="math align-center">$n$</span> is a positive integer greater than or equal to 2, then a set with <span class="math align-center">$n$</span> elements has <span class="math align-center">$\dfrac{n(n-1)}{2}$</span> possible subsets of size 2. We will refer to this claim as <span class="math align-center">$P(n)$</span>.</p><h3 id=try-it-out>Try it out</h3><p>Suppose <span class="math align-center">$n = 3$</span>, and our set contains the elements <span class="math align-center">$(a, b, c)$</span>. There are 3 possible subsets of size 2: <span class="math align-center">$(a, b)$</span>, <span class="math align-center">$(a, c)$</span>, and <span class="math align-center">$(b, c)$</span>. We also have that <span class="math align-center">$\dfrac{3(3-1)}{2} = 3$</span>.</p><h3 id=induction-proof>Induction proof</h3><p>We wish to use mathematical induction to prove that <span class="math align-center">$P(n)$</span> holds for all integers <span class="math align-center">$n \geq 2$</span>. That is, that a set with <span class="math align-center">$n$</span> elements has <span class="math align-center">$\dfrac{n(n-1)}{2}$</span>possible subsets of size 2.</p><h4 id=base-case>Base case</h4><p>We must prove that <span class="math align-center">$P(n)$</span> holds for the smallest such integer, <span class="math align-center">$n = 2$</span>. We must show that a set with two elements contains <span class="math align-center">$\dfrac{2(2-1)}{2} = 1$</span> possible subsets of size 2. If a set has just two elements, then there is only one possible subset of size 2 &ndash; the subset that contains both elements. This proves <span class="math align-center">$P(2)$</span>, so the base case holds.</p><h4 id=inductive-step>Inductive step</h4><p>We assume the inductive hypothesis - that <span class="math align-center">$P(k)$</span> holds for some arbitrary integer <span class="math align-center">$k \geq 2$</span>. In other words, we assume that a set with <span class="math align-center">$k$</span> elements has <span class="math align-center">$\dfrac{k(k-1)}{2}$</span> possible subsets of size 2. We must prove that <span class="math align-center">$P(k+1)$</span> also holds &ndash; i.e., that a set with <span class="math align-center">$k + 1$</span> elements has:</p><span class="math align-center">$$
\dfrac{(k+1)((k+1)-1)}{2} = \dfrac{k(k+1)}{2}
$$</span><p>possible subsets of size 2.</p><p>Introducing a new element to a set with <span class="math align-center">$k$</span> elements yields <span class="math align-center">$k$</span> additional 2-element subsets, as the new element could pair with each of the original elements.</p><p>A set with <span class="math align-center">$k+1$</span> elements contains all the original <span class="math align-center">$\dfrac{k(k-1)}{2}$</span> size-2 elements from the size-<span class="math align-center">$k$</span> set, plus the <span class="math align-center">$k$</span> new subsets described above.</p><p>We have that:</p><span class="math align-center">$$
\dfrac{k(k-1)}{2} + k = \dfrac{k(k-1)+2k}{2}
$$
$$
= \dfrac{k(k-1+2)}{2}
$$
$$
= \dfrac{k(k+1)}{2}
$$</span><p>We have proved <span class="math align-center">$P(k+1)$</span>. Thus the inductive hypothesis holds.</p><p>We conclude that for all positive integers <span class="math align-center">$n \geq 2$</span>, <span class="math align-center">$P(n)$</span> holds &ndash; that is, that a set with <span class="math align-center">$n$</span> elements has <span class="math align-center">$\dfrac{n(n-1)}{2}$</span> possible subsets of size 2.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=intro-to-programming-logic>Intro to Programming Logic</h1><h6 id=intro-to-programming-logic-assignments-and-conditionals>Intro to Programming Logic: Assignments and Conditionals</h6><p>For the rest of the course, we will switch gears back to something more familiar for most &ndash; computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Intro to Programming Logic</h1><article class=default><header class=headline></header><h1 id=programming-logic-goal>Programming Logic Goal</h1><p>In the next three chapters, we will learn how to reason about different kinds of program structures &ndash; assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs using a toy language that is a subset of Scala. While our toy language is not used in practice, the ideas that we will see to prove program correctness &ndash; preconditions, postconditions, loop invariants, and global invariants &ndash; can be used to specify functions in ANY language.</p><p>We will see that the process for formal specifications and proofs of correctness is rather tedious, even for relatively simple programs. And in practice, proving correctness of computer programs is rarely done. So why bother studying it?</p><h2 id=safety-critical-code>Safety critical code</h2><p>One case where reasoning about correctness is certainly relevant is the arena of <em>safety critical code</em> &ndash; where lives depend on a program working correctly. Certain medical devices, such as pacemakers and continuous glucose monitors, have a software component. If that software fails, then a person could die. We can&rsquo;t test the correctness of medical devices by installing them in a human body and trying them out &ndash; instead, we need to be absolutely sure they work correctly before they are used.</p><p>Similarly, there is software in things like shuttle launches. While that might not cost lives, it&rsquo;s also a process that can&rsquo;t be fully tested beforehand. After all, no one is going to spend over a billion dollar on a &ldquo;practice&rdquo; launch. Instead, we need a way to more formally demonstrate that the software will work correctly.</p><h2 id=specifications>Specifications</h2><p>In chapter 9, we will learn to write function <em>specifications</em>. These specifications list any requirements the function has in order to work correctly (<em>preconditions</em>) and descibe the impact of calling the function (<em>postconditions</em>) - most notably, what the function returns in terms of its inputs. Even in cases where we do not formally prove correctness of a program, it is very useful to write a specification for all functions. This can make it clear to any calling code what kinds of parameters should be passed, as well as what to expect about the returned value. By providing this structure, there will be fewer surprises and unintended errors.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logika-programs>Logika Programs</h1><p>As we study program logic, we will use Logika to verify a subset of programs that use the Scala language. Specifically, we will study verification of programs with the following features:</p><ul><li>Variables (booleans, ints, and sequences [which are like arrays/lists])</li><li>Printing and user input</li><li>Math operations</li><li>Conditional operations</li><li>If and if/else statements</li><li>While loops</li><li>Functions</li></ul><p>The Scala programs we verify should be saved with a .sc extension. To show we are using Logika for verification, the first line of the file should be:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika</span></span></code></pre></div><h2 id=verifying-logika-programs>Verifying Logika programs</h2><p>There are two modes in Logika &ndash; manual and automatic. In chapters 8 and 9, we will use manual mode. In chapter 10, we will use automatic mode. You will designate the verification mode on the second line of the Scala file (just below <code>// #Sireum #Logika</code>). To specify manual mode, you will write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//@Logika: --manual --background save</span></span></code></pre></div><p>And to specify automatic mode, you will delete the <code>--manual</code> from above, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//@Logika: --background save</span></span></code></pre></div><p>Logika verification <em>should</em> run automatically as you edit these programs and their proofs. If a program is verified, you will see a purple checkmark in the lower right corner just as you did in propositional and predicate logic proofs. If there are syntax or logic errors, you will see them highlighted in red.</p><p>Sometimes, the Logika verification needs to be run manually. If you don&rsquo;t see either red errors or a purple checkmark, right-click in the text area that contains the code and select &ldquo;Logika Check (All in File)&rdquo;.</p><h2 id=example-programs>Example programs</h2><p>This section contains four sample Scala programs that highlight the different language features that we will work with.</p><h3 id=example-1-user-input-printing-operations>Example 1: User input, printing, operations</h3><p>This first example gets a number as input from the user, adds one to it, and prints the result:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = Z.prompt(&#34;Enter a number: &#34;)
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(&#34;One more is &#34;, x)</span></span></code></pre></div><p>A few things to note:</p><ul><li>After the two comment lines to show we are using the Logika verification tool in manual mode, our program begins with an import statement: <code>import org.sireum._</code></li><li>The <code>var</code> keyword stands for variable, which is something that can be changed. Logika also has a <code>val</code> keyword, which creates a constant value that cannot be changed.</li><li>Lines do not end in semi-colons</li><li>The <code>Z.prompt(...)</code> function prints a prompt and returns the integer (<code>Z</code>) that was typed. The parameter to this function is the desired prompt. Alternately, the <code>Z.read()</code> function gets and returns an integer from user input without taking a prompt.</li><li>The code <code>var x: Z</code> creates a variable called <code>x</code> of type <code>Z</code> &ndash; as with the user input functions, the <code>Z</code> means <em>integer</em></li></ul><h3 id=example-2-ifelse-statements>Example 2: If/else statements</h3><p>Here is a Scala program that gets a number from the user, and uses an if/else statement to print whether the number is positive or negative/zero:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = Z.prompt(&#34;Enter a number: &#34;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (num &gt; 0) {
</span></span><span style=display:flex><span>    println(num, &#34; is positive&#34;)
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    println(num, &#34; is negative (or zero)&#34;)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>A couple of things to note here:</p><ul><li>The <code>else</code> statement MUST appear on the same line as the closing <code>}</code> of the previous if-statement</li><li>As mentioned above, the <code>val</code> keyword in this program means that <code>num</code> cannot be changed after being initialized</li></ul><h3 id=example-3-while-loops>Example 3: While loops</h3><p>Our next program uses a while loop to print the numbers from 10 down to 1:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var cur: Z = 10
</span></span><span style=display:flex><span>while (cur &gt;= 1) {
</span></span><span style=display:flex><span>  println(&#34;Next number: &#34;, cur)
</span></span><span style=display:flex><span>  cur = cur - 1
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=example-4-sequences-and-functions>Example 4: Sequences and functions</h3><p>Our final sample program demonstrates <em>sequences</em> (similar to an array or list) and functions. It contains a function, <code>sumSequence</code>, which takes a sequence of integers as a parameter and returns the sum of the numbers in the sequence. At the bottom, we can see our test code that creates a sample sequence and tries calling <code>sumSequence</code>. If you create this file, you will see an error about the sequence indices possibly being negative &ndash; this code cannot be run without some verification work:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def sumSequence(seq: ZS) : Z = {
</span></span><span style=display:flex><span>  var sum: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  var i: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  while (i &lt; seq.size) {
</span></span><span style=display:flex><span>    sum = sum + seq(i)
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////// Calling code ////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val list: ZS = ZS(1,2,3,4)
</span></span><span style=display:flex><span>val total: Z = sumSequence(list)
</span></span><span style=display:flex><span>println(&#34;Sum of elements:&#34;, total)</span></span></code></pre></div><p>A few things of note here:</p><ul><li><p>The definition <code>def sumSequence(seq: ZS) : Z</code> means that a function named <code>sumSequence</code> takes a parameter of type <code>ZS</code> (sequence of integers, <code>Z</code> = int and <code>S</code> = sequence) and returns something of type <code>Z</code> (int)</p></li><li><p>There is an <code>=</code> after the function header but before the opening <code>{</code> of the function</p></li><li><p>These functions are not part of a class - they are more similar to the structure in Python. We can include as many functions as we want in a file. At the bottom of the file (marked below the optional <code>////// Calling code ////////////</code>) is the <em>calling code</em>. When a Logika program runs, those calling code lines (which may call different functions) are executed. When the calling code lines are done, the program is done.</p></li></ul><h2 id=logika-program-proof-syntax>Logika program proof syntax</h2><p>In order to prove correctness of these Scala programs, we will add <em>Deduce blocks</em> to process what we have learned at different points in the program. In general, every time there is an assignment statement, there will be a following <code>Deduce</code> proof block updating all relevant facts.</p><h3 id=necessary-import-statements>Necessary import statements</h3><p>We have already seen that we must include the import statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>import org.sireum._</span></span></code></pre></div><p>Anytime we want to do anything with the Logika proof checker. There are three other import statements that you will commonly use:</p><ol><li><code>import org.sireum.justification._</code> is needed for any Deduce statements and basic justifications (<code>Premise</code>, etc.)</li><li><code>import org.sireum.justification.natded.prop._</code> is needed for any propositional logic justifications</li><li><code>import org.sireum.justification.natded.pred._</code> is needed for any predicate logic justifications</li></ol><h3 id=deduce-block>Deduce block</h3><p>Here is the syntax for a Deduce proof block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    claim       ) by Justification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Just as with our propositional and predicate logic proofs, we will number the lines in our proof blocks. Each line will contain a <em>claim</em> and a corresponding <em>justification</em> for that claim. We will still be able to use all of our propositional and predicate logic deduction rules, but we will learn new justifications for processing program statements. Each program may have multiple of these proof blocks to process each assignment statement.</p><h3 id=premise-justification>Premise justification</h3><p>Our first justification in programming logic is <em>Premise</em>. In a Deduce proof block, we use <code>Premise</code> as a justification in the following cases:</p><ul><li><p>To express an assignment statement (or other program statement)</p></li><li><p>To pull a claim established in a previous proof block into a later proof block</p></li></ul><p>In both cases, the claim must capture the current value of the involved variables.</p><p>For example, consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>x = x + 1</span></span></code></pre></div><p>We could insert a proof block between the two lines to express that <code>x</code> currently has the value 6:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6  ) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1</span></span></code></pre></div><p>But we could NOT have the same proof block after incrementing <code>x</code>, since <code>x</code>&rsquo;s value has changed since that claim was established:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this proof block is correct -- it captures the current value of x
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6  ) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//NO! This statement no longer captures the current value of x
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6  ) by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h3 id=using-previous-deduction-rules>Using previous deduction rules</h3><p>We can use any of our previous deduction rules in a Logika proof block. For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 7
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6                ) by Premise,
</span></span><span style=display:flex><span>  2 (   y == 7                ) by Premise,
</span></span><span style=display:flex><span>  3 (   (x == 6) âˆ§ (y == 7)   ) by AndI(1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=assert-and-assume>Assert and Assume</h1><h2 id=assert-statements>Assert statements</h2><p>An <em>assert</em> statement in Scala uses the syntax <code>assert(expression)</code>, where <code>expression</code> is of type <code>bool</code>. The assert passes if the expression is true, and throws an error if the expression is false.</p><p>Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven.</p><p>Note that we are using these assert statements differently than assert statements in languages like Java and C# &ndash; in those languages, the code in the assert statement (which often includes test method calls) is actually run, and the assert statement checks whether those methods are returning the expected values. In Logika, assert statements only pass if we have previously PROVED what we are claiming &ndash; the code is never executed.</p><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 6
</span></span><span style=display:flex><span>val z: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert (x == y &amp; y &gt; z)</span></span></code></pre></div><p>While we can tell that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>, this code would fail in Logika (at least in its manual mode, which is what we are using now). In order for an assert to pass, we must have already proved EXACTLY the statement in the assert.</p><p>Why do WE know that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>? From looking at the code! We can tell that <code>x</code> and <code>y</code> are given the same value (6), and that <code>y</code>&rsquo;s value of 6 is bigger than <code>z</code>&rsquo;s value of 4.</p><p>So far, we know we can pull in the values of each variable as premises, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 6
</span></span><span style=display:flex><span>val z: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (x == 6) by Premise,
</span></span><span style=display:flex><span>    2  (y == 6) by Premise,
</span></span><span style=display:flex><span>    3  (z == 4) by Premise,
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    //how to say that x and y are equal, and that y is bigger than z?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>assert(x == y âˆ§ y &gt; z)</span></span></code></pre></div><p>But we don&rsquo;t yet know how to justify claims that describe how variables compare to one another. We will learn how to do that with the <code>Algebra</code> and <code>Subst</code> rules in section 8.4.</p><h3 id=using-conditional-operators>Using conditional operators</h3><p>Notice that the program above used an <code>âˆ§</code> symbol for an AND operator in an assert statement. As with our propositional logic proofs, if we want to use a <code>âˆ§</code> operator then we type the symbol <code>&</code>. This <code>&</code> is automatically changed to a <code>âˆ§</code> when we view our program, just as it was in our deduction proofs. Similarly, we type <code>!</code> for NOT in asserts (which displays as <code>Â¬</code>) and <code>|</code> for OR (which displays as <code>âˆ¨</code>). However, we are not able to use an implies operator in an assert statement as it is not part of the Scala language (and our asserts are part of the program and not just a proof element).</p><p>If we wanted to write an assert statement that would be true when some variable <code>p</code> was even and/or was a positive two-digit number, we could say:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(p % 2 == 0 âˆ¨ (p &gt; 9 âˆ§ p &lt; 100))</span></span></code></pre></div><p>As was mentioned above, the implies operator is not available in assert statements. However, we can make use of one of the equivalences we learned about in section 3.4: that <code>p â†’ q</code> is equivalent to <code>Â¬p âˆ¨ q</code>. So if we wanted to assert that if <code>p</code> was positive, then <code>q</code> was equal to <code>p</code>, then we could write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//expressing the implicaton ((p &gt; 0) â†’ (q == p))
</span></span><span style=display:flex><span>assert(Â¬(p &gt; 0) âˆ¨ (q == p))</span></span></code></pre></div><p>Or, equivalently, we could write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert((p &lt;= 0) âˆ¨ (q == p))</span></span></code></pre></div><h2 id=assume-statement>Assume statement</h2><p>An <em>assume</em> statement in Scala uses the syntax <code>assume(expression)</code>. If the expression is satisfiable, then we can use <code>expression</code> as a premise in the following Logika proof block.</p><h3 id=assume-example>Assume example</h3><p>For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var a: Z = Z.read()
</span></span><span style=display:flex><span>assume (a &gt; 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (a &gt; 0)   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Assume statements are almost always used to make assumptions about user input. Perhaps our program only works correctly for certain values of input. If we can assume that the user really did enter acceptable values, then we can use that information (by pulling it in as a premise in the next proof block) to prove the correctness of the program based on that assumption.</p><h3 id=assumes-vs-wrapping-if-statements>Assumes vs. wrapping if-statements</h3><p>Toy programs often use assume in lieu of wrapping code in an if statement. The following two examples are equivalent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a : Z = Z.read()
</span></span><span style=display:flex><span>assume (a != 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1  (a != 0) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var b: Z = 20 / a</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//...is equivalent to:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a : Z = Z.read()
</span></span><span style=display:flex><span>var b : Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (a != 0) {
</span></span><span style=display:flex><span>    b = 20 / a
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>These examples also demonstrate a requirement when we use the division operator in Logika programs, we must first demonstrate that we are not dividing by zero.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=algebra-and-subst-rules>Algebra and Subst Rules</h1><p>In this section, we will learn our first two proof rules for programming logic &ndash; <code>Algebra</code> and <code>Subst</code>.</p><h2 id=verifying-simple-programs>Verifying simple programs</h2><p>Before we delve into our new proof rules, let&rsquo;s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the <code>// --></code> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>get user input / set initial variable values
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add assume statements to specify what must be true about the input
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program statement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program statement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program statement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(...more program statements)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add assert statements to express what our program did</span></span></code></pre></div><p>We see that if our program involves user input, then we must consider whether our program will only work correctly for certain input values. In that situation, we express our assumptions using <code>assume</code> statements.</p><p>After each program statement, we must add a proof block to evaluate what changed on that line of code. We will see more details on these proof blocks throughout the rest of this chapter. Recall that the syntax for those proof blocks looks like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //@formatter:off
</span></span><span style=display:flex><span>    1  (    claim       ) by Justification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    //@formatter:on
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Finally, we add one or more <code>assert</code> statements to express what our program did. These are usually placed at the end of a program, but sometimes we have assert statements throughout the program to describe the progress up to that point.</p><h2 id=algebra-justification>Algebra justification</h2><p>The <code>Algebra*</code> justification can be used for ANY algebraic manipulation on previous claims. When using this justification, include all relevant proof line numbers in whatever order (you might use as few as zero line numbers or as many as 3+ line numbers).</p><h3 id=example>Example</h3><p>Consider this example (which eliminates the Logika mode notation and the necessary import statements):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>var y: Z = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert (y == 6)</span></span></code></pre></div><p>Following our process from above, we add proof blocks after each program statement. In these proof blocks, we start by listing the previous program statement as a premise:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    x == 6      )   by Premise,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var y: Z = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    y == x      )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //need claim &#34;y == 6&#34; for our assert to hold
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert (y == 6)</span></span></code></pre></div><p>For our assert to hold, we must have EXACTLY that claim in a previous proof block &ndash; so we know we want our second proof block to include the claim <code>y == 6</code>.</p><p>Here is the program with the second proof block completed &ndash; the assert statement will now hold.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    x == 6      )   by Premise,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var y: Z = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     y == x      )   by Premise,
</span></span><span style=display:flex><span>    2 (     x == 6      )   by Premise,         //established in a previous proof block, and x is unchanged since then
</span></span><span style=display:flex><span>    3 (     y == 6      )   by Algebra*(1, 2)   //we know y is 6 using the claims from lines 1 and 2
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will now hold yet
</span></span><span style=display:flex><span>assert (y == 6)</span></span></code></pre></div><p>We could have also deleted the first proof block in this example. We would still be able to claim <code>x == 6</code> as a premise in the last proof block, as <code>x</code> had not changed since being given that value.</p><h2 id=subst_-and-subst_>Subst_&lt; and Subst_></h2><p>We have two deduction rules that involve substitution &ndash; <code>Subst_&lt;</code> and <code>Subst_></code>. Both of these rules are similar to the find/replace feature in text editors. They preserve truth by replacing one proposition with an equivalent one.</p><p>The <code>Algebra*</code> justification will work for most mathematical manipulation. However, it will not work for any claim involving <code>âˆ§</code>, <code>âˆ¨</code>, <code>â†’</code>, <code>F</code>, <code>âˆ€</code>, <code>âˆƒ</code> &ndash; in those cases, we will be required to use substitution instead.</p><h3 id=subst_-justification>Subst_&lt; justification</h3><p>Here is the syntax for the <code>Subst_&lt;</code> rule. In the example below, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    m (     LHS_M == RHS_M  )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    n (     LINE_N          )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    p (     claim           )   by Subst_&lt;(m, n),
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p><code>(claim)</code> rewrites <code>LINE_N</code> by substituting all occurrences of <code>RHS_M</code> with <code>LHS_M</code>. The <code>_&lt;</code> part of the justification name indicates the direction of the find/replace. You can think of it as <code>LHS_M &lt;- RHS_M</code> (showing that <code>RHS_M</code> is coming in for each <code>LHS_M</code>). Here is an example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x + 1 == y - 4                          )   by SomeJustification,
</span></span><span style=display:flex><span>    2 (     x*(x + 1) == (x + 1) + y                )   by SomeJustification,
</span></span><span style=display:flex><span>    3 (     x*(y - 4) == (y - 4) + y                )   by Subst_&lt;(1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We wrote line 3 by replacing each occurence of <code>x + 1</code> with <code>y - 4</code>.</p><h3 id=subst_-justification-1>Subst_> justification</h3><p>Here is the syntax for the <code>Subst_></code> rule. Just as with <code>Subst_&lt;</code>, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    m (     LHS_M == RHS_M  )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    n (     LINE_N          )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    p (     claim           )   by Subst_&gt;(m, n),
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, <code>(claim)</code> rewrites <code>LINE_N</code> by substituting all occurrences of <code>LHS_M</code> with <code>RHS_M</code>. We can think of it as indicating <code>LHS_M -> RHS_M</code> (showing that <code>LHS_M</code> is coming in for each <code>RHS_M</code>). Here is an example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x + 1 == y                      )   by SomeJustification,
</span></span><span style=display:flex><span>    2 (     x*y == (x + 1) + y              )   by SomeJustification,
</span></span><span style=display:flex><span>    3 (     x*(x + 1) == (x + 1) + x + 1    )   by Subst_&gt;(1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We wrote line 3 by replacing each occurence of <code>y</code> with <code>x + 1</code>. Note that we put parentheses around our first replacement to ensure a product equivalent to the original statement.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=assignment-statements>Assignment Statements</h1><p>Assignment statements in a program come in two forms &ndash; with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.</p><p>For example, an increment statement like <code>x = x + 1</code> MUTATES the value of <code>x</code> by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of <code>x</code>.</p><p>In contrast, a statement like <code>y = x + 1</code> assigns to <code>y</code> one more than the value in <code>x</code>. We do not need to know the previous value of <code>y</code>, as we are not using it in the assignment statement. (We do need to know the value of <code>x</code>).</p><h2 id=assignments-without-mutation>Assignments without mutation</h2><p>We have already seen the steps necessary to process assignment statements that do not involve variable mutation. Recall that we can declare as a <code>Premise</code> any assignment statement or claim from a previous proof block involving variables that have not since changed.</p><p>For example, suppose we want to verify the following program so the assert statement at the end will hold (this example again eliminates the Logika mode notation and the necessary import statements, which we will continue to do in subsequent examples):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val y: Z = x + 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val z: Z = 10 - x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the assert will not hold yet
</span></span><span style=display:flex><span>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Since none of the statements involve variable mutation, we can do the verification in a single proof block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 4    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val y: Z = x + 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val z: Z = 10 - x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 4          )   by Premise,     //assignment of unchanged variable
</span></span><span style=display:flex><span>    2 (     y == x + 2      )   by Premise,     //assignment of unchanged variable
</span></span><span style=display:flex><span>    3 (     z == 10 - x     )   by Premise,     //assignment of unchanged variable
</span></span><span style=display:flex><span>    4 (     y == 4 + 2      )   by Subst_&lt;(1, 2),
</span></span><span style=display:flex><span>    5 (     z == 10 - 4     )   by Subst_&lt;(1, 3),
</span></span><span style=display:flex><span>    6 (     y == 6          )   by Algebra*(4),
</span></span><span style=display:flex><span>    7 (     z == 6          )   by Algebra*(5),
</span></span><span style=display:flex><span>    8 (     y == z          )   by Subst_&gt;(7, 6),
</span></span><span style=display:flex><span>    9 (     y == z âˆ§ y == 6 )   by AndI(8, 6)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now the assert will hold
</span></span><span style=display:flex><span>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Note that we did need to do <code>AndI</code> so that the last claim was <code>y == z âˆ§ y == 6 </code>, even though we had previously established the claims <code>y == z</code> and <code>y == 6</code>. In order for an assert to hold (at least until we switch Logika modes in chapter 10), we need to have established EXACTLY the claim in the assert in a previous proof block.</p><h2 id=assignments-with-mutation>Assignments with mutation</h2><p>Assignments with mutation are trickier &ndash; we need to know the old value of a variable in order to reason about its new value. For example, if we have the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert(x == 5)</span></span></code></pre></div><p>Then we might try to add the following proof blocks:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 4      )   by Premise  //from previous variable assignment
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == x + 1  )   by Premise, //NO! Need to distinguish between old x (right side) and new x (left side)
</span></span><span style=display:flex><span>    2 (     x == 4      )   by Premise, //NO! x has changed since this claim
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert(x == 5)</span></span></code></pre></div><p>&mldr;but then we get stuck in the second proof block. There, <code>x</code> is supposed to refer to the CURRENT value of <code>x</code> (after being incremented), but both our attempted claims are untrue. The current value of <code>x</code> is not one more than itself (this makes no sense!), and we can tell from reading the code that <code>x</code> is now 5, not 4.</p><p>To help reason about changing variables, Logika has a special <code>Old(varName)</code> function that refers to the OLD value of a variable called <code>varName</code>, just before the latest update. In the example above, we can use <code>Old(x)</code> in the second proof block to refer to <code>x</code>&rsquo;s value just before it was incremented. We can now change our premises and finish the verification as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 4      )   by Premise  //from previous variable assignment
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == Old(x) + 1     )   by Premise, //Yes! x equals its old value plus 1
</span></span><span style=display:flex><span>    2 (     Old(x) == 4         )   by Premise, //Yes! The old value of x was 4
</span></span><span style=display:flex><span>    3 (     x == 4 + 1          )   by Subst_&lt;(2, 1),
</span></span><span style=display:flex><span>    4 (     x == 5              )   by Algebra*(3)  //Could have skipped line 3 and used &#34;Algebra*(1, 2)&#34; instead
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now the assert will hold
</span></span><span style=display:flex><span>assert(x == 5)</span></span></code></pre></div><p>By the end of the proof block following a variable mutation, we need to express everything we know about the variable&rsquo;s current value WITHOUT using the <code>Old</code> terminology, as its scope will end when the proof block ends. Moreover, we only ever have one <code>Old</code> value available in a proof block &ndash; the variable that was most recently changed. This means we will need proof blocks after each variable mutation to process the changes to any related facts.</p><h2 id=variable-swap-example>Variable swap example</h2><p>Suppose we have the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val temp: Z = x
</span></span><span style=display:flex><span>x = y
</span></span><span style=display:flex><span>y = temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//what do we want to assert we did?</span></span></code></pre></div><p>We can see that this program gets two user input values, <code>x</code> and <code>y</code>, and then swaps their values. So if <code>x</code> was originally 4 and <code>y</code> was originally 6, then at the end of the program <code>x</code> would be 6 and <code>y</code> would be 4.</p><p>We would like to be able to assert what we did &ndash; that <code>x</code> now has the original value from <code>y</code>, and that <code>y</code> now has the original value from <code>x</code>. To do this, we might invent dummy constants called <code>xOrig</code> and <code>yOrig</code> that represent the original values of those variables. Then we can add our assert:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the original values of both inputs
</span></span><span style=display:flex><span>val xOrig: Z = x
</span></span><span style=display:flex><span>val yOrig: Z = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val temp: Z = x
</span></span><span style=display:flex><span>x = y
</span></span><span style=display:flex><span>y = temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//x and y have swapped
</span></span><span style=display:flex><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style=display:flex><span>assert(x == yOrig âˆ§ y == xOrig)     //this assert will not yet hold</span></span></code></pre></div><p>We can complete the verification by adding proof blocks after assignment statements, being careful to update all we know (without using the <code>Old</code> value) by the end of each block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the original values of both inputs
</span></span><span style=display:flex><span>val xOrig: Z = x
</span></span><span style=display:flex><span>val yOrig: Z = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     xOrig == x  )   by Premise,
</span></span><span style=display:flex><span>    2 (     yOrig == y  )   by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//swap x and y
</span></span><span style=display:flex><span>val temp: Z = x
</span></span><span style=display:flex><span>x = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == y              )   by Premise,     //from the assignment statement
</span></span><span style=display:flex><span>    2 (     temp == Old(x)      )   by Premise,     //temp equaled the OLD value of x
</span></span><span style=display:flex><span>    3 (     xOrig == Old(x)     )   by Premise,     //xOrig equaled the OLD value of x
</span></span><span style=display:flex><span>    4 (     yOrig == y          )   by Premise,     //yOrig still equals y
</span></span><span style=display:flex><span>    5 (     temp == xOrig       )   by Algebra*(2, 3),
</span></span><span style=display:flex><span>    6 (     x == yOrig          )   by Algebra*(1, 4)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>y = temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     y == temp           )   by Premise,     //from the assignment statement
</span></span><span style=display:flex><span>    2 (     temp == xOrig       )   by Premise,     //from the previous proof block (temp and xOrig are unchanged since)
</span></span><span style=display:flex><span>    3 (     yOrig == Old(y)     )   by Premise,     //yOrig equaled the OLD value of y
</span></span><span style=display:flex><span>    4 (     y == xOrig          )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>    5 (     x == yOrig          )   by Premise,     //from the previous proof block (x and yOrig are unchanged since)  
</span></span><span style=display:flex><span>    6 (     x == yOrig âˆ§ y == xOrig )   by AndI(5, 4)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//x and y have swapped
</span></span><span style=display:flex><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style=display:flex><span>assert(x == yOrig âˆ§ y == xOrig)     //this assert will hold now</span></span></code></pre></div><p>Notice that in each proof block, we express as much as we can about all variables/values in the program. In the first proof block, even though <code>xOrig</code> and <code>yOrig</code> were not used in the previous assignment statement, we still expressed how the current values our other variables compared to <code>xOrig</code> and <code>yOrig</code>. It helps to think about what you are trying to claim in the final assert &ndash; since our assert involved <code>xOrig</code> and <code>yOrig</code>, we needed to relate the current values of our variables to those values as we progressed through the program.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=integer-division-and-modulo>Integer Division and Modulo</h1><p>We will see in this section that verifying programs with division and modulo requires extra care.</p><h2 id=division>Division</h2><p>Recall that <code>Z</code> (int) is the only numeric type for Logika verification, so any division is integer division. This means something like <code>9/2</code> evaluates to 4, just as it would in Java or C#.</p><h3 id=check-for-division-by-zero>Check for division by zero</h3><p>Before doing division of the form <code>numerator/denominator</code>, either in a line of code or in a proof block, you must have have shown in a previous proof block that <code>denominator</code> is not 0. The easiest way to do this is to prove the claim: <code>denominator != 0</code>. You are even required to do this when dividing by a constant value that is obviously not zero.</p><p>For example, if we do:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 10 / 2</span></span></code></pre></div><p>Then Logika will give us an error complaining we have not proved that the denominator is not zero. We must add the claim <code>2 != 0</code> as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    2 != 0      )   by Algebra*()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 10 / 2</span></span></code></pre></div><p>Note that our justification is just, <code>Algebra*()</code>, as we don&rsquo;t need any extra information to claim that 2 is not equal to 0.</p><p>We could have instead claimed that 2 > 0 (again using <code>Algebra*()</code>), which would also prove that the denominator was not 0. However, claims such as <code>2 > 1</code> would not be accepted as proof that the denominator wasn&rsquo;t 0 (at least in Logika&rsquo;s manual mode).</p><h3 id=pitfalls>Pitfalls</h3><p>Be careful when making claims that involve division. For example, the following claim will not validate in Logika:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    x == (x/3)*3    )   by Algebra*()
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>While the claim <code>x == (x/3)*3</code> is certainly true in math, it is not true with integer division. For example, if <code>x</code> is 7, then <code>(x/3)*3</code> is 6 &ndash; so the two sides are not equal. In general, I recommend avoiding claims involving division if you can at all help it. Instead, try to find a way to express the same idea in a different way using multiplication.</p><h2 id=modulo>Modulo</h2><p>Modulo (%) works the same way in Scala (and Logika) as it does in other programming languages. For example, <code>20 % 6</code> evaluates to 2.</p><h3 id=modulo-checks-on-denominator>Modulo checks on denominator</h3><p>Before using the modulo operator in the form <code>numerator % denominator</code>, either in a line of code or as a claim in a proof block, you must have previously established one of the following:</p><ul><li><code>denominator != 0</code></li><li><code>denominator > 0</code></li></ul><p>This must be done even if the denominator is a literal value (like 2), and can be demonstrated in the same way as we did with division.</p><p>For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    7 != 0      )   by Algebra*()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = a % 7</span></span></code></pre></div><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.prompt(&#34;Enter positive number: &#34;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assume(num &gt; 0)
</span></span><span style=display:flex><span>val orig: Z = num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num * 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num + 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num/2 - 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num == orig)</span></span></code></pre></div><p>It can often be handy to walk through a program with sample numbers before trying to prove its correctness:</p><ul><li>Suppose our input value, <code>num</code>, is 11</li><li><code>orig</code> is initialized to be 11 also</li><li><code>num</code> is multiplied by 2, and is 22</li><li>It makes sense that <code>num</code> would be even, since any number times two is always even (and indeed, 22 is even)</li><li>We add 2 to <code>num</code>, so it is now 24</li><li>It makes sense that <code>num</code> would still be even, as it was even before and we added 2 (another even number) to it. Indeed, 24 is still even.</li><li>We update <code>num</code> by dividing it by 2 and subtracting 1, so <code>num</code> is now back to its original value of 11 (the same as <code>orig</code>). This step &ldquo;undoes&rdquo; the changes we have made to <code>num</code> &ndash; looking at the code, we can see that the final value of <code>num</code> is <code>orig*2 + 2</code>, so if we do <code>(orig*2 + 2) / 2 - 1</code>, we are left with <code>orig</code>.</li></ul><p>Here is the completed verification, with comments at each step:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.prompt(&#34;Enter positive number: &#34;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assume(num &gt; 0)
</span></span><span style=display:flex><span>val orig: Z = num
</span></span><span style=display:flex><span>num = num * 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    num == Old(num) * 2     )   by Premise,         //we updated num to be its old value times 2
</span></span><span style=display:flex><span>    2  (    orig == Old(num)        )   by Premise,         //orig equaled the old value of num (before our change)
</span></span><span style=display:flex><span>    3  (    num == orig * 2         )   by Algebra*(1, 2),  //express the new value of num without referring to &#34;Old&#34;
</span></span><span style=display:flex><span>    4  (    2 != 0                  )   by Algebra*(),      //needed to use modulo in the assert
</span></span><span style=display:flex><span>    5  (    num % 2 == 0            )   by Algebra*(1)      //we have showed num is now even (needed for next assert)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num + 2 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    num == Old(num) + 2     )   by Premise,         //we updated num to be its old value plus 2
</span></span><span style=display:flex><span>    2  (    Old(num) % 2 == 0       )   by Premise,         //from line 5 in previous block, but num has since changed
</span></span><span style=display:flex><span>    3  (    num % 2 == 0            )   by Algebra*(1, 2),  //we have showed num is still even (needed for next assert)
</span></span><span style=display:flex><span>    4  (    Old(num) == orig * 2    )   by Premise,         //from line 3 in block above, but num has since changed
</span></span><span style=display:flex><span>    5  (    num - 2 == orig * 2     )   by Algebra*(1, 4)   //express new value of num without using &#34;Old&#34;
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//we have already established that 2!= 0, which is needed to divide by 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num/2 - 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    num == Old(num) / 2 - 1         )   by Premise,         //we updated num to be its old value divided by 2 minus 1
</span></span><span style=display:flex><span>    2  (    Old(num) - 2 == orig * 2        )   by Premise,         //from line 7 in previous block, but num has since changed
</span></span><span style=display:flex><span>    3  (    Old(num) == orig * 2 + 2        )   by Algebra*(2),
</span></span><span style=display:flex><span>    4  (    num == (orig * 2 + 2) / 2 - 1   )   by Algebra*(1, 3),  //express new value of num without using &#34;Old&#34;
</span></span><span style=display:flex><span>    5  (    num == orig + 1 - 1             )   by Algebra*(4),
</span></span><span style=display:flex><span>    6  (    num == orig                     )   by Algebra*(5)      //we have showed num is back to being orig (needed for last assert)
</span></span><span style=display:flex><span>                                                                    //could have skipped straight here with &#34;Algebra*(1,2)&#34;
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num == orig)</span></span></code></pre></div><p>Sometimes it can be tricky to figure out what to do at each step in order to get assert statements to pass. If you are unsure what to do, I recommend:</p><ul><li><p>Walk through the program several times with sample numbers, keeping track of changes to variables. Why do the assert statements make sense to you? Convince yourself that they are valid claims before you worry about the formal verification.</p></li><li><p>Add a proof block after each variable mutation. Work from the top down:</p><ul><li>Write a premise for every variable assignment and assume statement since the previous proof block.</li><li>Find all claims in the proof block just before you that do not use an &ldquo;Old&rdquo; reference &ndash; pull each claim into your current block, using an &ldquo;Old&rdquo; reference as needed for the most recently changed variable.</li><li>Manipulate your claims that use an &ldquo;Old&rdquo; reference until you have statements that capture the current value of the recently changed variable that do not reference &ldquo;Old&rdquo;</li><li>If your next statement is an assert, manipulate your claims until you have exactly the claim in the assert.</li><li>If any claims</li></ul></li><li><p>Add a proof block before each use of division (<code>numerator / denominator</code>) and modulus (<code>numerator % denominator</code>). Pull in claims from previous blocks as described above to help you show the claim <code>denominator != 0</code>. If you can, avoid using division in proof block claims.</p></li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=conditional-statements>Conditional Statements</h1><p>To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. We will only consider programs with an if/else as opposed to an if/else if. However, you can simulate more than two branches by nesting another if/else inside the outer else.</p><h2 id=motivation>Motivation</h2><p>Before we formalize the details of verifying a program with a conditional statement, let&rsquo;s motivate the topic with an example.</p><h3 id=max-program>Max program</h3><p>Suppose we have a program that finds finds the maximum (<code>max</code>) between two user input numbers (<code>x</code> and <code>y</code>):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var max: Z = 0  //give max a dummy starting value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (x &gt; y) {
</span></span><span style=display:flex><span>    max = x
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    max = y
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=max-assert>Max assert</h3><p>Before worrying about how to do the verification, let&rsquo;s consider what we should assert at the end in order to be sure that <code>max</code> really does hold the biggest of the two inputs. Clearly, <code>max</code> should be greater than or equal to both inputs. So should our assert be:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//Not quite all we want to say
</span></span><span style=display:flex><span>assert(max &gt;= x âˆ§ max &gt;= y)</span></span></code></pre></div><p>Suppose <code>x</code> was 10, <code>y</code> was 15&mldr;and that <code>max</code> was 20. (Clearly this isn&rsquo;t what our code would do, but you can imagine writing something else for the max code that came up with such a calculation). In this case, <code>max</code> is indeed greater than or equal to both inputs&mldr;but it is just as clearly not the max. We know see that we also need to claim that <code>max</code> equals one of the two inputs. This makes our assert:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//Now we are sure we are describing the max between x and y
</span></span><span style=display:flex><span>assert(max &gt;= x âˆ§ max &gt;= y âˆ§ (max == x âˆ¨ max == y))</span></span></code></pre></div><h3 id=analyzing-max>Analyzing max</h3><p>Now, we need to prove that our assert holds no matter which branch we follow in the conditional statement. First, when we analyze the code in the if-branch, we have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     max == x    )   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>and when we analyze the code in the else-branch, we have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>max = y
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     max == y    )   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>These two deductions imply that, when the if/else statements finishes, one or the other property holds true:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (x &gt; y) {
</span></span><span style=display:flex><span>    max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == x    )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    max = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == y    )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style=display:flex><span>    1 (     max == x  v  max == y   )   by Premise 
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>This illustrates the first principle of conditional commands: the knowledge produced by the command is the disjunction (or) of the knowledge produced by each branch. In the section on propositional logic, we covered how to apply cases analyses on disjunctive assertions to extract useful knowledge.</p><p>Recall that the intent of the if/else statement was to set <code>max</code> so that it holds the larger of <code>x</code> and <code>y</code>, so that our assert would hold:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(max &gt;= x âˆ§ max &gt;= y âˆ§ (max == x v max == y))</span></span></code></pre></div><p>The claim we proved so far satisifies the second part of our assert statement, but not the first part. This is because we ignored a critical feature of an if/else statement: By asking a question â€” the condition â€” the if/else statement generates new knowledge.</p><p>For the if-branch, we have the new knowledge that <code>x > y</code>; for the else-branch, we have that <code>Â¬(x > y)</code>, that is, <code>y >= x</code>. We can embed these assertions into the analysis of the conditional command, like this, and conclude that, in both cases, <code>max</code> is greater than or equal to both inputs:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var max: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (x &gt; y) {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     x &gt; y       )   by Premise      //the condition is true
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == x    )   by Premise,    //from the &#34;max = x&#34; assignment
</span></span><span style=display:flex><span>        2 (     max &gt;= x    )   by Algebra*(1),
</span></span><span style=display:flex><span>        3 (     x &gt; y       )   by Premise,    //condition is still true (x and y are unchanged)
</span></span><span style=display:flex><span>        4 (     max &gt;= y    )   by Algebra*(1,3)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Â¬(x &gt; y)    )   by Premise,    //the condition is NOT true
</span></span><span style=display:flex><span>        2 (     x &lt;= y      )   by Algebra*(2)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max = y
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == y    )   by Premise,    //from the &#34;max = y&#34; assignment
</span></span><span style=display:flex><span>        2 (     x &lt;= y      )   by Premise,    //pulled down from previous proof block (x and y are unchanged)
</span></span><span style=display:flex><span>        3 (     max &gt;= x    )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>        4 (     max &gt;= y    )   by Algebra*(1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//summary of what just happened
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style=display:flex><span>    1 (     max == x âˆ¨ max == y )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 (     max &gt;= x            )   by Premise,     //true in BOTH branches
</span></span><span style=display:flex><span>    3 (     max &gt;= y            )   by Premise,     //true in BOTH branches
</span></span><span style=display:flex><span>    4 (     max &gt;= x âˆ§ max &gt;= y )   by AndI(2, 3),
</span></span><span style=display:flex><span>    5 (     max &gt;= x âˆ§ max &gt;= y) âˆ§ (max == x âˆ¨ max == y )   by AndI(4, 1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(max &gt;= x âˆ§ max &gt;= y âˆ§ (max == x v max == y))</span></span></code></pre></div><h2 id=rules-for-analyzing-programs-with-conditionals>Rules for analyzing programs with conditionals</h2><p>In this section, we will summarize how to analyze programs with conditional statements.</p><h3 id=declaring-condition-and-condition-as-premises>Declaring condition and Â¬(condition) as premises</h3><p>If we have a program such as this with an if/else statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Then we can claim <code>C</code> as a premise immediately inside the if-branch and <code>Â¬(C)</code> as a premise immediately inside the else branch:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     C       )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Â¬(C)    )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Be careful with the <code>else</code> case &ndash; you must claim exactly <code>Â¬(C)</code>, and not some claim you know to be equivalent. In our max example, <code>C</code> was <code>x &lt; y</code>, and we needed to claim exactly <code>Â¬(x &lt; y)</code> in the else &ndash; NOT <code>x >= y</code>. After you have pulled in the initial claim using the form <code>Â¬(C)</code>, you can use <code>Algebra*</code> to manipulate it into a different form.</p><h3 id=each-branch-reaches-a-different-conclusion>Each branch reaches a different conclusion</h3><p>If the if-branch reaches conclusion <code>Q1</code> and the else branch reaches conclusion <code>Q2</code>, then afterwards we can list as a premise that one of those conclusions is true (since we know that one of the branches in an if/else will ALWAYS execute):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Q1      )   by SomeJustification    //conclusion in if-branch
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Q2      )   by SomeJustification   //conclusion in else-branch
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     Q1 âˆ¨ Q2     )   by Premise     //Q1 from if, Q2 from else
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that order matters, and that we must claim <code>(if conclusion) âˆ¨ (else conclusion)</code> &ndash; in the example above, we could not claim <code>Q2 âˆ¨ Q1</code> afterwards.</p><h3 id=each-branch-reaches-the-same-conclusion>Each branch reaches the same conclusion</h3><p>If the if-branch and the else-branch both reach the SAME conclusion <code>Q</code>, then afterwards we can list <code>Q</code> as a premise. Here, we know that one of the branches in an if/else will ALWAYS execute &ndash; so if we get to the same conclusion in both cases, then we must always reach that conclusion:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        1 (     Q       )   by SomeJustification    //common conclusion reached in IF
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Q       )    by SomeJustification   //common conclusion reached in ELSE
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     Q           )   by Premise     //Q was true in both the IF and the ELSE
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h2 id=example-programs-with-no-else>Example: programs with no &ldquo;else&rdquo;</h2><p>Some programs have just an if statement with no else. For example, consider this program to find the absolute value of a number:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.read()
</span></span><span style=display:flex><span>var orig: Z = num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (num &lt; 0) {
</span></span><span style=display:flex><span>    num = num * -1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//num is now the absolute value of the original input
</span></span><span style=display:flex><span>//(num is nonnegative and either equals `orig` [the original input] or -1*orig)
</span></span><span style=display:flex><span>assert(num &gt;= 0 âˆ§ (num == -1*orig âˆ¨ num == orig))</span></span></code></pre></div><p>Even though an &ldquo;else&rdquo; is unnecessary in the implementation, we want an else statement in order to ensure our program works in the case that num is NOT less than 0. Our solution is to add an else statement that is solely to hold a proof block for that branch.</p><p>We add an else statement and complete our verification as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.read()
</span></span><span style=display:flex><span>var orig: Z = num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     orig == num     )   by Premise,     //from &#34;orig = num&#34; assignment
</span></span><span style=display:flex><span>    2 (     num == orig     )   by Algebra*(1)  //switch order to match assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (num &lt; 0) {
</span></span><span style=display:flex><span>    num = num * -1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1  (    Old(num) &lt; 0            )   by Premise,         //if condition (num just changed)
</span></span><span style=display:flex><span>        2  (    num == Old(num) * -1    )   by Premise,         //from &#34;num = num * -1&#34; assignment
</span></span><span style=display:flex><span>        3  (    orig == Old(num)        )   by Premise,         //orig did equal num (num just changed)
</span></span><span style=display:flex><span>        4  (    num &gt;= 0                )   by Algebra*(1, 2),  //a negative number times -1 is nonnegative
</span></span><span style=display:flex><span>        5  (    num == -1 * orig        )   by Algebra*(2, 3)   //needed for last part of assert
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //no code - just the proof block
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Â¬(num &lt; 0)              )   by Premise,         //negation of condition
</span></span><span style=display:flex><span>        2 (     num == orig             )   by Premise,         //num is unchanged
</span></span><span style=display:flex><span>        3 (     num &gt;= 0                )   by Algebra*(1)      //needed for assert
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     num &gt;= 0                        )   by Premise, //true in both branches
</span></span><span style=display:flex><span>    2 (     num == -1*orig âˆ¨ num == orig    )   by Premise  //LHS in if, RHS in else
</span></span><span style=display:flex><span>    3 (     num &gt;= 0 âˆ§ (num == -1*orig âˆ¨ num == orig)   )   by AndI(1, 2)   //match assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//num is now the absolute value of the original input
</span></span><span style=display:flex><span>//(num is nonnegative and either equals `orig` [the original input] or -1*orig)
</span></span><span style=display:flex><span>assert(num &gt;= 0 âˆ§ (num == -1*orig âˆ¨ num == orig))</span></span></code></pre></div><h2 id=nested-conditionals>Nested conditionals</h2><p>We employ the same rules when analyzing programs with nested conditional statements. If we reach a common conclusion in both the if and else branches of an inner if/else statement, for example, then we can claim the common conclusion as a premise after that inner if/else statement (but still inside the outer if/else). The outline below summarizes what we can claim at various places in nested if/else statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C1) {
</span></span><span style=display:flex><span>    if (C2) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( C1  )   by Premise,     //outer if condition is true
</span></span><span style=display:flex><span>            2 ( C2  )   by Premise      //inner if condition is true
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q1      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    else {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( C1      )   by Premise,     //outer if condition is true
</span></span><span style=display:flex><span>            2 ( Â¬(C2)   )   by Premise      //inner if condition is false
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q2      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( common  )   by Premise,    //common conclusion in inner if/else
</span></span><span style=display:flex><span>        2 ( Q1 âˆ¨ Q2 )   by Premise     //Q1 from inner if, Q2 from inner else
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    if (C3) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( Â¬(C1)   )   by Premise,     //outer if condition is false
</span></span><span style=display:flex><span>            2 ( C3      )   by Premise      //inner if condition is true
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q3      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    else {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( Â¬(C1)   )   by Premise,     //outer if condition is false
</span></span><span style=display:flex><span>            2 ( Â¬(C3)   )   by Premise      //inner if condition is false
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q4      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( common  )   by Premise,    //common conclusion in inner if/else
</span></span><span style=display:flex><span>        2 ( Q3 âˆ¨ Q4 )   by Premise     //Q1 from inner if, Q2 from inner else
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( common                  )   by Premise,     //&#34;common&#34; was true in both the outer IF and the outer ELSE 
</span></span><span style=display:flex><span>    2 ( (Q1 âˆ¨ Q2) âˆ¨ (Q3 âˆ¨ Q4)   )   by Premise      //(Q1 âˆ¨ Q2) from outer if, (Q3 âˆ¨ Q4) from else
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=functions-and-loops>Functions and Loops</h1><h6 id=programming-logic-functions-and-loops>Programming Logic: Functions and Loops</h6><p>In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Functions and Loops</h1><article class=default><header class=headline></header><h1 id=functions>Functions</h1><p>A <em>function</em> in Scala is analogous to a method in Java or C# &ndash; it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def functionName(paramList): returnType = {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We will use the keyword <code>Unit</code> (like <code>void</code> in other languages) for a function that does not return a value. If a function has a non-<code>Unit</code> return type, then all paths through the function must end in a return statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>return expression</span></span></code></pre></div><p>Where <code>expression</code> is a variable, literal, or expression matching <code>returnType</code>.</p><h2 id=function-contracts>Function contracts</h2><p>In order to prove the correctness of a function, it must include a <em>function contract</em> just inside the function header. This function contract specifies what we need to know to use the function correctly. While we will use these specifications to help us prove correctness, they are good to include in ANY library function that will be used by someone else (even more informally in other languages). <em>The person/program who calls the function is not supposed to read the function&rsquo;s code to know how to use the function</em>. A function contract shows them what parameters to pass (including what range of values are acceptable), what the function will return in terms of the parameter, and whether/how the function will modify things like sequences (arrays/lists in other languages) or global variables.</p><p>Here is the syntax for a function contract in Logika:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires (  preconditions   ),
</span></span><span style=display:flex><span>    Ensures (   postconditions  )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here is a summary of the different function contract clauses:</p><ul><li><code>Requires</code>: lists the <em>preconditions</em> for the function in a comma-separated list. If there are no preconditions, we can skip this clause.</li><li><code>Ensures</code>: lists the <em>postconditions</em> for the function in a comma-separated list.</li></ul><h3 id=preconditions>Preconditions</h3><p>The <em>preconditions</em> for a function are requirements the function has in order to operate correctly. Generally, preconditions constrain the values of the parameters and/or global variables. For example, this function returns the integer division between two parameters. The function can only operate correctly when the denominator (the second parameter, <code>b</code>) is non-zero:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (  b != 0  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val ans: Z = a/b
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Logika will display an error if any preconditions are not proven before calling a function. Because we are required to prove the preconditions before any function call, the function itself can list the preconditions as premises in a proof block just after the function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def example(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (  Precondition1, Precondition2, ...),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //we can list the preconditions as premises
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( precondition1   )   by Premise,
</span></span><span style=display:flex><span>        2 ( precondition2   )   by Premise
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=postconditions>Postconditions</h3><p>The <em>postconditions</em> of a function state what the function has accomplished when it terminates. In particular, postconditions should include:</p><ul><li><p>A formalization of what the function promises to return in terms of the parameters/global variables. We use the keyword <code>Res[returnType]</code> to refer to the object returned by the function (we will only use this keyword in the function contract). For example, in a function that returns an integer (<code>Z</code>), we can use the keyword <code>Res[Z]</code> in a postcondition to refer to the return value.</p></li><li><p>A description of how any global variables and/or sequence parameters will be modified by the function (we will not use global variables or sequences until chapter 10).</p></li></ul><p>For example, the <code>div</code> function above should promise to return the integer division of its two parameters, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   b != 0  ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == a/b   )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val ans: Z = a/b
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>In order to prove a postcondition involving the return value, we must have proof blocks just before returning that demonstrate each postcondition claim, using the variable name being returned instead of the <code>Res[returnType]</code> keyword. In the example above, since we are returning a variable named <code>ans</code>, then we must prove the claim <code>ans == a/b</code> in order to satisfy the postcondition. We can complete the verification of the <code>div</code> function as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   b != 0  ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == a/b   )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val ans: Z = a/b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( b != 0      )   by Premise, //precondition (needed for division)
</span></span><span style=display:flex><span>        2 ( ans == a/b  )   by Premise  //satisifes the postcondition
</span></span><span style=display:flex><span>                                        //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Logika will display an error if postconditions are not proven before leaving a function. Because we are required to prove the postconditions before the function ends, any calling code can list those postconditions as premises after calling the function. We will see this in more detail in the next section.</p><h2 id=work-of-the-calling-code>Work of the calling code</h2><p>We saw above that when writing code that calls a function, we must PROVE the preconditions before the function call (since the function requires that we meet those preconditions in order to work correctly). After the function terminates, the calling code can list the function&rsquo;s postconditions as PREMISES (since the function ensured that certain things would happen).</p><p>The &ldquo;calling code&rdquo; in Scala goes outside of any function definition. Typically, I place the calling code at the bottom of the Scala file, after all functions. This is the code executed first by Scala, just like in Python programs.</p><h3 id=proving-preconditions>Proving preconditions</h3><p>Suppose we wish to call the <code>div</code> function to divide two numbers:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x, y)</span></span></code></pre></div><p>If we included that calling code in a file with our <code>div</code> function, we would see an error that we had not yet proved the precondition. To prove each precondition, we must have a proof block just before the function call that demonstrate each precondition claim, using value being passed instead of the parameter name. Since we are passing the value <code>y</code> as our second parameter, and since the <code>div</code> function requires that <code>b != 0</code> (where <code>b</code> is the second parameter), then we must demonstrate that <code>y != 0</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y != 0      )   by Algebra*(2)  //satisfies the precondition for div
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x, y)</span></span></code></pre></div><p>Note that Logika is picky about proving the precondition using EXACTLY the value being passed for the corresponding parameter. For example, suppose instead that we wanted to divide <code>x-1</code> and <code>y+1</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y != 0      )   by Algebra*(2)  //NO! precondition is not satisfied!
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)</span></span></code></pre></div><p>If we made no changes to our logic block, Logika would complain that we had not satisfied the precondition. And indeed we haven&rsquo;t &ndash; while we&rsquo;ve shown that <code>y</code> isn&rsquo;t 0, we haven&rsquo;t shown that our second parameter <code>y+1</code> isn&rsquo;t 0. Here is the correction:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)</span></span></code></pre></div><h3 id=using-postconditions>Using postconditions</h3><p>Recall that since the function is ensuring that it will do/return specific things (its postconditions), then the calling code can list those postconditions as premises after the function call. If a postcondition uses the keyword <code>Res[returnType]</code>, then the calling code can list exactly that postcondition using whatever variable it used to store the return value in place of <code>Res[returnType]</code> and using whatever values were passed in place of the parameter names. In the <code>div</code> example above where we divide <code>x-1</code> by <code>y+1</code>, the calling code stores the value returned by <code>div</code> in a variable called <code>num</code>. Since the <code>div</code> postcondition is <code>result == a/b</code>, then we can claim the premise <code>num == (x-1)/(y+1)</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( num == (x-1)/(y+1)  )   by Premise  //postcondition of div
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We know from looking at this example that <code>(x-1)/(y+1)</code> is really <code>9/3</code>, which is 3. We would like to be able to assert that <code>num</code>, the value returned from <code>div</code>, equals 3. We can do this by adding a few more steps to our final proof block, plugging in the values for <code>x</code> and <code>y</code> and doing some algebra:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( num == (x-1)/(y+1)  )   by Premise,     //postcondition of div
</span></span><span style=display:flex><span>    2 ( x == 10             )   by Premise,     //previous variable assignment
</span></span><span style=display:flex><span>    3 ( y == 2              )   by Premise,     //previous variable assignment
</span></span><span style=display:flex><span>    4 ( num == 9/3          )   by Algebra*(1,2,3),
</span></span><span style=display:flex><span>    5 ( num == 3            )   by Algebra*(4)  //needed for assert 
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num == 3)</span></span></code></pre></div><p>Using a function contract and our deduction rules, we have PROVED that the <code>div</code> function will return 3 in our example (without needing to test the code at all).</p><h2 id=examples>Examples</h2><p>In this section, we will see two completed examples of Logika programs with a function and calling code.</p><h3 id=example-1>Example 1</h3><p>In this example, we write a <code>plusOne</code> function that takes a non-negative parameter and returns one more than that parameter:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def plusOne(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 0  ),
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            Res[Z] == n + 1,
</span></span><span style=display:flex><span>            Res[Z] &gt; 0
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val answer: Z = n + 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1  (    n &gt;= 0          )   by Premise,
</span></span><span style=display:flex><span>        2  (    answer == n + 1 )   by Premise,
</span></span><span style=display:flex><span>        3  (    answer &gt; 0      )   by Algebra*(1, 2)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return answer
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////// Test code ///////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 5      )   by Premise,     //from the &#34;x=5&#34; assignment
</span></span><span style=display:flex><span>    2 (     x &gt;= 0      )   by Algebra*(1)  //proves the plusOne precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var added: Z = plusOne(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //I can list the postcondition (what is returned) as a premise
</span></span><span style=display:flex><span>    1 (     x == 5                  )   by Premise, //x is unchanged 
</span></span><span style=display:flex><span>    2 (     added == x+1            )   by Premise, //plusOne postcondition 1
</span></span><span style=display:flex><span>    3 (     added &gt; 0               )   by Premise, //plusOne postcondition 2
</span></span><span style=display:flex><span>    4 (     added == 6              )   by Algebra*(1,2),
</span></span><span style=display:flex><span>    5 (     added == 6 âˆ§ added &gt; 0  )   by AndI(4,3)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(added == 6 âˆ§ added &gt; 0)</span></span></code></pre></div><p>Note that when we have more than one postcondition, we must prove all postconditions inside the function, and we can list all postconditions as premises in the calling code after the function call.</p><h3 id=example-2>Example 2</h3><p>In this example, we write a <code>findMax</code> function that returns the biggest between two integer parameters. This is very similar to an example from section 8.7, which used an if/else statement to find the max. In that example, our assert that we had indeed found the max was: <code>assert((max >= x & max >= y) & (max == x | max == y))</code>. We will see that our postconditions for <code>findMax</code> come directly from the different claims in that assert. In our calling code, we call <code>findMax</code> with <code>num1</code> (which has the value 3) and <code>num2</code> (which has the value 2). We are able to prove that <code>findMax</code> returns 2:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//find the max between x and y
</span></span><span style=display:flex><span>def findMax(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        //no precondition needed
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            Res[Z] &gt;= x,                //postcondition 1
</span></span><span style=display:flex><span>            Res[Z] &gt;= y,                //postcondition 2
</span></span><span style=display:flex><span>            Res[Z] == x v Res[Z] == y   //postcondition 3
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var max: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (x &gt; y) {
</span></span><span style=display:flex><span>        max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     max == x    )   by Premise,
</span></span><span style=display:flex><span>            2 (     max &gt;= x    )   by Algebra*(1),     //build to postcondition 1
</span></span><span style=display:flex><span>            3 (     x &gt; y       )   by Premise,         //IF condition is true
</span></span><span style=display:flex><span>            4 (     max &gt;= y    )   by Algebra*(1,3)    //build to postcondition 2
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        max = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     max == y    )   by Premise,
</span></span><span style=display:flex><span>            2 (     Â¬(x &gt; y)    )   by Premise,         //IF condition is false
</span></span><span style=display:flex><span>            3 (     x &lt;= y      )   by Algebra*(2),
</span></span><span style=display:flex><span>            4 (     max &gt;= x    )   by Algebra*(1, 2),  //build to postcondition 1
</span></span><span style=display:flex><span>            5 (     max &gt;= y    )   by Algebra*(1)      //build to postcondition 2
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //prove the postconditions
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        //true in both the if and the else
</span></span><span style=display:flex><span>        1 (     max &gt;= x            )   by Premise,     //proves postcondition 1 
</span></span><span style=display:flex><span>        2 (     max &gt;= y            )   by Premise,     //proves postcondition 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //first was true in if, second true in else
</span></span><span style=display:flex><span>        3 (     max == x v max == y )   by Premise     //proves postcondition 3
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return max
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////////// Test code /////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num1: Z = 3
</span></span><span style=display:flex><span>val num2: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//findMax has no preconditions, so nothing to prove here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val biggest: Z = findMax(num1, num2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     biggest &gt;= num1                     )   by Premise,     //findMax postcondition 1
</span></span><span style=display:flex><span>    2 (     biggest &gt;= num2                     )   by Premise,     //findMax postcondition 2
</span></span><span style=display:flex><span>    3 (     biggest == num1 v biggest == num2   )   by Premise,     //findMax postcondition 3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in the initial values
</span></span><span style=display:flex><span>    4 (     num1 == 3                           )   by Premise,
</span></span><span style=display:flex><span>    5 (     num2 == 2                           )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    6 (     biggest &gt;= 3                        )   by Algebra*(1, 4),
</span></span><span style=display:flex><span>    7 (     biggest &gt;= 2                        )   by Algebra*(2, 5),
</span></span><span style=display:flex><span>    8 (     biggest == 3 v biggest == num2      )   by Subst_&lt;(4, 3),
</span></span><span style=display:flex><span>    9 (     biggest == 3 v biggest == 2         )   by Subst_&lt;(5, 8),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //OR-elimination
</span></span><span style=display:flex><span>    10 SubProof(
</span></span><span style=display:flex><span>        11  Assume( biggest == 3 ) 
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    12 SubProof(
</span></span><span style=display:flex><span>        13  Assume( biggest == 2 ) 
</span></span><span style=display:flex><span>        14 (    Â¬(biggest &gt;= 3)                 )   by Algebra*(13),
</span></span><span style=display:flex><span>        15 (    F                               )   by NegE(6, 14),
</span></span><span style=display:flex><span>        16 (    biggest == 3                    )   by BottomE(15)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    17 (        biggest == 3                    )   by OrE(9,10,12) //needed for assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(biggest == 3)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=recursion>Recursion</h1><p>In this section, we will see how to prove the correctness of programs that use recursive functions. We will see that verifying a recursive function is exactly the same as verifying a non-recursive function:</p><ul><li>We must prove a function&rsquo;s preconditions before calling it (including before making a recursive call)</li><li>After calling a function, we can list the function&rsquo;s postconditions as premises (including after making a recursive call)</li><li>The function can list its preconditions as premises</li><li>The function must prove its postconditions just before it ends</li></ul><h2 id=writing-a-recursive-mult-function>Writing a recursive mult function</h2><p>We know we can multiply two numbers, <code>x</code> and <code>y</code>, using the <code>*</code> operator &ndash; <code>x * y</code>. But what if we wanted to find the same result using only addition, not multiplication? Multiplication can be thought of as repeated addition &ndash; <code>x * y</code> is really <code>x + x + ... + x</code>, where we add together <code>y</code> total <code>x</code>&rsquo;s.</p><p>We <em>could</em> do this repeated addition with a loop (and we will when we introduce loops in section 9.3), but we will use recursion instead. When we write a recursive function, we try to think of two things:</p><ul><li>The <em>base case</em>: the simplest version of the problem that we could immediately solve with no more work.</li><li>The <em>recursive case</em>: bigger versions of the problem, where we solve a piece of the problem and then recursively solve a smaller piece</li></ul><p>In the case of the multiplication <code>x * y</code>, we have:</p><ul><li>Base case: if <code>y</code> is 0, we have no work to do. Adding together 0 <code>x</code>&rsquo;s is just 0.</li><li>Recursive case: if <code>y</code> is bigger than 0, we do ONE addition (<code>x + ...</code>) and recursively add the remaining <code>y - 1</code> numbers. (This will become our recursive call.)</li></ul><p>With those cases in mind, we can write a recursive <code>mult</code> function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        ans = mult(x, y-1)
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Note that we separated the recursive call (<code>ans = mult(x, y-1)</code>) from adding on the next piece (<code>ans = ans + x</code>). When using Logika, all function calls must go on a separate line by themselves &ndash; we can&rsquo;t combine them with other operations. Also, we included a dummy &ldquo;else&rdquo; branch to make the verification simpler.</p><h2 id=walking-through-mult>Walking through mult</h2><p>Suppose we call <code>mult</code> as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var times: Z = mult(4, 2)</span></span></code></pre></div><p>We can trace the recursive calls:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>times = mult(4, 2) 
</span></span><span style=display:flex><span>            (x = 4, y = 2)
</span></span><span style=display:flex><span>            ans = mult(4, 1)    =&gt; mult(4, 1)
</span></span><span style=display:flex><span>            ans = ans + 4               (x = 4, y = 1)
</span></span><span style=display:flex><span>            returns ans                     ans = mult(4, 0)    =&gt;  mult(4, 0)
</span></span><span style=display:flex><span>                                            ans = ans + 4               (x = 4, y = 0)
</span></span><span style=display:flex><span>                                            returns ans                     ans = 0
</span></span><span style=display:flex><span>                                                                            returns 0</span></span></code></pre></div><p>We start with <code>mult(4, 2)</code>, and then immediately make the recursive call <code>mult(4, 1)</code>, which immediately makes the recursive call <code>mult(4, 0)</code>. That function instance hits the base case and returns 0. We now return back up the chain of function calls &ndash; the 0 gets returned back to the <code>mult(4, 1)</code> instance, which adds 4 and then returns 4:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>=&gt; mult(4, 1)
</span></span><span style=display:flex><span>    (x = 4, y = 1)
</span></span><span style=display:flex><span>    ans = mult(4, 0) = 0
</span></span><span style=display:flex><span>    ans = ans + 4 = 4
</span></span><span style=display:flex><span>    returns ans (4)</span></span></code></pre></div><p>This 4 returns back to the <code>mult(4, 2)</code> instance, which adds another 4 and returns 8:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mult(4, 2) 
</span></span><span style=display:flex><span>    (x = 4, y = 2)
</span></span><span style=display:flex><span>    ans = mult(4, 1) = 4
</span></span><span style=display:flex><span>    ans = ans + 4 = 8
</span></span><span style=display:flex><span>    returns ans (8)</span></span></code></pre></div><p>We have now backed our way up the chain &ndash; the 8 is returned back from the original function call, and <code>times</code> is set to 8.</p><h2 id=mult-function-contract>mult function contract</h2><p>Looking at our <code>mult</code> function, we see that the base case is when <code>y</code> is 0 and the recursive case is when <code>y > 0</code>. Clearly, the function is not intended to work for negative values of <code>y</code>. This will be our precondition &ndash; that <code>y</code> must be greater than or equal to 0.</p><p>Our postcondition should describe what <code>mult</code> is returning in terms of its parameters. In this case, we know that <code>mult</code> is performing a multiplication of <code>x</code> and <code>y</code> using repeated addition. So, our function should ensure that it returns <code>x*y</code> (that <code>Res[Z] == x*y</code>). Here is the function with the function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    //we still need to add the verification logic blocks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        ans = mult(x, y-1)
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=verification-in-mult>Verification in mult</h2><p>Now that we have our function contract for <code>mult</code>, we must add logic blocks with two things in mind:</p><ul><li>Proving the precondition before a recursive call</li><li>Proving the postcondition before we return from the function</li></ul><p>Our recursive call looks like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ans = mult(x, y-1)</span></span></code></pre></div><p>Since our precondition is <code>y >= 0</code>, we see that we must prove that what we are passing as the second parameter (<code>y-1</code>, in the case of the recursive call) is greater than or equal to 0. This tells us that before our recursive call, we must have shown exactly: <code>y-1 >= 0</code>. We can finish proving the precondition as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    //we still need to prove the postcondition
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     y &gt; 0       )   by Premise,     //IF condition is true
</span></span><span style=display:flex><span>            2 (     y-1 &gt;= 0    )   by Algebra*(1)  //Proves the precondition for the recursive call
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans = mult(x, y-1)
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>All that remains is to prove the <code>mult</code> postcondition &ndash; that we are returning <code>x*y</code>. Since we are returning the variable <code>ans</code>, then we must prove the claim <code>ans == x*y</code> just before our return statement. In order to help with this process, we will need to take advantage of the postcondition after our recursive call. The function promises to return the first parameter times the second parameter, so when we do <code>ans = mult(x, y-1)</code>, we know that <code>ans == x*(y-1)</code> (the first parameter, <code>x</code>, times the second parameter, <code>y-1</code>). Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    //verification complete!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     y &gt; 0       )   by Premise,     //IF condition is true
</span></span><span style=display:flex><span>            2 (     y-1 &gt;= 0    )   by Algebra*(1)  //Proves the precondition for the recursive call
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       ans = mult(x, y-1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     ans == x * (y - 1)  )   by Premise, //Postcondition from the recursive call
</span></span><span style=display:flex><span>            2 (     ans == x * y - x    )   by Algebra*(1)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     Old(ans) == x * y - x   )   by Premise,         //Pulled from previous block
</span></span><span style=display:flex><span>            2 (     ans == Old(ans) + x     )   by Premise,         //From the &#34;ans = ans + x&#34; assignment statement
</span></span><span style=display:flex><span>            3 (     ans == x + x * y - x    )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>            4 (     ans == x * y            )   by Algebra*(3)      //Showed the postcondition for the IF branch
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing in code - but we still do verification
</span></span><span style=display:flex><span>        //need to show that postcondition will be correct even if we take this branch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     Â¬(y &gt; 0)        )   by Premise,         //if condition is false
</span></span><span style=display:flex><span>            2 (     y &gt;= 0          )   by Premise,         //precondition
</span></span><span style=display:flex><span>            3 (     y == 0          )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>            4 (     ans == 0        )   by Premise,         //ans is unchanged
</span></span><span style=display:flex><span>            5 (     ans == x * y    )   by Algebra*(3, 4)   //Showed the postcondition for the ELSE branch
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Tie together what we learned in both branches
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     ans == x*y          )   by Premise          //shows the postcondition      
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=verification-of-calling-code>Verification of calling code</h2><p>Verifying the test code that calls a recursive function works exactly the same way as it does for any other function:</p><ul><li>We must prove the precondition before calling the function</li><li>We can list the postcondition as a premise after calling the function</li></ul><p>Suppose we want to test <code>mult</code> as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val times: Z = mult(4, 2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(times == 8)</span></span></code></pre></div><p>We could complete the verification by proving the precondition and then using the postcondition to help us prove the claim in the assert:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     2 &gt;= 0      )   by Algebra*()    //proves the precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val times: Z = mult(4, 2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     times == 4*2    )   by Premise,     //mult postcondition
</span></span><span style=display:flex><span>    2 (     times == 8      )   by Algebra*(1)  //needed for the assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(times == 8)</span></span></code></pre></div><p>Note that since our second parameter is <code>2</code>, that we must demonstrate exactly <code>2 >= 0</code> to satisfy <code>mult</code>&rsquo;s precondition. Furthermore, since <code>mult</code> promises to return the first parameter times the second parameter, and since we are storing the result of the function call in the <code>times</code> variable, then we can claim <code>times == 4*2</code> as a premise.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=loops>Loops</h1><p>A <em>loop</em> is a command that restarts itself over and over while its <em>loop condition</em> remains true. Loops are trickier to analyze than if/else statements, because we don&rsquo;t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations&mldr;we don&rsquo;t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.</p><p>The only loop available in Logika is a <em>while</em> loop, which behaves in the same way as while loops in other languages. If the loop condition is initially false, then the body of the while loop is skipped entirely. If the loop condition is initially true, then we execute the loop body and then recheck the condition. This continues until the loop condition becomes false.</p><p>Here is the syntax of a Scala while loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (condition) {
</span></span><span style=display:flex><span>   //body of loop
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=loop-invariants>Loop invariants</h2><p>Our solution to analyzing loops despite not knowing the number of iterations is a tool called a <em>loop invariant</em>. The job of the loop invariant is to summarize what is always true about the loop. Often, the loop invariant describes the relationship between variables and demonstrates how much progress the loop has made. Sometimes the loop invariant also contains claims that certain variables will always stay in a particular range.</p><p>Whatever we choose as the loop invariant, we must be able to do the following:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li></ul><h2 id=loop-invariants-and-mathematical-induction>Loop invariants and mathematical induction</h2><p>The process of proving the correctness of loop invariants is very similar to a mathematical induction proof. We must prove the loop invariant is true before the loop begins, which is analogous to the <em>base case</em> in mathematical induction. The process of assuming the invariant is true at the beginning of an iteration and proving that it is still true at the end of an iteration is just like mathematical induction&rsquo;s <em>inductive step</em>.</p><p>If we prove those two things about our invariant, we can be certain the invariant will still hold after the loop terminates. Why? For the same reason mathematical induction proves a property for a general <span class="math align-center">$n$</span>:</p><ul><li>We know the invariant holds before the loop begins</li><li>Because the invariant holds before the loop begins, we are sure it holds at the beginning of the first iteration</li><li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the first iteration</li><li>Because we&rsquo;re sure it still holds at the end of the first iteration, we know it holds at the beginning of the second iteration</li><li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the second iteration
&mldr;</li><li>We&rsquo;re sure the invariant still holds at the end of each iteration, including the end of the LAST iteration. Thus we&rsquo;re certain the invariant holds just after the loop ends.</li></ul><h2 id=loop-invariant-block-syntax>Loop invariant block syntax</h2><p>In Logika, we will write a <em>loop invariant block</em> to describe our loop invariants. This block will go just inside the loop, before the loop body:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (condition) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(comma-separated list of variables),
</span></span><span style=display:flex><span>        Invariant_1,
</span></span><span style=display:flex><span>        Invariant_2,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //loop body
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here is a summary of the different loop invariant clauses:</p><ul><li><code>Modifies</code>: uses a comma-separated list to name each variable whose value changes in the loop body</li><li><code>Invariant_i</code>: lists an invariant for the function. If we have multiple invariants, we can list them on separate lines (<code>Invariant_1</code>, <code>Invariant_2</code>, etc.)</li></ul><h2 id=example-loop-invariant-block-for-a-multiplication-loop>Example: loop invariant block for a multiplication loop</h2><p>Suppose we have the following loop to multiply two numbers, <code>x</code> and <code>y</code>, using repeated addition. (This is very similar to our <code>mult</code> function from section 9.2, except it does the additions using a loop instead of using recursion):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><p>Before writing the loop invariant block, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>After iteration 3</th><th>&mldr;</th><th>After iteration y</th></tr></thead><tbody><tr><td><code>count</code></td><td>0</td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>y</td></tr><tr><td><code>sum</code></td><td><span class="math align-center">$0 (= 0*x)$</span></td><td><span class="math align-center">$x (= 1*x)$</span></td><td><span class="math align-center">$x + x (= 2*x)$</span></td><td><span class="math align-center">$x + x + x (= 3*x)$</span></td><td>&mldr;</td><td><span class="math align-center">$x + x + ... + x (= y*x)$</span></td></tr></tbody></table><p>Before the loop begins, we&rsquo;ve added 0 <span class="math align-center">$x$</span>&rsquo;s together, so the sum is 0. After the first iteration, we&rsquo;ve added 1 <span class="math align-center">$x$</span> together, so the sum is <span class="math align-center">$x$</span>. After the second iteration, we&rsquo;ve added 2 <span class="math align-center">$x$</span>&rsquo;s together, so the sum is <span class="math align-center">$x + x$</span> which is really <span class="math align-center">$2 * x$</span>. This continues until after the y-th iteration, when we&rsquo;ve added y <span class="math align-center">$x$</span>&rsquo;s together (and the sum is <span class="math align-center">$y*x$</span>).</p><p>Using this table, it is easy to see that at any point, <code>sum == count*x</code> (since <code>count</code> tracks the number of iterations). This is true both before the loop begins and at the end of each iteration, so it will be our loop invariant.</p><p>We now add a loop invariant block to our loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    //loop invariant block (still needs to be proved)
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><p>We list <code>sum</code> and <code>count</code> in the <code>Modifies</code> clause because those are the two variables that change value inside the loop.</p><h2 id=proving-the-loop-invariant>Proving the loop invariant</h2><p>In order to prove the correctness of a loop, we must do two things:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li></ul><h3 id=proving-loop-invariant-before-loop-begins>Proving loop invariant before loop begins</h3><p>In our multiplication loop above, let&rsquo;s start by proving the loop invariant before the loop begins. This means that just before the loop, we must prove exactly the claim <code>sum == count*x</code>. We can do this with algebra on the current variable values:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//prove the invariant before the loop begins
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //we still need to prove the invariant after each iteration
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><h3 id=proving-loop-invariant-at-the-end-of-each-iteration>Proving loop invariant at the end of each iteration</h3><p>To prove the loop invariant still holds at the end of an iteration, we must have a logic block at the end of the loop body with exactly the claim in the loop invariant (which will now be referring to the updated values of each variable). Since this step has us assuming the loop invariant is true at the beginning of each iteration, we can list the loop invariant as a <em>premise</em> in a logic block just inside the loop body. Here is the structure we wish to follow for our multiplication loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                        //at the beginning of an iteration
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //need to prove exactly &#34;sum == count*x&#34;
</span></span><span style=display:flex><span>    //to prove our invariant still holds at the end of an iteration
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We can complete the loop invariant proof by using our tools for processing assignment statements with mutations. Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//prove the invariant before the loop begins
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                        //at the beginning of an iteration
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span style=display:flex><span>        2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span style=display:flex><span>        3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span style=display:flex><span>        2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style=display:flex><span>                                                                //but count has changed
</span></span><span style=display:flex><span>        3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span style=display:flex><span>        4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span style=display:flex><span>        5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><h3 id=knowledge-after-loop-ends>Knowledge after loop ends</h3><p>In the example above, suppose we add the following assert after the loop ends:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(sum == x*y)</span></span></code></pre></div><p>This seems like a reasonable claim &ndash; after all, we said that our loop was supposed to calculated <code>x * y</code> using repeated addition. We have proved the loop invariant, so we can be sure that <code>sum == count*x</code> after the loop&mldr;but that&rsquo;s not quite the same thing. Does <code>count</code> equal <code>y</code>? How do we know?</p><p>We can prove our assert statement by considering one more piece of information &ndash; if we have exited the loop, we know that the loop condition must be false. In fact, you always know two things (which you can claim as premises) after the loop ends:</p><ol><li>The loop condition is false (so we can claim <code>Â¬(condition)</code>)</li><li>The loop invariant is true, since we proved is true at the end of each iteration</li></ol><p>We can use those pieces of information to prove our assert statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//the multiplication loop example goes here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     sum == count*x  )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>    2 (     Â¬(count != y)   )   by Premise,     //the loop condition is not true
</span></span><span style=display:flex><span>    3 (     count == y      )   by Algebra*(2),
</span></span><span style=display:flex><span>    4 (     sum == x*y      )   by Algebra*1,3  //proves our assert statement
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(sum == x*y)</span></span></code></pre></div><h2 id=functions-with-loops>Functions with loops</h2><p>If we have a function that includes a loop, we must do the following:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Given that the loop invariant is true at the beginning of an iteration, prove that it is still true at the end of the iteration</li><li>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition</li></ul><p>For example, suppose our loop multiplication is inside a function which is tested by some calling code. We would like to add a function contract, our loop invariant proof, and necessary logic blocks to show that our assert holds at the end of the calling code. Here is just the code for the example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != y) {
</span></span><span style=display:flex><span>        sum = sum + x
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><p>We start by adding a function contract to <code>mult</code>, which will be the same as our function contract for the recursive version of this function in section 9.2 &ndash; <code>y</code> needs to be nonnegative, and we promise to return <code>x*y</code>. Here is the code after adding the function contract and our previous loop verificaton:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style=display:flex><span>    //function contract
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),  //precondition: y should be nonnegative
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )   //postcondition (we promise to return x*y)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //prove the invariant before the loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != y) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == count * x
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                            //at the beginning of an iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span style=display:flex><span>            2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span style=display:flex><span>            3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span style=display:flex><span>            2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style=display:flex><span>                                                                    //but count has changed
</span></span><span style=display:flex><span>            3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span style=display:flex><span>            4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span style=display:flex><span>            5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //STILL NEED TO PROVE POSTCONDITION
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//STILL NEED TO ADD VERIFICATION FOR ASSERT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><p>We can use the negation of the loop condition (<code>Â¬(count != y)</code>) together with the loop invariant to prove the postcondition will hold before the function returns. We can also apply the same process as in sections 9.1 and 9.2 to prove the precondition in the calling code before calling the <code>mult</code> function, and to use the function&rsquo;s postcondition after the call to <code>mult</code> to prove our goal assert. Here is the completed example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style=display:flex><span>    //function contract
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),  //precondition: y should be nonnegative
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )   //postcondition (we promise to return x*y)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //prove the invariant before the loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != y) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == count * x
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                            //at the beginning of an iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span style=display:flex><span>            2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span style=display:flex><span>            3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span style=display:flex><span>            2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style=display:flex><span>                                                                    //but count has changed
</span></span><span style=display:flex><span>            3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span style=display:flex><span>            4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span style=display:flex><span>            5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Â¬(count != y)       )   by Premise,         //loop condition is now false
</span></span><span style=display:flex><span>        2 (     sum == count*x      )   by Premise,         //loop invariant holds after loop
</span></span><span style=display:flex><span>        3 (     count == y          )   by Algebra*(1),
</span></span><span style=display:flex><span>        4 (     sum == x*y          )   by Algebra*(2,3)    //proves the postcondition
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     two == 4        )   by Premise,     //from the &#34;two = 4&#34; assignment
</span></span><span style=display:flex><span>    2 (     two &gt;= 0        )   by Algebra*(1)  //proves the mult precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     one == 3            )   by Premise,
</span></span><span style=display:flex><span>    2 (     two == 4            )   by Premise,
</span></span><span style=display:flex><span>    3 (     answer == one*two   )   by Premise          //from the mult postcondition
</span></span><span style=display:flex><span>    4 (     answer == 12        )   by Algebra*(1,2,3)  //proves the assert 
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><h2 id=how-to-construct-a-loop-invariant>How to construct a loop invariant</h2><p>The most difficult part of the entire process of proving the correctness of a function with a loop is coming up with an appropriate loop invariant. In this section, we will study two additional loops and learn techniques for deriving loop invariants. In general, we need to think about what the loop is doing as it iterates, and what progress it has made so far towards its goal. A good first approach is to trace through the values of variables for several iterations of the loop, as we did with <code>mult</code> above &ndash; this helps us identify patterns that can then become the loop invariant.</p><h3 id=example-1-sum-of-odds>Example 1: Sum of odds</h3><p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var total: Z = 0
</span></span><span style=display:flex><span>var i: Z = 0
</span></span><span style=display:flex><span>while (i &lt; n) {
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    total = total + (2*i - 1)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>It might be difficult to tell what this code is doing before walking through a few iterations. Let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>After iteration 3</th><th>&mldr;</th><th>After iteration n</th></tr></thead><tbody><tr><td><code>i</code></td><td>0</td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>n</td></tr><tr><td><code>total</code></td><td><span class="math align-center">$0 $</span></td><td><span class="math align-center">$1 $</span></td><td><span class="math align-center">$1 + 3 (= 4)$</span></td><td><span class="math align-center">$1 + 3 + 5 (= 9)$</span></td><td>&mldr;</td><td><span class="math align-center">$1 + 3 + 5 + ... + (2*n-1) (=n^2)$</span></td></tr></tbody></table><p>Now we can see the pattern &ndash; we are adding up the first <span class="math align-center">$n$</span> odd numbers. We can see that at the end of the i-th iteration we have added the first <span class="math align-center">$i$</span> odd numbers, where <span class="math align-center">$(2*i-1)$</span> is our most recent odd number. We also see that the sum of the first 1 odd number is 1, the sum of the first 2 odd numbers is <span class="math align-center">$2^2 = 4$</span>, &mldr;, and the sum of the first <span class="math align-center">$n$</span> odd numbers is <span class="math align-center">$n^2$</span>.</p><p>Since our loop invariant should describe what progress it has made towards its goal of adding the first <span class="math align-center">$n$</span> odd numbers, we can see that the loop invariant should be that at any point (before the loop begins and at the end each iteration), <span class="math align-center">$total$</span> holds the sum of the first <span class="math align-center">$i$</span> numbers (whose value is <span class="math align-center">$i^2$</span>). We first try this as our loop invariant:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var total: Z = 0
</span></span><span style=display:flex><span>var i: Z = 0
</span></span><span style=display:flex><span>while (i &lt; n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, n),
</span></span><span style=display:flex><span>        total == i*i
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    total = total + (2*i - 1)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Another consideration of writing a loop invariant is that we should be able to deduce our overall goal once the loop ends. After our loop, we want to be sure that <code>total</code> holds the sum of the first <code>n</code> odd numbers &ndash; i.e., that <code>total == n*n</code>. Our loop invariant tells us that <code>total == i*i</code> after the loop ends &ndash; but does <code>n</code> necessarily equal <code>i</code>?</p><p>The way it is written, we can&rsquo;t be certain. We do know that the loop condition must be false after the loop, or that <code>Â¬(i &lt; n)</code>. But this is equivalent to <code>i >= n</code> and not <code>i == n</code>. We need to tighten our invariant to add a restriction that <code>i</code> always be less than or equal to n:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var total: Z = 0
</span></span><span style=display:flex><span>var i: Z = 0
</span></span><span style=display:flex><span>while (i &lt; n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, n),
</span></span><span style=display:flex><span>        total == i*i,
</span></span><span style=display:flex><span>        i &lt;= n
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    total = total + (2*i - 1)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>After the loop ends, we can now combine the negation of the loop condition, <code>Â¬(i &lt; n)</code> together with the <code>i &lt;= n</code> portion of the invariant to deduce that <code>i == n</code>. Together with the other half of the invariant &ndash; <code>total == i*i</code> &ndash; we can be sure that <code>total == n*n</code> when the loop ends.</p><h3 id=example-2-factorial>Example 2: factorial</h3><p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var prod: Z = 1
</span></span><span style=display:flex><span>var i: Z = 1
</span></span><span style=display:flex><span>while (i != n) {
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    prod = prod * i
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>As before, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>&mldr;</th><th>After iteration n</th></tr></thead><tbody><tr><td><code>i</code></td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>n</td></tr><tr><td><code>prod</code></td><td><span class="math align-center">$1 $</span></td><td><span class="math align-center">$1 * 2$</span></td><td><span class="math align-center">$1 * 2 * 3$</span></td><td>&mldr;</td><td><span class="math align-center">$1 * 2 * 3 * ... * n$</span></td></tr></tbody></table><p>From this table, we can clearly see that after <span class="math align-center">$i$</span> iterations, <span class="math align-center">$prod == i!$</span> (i factorial). This <em>should</em> be our loop invariant&mldr;but as with many other languages, Logika does not recognize <code>!</code> as a factorial operator (instead, it is a negation operator). In the next section, we will see how to create a <em>Logika fact</em> to help define the factorial operation. We will then be able to use that Logika fact in place of <code>!</code> to let our invariant be a formalization of: <em>prod equals i factorial</em>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logika-facts>Logika Facts</h1><p>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that <span class="math align-center">$n! = n * (n-1) * (n-2) * ... * 2 * 1$</span>, but we don&rsquo;t have a way to describe the &ldquo;&mldr;&rdquo; portion using our current tools.</p><p>In this section, we introduce <em>Logika facts</em>, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a &ldquo;&mldr;&rdquo; to demonstrate a pattern.</p><h2 id=logika-fact-syntax>Logika fact syntax</h2><p>Logika allows these proof functions to be written in multiple ways, but we will start with the most straightforward of these options:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def proofFunction(paramList): returnType = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def proofFacts = Fact(
</span></span><span style=display:flex><span>    proofFunction(baseCase) == baseValue,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    âˆ€( (x: Z) =&gt; (rangeOfX) â†’ (proofFunction(x) == proofFunction(x - 1) * x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>In the above definition, <code>proofFunction</code> is the name we give our proof function, <code>paramList</code> is the list of parameter names and types needed for this proof function (which are formatted exactly like a parameter list in a regular Logika function), and <code>returnType</code> is the return type of the proof function (usually either <code>Z</code> for integer or <code>B</code> for boolean). The <code>= $</code> at the end of the proof function is indicating that its definition will be provided later.</p><p>Below the proof function, we include the <em>proof facts</em>, which is a recursive definition of the values for our proof function. We include one or more base cases, which list the value of our proof function for its smallest possible input (or for the smallest several inputs). Finally, we include our recursive case as a quantified statement &ndash; it lists the value of our proof function on all inputs bigger than our base cases. This recursive case uses the proof function&rsquo;s definition for a smaller value, like <code>proofFunction(x-1)</code>.</p><p>Logika facts are defined at the top of the Logika file, below the <code>import</code>s but before any of the code.</p><h2 id=example-logika-fact-to-define-factorial>Example: Logika fact to define factorial</h2><p>It is much easier to see how Logika facts work by using an example. Suppose we want to define the factorial operation. The first step is to come up with a <em>recursive definition</em>, which has us defining the operation the same way we would in a recursive function &ndash; with one or more <em>base cases</em> where we can define the operation for the simplest case, and one or more <em>recursive cases</em> that express a general instance of the problem in terms of a smaller instance.</p><p>For factorial, the simplest version is <span class="math align-center">$1!$</span>, which is just 1. In the general case, we have that:</p><span class="math align-center">$$
n! = n * (n-1) * (n-2) * ... * 2 * 1 = n * (n-1)!
$$</span><br><p>So we can write the following recursive definition:</p><ul><li>Base case: <span class="math align-center">$1! = 1$</span></li><li>Recursive case: for values of <span class="math align-center">$n$</span> greater than 1, <span class="math align-center">$n! = n * (n-1)!$</span></li></ul><p>And we can then translate the recursive definition to a Logika fact:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    âˆ€ ( (x: Z) =&gt; (x &gt; 1) â†’ (factFunction(x) == factFunction(x-1)*x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Let&rsquo;s consider each portion of this proof function. Here, <code>factFunction</code> is the name given to the proof function. It takes one parameter, <code>n</code>, which is an integer, and it returns an integer. We have two possible ways of calculating the value for the proof function, which we detail in <code>factorialFacts</code>. First, we define our base case:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(1) == 1</span></span></code></pre></div><p>Which says that <code>factFunction(n)</code> is 1 if <span class="math align-center">$n == 1$</span>. This is the same as our base case in our recursive definition for factorial &ndash; <span class="math align-center">$1! = 1$</span>.</p><p>Next, consider the recursive case of our proof function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ ( (x: Z) =&gt; (x &gt; 1) â†’ (factFunction(x) == factFunction(x-1)*x) )</span></span></code></pre></div><p>This case states that for all integers <code>x</code> that are bigger than 1, we define <code>factFunction(x) == x * factFunction(x - 1)</code>. This is the same as our recursive case in our recursive definition for factorial &ndash; for values of <span class="math align-center">$n$</span> greater than 1, <span class="math align-center">$n! = n * (n-1)!$</span>.</p><h2 id=evaluating-a-logika-fact>Evaluating a Logika fact</h2><p>Suppose we used our <code>factorialFacts</code> proof function to calculate <code>factFunction(3)</code>. We would have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(3) == 3 * factFunction(2)      //we use the recursive case, since 3 &gt; 1
</span></span><span style=display:flex><span>factFunction(2) == 2 * factFunction(1)      //we use the recursive case, since 2 &gt; 1
</span></span><span style=display:flex><span>factFunction(1) == 1                        //we use the base case       </span></span></code></pre></div><p>Once we work down to:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(1) == 1</span></span></code></pre></div><p>We can plug <code>1</code> in for <code>facfactFunctiontDef(1)</code> in <code>factFunction(2) == 2 * factFunction(1)</code>, which gives us:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(2) == 2</span></span></code></pre></div><p>Similarly, we can plug <code>2</code> in for <code>factFunction(2)</code> in <code>factFunction(3) == 3 * factFunction(2)</code>, and see that:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(3) == 6</span></span></code></pre></div><h2 id=using-logika-facts-as-justifications>Using Logika facts as justifications</h2><p>If we had our proof function, <code>factFunction</code>, then we could pull its two facts from its <code>factorialFacts</code> recursive definition into a proof block like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     factFunction(1) == 1                                                )   by ClaimOf(factorialFacts _),                                             
</span></span><span style=display:flex><span>    2 (     âˆ€ ( (x: Z) =&gt; (x &gt; 1) â†’ (factFunction(x) == factFunction(x-1)*x) )  )   by ClaimOf(factorialFacts _)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that we must pull in the definitions EXACTLY as they are written in the proof function. The justification is always <code>ClaimOf(proofFacts _)</code> where <code>proofFacts</code> is the name of the recursive definition.</p><h2 id=using-logika-facts-in-postconditions-and-invariants>Using Logika facts in postconditions and invariants</h2><p>Consider the following full Logika program that includes a function to find and return a factorial, as well as test code that calls our factorial function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// n! = n * (n-1) * (n-2) * .. * 1
</span></span><span style=display:flex><span>// 1! = 1
</span></span><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style=display:flex><span>    var product: Z = 1  //our current calculation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>        product = product * i
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return product
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = factorial(num)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 2)</span></span></code></pre></div><p>We want to add a function contract, loop invariant block, and supporting logic blocks to demonstrate that <code>factorial</code> is returning <code>n!</code> and to prove the assert in our text code.</p><h3 id=writing-a-function-contract-using-a-logika-fact>Writing a function contract using a Logika fact</h3><p>We want our <code>factorial</code> function contract to say that it is returning <code>n!</code>, and that it is only defined for values of <code>n</code> that are greater than or equal to 0. We recall that our Logika fact, <code>factFunction</code>, defines the factorial operation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    âˆ€ ( (x: Z) =&gt; (x &gt; 1) â†’ (factFunction(x) == factFunction(x-1)*x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>And we will use <code>factFunction</code> to define what we mean by &ldquo;factorial&rdquo; in our <code>factorial</code> function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 1                      ),  //factFunction(n) is only defined when n &gt;= 1
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == factFunction(n)   )   //we promise to return factFunction(n), where factFunction defines n!
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //code for factorial function
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=writing-a-loop-invariant-block-using-a-logika-fact>Writing a loop invariant block using a Logika fact</h3><p>We can similarly use <code>factFunction</code> in our loop invariant block. We noted at the end of section 9.3 that the invariant in our loop should be: <em>prod equals i factorial</em>. Now we have a way to express what we mean by &ldquo;factorial&rdquo;, so our invariant will be: <code>prod == factFunction(i)</code>. Since the <code>factFunction</code> proof function is only defined for parameters greater than or equal to 1, we need to add a second piece to the invariant to guarantee that <code>i</code> will always be greater than or equal to 1. We now have the following loop invariant block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (i != n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, product),
</span></span><span style=display:flex><span>        product == factFunction(i),
</span></span><span style=display:flex><span>        i &gt;= 1
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //loop body
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=finishing-the-verification>Finishing the verification</h3><p>All that remains is to:</p><ul><li>Prove our loop invariant holds before the loop begins</li><li>When we assume the loop invariant holds at the beginning of an iteration, prove that it still holds at the end of the iteration</li><li>Use the loop invariant together with the negation of the loop condition to prove the <code>factorial</code> postcondition</li><li>Prove the precondition holds in the calling code just before calling <code>factorial</code></li><li>Use the postcondition after calling <code>factorial</code> to prove the final assert</li></ul><p>Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    âˆ€((x: Z) =&gt; (x &gt; 1) â†’ (factFunction(x) == factFunction(x-1)*x))
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 1                      ),  //factFunction(n) is only defined when n &gt;= 1
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == factFunction(n)   )   //we promise to return factFunction(n), where factFunction defines n!
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style=display:flex><span>    var product: Z = 1  //my current calculation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Prove invariant before loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     i == 1                      ) by Premise,
</span></span><span style=display:flex><span>        2 (     product == 1                ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         //pull in proof function base case
</span></span><span style=display:flex><span>        3 (     factFunction(1) == 1        ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //proves first loop invariant holds 
</span></span><span style=display:flex><span>        4 (     product == factFunction(i)  ) by Algebra*(1, 2, 3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //proves second loop invariant holds 
</span></span><span style=display:flex><span>        5 (     i &gt;= 1                      ) by Algebra*(1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(i, product),
</span></span><span style=display:flex><span>            product == factFunction(i),
</span></span><span style=display:flex><span>            i &gt;= 1
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            //from &#34;i = i + 1&#34;
</span></span><span style=display:flex><span>            1 (     i == Old(i) + 1                  ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //loop invariant held before changing i
</span></span><span style=display:flex><span>            2 (     product == factFunction(Old(i))  ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //rewrite invariant with no &#34;Old&#34;
</span></span><span style=display:flex><span>            3 (     product == factFunction(i - 1)   ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //second loop invariant held before changing i
</span></span><span style=display:flex><span>            4 (     Old(i) &gt;= 1                      ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //needed for the Logika fact
</span></span><span style=display:flex><span>            5 (     i &gt; 1                            ) by Algebra*(1, 4)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        product = product * i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //Prove invariant still holds at end of iteration
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            //from &#34;product = product * i&#34;
</span></span><span style=display:flex><span>            1 (  product == Old(product) * i                                        ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //from previous logic block
</span></span><span style=display:flex><span>            2 (  Old(product) == factFunction(i - 1)                                ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             //pull in recursive case from proof function
</span></span><span style=display:flex><span>            3 (  âˆ€( (x: Z) =&gt; x &gt; 1 â†’ factFunction(x) == factFunction(x - 1) * x )  ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //plug in &#34;i&#34; for &#34;x&#34; (where i is of type Z)
</span></span><span style=display:flex><span>            4 (  i &gt; 1 â†’ factFunction(i) == factFunction(i - 1) * i                 ) by AllE[Z](3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //from previous logic block
</span></span><span style=display:flex><span>            5 (  i &gt; 1                                                              ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //i &gt; 1, so get right side of â†’
</span></span><span style=display:flex><span>            6 (  factFunction(i) == factFunction(i - 1) * i                         ) by ImplyE(4, 5),
</span></span><span style=display:flex><span>            7 (  product == factFunction(i - 1) * i                                 ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //proves first invariant still holds
</span></span><span style=display:flex><span>            8 (  product == factFunction(i)                                         ) by Algebra*(6, 7),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //proves second invariant still holds
</span></span><span style=display:flex><span>            9 (  i &gt;= 1                                                             ) by Algebra*(5)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Prove postcondition
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     product == factFunction(i)  ) by Premise,      //loop invariant
</span></span><span style=display:flex><span>        2 (     !(i != n)                   ) by Premise,      //loop condition false
</span></span><span style=display:flex><span>        3 (     i == n                      ) by Algebra*(2),
</span></span><span style=display:flex><span>        4 (     product == factFunction(n)  ) by Algebra*(1, 3)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return product
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//Prove precondition
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     num == 2  ) by Premise,
</span></span><span style=display:flex><span>    2 (     num &gt;= 1  ) by Algebra*(1)     //proves factorial precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = factorial(num)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (  answer == factFunction(num)                                        ) by Premise,       //factorial postcondition
</span></span><span style=display:flex><span>    2 (  num == 2                                                           ) by Premise,
</span></span><span style=display:flex><span>    3 (  answer == factFunction(2)                                          ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in recursive case from proof function
</span></span><span style=display:flex><span>    4 (  âˆ€( (x: Z) =&gt; x &gt; 1 â†’ factFunction(x) == factFunction(x - 1) * x )  ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     //plug in &#34;2&#34; for &#34;x&#34; (where 2 is an integer of type Z)
</span></span><span style=display:flex><span>    5 (  2 &gt; 1 â†’ factFunction(2) == factFunction(2 - 1) * 2                 ) by AllE[Z](4),
</span></span><span style=display:flex><span>    6 (  2 &gt; 1                                                              ) by Algebra*(),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //2 &gt; 1, so use â†’
</span></span><span style=display:flex><span>    7 (  factFunction(2) == factFunction(2 - 1) * 2                         ) by ImplyE(5, 6),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in base case from proof function
</span></span><span style=display:flex><span>    8 (  factFunction(1) == 1                                               ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>    9 (  factFunction(2) == factFunction(1) * 2                             ) by Algebra*(7),
</span></span><span style=display:flex><span>    10 (  factFunction(2) == 2                                              ) by Algebra*(8, 9),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //proves claim in assert
</span></span><span style=display:flex><span>    11 (  answer == 2                                                       ) by Algebra*(1, 2, 10)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 2)</span></span></code></pre></div><h2 id=logika-fact-for-multiplication>Logika fact for multiplication</h2><p>Suppose we wanted to create a Logika fact that recursively defined multiplication. We first recursively define how we would multiply <span class="math align-center">$x * y$</span>. We know that our base case will be when <span class="math align-center">$y == 0$</span>, because anything times 0 is 0. We also saw that multiplication can be defined as repeated addition, so that <span class="math align-center">$x * y == x + x + ... x$</span> for a total of <span class="math align-center">$y$</span> additions. We also see that <span class="math align-center">$x * y == x + x * (y-1)$</span>, since we can pull out one of the additions and then have <span class="math align-center">$y-1$</span> additions left to do.</p><p>Here is our recursive definition of the problem:</p><ul><li>Base case: for all numbers x, x * 0 is 0</li><li>Recursive case: for all numbers x and all positive numbers y, x * y = x + x * (y-1)</li></ul><p>We can translate this directly to a proof function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def multFunction(m: Z, n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFacts = Fact(
</span></span><span style=display:flex><span>    //anything multiplied by 0 is just 0
</span></span><span style=display:flex><span>    âˆ€((x: Z) =&gt; multFunction(x, 0) == 0 ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    âˆ€( (x: Z) =&gt; âˆ€( (y: Z) =&gt; (y &gt; 1) â†’ (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We could use this Logika fact in the postcondition and loop invariant block for a multiplication function as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFunction(m: Z, n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFacts = Fact(
</span></span><span style=display:flex><span>    //anything multiplied by 0 is just 0
</span></span><span style=display:flex><span>    âˆ€((x: Z) =&gt; multFunction(x, 0) == 0 ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    âˆ€( (x: Z) =&gt; âˆ€( (y: Z) =&gt; (y &gt; 1) â†’ (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//want to find: num1 + num1 + ... + num1 (a total of num2 times)
</span></span><span style=display:flex><span>def mult(num1: Z, num2: Z): Z = {
</span></span><span style=display:flex><span>    Contract( 
</span></span><span style=display:flex><span>        Requires( num2 &gt;= 1 ),
</span></span><span style=display:flex><span>        Ensures( Res[Z] == multFunction(num1, num2) )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    var answer: Z = 0
</span></span><span style=display:flex><span>    var cur: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (cur != num2) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(cur, answer),
</span></span><span style=display:flex><span>            answer == multFunction(num1, cur),
</span></span><span style=display:flex><span>            cur &gt;= 0
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cur = cur + 1
</span></span><span style=display:flex><span>        answer = answer + num1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return answer
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>The example above does not include the verification steps to prove the loop invariant and postcondition, but those things could be accomplished in the same way as for the <code>factorial</code> function.</p><h2 id=logika-fact-for-fibonacci-numbers>Logika fact for Fibonacci numbers</h2><p>The Fibonacci sequence is:</p><span class="math align-center">$$
1, 1, 2, 3, 5, 8, 13, ...
$$</span><p><br><br></p><p>The first two Fibonacci numbers are both 1, and subsequent Fibonacci numbers are found by adding the two previous values. In the sequence above, we see that the two latest numbers were 8 and 13, so the next number in the sequence will be <span class="math align-center">$8 + 13 = 21$</span>.</p><p>We can recursively define the Fibonacci sequence as follows:</p><ul><li>Base case 1: the first Fibonacci number is 1</li><li>Base case 2: the second Fibonacci number is 1</li><li>Recursive case: for all numbers x greater than 2, the x-th Fibonacci number is the (x-1)-th Fibonacci number + the (x-2)-th Fibonacci number</li></ul><p>We can translate this directly to a Logika fact:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//defines the nth number in the Fibonacci sequence
</span></span><span style=display:flex><span>//1, 1, 2, 3, 5, 8, 13, ...
</span></span><span style=display:flex><span>@spec def fibFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def fibFacts = Fact(
</span></span><span style=display:flex><span>    fibFunction(1) == 1,
</span></span><span style=display:flex><span>    fibFunction(2) == 2,
</span></span><span style=display:flex><span>    âˆ€( (x: Z) =&gt; (x &gt; 2) â†’ fibFunction(x-1) + fibFunction(x-2) )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    âˆ€( (x: Z) =&gt; âˆ€( (y: Z) =&gt; (y &gt; 1) â†’ (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Which we could use in a postcondition and loop invariant if we wrote a function to compute the Fibonacci numbers.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:</p><h2 id=step-1-write-function-contracts>Step 1: Write function contracts</h2><p>Write a function contract for any function that doesn&rsquo;t already have one. Function contracts go just inside the function defintion, and look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires( preconditions ),
</span></span><span style=display:flex><span>    Ensures( postconditions )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, <em>preconditions</em> is a comma-separated list of any requirements your function has about the range of its parameters, and <em>postconditions</em> is a comma-separated list describing the impact of calling the function (in this chapter, the postcondition always describes how the return value relates to the parameters.) If you&rsquo;re not sure what to write as the postcondition, try walking through your function with different parameters to get a sense for the pattern of what the function is doing in relation to the parameters. If you were given a Logika proof function, you will likely need to use it in the postcondition (and loop invariant) to describe the behavior.</p><h2 id=step-2-write-loop-invariant-blocks>Step 2: Write loop invariant blocks</h2><p>Write a loop invariant block for any loop that doesn&rsquo;t already have one. Loop invariant blocks go just inside the loop (before any code) and look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Invariant(
</span></span><span style=display:flex><span>    Modifies(comma-separated list of variables),
</span></span><span style=display:flex><span>    Invariant_1,
</span></span><span style=display:flex><span>    Invariant_2,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Each <em>Invariant_i</em> describes an invariant for the loop, which should describe the progress the loop has made toward its goal (the loop invariant will often greatly resemble the postcondition for the enclosing function). Loop invariants occasionally need to specify the range of different variables, especially if the invariant uses Logika facts (which may only be defined for particular values) or if you need more information about the final value of a variable when a loop terminates. I recommend making a table of variable values for several iterations of your loop to get a sense of the relationship between variables &ndash; this relationship is what will become the loop invariant.</p><p>The <em>Modifies</em> clause lists all variables that are modified in the loop body.</p><h2 id=step-3-prove-invariant-holds-before-loop-begins>Step 3: Prove invariant holds before loop begins</h2><p>In each loop, prove your invariant holds before the loop begins. You may need to pull in the function&rsquo;s precondition as a premise in this step. You must prove EXACTLY the claim in all pieces of the loop invariant. If your loop invariant involves a Logika fact, you may need to pull in a piece of the fact definition to help prove the invariant.</p><h2 id=step-4-prove-invariant-still-holds-at-end-of-iteration>Step 4: Prove invariant still holds at end of iteration</h2><p>In each loop, prove your invariant still holds at the end of each iteration. Start by pulling in each part of the loop invariant as a premise before the loop body begins. Use logic blocks to process each statement in the body of the loop. By the end of the loop, you must prove EXACTLY the claim in all pieces of the loop invariant. (Again, if your loop invariant involves a Logika fact, you&rsquo;ll want to pull in a piece of the fact definition to help with this step.)</p><h2 id=step-5-prove-the-postcondition>Step 5: Prove the postcondition</h2><p>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition just before your function ends.</p><h2 id=step-6-prove-the-precondition-before-each-function-call>Step 6: Prove the precondition before each function call</h2><p>Before any function call, prove exactly the precondition(s) for the function (using whatever values you are passing as parameters).</p><h2 id=step-7-use-postcondition-after-each-function-call>Step 7: Use postcondition after each function call</h2><p>After returning from each function call, pull the function&rsquo;s postcondition into a logic block as a premise (using whatever values you passed as parameters). Use this information to help prove any asserts.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><h1 id=sequences-globals-and-termination>Sequences, Globals, and Termination</h1><p>In our conclusion of programming logic, we&rsquo;ll examines programs with sequences and global variables. We&rsquo;ll also learn the idea of <em>termination</em> in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Sequences, Globals, and Termination</h1><article class=default><header class=headline></header><h1 id=logika-modes>Logika Modes</h1><p>Logika has different modes for programming logic verification. We can switch between modes by going to File->Settings->Tools->Sireum->Logika.</p><h2 id=logikas-manual-mode>Logika&rsquo;s &ldquo;manual&rdquo; mode</h2><p>Up to now, we have been running Logika in &ldquo;manual mode&rdquo;, where we list the following settings at the beginning of a file:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._</span></span></code></pre></div><p>We are now reaching the point where additional practice in manual mode may no longer be a learning activity, and where the proof blocks after claim transformations can become dozens of lines long.</p><h2 id=logikas-auto-mode>Logika&rsquo;s auto mode</h2><p>In Chapter 10, we will be switching to Logika&rsquo;s &ldquo;auto mode&rdquo;, where we remove the <code>--manual</code> from our file settings. We also no longer need the <code>org.sireum.justification._</code> library:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._</span></span></code></pre></div><p>Auto mode allows us to reason about our program by using ONLY invariants and function contracts. While the same work has to be done for a program to be verified (the precondition must be true before a function call, the loop invariant must be true before the loop begins, etc.), symexe mode does the work of analyzing your program statements to ensure that all parts of your loop invariant and function contract are satisfied. When you use symexe mode, you will only need to include a function contract for each function and a loop invariant block for each loop, and it will do the grunt work.</p><h3 id=multiplication-example>Multiplication example</h3><p>In section 9.3, we did a verification of a multiplication program using Logika&rsquo;s manual mode. Here is how we would write the verification of the same program using Logika&rsquo;s symexe mode:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(n &gt;= 0),  //precondition: n should be nonnegative
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)    //postcondition (we promise to return m*n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var r: Z = 0
</span></span><span style=display:flex><span>    var i: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(r, i),
</span></span><span style=display:flex><span>            r == m * i
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        r = r + m
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return r
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><p>Note that the only proof blocks we needed to provide were the function contract and the loop invariant block.</p><h3 id=pitfalls>Pitfalls</h3><p>When using this more advanced mode, it is not always obvious why Logika will not verify. Sometimes semantic errors in the program keep it from verifying; i.e. Logika has found a corner or edge case for which the program does not account. Other times the invariants and conditions do not actually help prove the goal in an assert or postcondition. Inevitably, sometimes it will be both.</p><p>In either case an option is to begin typing each proof-block as if in manual mode until you find the logical or programming error.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=intro-to-sequences>Intro to Sequences</h1><p><em>Sequences</em> in Logika are fairly similar to lists in Python and arrays in Java and C#. As with lists and arrays, Logika sequences are ordered. Each element is stored at a particular (zero-based) position, and there are no gaps in the sequence.</p><p>Logika can work with sequences of integers (type <code>ZS</code>).</p><h2 id=sequence-syntax>Sequence syntax</h2><p>We can create new sequence variables like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//creates the sequence (5, 10, 15)
</span></span><span style=display:flex><span>var seq: ZS = ZS(5,10,15)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//creates an empty sequence of integers
</span></span><span style=display:flex><span>var empty: ZS = ZS()</span></span></code></pre></div><p>Given the following sequence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var a: ZS = ZS(1, 2, 3)</span></span></code></pre></div><p>Here is a table of the different sequence operations we will use in this course:</p><table><thead><tr><th>Operation</th><th>Explanation</th></tr></thead><tbody><tr><td>Indexing: <code>a(pos)</code></td><td>Accesses the value in the sequence at position <code>pos</code>.<br>Sequences are zero-based, and Logika will show an error if you have not proven (or if it cannot infer, in symexe mode) that the position lies within the sequence range.<br><br>For example, <code>a(0)</code> is 1.<br><code>a(0) = 11</code> would change the first value to be 11, so the sequence would be <code>(11,2,3)</code>.<br><code>a(3)</code> would give an error, as position 3 is past the end of the sequence.</td></tr><tr><td>Size: <code>a.size</code></td><td>Evaluates to the number of elements in the sequence: <code>a.size == 3</code></td></tr><tr><td>Reassignment</td><td>Sequences instantiated as <code>var</code> can be reassigned.<br><br>For example, after <code>a = ZS(5,6)</code>, <code>a</code> is now <code>(5,6)</code>.</td></tr></tbody></table><h2 id=sample-program-with-a-sequence>Sample program with a sequence</h2><p>Here is a sample program that uses a sequence. The <code>makeFirstZero</code> function sets the first element in a sequence to 0:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//&#34;Unit&#34; is like a void return type
</span></span><span style=display:flex><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style=display:flex><span>    seq(0) = 0
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>///// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var nums: ZS = ZS(1,2,3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>makeFirstZero(nums)
</span></span><span style=display:flex><span>assert(nums == ZS(0,2,3))</span></span></code></pre></div><p>This program will not be verified as we have not yet provided a function contract for <code>makeZeroFirst</code>. We will complete the verification for the program later in the section.</p><h2 id=predicate-logic-statements-with-sequences>Predicate logic statements with sequences</h2><p>When we write function contracts and loop invariants with sequences, we will need to make statements about <em>all</em> or <em>some</em> elements in a sequence. We can do this with predicate logic statements.</p><h3 id=statements-about-all-sequence-elements>Statements about all sequence elements</h3><p>As we did in chapters 4 and 5, we will use the universal (<code>âˆ€</code>) quantifier for statements involving all elements in a sequence. The basic forms of specifying some claim <code>P(a(x))</code> holds for every element in a sequence <code>a</code> are:</p><table><thead><tr><th>Statement</th><th>Explanation</th></tr></thead><tbody><tr><td><code>âˆ€ (lower to upper)(x => P(a(x)))</code></td><td><code>P(a(x))</code> holds for every element in <code>a</code> from position <code>lower</code> to position <code>upper</code> (including both <code>lower</code> and <code>upper</code>)</td></tr><tr><td><code>âˆ€ (lower until upper)(x => P(a(x)))</code></td><td><code>P(a(x))</code> holds for every element in <code>a</code> from position <code>lower</code> up to but not including position <code>upper</code> (<code>lower</code> but not <code>upper</code>)</td></tr></tbody></table><p>Here are several sample claims and explanations about integer sequence <code>a</code>:</p><table><thead><tr><th>Claim</th><th>Explanation</th></tr></thead><tbody><tr><td><code>âˆ€ (0 until a.size)(x => a(x) > 0)</code></td><td>Every element in <code>a</code> is greater than 0</td></tr><tr><td><code>âˆ€ (1 to 3)(x => a(x) == 0)</code></td><td>All elements in <code>a</code> between positions 1 and 3 (inclusive of 1 and 3) have value 0</td></tr><tr><td><code>âˆ€ (0 until a.size)(x => (a(x) &lt; 0 â†’ a(x) == -10)</code></td><td>All negative elements in <code>a</code> have value -10</td></tr></tbody></table><h3 id=statements-about-some-sequence-elements>Statements about some sequence elements</h3><p>We will use the existential (<code>âˆƒ</code>) quantifier for statements involving one or more elements in a sequence. The basic forms of specifying claims is the same as for the universal quantifier, but using the existential quantifier instead of the universal quantifier.</p><p>Here are several sample claims and explanations about integer sequences <code>a</code> and <code>b</code>:</p><table><thead><tr><th>Claim</th><th>Explanation</th></tr></thead><tbody><tr><td><code>âˆƒ (0 until a.size)(x => a(x) > 0)</code></td><td>There is an element in <code>a</code> that is greater than 0</td></tr><tr><td><code>âˆƒ (2 to 4)(x => a(x) == a(x-1) * 2)</code></td><td>There is an element in <code>a</code> between positions 2 and 4 (inclusive) that is twice as big as the previous element</td></tr><tr><td><code>âˆ€ (0 until a.size)(x => (âˆƒ (0 until b.size) (y => a(x) == b(y)))</code></td><td>Every value in <code>a</code> appears somewhere in <code>b</code></td></tr></tbody></table><h3 id=statements-about-initial-and-current-sequence-values>Statements about initial and current sequence values</h3><p>When we write preconditions, postconditions, and loop invariants involving sequences, we will want a way to distinguish between the INITIAL value a sequence had at the beginning of a function and the CURRENT value for that same sequence. We will use the notation <code>In(sequenceName)</code> to mean the value the sequence <code>sequenceName</code> had at the beginning of a function. In contrast, using just <code>sequenceName</code> refers to the value the sequence has right now (or, in the case of a postcondition, the value a sequence is promised to have at the end of a function).</p><p>For example, the postcondition:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ (0 until a.size)(i =&gt; a(i) == In(a)(i) + 1</span></span></code></pre></div><p>Means that when the function ends, every value in the sequence <code>a</code> (so each element <code>a(i)</code>) will be one bigger than the initial value at the same position (<code>In(a)(i) + 1</code>).</p><h3 id=shortcut-to-describing-sequence-changes>Shortcut to describing sequence changes</h3><p>Occasionally we wish to claim that a sequence is unchanged except for a handful of positions. We can do this in a more pedantic way by describing which elements have changed and which elements have not changed, but there is also a cleaner sequence update notation we can use instead.</p><p>For example, these postconditions state that a function sets the first element (position 0) in sequence a to 10, but leaves every other element unchanged:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a(0) == 10,
</span></span><span style=display:flex><span>âˆ€ (1 until a.size)(x =&gt; (a(x) == In(a)(x)))</span></span></code></pre></div><p>We could have described the same set of changes using the sequence update notation as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>a â‰¡ In(a)(0 ~&gt; 10)</span></span></code></pre></div><p>The statement above says that the resulting value of sequence <code>a</code> is equivalent to the initial value of sequence <code>a</code> (<code>In(a)</code>) except that position <code>0</code> now holds a <code>10</code>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sequences-in-functions>Sequences in Functions</h1><p>Sequences in Scala are passed to functions by reference. This means that if a function makes changes to a sequence parameter, then it will also change whatever sequence object was passed to the function. For example, the test code below passes <code>nums</code>, which has the value <code>ZS(1,2,3)</code>, to the <code>makeFirstZero</code> function. The <code>makeFirstZero</code> function changes the first position in its parameter (<code>seq</code>) to be 0, which means that the <code>nums</code> sequence in the test code will also have its first position set to 0 (making it have the value <code>ZS(0,2,3)</code>).</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def makeFirstZero(seq: ZS): Unit = {  // Unit is like void in Java and C#
</span></span><span style=display:flex><span>    seq(0) = 0
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>///////////// Test code /////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var nums: ZS = ZS(1,2,3)
</span></span><span style=display:flex><span>makeFirstZero(nums)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(nums == ZS(0,2,3))</span></span></code></pre></div><h2 id=preconditions-with-sequences>Preconditions with sequences</h2><p>When writing the precondition for a function that takes a sequence parameter, we must consider whether our function will only work correctly for particular sequence values or sizes. For example, our <code>makeFirstZero</code> function will not work if the size of the <code>seq</code> parameter is zero. We would need to add this requirement to the function&rsquo;s precondition (to its <code>Requires</code> clause):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>seq.size &gt; 0</span></span></code></pre></div><p>If we wanted to require that all values in a sequence parameter (say, <code>nums</code>) be between 10 and 20, we would add the following to the precondition:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>âˆ€ (0 until nums.size)(x =&gt; (nums(x) &gt;= 10 âˆ§ nums(x) &lt;= 20))</span></span></code></pre></div><p>Sometimes, functions with sequence parameters will work for any size/values &ndash; in those cases, we don&rsquo;t need to list anything about the sequence in the precondition.</p><h2 id=function-modifies-clause>Function <code>Modifies</code> clause</h2><p>We learned in chapter 9 that the format of a function contract is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires (  preconditions   ),
</span></span><span style=display:flex><span>    Ensures (   postconditions  )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>However, there is actually a third portion of the function contract that we have omitted until this point &ndash; the <code>Modifies</code> clause. This clause is required whenever a function changes the values in a sequence parameter or changes global variables. For example, the <code>makeFirstZero</code> function DOES change its sequence parameter, <code>seq</code>, as it sets its first position to 0. <code>makeFirstZero</code> should therefore include this <code>Modifies</code> clause:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Modifies ( seq ),</span></span></code></pre></div><p>This clause goes between the precondition (<code>Requires</code>) and the postcondition (<code>Ensures</code>), making the new template for the function contract look like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires (  preconditions   ),
</span></span><span style=display:flex><span>    Modifies (  comma-separated list of sequences/global variables modified by the function ),
</span></span><span style=display:flex><span>    Ensures (   postconditions  )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>If the function modifies more than one sequence or global variable, they are listed together in a comma-separated list in the <code>Modifies</code> clause.</p><h2 id=postconditions-with-sequences>Postconditions with sequences</h2><p>When writing the postcondition for a function that uses a sequence parameter, we must consider two things:</p><ul><li>How the return value relates to the sequence</li><li>How the function will change the sequence</li></ul><h3 id=relating-return-values-to-sequence-elements>Relating return values to sequence elements</h3><p>We will still use the <code>Res[Type]</code> keyword for describing the function&rsquo;s return value in the postcondition. For example, if a function was returning the smallest value in the integer sequence <code>nums</code>, we would say:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Ensures(
</span></span><span style=display:flex><span>    âˆ€ (0 until nums.size)(x =&gt; (Res[Z] &lt;= nums(x))),
</span></span><span style=display:flex><span>    âˆƒ (0 until nums.size)(x =&gt; (Res[Z] == nums(x)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, the first postcondition states that our return value will be less than or equal to every value in the sequence, and the second postcondition states that our return value is one of the sequence elements. (The second postcondition prevents us from sneakily returning some negative number and claiming that it was the smallest element in the sequence, when in fact it wasn&rsquo;t one of the sequence elements.)</p><p>Sometimes, our postconditions will promise to return a particular value if some claim about the sequence is true. Suppose we have a function that returns whether or not (i.e., a boolean) all elements in the sequence <code>a</code> are negative. Our postcondition would be:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Ensures(
</span></span><span style=display:flex><span>    ( âˆ€ (0 until a.size)(x =&gt; (a(x) &lt; 0)) ) â†’ (result == true),
</span></span><span style=display:flex><span>    ( âˆƒ (0 until a.size)(x =&gt; (a(x) &gt;= 0)) ) â†’ (result == false),
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, the first postcondition promises that if all sequence elements are negative, then the function will return true. The second postcondition promises the opposite &ndash; that if there is a nonnegative sequence element, then the function will return false.</p><h3 id=describing-how-the-function-changes-the-sequence>Describing how the function changes the sequence</h3><p>Consider again the <code>makeFirstZero</code> function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style=display:flex><span>    seq(0) = 0
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This function doesn&rsquo;t return anything (hence the <code>Unit</code> return type), but we do need to describe what impact calling this function will have on the sequence. We can partially accomplish our goal with this postcondition (in our <code>Ensures</code> clause):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>seq(0) == 0</span></span></code></pre></div><p>Which promises that after the function ends, the first value in the sequence will be 0. However, suppose we wrote this instead for the <code>makeFirstZero</code> function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style=display:flex><span>    seq(0) = 0
</span></span><span style=display:flex><span>    seq(1) = 100
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This version of the function DOES satisfy the postcondition &ndash; the first element is indeed set to 0 &ndash; but it changes other elements, too. The postcondition should be descriptive enough that anyone calling it can be certain EXACTLY what every single value in the sequence will be afterwards. Our postcondition needs to describe exactly what values in the sequence WILL change and exactly what values WON&rsquo;T change.</p><p>This means that our <code>makeFirstZero</code> function needs to state that the first element in <code>seq</code> gets set to 0, and that every other value in the sequence <em>stays the same as its original value</em>. To help us describe the <em>original value</em> of a sequence, we can use the special <code>In(sequenceName)</code> syntax, which holds the value of a sequence parameter <code>sequenceName</code> at the time the function was called. (This <code>In</code> syntax can only be used in logic blocks, not in the code.)</p><p>We can specify exactly what happens to each sequence element in our first version of <code>makeFirstZero</code> like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Ensures(
</span></span><span style=display:flex><span>    seq(0) == 0,
</span></span><span style=display:flex><span>    âˆ€ (1 until seq.size)(x =&gt; ( seq(x) == In(seq)(x)))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>The second postcondition says: &ldquo;All elements from position 1 on keep their original values&rdquo;.</p><h2 id=example-finished-makefirstzero-verification>Example: finished <code>makeFirstZero</code> verification</h2><p>Now that we have seen all the pieces of writing function contracts for functions that work with sequences, we can put together the full function contract for our <code>makeFirstZero</code> function. The assert statement in the test code will be verified by Logika&rsquo;s auto mode:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(  seq.size &gt; 0  ),
</span></span><span style=display:flex><span>        Modifies(  seq  ), 
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>        seq(0) == 0,
</span></span><span style=display:flex><span>        âˆ€ (1 until seq.size)(x =&gt; ( seq(x) == In(seq)(x)))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    seq(0) = 0
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var nums: ZS = ZS(1,2,3)
</span></span><span style=display:flex><span>makeFirstZero(nums)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(nums == ZS(0,2,3))</span></span></code></pre></div><h2 id=example-swap-program>Example: swap program</h2><p>Suppose we have the following swap program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def swap(list: ZS, pos1: Z, pos2: Z): Unit = {
</span></span><span style=display:flex><span>    val temp: Z = list(pos1)
</span></span><span style=display:flex><span>    list(pos1) = list(pos2)
</span></span><span style=display:flex><span>    list(pos2) = temp
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>///////////// Test code ///////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var testList: ZS = ZS(1,2,3,4)
</span></span><span style=display:flex><span>swap(testList,0,3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the values in positions 0 and 3 should be swapped
</span></span><span style=display:flex><span>//all other elements should be the same
</span></span><span style=display:flex><span>assert(testList == ZS(4,2,3,1))</span></span></code></pre></div><p>Here, <code>swap</code> takes an integer sequence (<code>list</code>) and two positions (<code>pos1</code> and <code>pos2</code>). It uses a temp variable to swap the values in <code>list</code> at <code>pos1</code> and <code>pos2</code>. We would like to write an appropriate function contract so the assert statement in the test code holds.</p><p>We must first consider the precondition &ndash; does <code>swap</code> have any requirements about its parameters? Since <code>swap</code> uses <code>pos1</code> and <code>pos2</code> as positions within <code>list</code>, we can see that <code>swap</code> will crash if either position is out of bounds &ndash; either negative or past the end of the sequence.</p><p>The function is changing the sequence, so we will need a <code>Modifies</code> clause. Finally, we must consider the postcondition. This function isn&rsquo;t returning a value, but it is changing the sequence &ndash; so we should describe exactly what values HAVE changed (and their new values) and what values have NOT changed. We want to say that:</p><ul><li><code>list(pos1)</code> has the value that was originally at <code>list(pos2)</code> (i.e, the value at <code>In(list)(pos2)</code>)</li><li><code>list(pos2)</code> has the value that was originally at <code>list(pos1)</code> (i.e, the value at <code>In(list)(pos1)</code>)</li><li>All other positions are unchanged (i.e., they are the same as they were in <code>In(list)</code>)</li><li>The size doesn&rsquo;t change (which we must always list if a sequence is modified)</li></ul><p>We can now complete the function contract for <code>swap</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def swap(list: ZS, pos1: Z, pos2: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(
</span></span><span style=display:flex><span>            0 &lt;= pos1 &amp; pos1 &lt; list.size, // pos1 is a valid index
</span></span><span style=display:flex><span>            0 &lt;= pos2 &amp; pos2 &lt; list.size  // pos2 is a valid index
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        Modifies(list),           // documents list is modified
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            list(pos1) == In(list)(pos2),
</span></span><span style=display:flex><span>            list(pos2) == In(list)(pos1),
</span></span><span style=display:flex><span>            list.size == In(list).size,
</span></span><span style=display:flex><span>            âˆ€ (0 until list.size)(x =&gt; (x != pos1 &amp; x != pos2 â†’ list(x) == In(list)(x)))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  val temp: Z = list(pos1)
</span></span><span style=display:flex><span>  list(pos1) = list(pos2)
</span></span><span style=display:flex><span>  list(pos2) = temp
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var testList: ZS = ZS(1,2,3,4)
</span></span><span style=display:flex><span>swap(testList,0,3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(testList == ZS(4,2,3,1))</span></span></code></pre></div><p>If we test this program in Logika&rsquo;s symexe mode, the final assert will hold &ndash; we have enough information to make a claim about EXACTLY what the sequence will look like after calling <code>swap</code>.</p><p>Note that we could have simplified the postcondition by using the <em>sequence update notation</em> described at the end of section 10.2. We want to say that the value of <code>list</code> at the end of the function is equivalent to the value of list at the beginning of the function (<code>In(list)</code>) with the following exceptions:</p><ul><li>The new value at <code>pos1</code> should be the original value at <code>pos2</code> (<code>In(list)(pos2)</code>)</li><li>The new value at <code>pos2</code> should be the original value at <code>pos1</code> (<code>In(list)(pos1)</code>)</li></ul><p>Here is the equivalent (but shorter) postcondition for <code>swap</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Ensures(
</span></span><span style=display:flex><span>    list â‰¡ In(list)(pos1 ~&gt; In(list)(pos2), pos2 ~&gt; In(list)(pos1))
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sequences-in-loops>Sequences in Loops</h1><p>We also must consider sequences when writing loop invariants. Typically, we must include the following in our invariant:</p><ul><li>If the sequence changes in the loop<ul><li>Describe what sequence elements have already changed in the loop (and what their new values are)</li><li>Describe what sequence elements still have their original value</li><li>Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence)</li><li>State that the sequence size does not change (to reinforce that the variable used as the sequence position will not go out of bounds)</li><li>List the sequence along with other changing variables in the loop invariant block&rsquo;s <code>Modifies</code> clause</li></ul></li><li>If the sequence does not change in the loop<ul><li>Consider what we are doing with each sequence element as we look at them. Usually we have another variable that is storing our progress (and often, this variable is returned from the function after the loop). Express how the variable&rsquo;s value relates to the part of the sequence we&rsquo;ve looked at so far &ndash; this statement should look very similar to your postcondition, but should only describe part of the sequence.</li><li>Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence)</li></ul></li></ul><h2 id=example-add-one-to-all-program>Example: add one to all program</h2><p>Suppose we have the following program, which adds one to every element in a sequence parameter:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def addOne(list: ZS): Unit = {
</span></span><span style=display:flex><span>    var i: Z = 0
</span></span><span style=display:flex><span>    while (i &lt; list.size) {
</span></span><span style=display:flex><span>        list(i) = list(i) + 1
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////////// Calling code ///////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var test: ZS = ZS(1,2,3,4)
</span></span><span style=display:flex><span>addOne(test)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(test == ZS(2,3,4,5))</span></span></code></pre></div><p>We would like to write an appropriate function contract and loop invariant block so the assert statement in the test code holds (which asserts that the sequence <code>ZS(1,2,3,4)</code> becomes the sequence <code>ZS(2,3,4,5)</code> after calling the function).</p><p>For the function contract, we must consider:</p><ul><li><em>Precondition</em>: this function will work correctly on all sequences &ndash; even empty ones. We can leave the <code>Requires</code> clause off.</li><li><code>Modifies</code> clause: this function is changing the <code>list</code> sequence parameter, so we must list it in a <code>modifies</code> clause.</li><li><em>Postcondition</em>: the function is not returning anything, but we must describe that all sequence parameters will be one bigger than their original values.</li></ul><p>For the loop invariant block, we notice that the loop is changing the sequence. We must include:</p><ul><li><em>Which elements have already changed</em>. Since <code>i</code> is tracking our position in the sequence, we know that at the end of each iteration, all elements from position 0 up to but not including position <code>i</code> have been changed to be one bigger than their original values.</li><li><em>Which elements have not changed</em>. All other elements in the sequence &ndash; from position <code>i</code> to the end of the sequence &ndash; still have their original values</li><li><em>Upper and lower bounds for position variables</em>. Since <code>i</code> is tracking our position, we must state that i is always a valid sequence index. Here, we need to claim that <code>i</code> will always be greater than or equal to 0 and less than or equal to the sequence size. (While the sequence size itself is not a valid sequence index, we see from looking at the loop that <code>i</code> is incrementing as the very last step in the loop. On the last iteration, <code>i</code> will start off at <code>list.size-1</code>, and we will correctly access and modify the last element in <code>list</code>. Then we will increment <code>i</code>, making it EQUAL <code>list.size</code> &ndash; at that point, the loop ends. If we made part of our invariant be <code>i &lt; list.size</code>, it would be incorrect because of that last iteration.)</li><li><em>State that the sequence size does not change</em>. This is necessary any time we are writing a loop modifying a sequence in order to ensure that the sequence index (<code>i</code> in this case) will not go past the end of the sequence.</li></ul><p>We can now complete the function contract and loop invariant for <code>addOne</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def addOne(list: ZS): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Modifies(list),
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            âˆ€ (0 until list.size)(x =&gt; (list(x) == In(list)(x) + 1))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var i: Z = 0
</span></span><span style=display:flex><span>    while (i &lt; list.size) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(i, list),
</span></span><span style=display:flex><span>            i &gt;= 0,
</span></span><span style=display:flex><span>            i &lt;= list.size,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             //the sequence size never changes
</span></span><span style=display:flex><span>            list.size == In(list).size,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             //what I HAVE changed
</span></span><span style=display:flex><span>            âˆ€ (0 until i)(x =&gt; (list(x) == In(list)(x) + 1)),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             //what I HAVEN&#39;T changed
</span></span><span style=display:flex><span>            âˆ€ (i until list.size)(x =&gt; (list(x) == In(list)(x)))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        list(i) = list(i) + 1
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////////// Calling code ///////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var test: ZS = ZS(1,2,3,4)
</span></span><span style=display:flex><span>addOne(test)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(test == ZS(2,3,4,5))</span></span></code></pre></div><p>If we try to verify this program in Logika&rsquo;s auto mode, the final assert will hold &ndash; we have enough information to know what the sequence will look like after calling <code>addOne</code>.</p><h2 id=example-min-program>Example: min program</h2><p>In our next example, we examine a function that does <em>not</em> modify its sequence parameter, and that <em>does</em> return a value. Consider the following <code>min</code> function and test code:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//return the smallest element in list
</span></span><span style=display:flex><span>def min(list: ZS): Z = {
</span></span><span style=display:flex><span>    var small: Z = list(0)
</span></span><span style=display:flex><span>    var i: Z = 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i &lt; list.size) {
</span></span><span style=display:flex><span>        if (list(i) &lt; small) {
</span></span><span style=display:flex><span>            small = list(i)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return small
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////////// Calling code ///////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var test: ZS = ZS(8,1,0,10,9,2,0)
</span></span><span style=display:flex><span>var testMin: Z = min(test)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(testMin == 0)</span></span></code></pre></div><p>Here, our <code>min</code> function is supposed to find and return the smallest value in an integer sequence. We can see that our test code passes <code>min</code> the sequence (<code>ZS(8,1,0,10,9,2,0)</code>), and that we are trying to assert that <code>min</code> correctly returns <code>0</code> as the smallest value in the sequence. We need to add an appropriate function contract and loop invariant block to make this assert hold.</p><p>For the function contract, we must consider:</p><ul><li><em>Precondition</em>: this function starts by saving out the element at position 0. If the sequence was empty, the function would crash. We need to require that the sequence size be at least 1.</li><li><code>Modifies</code> clause: this function is NOT modifying its sequence parameter, so we can omit this clause</li><li><em>Postcondition</em>: the function is not changing the sequence, so we do not need to describe the final values of each sequence element. We <em>do</em> need to describe what value we are returning, and how it relates to the sequence. We want to describe that <code>Res[Z]</code> (our return value) is the smallest integer in <code>list</code>, so that:<ul><li><code>Res[Z]</code> is less than or equal to every element in <code>list</code></li><li>There is an element in <code>list</code> that equals <code>Res[Z]</code> (i.e., we really are returning one of our sequence values)</li></ul></li></ul><p>For the loop invariant block, we notice that the loop is NOT changing the sequence. We must include:</p><ul><li><em>What we are doing with each sequence element, and how that relates to another variable</em>. We can see that <code>small</code> tracks the smallest element we&rsquo;ve seen in the sequence so far &ndash; up to but not including position <code>i</code>. Similar to the postcondition, we want to claim that:<ul><li><code>small</code> is less than or equal to every element in <code>list</code> <em>that we have seen so far</em></li><li>There is an element <em>we have already seen</em> in <code>list</code> that equals small</li></ul></li><li><em>Upper and lower bounds for position variables</em>. Here, <code>i</code> is our position variable. We see that it is initialized to 1, so we will claim that it is always greater than or equal to 1 and less than or equal to the list size.</li><li><code>Modifies</code> clause - the variables <code>small</code> and <code>i</code> are modified in the while loop</li></ul><p>We can now complete the function contract and loop invariant for <code>min</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def min(list: ZS): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (list.size &gt;= 1),
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            âˆ€ (0 until list.size)(x =&gt; (Res[Z] &lt;= list(x))),
</span></span><span style=display:flex><span>            âˆƒ (0 until list.size)(x =&gt; (Res[Z] == list(x)))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var small: Z = list(0)
</span></span><span style=display:flex><span>    var i: Z = 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i &lt; list.size) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(i, small),
</span></span><span style=display:flex><span>            i &gt;= 1,
</span></span><span style=display:flex><span>            i &lt;= list.size,
</span></span><span style=display:flex><span>            âˆ€ (0 until i)(x =&gt; (small &lt;= list(x))),
</span></span><span style=display:flex><span>            âˆƒ (0 until i)(x =&gt; (small == list(x)))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        if (list(i) &lt; small) {
</span></span><span style=display:flex><span>            small = list(i)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return small
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////////// Calling code ///////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var test: ZS = ZS(8,1,0,10,9,2,0)
</span></span><span style=display:flex><span>var testMin: Z = min(test)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(testMin == 0)</span></span></code></pre></div><p>If we try to verify this program in Logika&rsquo;s auto mode, the final assert will hold &ndash; we have enough information to know exactly the minimum value in <code>test</code>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=global-variables>Global Variables</h1><h2 id=motivation>Motivation</h2><p>We will now consider programs with multiple functions that modify a shared pool of <em>global variables</em>. (This is very similar to the concerns in general classes in Java or C#, where multiple methods might edit fields/property values for an object). We want to be sure that global variables will maintain desired ranges and relationships between one another, even as multiple functions modify their values.</p><h2 id=global-variables-in-logika>Global variables in Logika</h2><p>A global variable exists before any function call, and still exists after any function ends.</p><h3 id=functions-that-access-global-variables>Functions that access global variables</h3><p>Consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//global variable
</span></span><span style=display:flex><span>var feetPerMile: Z = 5280  // feet in a mile mile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def convertToFeet(m : Z): Z = {
</span></span><span style=display:flex><span>    val feet: Z = m * feetPerMile
</span></span><span style=display:flex><span>    return feet
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/////////// Calling code ////////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var miles: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var totalFeet: Z = 0
</span></span><span style=display:flex><span>if (miles &gt;= 0){
</span></span><span style=display:flex><span>    totalFeet = convertToFeet(miles)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here, <code>feetPerMile</code> is a global variable &ndash; it exists before the <code>convertToFeet</code> function is called, and still exists after <code>convertToFeet</code> ends. In contrast, the <code>feet</code> variable inside <code>convertToFeet</code> is NOT global &ndash; its scope ends when the <code>convertToFeet</code> function returns.</p><p>(The <code>miles</code> and <code>totalFeet</code> variables in the calling code do not behave as global variables, as they were declared after any function definition. However, if we did add additional functions after our calling code, then <code>miles</code> and <code>totalFeet</code> would be global to those later functions. In Logika, the scope for any variable declared outside of a function begins at the point in the code where it is declared.)</p><p>In the example above, <code>convertToFeet</code> only accesses the <code>feetPerMile</code> global variable. A global variable that is read (but not updated) by a function body can be safely used in the functions precondition and postcondition &ndash; it acts just like an extra parameter to the function. We might edit <code>convertToFeet</code> to have this function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//global variable
</span></span><span style=display:flex><span>var feetPerMile: Z = 5280  // feet in a mile mile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def convertToFeet(m : Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Requires (
</span></span><span style=display:flex><span>            m &gt;= 0,             //only do conversions on nonnegative distances
</span></span><span style=display:flex><span>            feetPerMile &gt; 5200  //not needed, but demonstrates using global variables in preconditions
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //can use global variable in postcondition
</span></span><span style=display:flex><span>        Ensures (Res[Z]== m * feetPerMile)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val feet: Z = m * feetPerMile
</span></span><span style=display:flex><span>    return feet
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/////////// Calling code ////////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var miles: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var totalFeet: Z = 0
</span></span><span style=display:flex><span>if (miles &gt;= 0){
</span></span><span style=display:flex><span>    totalFeet = convertToFeet(miles)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>However, we cannot assign to a global variable the result of calling a function. That is, <code>totalFeet = convertToFeet(5)</code> is ok, and so is <code>totalFeet = convertToFeet(feetPerMile)</code>, but <code>feetPerMile = convertToFeet(5)</code> is not.</p><h3 id=functions-that-modify-global-variables>Functions that modify global variables</h3><p>Every global variable that is modified by a function must be listed in that function&rsquo;s <code>Modifies</code> clause. Such functions must also describe in their postconditions how these global variables will be changed by the function from their original (pre-function call) values. We will use the notation <code>In(globalVariableName)</code> for the value of global variable <code>globalVariableName</code> at the start of the function, just as we did for sequences.</p><p>Here is an example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//global variable
</span></span><span style=display:flex><span>var time: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def tick(): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(time &gt; 0),
</span></span><span style=display:flex><span>        Modifies (time),
</span></span><span style=display:flex><span>        Ensures (time == In(time) + 1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    time = time + 1
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here, we have a global <code>time</code> variable and a <code>tick</code> function that increases the time by 1 with each function call. Since the <code>tick</code> function changes the <code>time</code> global variable, we must include two things in its function contract:</p><ul><li>A <code>Modifies</code> clause that lists <code>time</code> as one of the global variables modified by this function</li><li>A postcondition that describes how the value of <code>time</code> after the function call compares to the value of <code>time</code> just before the function call. The statement <code>time == In(time) + 1</code> means: &ldquo;the value of time after the function call equals the value of time just before the function call, plus one&rdquo;.</li></ul><h2 id=global-invariants>Global invariants</h2><p>When we have a program with global variables that are modified by multiple functions, we often want some way to ensure that the global variables always stay within a desired range, or always maintain a particular relationship among each other. We can accomplish these goals with <em>global invariants</em>, which specify what must always be true about global variables.</p><h3 id=bank-example>Bank example</h3><p>For example, consider the following partial program that represents a bank account:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//global variables
</span></span><span style=display:flex><span>var balance: Z = 0
</span></span><span style=display:flex><span>var elite: B = false
</span></span><span style=display:flex><span>val eliteMin: Z = 1000000 //$1M is the minimum balance for elite status
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//global invariants
</span></span><span style=display:flex><span>@spec def inv = Invariant(  
</span></span><span style=display:flex><span>    balance &gt;= 0,                   //balance should be non-negative
</span></span><span style=display:flex><span>    elite == (balance &gt;= eliteMin)  //elite status should reflect if balance is at least a million
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def deposit(amount: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        //We still need to complete the function contract
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    balance = balance + amount
</span></span><span style=display:flex><span>    if (balance &gt;= eliteMin) {
</span></span><span style=display:flex><span>        elite = true
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        elite = false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def withdraw(amount: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        //We still need to complete the function contract
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    balance = balance - amount
</span></span><span style=display:flex><span>    if (balance &gt;= eliteMin) {
</span></span><span style=display:flex><span>        elite = true
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        elite = false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here, we have three global variables: <code>balance</code> (the bank account balance), <code>elite</code> (whether or not the customer has &ldquo;elite status&rdquo; with the bank, which is given to customers maintaining above a certain balance threshold), and <code>eliteMin</code> (a value representing the minimum account balance to achieve elite status). We have two global invariants describing what must always be true about these global variables:</p><ul><li><code>balance >= 0</code>, which states that the account balance must never be negative</li><li><code>elite == (balance >= eliteMin)</code>, which states that the <code>elite</code> boolean flag should always accurately represent whether the customer&rsquo;s current account balance is over the minimum threshold for elite status</li></ul><h3 id=global-invariants-must-hold-before-each-function-call>Global invariants must hold before each function call</h3><p>In any program with global invariants, we either must prove (in manual mode) or there must be sufficient evidence (in auto mode) that each global invariant holds immediately before any function call (including when the program first begins, before any function call). In our bank example, we see that the global variables are initialized as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var balance: Z = 0
</span></span><span style=display:flex><span>var elite: B = false
</span></span><span style=display:flex><span>val eliteMin: Z = 1000000</span></span></code></pre></div><p>In auto mode, there is clearly enough evidence that the global invariants all hold with those initial values &ndash; the balance is nonnegative, and the customer correctly does not have elite status (because they do not have about the $1,000,000 threshold).</p><h3 id=global-invariants-must-still-hold-at-the-end-of-each-function-call>Global invariants must still hold at the end of each function call</h3><p>Since we must demonstrate that global invariants hold before each function call, functions themselves can assume the global invariants are true at the beginning of the function. If we were using manual mode, we could list each global invariant as a <code>Premise</code> at the beginning of the function &ndash; much like we do with preconditions. Then, it is the job of each function to ensure that the global invariants STILL hold when the function ends. In manual mode, we would need to demonstrate that each global invariant claim <code>globalInvariant</code> still held in a logic block just before the end of the function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //each global invariant must still hold at the end of the function
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    1 ( globalInvariant )   by SomeJustification 
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>In auto mode, we do not need to include such logic blocks, but there must be sufficient detail in the function contract to infer that each global invariant will hold no matter what at the end of the function.</p><h3 id=bank-function-contracts>Bank function contracts</h3><p>Consider the <code>deposit</code> function in our bank example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def deposit(amount: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        //We still need to complete the function contract
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    balance = balance + amount
</span></span><span style=display:flex><span>    if (balance &gt;= eliteMin) {
</span></span><span style=display:flex><span>        elite = true
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        elite = false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Since <code>deposit</code> is modifying the global variables <code>balance</code> and <code>elite</code>, we know we must include two things in its function contract:</p><ul><li>A <code>Modifies</code> clause that lists <code>balance</code> and <code>elite</code> as global variables modified by this function</li><li>A postcondition that describes how the value of <code>balance</code> after the function call compares to the value of <code>balance</code> just before the function call. We want to say, <code>balance == In(balance) + amount</code>, because the value of <code>balance</code> at the end of the function equals the value of <code>balance</code> at the beginning of the function, plus <code>amount</code>.</li></ul><p>We also must consider how the <code>elite</code> variable changes as a result of the function call. In the code, we use an if/else statement to ensure that <code>elite</code> gets correctly updated if the customer&rsquo;s new balance is above or below the threshold for elite status. If we were to write a postcondition that summarized how <code>elite</code> was updated by the function, we would write: <code>elite == (balance >= eliteMin)</code> to say that the value of elite after the function equaled whether the new balance was above the threshold. However, this claim is already a global invariant, which already must hold at the end of the function. We do not need to list it again as a postcondition.</p><p>Consider this potential function contract for <code>deposit</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def deposit(amount: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        //this function contract is not quite correct
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Modifies (balance, elite ),
</span></span><span style=display:flex><span>        Ensures( balance == In(balance) + amount )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    balance = balance + amount
</span></span><span style=display:flex><span>    if (balance &gt;= eliteMin) {
</span></span><span style=display:flex><span>        elite = true
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        elite = false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This function contract is close to correct, but contains a major flaw. In symexe mode, the function contract must be tight enough to guarantee that the global invariants will still hold after the function ends. Suppose <code>balance</code> still has its starting value of 0, and that we called <code>deposit(-100)</code>. With no other changes, the function code would dutifully update the <code>balance</code> global variable to be -100&mldr;which would violate the global invariant that <code>balance >= 0</code>. In order to guarantee that the balance will never be negative after the <code>deposit</code> function ends, we must restrict the deposit amounts to be greater than or equal to 0. Since functions are can assume that the global invariants hold when they are called, we know that <code>balance</code> will be 0 at minimum at the beginning of <code>deposit</code>. If <code>amount</code> is also nonnegative, we can guarantee that the value of <code>balance</code> at the end of the <code>deposit</code> function will be greater than or equal to 0 &ndash; thus satisfying our global invariant.</p><p>Here is the corrected <code>deposit</code> function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def deposit(amount: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires( amount &gt;= 0 ),
</span></span><span style=display:flex><span>        Modifies( balance, elite ),
</span></span><span style=display:flex><span>        Ensures( In(balance) == balance + amount )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    balance = balance + amount
</span></span><span style=display:flex><span>    if (balance &gt;= eliteMin) {
</span></span><span style=display:flex><span>        elite = true
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        elite = false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We can similarly write the function contract for the <code>withdraw</code> function. Since withdraw is subtracting an amount from the balance, we must require that the withdraw amount be less than or equal to the account balance &ndash; otherwise, the account balance might become negative, and we would violate the global invariant. We will also require that our withdrawal amount be nonnegative, as it doesn&rsquo;t make any sense to withdraw a negative amount from a bank account:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def withdraw(amount: Z): Unit = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires( balance &gt;= amount ),
</span></span><span style=display:flex><span>        Modifies( balance, elite ),
</span></span><span style=display:flex><span>        Ensures( balance == In(balance) - amount )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    balance = balance - amount
</span></span><span style=display:flex><span>    if (balance &gt;= eliteMin) {
</span></span><span style=display:flex><span>        elite = true
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        elite = false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=bank-calling-code>Bank calling code</h3><p>When we call a function in a program with global invariants (whether in the calling code or from another function), we must consider four things:</p><ul><li>We must demonstrate that all global variables hold before the function call</li><li>We must demonstrate that the preconditions for the function holds</li><li>We can assume that all global variables hold after the function call (as the function itself if responsible for showing that the global invariants still hold just before the function ends)</li><li>We can assume the postcondition for the function holds after the function call</li></ul><p>Suppose we had this test code at the end of our bank program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>deposit(500000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//Assert will hold
</span></span><span style=display:flex><span>assert(balance == 500000 &amp;&amp; elite == false)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>deposit(500000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//Assert will hold
</span></span><span style=display:flex><span>assert(balance == 1000000 &amp;&amp; elite == true)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//Precondition will not hold
</span></span><span style=display:flex><span>withdraw(2000000)</span></span></code></pre></div><p>We already showed how our global invariants initially held for the starting values of the global variables (<code>balance = 0</code> and <code>elite = false</code>). When we consider the first function call, <code>deposit(500000)</code>, we can also see that the precondition holds (we are depositing a non-negative amount). The <code>deposit</code> postcondition tells us that the new value of <code>balance</code> is 500000 more than it was before the function call, so we know balance is now 500000. We can also assume that all global invariants hold after the <code>deposit</code> call, so we can infer that <code>elite</code> is still false (since the balance is not more than the threshold). Thus the next assert statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(balance == 500000 &amp;&amp; elite == false)</span></span></code></pre></div><p>will hold in Logika&rsquo;s auto mode.</p><p>The very next statement in the calling code is another call to <code>deposit</code>. Since we could assume the global invariants held immediately after the last call to deposit, we can infer that they still hold before the next <code>deposit</code> call. We also see that the function&rsquo;s precondition is satisfied, as we are depositing another nonnegative value. Just as before, we can use the <code>deposit</code> postcondition to see that <code>balance</code> will be 1000000 after the next function call (the postcondition tells us that <code>balance</code> is 500000 more than it was just before the function call). We also know that the global invariants hold, so we are sure <code>elite</code> has been updated to true. Thus our next assert holds as well:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(balance == 1000000 &amp;&amp; elite == true)</span></span></code></pre></div><p>Our final function call, <code>withdraw(2000000)</code>, will not be allowed. We are trying to withdraw $2,000,000, but our account balance at this point is $1,000,000. We will get an error saying that the <code>withdraw</code> precondition has not been satisfied, as that function requires that our withdrawal amount be less than or equal to the account balance.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=termination>Termination</h1><h2 id=what-is-termination>What is termination?</h2><p>In this section, we will consider the notion of <em>termination</em> &ndash; whether a function will ever finish running.</p><h2 id=partial-correctness-vs-total-correctness>Partial correctness vs total correctness</h2><p>Up to this point, we have proved <em>partial correctness</em> for functions &ndash; IF the function&rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.</p><h3 id=example-of-partial-correctness>Example of partial correctness</h3><p>Consider the following version of our <code>mult</code> function, which uses repeated addition to multiply two numbers:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == m * count
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + m
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  return sum
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This function will be verified in Logika&rsquo;s auto mode, but in fact it has a subtle flaw. If we were to pass in <code>-1</code> for our second parameter (<code>n</code>), then we would get stuck in an infinite loop. <code>count</code> would be initially 0, and we would increment <code>count</code> each time in the loop, but of course it NEVER equal -1.</p><p>This is an example of partial correctness &ndash; if our function DOES finish (which it would for nonnegative values of <code>n</code>), then we have shown it will return the correct value. We can see that we will need to require that the <code>n</code> parameter be nonnegative .</p><h3 id=total-correctness-definition>Total correctness definition</h3><p><em>Total correctness</em> goes a step further than partial correctness &ndash; it says that IF the function&rsquo;s precondition holds, THEN we promise that it will terminate and that its postcondition will hold.</p><p>In order to show total correctness for our <code>mult</code> function, we must show that it always terminates.</p><h2 id=process-of-proving-termination>Process of proving termination</h2><p>We will see later in this section that the idea of termination is a much more challenging topic than it might seem. There is no button in Logika that will check for termination, but we can often insert manual assertions which, if they are verified, will guarantee termination. We will show how to create such manual assertions for simple loops that execute a set number of times.</p><p>First, we need to come up with a way to measure (as an integer) how much work the loop has left to do. Using this measure of work, we want to show two things:</p><ul><li>Each loop iteration decreases the integer measure (i.e., the amount of work left to do is strictly decreasing)</li><li>When our integer measure is 0 or less, then we are certain that we are done (i.e., the loop exits)</li></ul><h2 id=termination-in-mult>Termination in mult</h2><p>In our <code>mult</code> example, let&rsquo;s first try to establish an integer measure of work for the loop. We know that the loop is computing <code>m + m + ... + m</code>, for a total of <code>n</code> additions. When <code>count</code> is 0, we know we have <code>n</code> more additions to do (<code>n</code> more iterations of the loop). When <code>count</code> is 1, we know we have <code>n-1</code> more additions&mldr;and when <code>count</code> is <code>n</code>, we know that we have no more additions to do (and the loop ends). Our measure of work should be the number of additions left to do, which is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Measure of work: n - count</span></span></code></pre></div><p>We can calculate this measure at the beginning of each iteration and again at the end of each iteration:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (count != n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == m * count
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //get measure value at beginning of iteration
</span></span><span style=display:flex><span>    val measureBegin: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + m
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //get measure value at end of iteration
</span></span><span style=display:flex><span>    val measureEnd: Z = n-count
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Next, we want to assert that <code>measureEnd &lt; measureBegin</code> &ndash; that the amount of work decreases with each iteration. We can also assert that <code>measureEnd > 0 || count == n</code> &ndash; that either we have more work to do, or our loop condition is false (meaning that if we have no more work to do, then our loop condition must be false and thus terminate):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (n &gt;= 0),          //needed for termination
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == m * count
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at beginning of iteration
</span></span><span style=display:flex><span>        val measureBegin: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + m
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at end of iteration
</span></span><span style=display:flex><span>        val measureEnd: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we are making progress
</span></span><span style=display:flex><span>        //the amount of work decreases with each iteration
</span></span><span style=display:flex><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we either have more work, or the loop will terminate
</span></span><span style=display:flex><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style=display:flex><span>        assert(measureEnd &gt; 0 || count == n)     //NOTE: will not hold!
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If we try verifying this program in Logika, the second assert, <code>assert(measureEnd > 0 || count == n)</code> will not hold. To see why, let&rsquo;s suppose that <code>measureEnd &lt;= 0</code>. For the assert to be true, we would need to be certain that <code>count == n</code> (since the left side of the OR would be false). Because <code>measureEnd = n-count</code>, we can infer that <code>count >= n</code> when <code>measureEnd &lt;= 0</code>. However, Logika is unable to infer that <code>count == n</code> from the knowledge that <code>count >= n</code> unless it also knows that <code>count &lt;= n</code> always holds. We can add this knowledge by strengthening our loop invariant to provide a range for the loop counter &ndash; <code>count >= 0</code> and <code>count &lt;= n</code>. Even if not required, it is a good habit anyway to include the loop counter range as part of the loop invariant.</p><p>We strengthen our loop invariant, and both asserts will hold &ndash; thus demonstrating termination:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (n &gt;= 0),          //needed for termination
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == m * count,
</span></span><span style=display:flex><span>            0 &lt;= count,
</span></span><span style=display:flex><span>            count &lt;= n
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at beginning of iteration
</span></span><span style=display:flex><span>        val measureBegin: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + m
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at end of iteration
</span></span><span style=display:flex><span>        val measureEnd: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we are making progress
</span></span><span style=display:flex><span>        //the amount of work decreases with each iteration
</span></span><span style=display:flex><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we either have more work, or the loop will terminate
</span></span><span style=display:flex><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style=display:flex><span>        assert(measureEnd &gt; 0 || count == n)     //This holds now!
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We could similarly use measures of work and manual assert statements to prove termination in some recursive functions. Here, we would demonstrate that a parameter value decreased with each recursive call, and that we either had more work to do or had reached the base case of our recursion (with no more recursive calls needed).</p><h2 id=collatz-function>Collatz function</h2><p>While it is possible to prove termination for certain kinds of programs &ndash; those that loop or make recursive calls a set number of times &ndash; it is not possible to prove termination for all programs.</p><p>Consider the <code>collatz</code> function below:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def collatz(m: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires( m &gt; 0 ),
</span></span><span style=display:flex><span>        Ensures( Res[Z] == 1 )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var n: Z = m
</span></span><span style=display:flex><span>    while (n &gt; 1) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies( n ),
</span></span><span style=display:flex><span>            n &gt;= 1
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        if (n % 2 == 0) {
</span></span><span style=display:flex><span>            n = n / 2
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>            n = 3 * n + 1
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return n
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We see that we must pass <code>collatz</code> a positve parameter, and that it promises to return 1 (no matter what the parameter is). It contains a loop that repeatedly modifies a current value (which is initially the parameter value):</p><ul><li>If the current number is even, we divide the number by 2</li><li>If the current number is odd, we triple the number and add 1</li></ul><p>Suppose we compute <code>collatz(17)</code>. We can track the value of <code>n</code> as follows: 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. We can see that <code>n</code> does eventually reach 1, and that the program terminates in that case. We can similarly try other parameters, and will again see that we always end up with 1 (sometimes after a surprising number of iterations). But in fact:</p><ul><li>No one has proved that the Collatz function terminates for all positive numbers; and</li><li>No one has found a positive number on which the Collatz function does not terminate</li></ul><p>You may notice that part of the problem is that due to the nature of the problem, we cannot write a sufficient loop invariant describing what progress we have made towards our goal &ndash; our only loop invariant is nearly identical to our loop condition. In cases where we <em>can</em> write a loop invariant that adequately describes our progress, we often have enough information to prove termination as well.</p><h2 id=decidability-and-the-halting-problem>Decidability and the Halting problem</h2><p>It is an obvious question whether we could write a program to check whether another program always terminates. Unfortunately, this (the <em>Halting problem</em>) turns out to be impossible, as was demonstrated by Alan Turing. The Halting problem is an example of an <em>undecidable</em> problem in computer science &ndash; a decision problem (a problem with a yes/no answer) that we can&rsquo;t correctly answer one way or another on all inputs, even if we have unlimited resources.</p><footer class=footline></footer></article></section></section></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/dec4297d81df48b5e02e2640601321e923ab5f5b>Aug 10, 2023</a></p></div></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis301/js/mathjax/tex-mml-chtml.js?1755885657></script><script src=/cis301/js/clipboard/clipboard.min.js?1755885657 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1755885657 defer></script><script src=/cis301/js/theme.min.js?1755885657 defer></script></body></html>