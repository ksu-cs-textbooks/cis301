<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.0.3+tip">




	
	
			

	
	
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Assignment Statements :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/" rel="canonical" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/index.xml" rel="alternate" type="application/rss+xml" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/_print/8-chapter/8_5-assignment/" rel="alternate" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/embed.html" rel="alternate" type="text/html" title="CIS 301 Textbook">
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1677622836" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1677622836" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1677622836" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <noscript>
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1677622836" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1677622836" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1677622836" rel="stylesheet">
    </noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1677622836" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1677622836" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1677622836" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1677622836" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-light-theme.css?1677622836" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1677622836" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1677622836" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1677622836" rel="stylesheet" media="print">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1677622836"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis301/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1677622836" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/jquery.min.js?1677622836" defer></script>

  </head>
  <body class="mobile-support disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/">
    
    <div id="tele" class="tele mirror">
    
    <div id="body" class="default-animation">
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
          <article class="default">
    
    
<h1>Assignment Statements</h1>
    
    
<p>Assignment statements in a program come in two forms &ndash; with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.</p>
<p>For example, an increment statement like <code>x = x + 1</code> MUTATES the value of <code>x</code> by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of <code>x</code>.</p>
<p>In contrast, a statemnet like <code>y = x + 1</code> assigns to <code>y</code> one more than the value in <code>x</code>. We do not need to know the previous value of <code>y</code>, as we are not using it in the assignment statement. (We do need to know the value of <code>x</code>).</p>
<h2 id="assignments-without-mutation">Assignments without mutation</h2>
<p>We have already seen the steps necessary to process assignment statements that do not involve variable mutation. Recall that we can declare as a <code>premise</code> any assignment statement or claim from a previous logic block involving variables that have not since changed.</p>
<p>For example, suppose we want to verify the following program so the assert statement at the end will hold:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val y: Z = x + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val z: Z = 10 - x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the assert will not hold yet
</span></span><span style="display:flex;"><span>assert(y == z &amp; y == 6)
</span></span></code></pre></div><p>Since none of the statements involve variable mutation, we can do the verification in a single logic block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 4    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val y: Z = x + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val z: Z = 10 - x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    2. y == x + 2           premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    3. z == 10 - x          premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    4. y == 4 + 2           subst1 1 2
</span></span><span style="display:flex;"><span>    5. z == 10 - 4          subst1 1 3
</span></span><span style="display:flex;"><span>    6. y == 6               algebra 4
</span></span><span style="display:flex;"><span>    7. z == 6               algebra 5
</span></span><span style="display:flex;"><span>    8. y == z               subst2 7 6
</span></span><span style="display:flex;"><span>    9. y == z ∧ y == 6      ∧i 8 6
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now the assert will hold
</span></span><span style="display:flex;"><span>assert(y == z &amp; y == 6)
</span></span></code></pre></div><p>Note that we did need to do <code>∧i</code> so that the last claim was <code>y == z ∧ y == 6 </code>, even though we had previously established the claims <code>y == z</code> and <code>y == 6</code>. In order for an assert to hold (at least until we switch Logika modes in chapter 10), we need to have established EXACTLY the claim in the assert in a previous logic block.</p>
<h2 id="assignments-with-mutation">Assignments with mutation</h2>
<p>Assignments with mutation are trickier &ndash; we need to know the old value of a variable in order to reason about its new value. For example, if we have the following program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert(x == 5)
</span></span></code></pre></div><p>Then we might try to add the following logic blocks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //from previous variable assignment
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == x + 1           premise     //NO! Need to distinguish between old x (right side) and new x (left side)
</span></span><span style="display:flex;"><span>    2. x == 4               premise     //NO! x has changed since this claim
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert(x == 5)
</span></span></code></pre></div><p>&hellip;but then we get stuck in the second logic block. There, <code>x</code> is supposed to refer to the CURRENT value of <code>x</code> (after being incremented), but both our attempted claims are untrue. The current value of <code>x</code> is not one more than itself (this makes no sense!), and we can tell from reading the code that <code>x</code> is now 5, not 4.</p>
<p>To help reason about changing variables, Logika has a special <code>name_old</code> value that refers to the OLD value of a variable called <code>name</code>, just before the latest update. In the example above, we can use <code>x_old</code> in the second logic block to refer to <code>x</code>&rsquo;s value just before it was incremented. We can now change our premises and finish the verification as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //from previous variable assignment
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == x_old + 1       premise     //Yes! x equals its old value plus 1
</span></span><span style="display:flex;"><span>    2. x_old == 4           premise     //Yes! The old value of x was 4
</span></span><span style="display:flex;"><span>    3. x == 4 + 1           subst1 2 1  
</span></span><span style="display:flex;"><span>    4. x == 5               algebra 3   //Could have skipped line 3 and used &#34;algebra 1 2&#34; instead
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now the assert will hold
</span></span><span style="display:flex;"><span>assert(x == 5)
</span></span></code></pre></div><p>By the end of the logic block following a variable mutation, we need to express everything we know about the variable&rsquo;s current value WITHOUT using the <code>_old</code> terminology, as its scope will end when the logic block ends. Moreover, we only ever have one <code>_old</code> value available in a logic block &ndash; the variable that was most recently changed. This means we will need logic blocks after each variable mutation to process the changes to any related facts.</p>
<h2 id="variable-swap-example">Variable swap example</h2>
<p>Suppose we have the following Logika program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//what do we want to assert we did?
</span></span></code></pre></div><p>We can see that this program gets two user input values, <code>x</code> and <code>y</code>, and then swaps their values. So if <code>x</code> was originally 4 and <code>y</code> was originally 6, then at the end of the program <code>x</code> would be 6 and <code>y</code> would be 4.</p>
<p>We would like to be able to assert what we did &ndash; that <code>x</code> now has the original value from <code>y</code>, and that <code>y</code> now has the original value from <code>x</code>. To do this, we might invent dummy constants called <code>xOrig</code> and <code>yOrig</code> that represent the original values of those variables. Then we can add our assert:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the original values of both inputs
</span></span><span style="display:flex;"><span>val xOrig: Z = x
</span></span><span style="display:flex;"><span>val yOrig: Z = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//x and y have swapped
</span></span><span style="display:flex;"><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style="display:flex;"><span>assert(x == yOrig &amp; y == xOrig)     //this assert will not yet hold
</span></span></code></pre></div><p>We can complete the verification by adding logic blocks after assignment statements, being careful to update all we know (without using the <code>_old</code> value) by the end of each block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the original values of both inputs
</span></span><span style="display:flex;"><span>val xOrig: Z = x
</span></span><span style="display:flex;"><span>val yOrig: Z = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. xOrig == x           premise
</span></span><span style="display:flex;"><span>    2. yOrig == y           premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//swap x and y
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == y                   premise     //from the assignment statement
</span></span><span style="display:flex;"><span>    2. temp == x_old            premise     //temp equaled the OLD value of x
</span></span><span style="display:flex;"><span>    3. xOrig == x_old           premise     //xOrig equaled the OLD value of x
</span></span><span style="display:flex;"><span>    4. yOrig == y               premise     //yOrig still equals y
</span></span><span style="display:flex;"><span>    5. temp == xOrig            algebra 2 3
</span></span><span style="display:flex;"><span>    6. x == yOrig               algebra 1 4
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == temp                premise     //from the assignment statemnet
</span></span><span style="display:flex;"><span>    2. temp == xOrig            premise     //from the previous logic block (temp and xOrig are unchanged since then)
</span></span><span style="display:flex;"><span>    3. yOrig == y_old           premise     //yOrig equaled the OLD value of y
</span></span><span style="display:flex;"><span>    4. y == xOrig               algebra 1 2
</span></span><span style="display:flex;"><span>    5. x == yOrig               premise     //from the previous logic block (x and yOrig are unchanged since then)
</span></span><span style="display:flex;"><span>    6. x == yOrig ^ y == xOrig  ^i 5 4
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//x and y have swapped
</span></span><span style="display:flex;"><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style="display:flex;"><span>assert(x == yOrig &amp; y == xOrig)     //this assert will hold now
</span></span></code></pre></div><p>Notice that in each logic block, we express as much as we can about all variables/values in the program. In the first logic block, even though <code>xOrig</code> and <code>yOrig</code> were not used in the previous assignment statement, we still expressed how the current values our other variables compared to <code>xOrig</code> and <code>yOrig</code>. It helps to think about what you are trying to claim in the final assert &ndash; since our assert involved <code>xOrig</code> and <code>yOrig</code>, we needed to relate the current values of our variables to those values as we progressed through the program.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    
    
    </div>
    
  </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1677622836" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1677622836" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/featherlight.min.js?1677622836" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1677622836" defer></script>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/tele-scroll.js?1677622836 defer"></script>
    
  </body>
</html>
