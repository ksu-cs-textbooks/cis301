<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Intro to Programming Logic :: CIS 301 Textbook"><meta name=twitter:description content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/8-chapter/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Intro to Programming Logic :: CIS 301 Textbook"><meta property="og:description" content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Intro to Programming Logic :: CIS 301 Textbook"><meta itemprop=description content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T14:52:41-05:00"><meta itemprop=wordCount content="59"><title>Intro to Programming Logic :: CIS 301 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis301/8-chapter/ rel=canonical type=text/html title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/8-chapter/index.xml rel=alternate type=application/rss+xml title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/8-chapter/tele.html rel=alternate type=text/html title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/8-chapter/embed.html rel=alternate type=text/html title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1741190549 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1741190549 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1741190549 rel=stylesheet><link href=/cis301/css/auto-complete.css?1741190549 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1741190549 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1741190549 rel=stylesheet><link href=/cis301/css/fonts.css?1741190549 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1741190549 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1741190549 rel=stylesheet><link href=/cis301/css/theme-auto.css?1741190549 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1741190549 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1741190549 rel=stylesheet><link href=/cis301/css/print.css?1741190549 rel=stylesheet media=print><link href=/cis301/css/format-print.css?1741190549 rel=stylesheet><script src=/cis301/js/variant.js?1741190549></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1741190549 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis301/8-chapter/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Intro to Programming Logic</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/7-chapter/7_4-setex/ title="Set example (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/8-chapter/8_1-goal/ title="Programming Logic Goal (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 8</div><h1 id=intro-to-programming-logic>Intro to Programming Logic</h1><h6 id=intro-to-programming-logic-assignments-and-conditionals>Intro to Programming Logic: Assignments and Conditionals</h6><p>For the rest of the course, we will switch gears back to something more familiar for most &ndash; computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Intro to Programming Logic</h1><article class=default><header class=headline></header><h1 id=programming-logic-goal>Programming Logic Goal</h1><p>In the next three chapters, we will learn how to reason about different kinds of program structures &ndash; assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs using a toy language that is a subset of Scala. While our toy language is not used in practice, the ideas that we will see to prove program correctness &ndash; preconditions, postconditions, loop invariants, and global invariants &ndash; can be used to specify functions in ANY language.</p><p>We will see that the process for formal specifications and proofs of correctness is rather tedious, even for relatively simple programs. And in practice, proving correctness of computer programs is rarely done. So why bother studying it?</p><h2 id=safety-critical-code>Safety critical code</h2><p>One case where reasoning about correctness is certainly relevant is the arena of <em>safety critical code</em> &ndash; where lives depend on a program working correctly. Certain medical devices, such as pacemakers and continuous glucose monitors, have a software component. If that software fails, then a person could die. We can&rsquo;t test the correctness of medical devices by installing them in a human body and trying them out &ndash; instead, we need to be absolutely sure they work correctly before they are used.</p><p>Similarly, there is software in things like shuttle launches. While that might not cost lives, it&rsquo;s also a process that can&rsquo;t be fully tested beforehand. After all, no one is going to spend over a billion dollar on a &ldquo;practice&rdquo; launch. Instead, we need a way to more formally demonstrate that the software will work correctly.</p><h2 id=specifications>Specifications</h2><p>In chapter 9, we will learn to write function <em>specifications</em>. These specifications list any requirements the function has in order to work correctly (<em>preconditions</em>) and descibe the impact of calling the function (<em>postconditions</em>) - most notably, what the function returns in terms of its inputs. Even in cases where we do not formally prove correctness of a program, it is very useful to write a specification for all functions. This can make it clear to any calling code what kinds of parameters should be passed, as well as what to expect about the returned value. By providing this structure, there will be fewer surprises and unintended errors.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logika-programs>Logika Programs</h1><p>As we study program logic, we will use Logika to verify a subset of programs that use the Scala language. Specifically, we will study verification of programs with the following features:</p><ul><li>Variables (booleans, ints, and sequences [which are like arrays/lists])</li><li>Printing and user input</li><li>Math operations</li><li>Conditional operations</li><li>If and if/else statements</li><li>While loops</li><li>Functions</li></ul><p>The Scala programs we verify should be saved with a .sc extension. To show we are using Logika for verification, the first line of the file should be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika</span></span></code></pre></div><h2 id=verifying-logika-programs>Verifying Logika programs</h2><p>There are two modes in Logika &ndash; manual and automatic. In chapters 8 and 9, we will use manual mode. In chapter 10, we will use automatic mode. You will designate the verification mode on the second line of the Scala file (just below <code>// #Sireum #Logika</code>). To specify manual mode, you will write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//@Logika: --manual --background save</span></span></code></pre></div><p>And to specify automatic mode, you will delete the <code>--manual</code> from above, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//@Logika: --background save</span></span></code></pre></div><p>Logika verification <em>should</em> run automatically as you edit these programs and their proofs. If a program is verified, you will see a purple checkmark in the lower right corner just as you did in propositional and predicate logic proofs. If there are syntax or logic errors, you will see them highlighted in red.</p><p>Sometimes, the Logika verification needs to be run manually. If you don&rsquo;t see either red errors or a purple checkmark, right-click in the text area that contains the code and select &ldquo;Logika Check (All in File)&rdquo;.</p><h2 id=example-programs>Example programs</h2><p>This section contains four sample Scala programs that highlight the different language features that we will work with.</p><h3 id=example-1-user-input-printing-operations>Example 1: User input, printing, operations</h3><p>This first example gets a number as input from the user, adds one to it, and prints the result:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = Z.prompt(&#34;Enter a number: &#34;)
</span></span><span class=line><span class=cl>x = x + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>println(&#34;One more is &#34;, x)</span></span></code></pre></div><p>A few things to note:</p><ul><li>After the two comment lines to show we are using the Logika verification tool in manual mode, our program begins with an import statement: <code>import org.sireum._</code></li><li>The <code>var</code> keyword stands for variable, which is something that can be changed. Logika also has a <code>val</code> keyword, which creates a constant value that cannot be changed.</li><li>Lines do not end in semi-colons</li><li>The <code>Z.prompt(...)</code> function prints a prompt and returns the integer (<code>Z</code>) that was typed. The parameter to this function is the desired prompt. Alternately, the <code>Z.read()</code> function gets and returns an integer from user input without taking a prompt.</li><li>The code <code>var x: Z</code> creates a variable called <code>x</code> of type <code>Z</code> &ndash; as with the user input functions, the <code>Z</code> means <em>integer</em></li></ul><h3 id=example-2-ifelse-statements>Example 2: If/else statements</h3><p>Here is a Scala program that gets a number from the user, and uses an if/else statement to print whether the number is positive or negative/zero:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = Z.prompt(&#34;Enter a number: &#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>if (num &gt; 0) {
</span></span><span class=line><span class=cl>    println(num, &#34; is positive&#34;)
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    println(num, &#34; is negative (or zero)&#34;)
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>A couple of things to note here:</p><ul><li>The <code>else</code> statement MUST appear on the same line as the closing <code>}</code> of the previous if-statement</li><li>As mentioned above, the <code>val</code> keyword in this program means that <code>num</code> cannot be changed after being initialized</li></ul><h3 id=example-3-while-loops>Example 3: While loops</h3><p>Our next program uses a while loop to print the numbers from 10 down to 1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var cur: Z = 10
</span></span><span class=line><span class=cl>while (cur &gt;= 1) {
</span></span><span class=line><span class=cl>  println(&#34;Next number: &#34;, cur)
</span></span><span class=line><span class=cl>  cur = cur - 1
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><h3 id=example-4-sequences-and-functions>Example 4: Sequences and functions</h3><p>Our final sample program demonstrates <em>sequences</em> (similar to an array or list) and functions. It contains a function, <code>sumSequence</code>, which takes a sequence of integers as a parameter and returns the sum of the numbers in the sequence. At the bottom, we can see our test code that creates a sample sequence and tries calling <code>sumSequence</code>. If you create this file, you will see an error about the sequence indices possibly being negative &ndash; this code cannot be run without some verification work:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def sumSequence(seq: ZS) : Z = {
</span></span><span class=line><span class=cl>  var sum: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  var i: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  while (i &lt; seq.size) {
</span></span><span class=line><span class=cl>    sum = sum + seq(i)
</span></span><span class=line><span class=cl>    i = i + 1
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  return sum
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////// Calling code ////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val list: ZS = ZS(1,2,3,4)
</span></span><span class=line><span class=cl>val total: Z = sumSequence(list)
</span></span><span class=line><span class=cl>println(&#34;Sum of elements:&#34;, total)</span></span></code></pre></div><p>A few things of note here:</p><ul><li><p>The definition <code>def sumSequence(seq: ZS) : Z</code> means that a function named <code>sumSequence</code> takes a parameter of type <code>ZS</code> (sequence of integers, <code>Z</code> = int and <code>S</code> = sequence) and returns something of type <code>Z</code> (int)</p></li><li><p>There is an <code>=</code> after the function header but before the opening <code>{</code> of the function</p></li><li><p>These functions are not part of a class - they are more similar to the structure in Python. We can include as many functions as we want in a file. At the bottom of the file (marked below the optional <code>////// Calling code ////////////</code>) is the <em>calling code</em>. When a Logika program runs, those calling code lines (which may call different functions) are executed. When the calling code lines are done, the program is done.</p></li></ul><h2 id=logika-program-proof-syntax>Logika program proof syntax</h2><p>In order to prove correctness of these Scala programs, we will add <em>Deduce blocks</em> to process what we have learned at different points in the program. In general, every time there is an assignment statement, there will be a following <code>Deduce</code> proof block updating all relevant facts.</p><h3 id=necessary-import-statements>Necessary import statements</h3><p>We have already seen that we must include the import statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>import org.sireum._</span></span></code></pre></div><p>Anytime we want to do anything with the Logika proof checker. There are three other import statements that you will commonly use:</p><ol><li><code>import org.sireum.justification._</code> is needed for any Deduce statements and basic justifications (<code>Premise</code>, etc.)</li><li><code>import org.sireum.justification.natded.prop._</code> is needed for any propositional logic justifications</li><li><code>import org.sireum.justification.natded.pred._</code> is needed for any predicate logic justifications</li></ol><h3 id=deduce-block>Deduce block</h3><p>Here is the syntax for a Deduce proof block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    claim       ) by Justification,
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Just as with our propositional and predicate logic proofs, we will number the lines in our proof blocks. Each line will contain a <em>claim</em> and a corresponding <em>justification</em> for that claim. We will still be able to use all of our propositional and predicate logic deduction rules, but we will learn new justifications for processing program statements. Each program may have multiple of these proof blocks to process each assignment statement.</p><h3 id=premise-justification>Premise justification</h3><p>Our first justification in programming logic is <em>Premise</em>. In a Deduce proof block, we use <code>Premise</code> as a justification in the following cases:</p><ul><li><p>To express an assignment statement (or other program statement)</p></li><li><p>To pull a claim established in a previous proof block into a later proof block</p></li></ul><p>In both cases, the claim must capture the current value of the involved variables.</p><p>For example, consider the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 6
</span></span><span class=line><span class=cl>x = x + 1</span></span></code></pre></div><p>We could insert a proof block between the two lines to express that <code>x</code> currently has the value 6:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>  1 (   x == 6  ) by Premise
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x = x + 1</span></span></code></pre></div><p>But we could NOT have the same proof block after incrementing <code>x</code>, since <code>x</code>&rsquo;s value has changed since that claim was established:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//this proof block is correct -- it captures the current value of x
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>  1 (   x == 6  ) by Premise
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x = x + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//NO! This statement no longer captures the current value of x
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>  1 (   x == 6  ) by Premise
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h3 id=using-previous-deduction-rules>Using previous deduction rules</h3><p>We can use any of our previous deduction rules in a Logika proof block. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = 6
</span></span><span class=line><span class=cl>val y: Z = 7
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>  1 (   x == 6                ) by Premise,
</span></span><span class=line><span class=cl>  2 (   y == 7                ) by Premise,
</span></span><span class=line><span class=cl>  3 (   (x == 6) ∧ (y == 7)   ) by AndI(1, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=assert-and-assume>Assert and Assume</h1><h2 id=assert-statements>Assert statements</h2><p>An <em>assert</em> statement in Scala uses the syntax <code>assert(expression)</code>, where <code>expression</code> is of type <code>bool</code>. The assert passes if the expression is true, and throws an error if the expression is false.</p><p>Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven.</p><p>Note that we are using these assert statements differently than assert statements in languages like Java and C# &ndash; in those languages, the code in the assert statement (which often includes test method calls) is actually run, and the assert statement checks whether those methods are returning the expected values. In Logika, assert statements only pass if we have previously PROVED what we are claiming &ndash; the code is never executed.</p><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = 6
</span></span><span class=line><span class=cl>val y: Z = 6
</span></span><span class=line><span class=cl>val z: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert (x == y &amp; y &gt; z)</span></span></code></pre></div><p>While we can tell that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>, this code would fail in Logika (at least in its manual mode, which is what we are using now). In order for an assert to pass, we must have already proved EXACTLY the statement in the assert.</p><p>Why do WE know that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>? From looking at the code! We can tell that <code>x</code> and <code>y</code> are given the same value (6), and that <code>y</code>&rsquo;s value of 6 is bigger than <code>z</code>&rsquo;s value of 4.</p><p>So far, we know we can pull in the values of each variable as premises, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = 6
</span></span><span class=line><span class=cl>val y: Z = 6
</span></span><span class=line><span class=cl>val z: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (x == 6) by Premise,
</span></span><span class=line><span class=cl>    2  (y == 6) by Premise,
</span></span><span class=line><span class=cl>    3  (z == 4) by Premise,
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    //how to say that x and y are equal, and that y is bigger than z?
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>assert(x == y ∧ y &gt; z)</span></span></code></pre></div><p>But we don&rsquo;t yet know how to justify claims that describe how variables compare to one another. We will learn how to do that with the <code>Algebra</code> and <code>Subst</code> rules in section 8.4.</p><h3 id=using-conditional-operators>Using conditional operators</h3><p>Notice that the program above used an <code>∧</code> symbol for an AND operator in an assert statement. As with our propositional logic proofs, if we want to use a <code>∧</code> operator then we type the symbol <code>&</code>. This <code>&</code> is automatically changed to a <code>∧</code> when we view our program, just as it was in our deduction proofs. Similarly, we type <code>!</code> for NOT in asserts (which displays as <code>¬</code>) and <code>|</code> for OR (which displays as <code>∨</code>). However, we are not able to use an implies operator in an assert statement as it is not part of the Scala language (and our asserts are part of the program and not just a proof element).</p><p>If we wanted to write an assert statement that would be true when some variable <code>p</code> was even and/or was a positive two-digit number, we could say:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>assert(p % 2 == 0 ∨ (p &gt; 9 ∧ p &lt; 100))</span></span></code></pre></div><p>As was mentioned above, the implies operator is not available in assert statements. However, we can make use of one of the equivalences we learned about in section 3.4: that <code>p → q</code> is equivalent to <code>¬p ∨ q</code>. So if we wanted to assert that if <code>p</code> was positive, then <code>q</code> was equal to <code>p</code>, then we could write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//expressing the implicaton ((p &gt; 0) → (q == p))
</span></span><span class=line><span class=cl>assert(¬(p &gt; 0) ∨ (q == p))</span></span></code></pre></div><p>Or, equivalently, we could write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>assert((p &lt;= 0) ∨ (q == p))</span></span></code></pre></div><h2 id=assume-statement>Assume statement</h2><p>An <em>assume</em> statement in Scala uses the syntax <code>assume(expression)</code>. If the expression is satisfiable, then we can use <code>expression</code> as a premise in the following Logika proof block.</p><h3 id=assume-example>Assume example</h3><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var a: Z = Z.read()
</span></span><span class=line><span class=cl>assume (a &gt; 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (a &gt; 0)   by Premise
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Assume statements are almost always used to make assumptions about user input. Perhaps our program only works correctly for certain values of input. If we can assume that the user really did enter acceptable values, then we can use that information (by pulling it in as a premise in the next proof block) to prove the correctness of the program based on that assumption.</p><h3 id=assumes-vs-wrapping-if-statements>Assumes vs. wrapping if-statements</h3><p>Toy programs often use assume in lieu of wrapping code in an if statement. The following two examples are equivalent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var a : Z = Z.read()
</span></span><span class=line><span class=cl>assume (a != 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>  1  (a != 0) by Premise
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var b: Z = 20 / a</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//...is equivalent to:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var a : Z = Z.read()
</span></span><span class=line><span class=cl>var b : Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>if (a != 0) {
</span></span><span class=line><span class=cl>    b = 20 / a
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>These examples also demonstrate a requirement when we use the division operator in Logika programs, we must first demonstrate that we are not dividing by zero.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=algebra-and-subst-rules>Algebra and Subst Rules</h1><p>In this section, we will learn our first two proof rules for programming logic &ndash; <code>Algebra</code> and <code>Subst</code>.</p><h2 id=verifying-simple-programs>Verifying simple programs</h2><p>Before we delve into our new proof rules, let&rsquo;s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the <code>// --></code> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>get user input / set initial variable values
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // --&gt; add assume statements to specify what must be true about the input
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>program statement
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>program statement
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>program statement
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(...more program statements)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // --&gt; add assert statements to express what our program did</span></span></code></pre></div><p>We see that if our program involves user input, then we must consider whether our program will only work correctly for certain input values. In that situation, we express our assumptions using <code>assume</code> statements.</p><p>After each program statement, we must add a proof block to evaluate what changed on that line of code. We will see more details on these proof blocks throughout the rest of this chapter. Recall that the syntax for those proof blocks looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    //@formatter:off
</span></span><span class=line><span class=cl>    1  (    claim       ) by Justification,
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    //@formatter:on
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Finally, we add one or more <code>assert</code> statements to express what our program did. These are usually placed at the end of a program, but sometimes we have assert statements throughout the program to describe the progress up to that point.</p><h2 id=algebra-justification>Algebra justification</h2><p>The <code>Algebra*</code> justification can be used for ANY algebraic manipulation on previous claims. When using this justification, include all relevant proof line numbers in whatever order (you might use as few as zero line numbers or as many as 3+ line numbers).</p><h3 id=example>Example</h3><p>Consider this example (which eliminates the Logika mode notation and the necessary import statements):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = 6
</span></span><span class=line><span class=cl>var y: Z = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//this assert will not hold yet
</span></span><span class=line><span class=cl>assert (y == 6)</span></span></code></pre></div><p>Following our process from above, we add proof blocks after each program statement. In these proof blocks, we start by listing the previous program statement as a premise:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = 6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    x == 6      )   by Premise,
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var y: Z = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    y == x      )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //need claim &#34;y == 6&#34; for our assert to hold
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//this assert will not hold yet
</span></span><span class=line><span class=cl>assert (y == 6)</span></span></code></pre></div><p>For our assert to hold, we must have EXACTLY that claim in a previous proof block &ndash; so we know we want our second proof block to include the claim <code>y == 6</code>.</p><p>Here is the program with the second proof block completed &ndash; the assert statement will now hold.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = 6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    x == 6      )   by Premise,
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var y: Z = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     y == x      )   by Premise,
</span></span><span class=line><span class=cl>    2 (     x == 6      )   by Premise,         //established in a previous proof block, and x is unchanged since then
</span></span><span class=line><span class=cl>    3 (     y == 6      )   by Algebra*(1, 2)   //we know y is 6 using the claims from lines 1 and 2
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//this assert will now hold yet
</span></span><span class=line><span class=cl>assert (y == 6)</span></span></code></pre></div><p>We could have also deleted the first proof block in this example. We would still be able to claim <code>x == 6</code> as a premise in the last proof block, as <code>x</code> had not changed since being given that value.</p><h2 id=subst_-and-subst_>Subst_&lt; and Subst_></h2><p>We have two deduction rules that involve substitution &ndash; <code>Subst_&lt;</code> and <code>Subst_></code>. Both of these rules are similar to the find/replace feature in text editors. They preserve truth by replacing one proposition with an equivalent one.</p><p>The <code>Algebra*</code> justification will work for most mathematical manipulation. However, it will not work for any claim involving <code>∧</code>, <code>∨</code>, <code>→</code>, <code>F</code>, <code>∀</code>, <code>∃</code> &ndash; in those cases, we will be required to use substitution instead.</p><h3 id=subst_-justification>Subst_&lt; justification</h3><p>Here is the syntax for the <code>Subst_&lt;</code> rule. In the example below, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    m (     LHS_M == RHS_M  )   by SomeJustification,
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    n (     LINE_N          )   by SomeJustification,
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    p (     claim           )   by Subst_&lt;(m, n),
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p><code>(claim)</code> rewrites <code>LINE_N</code> by substituting all occurrences of <code>RHS_M</code> with <code>LHS_M</code>. The <code>_&lt;</code> part of the justification name indicates the direction of the find/replace. You can think of it as <code>LHS_M &lt;- RHS_M</code> (showing that <code>RHS_M</code> is coming in for each <code>LHS_M</code>). Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x + 1 == y - 4                          )   by SomeJustification,
</span></span><span class=line><span class=cl>    2 (     x*(x + 1) == (x + 1) + y                )   by SomeJustification,
</span></span><span class=line><span class=cl>    3 (     x*(y - 4) == (y - 4) + y                )   by Subst_&lt;(1, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We wrote line 3 by replacing each occurence of <code>x + 1</code> with <code>y - 4</code>.</p><h3 id=subst_-justification-1>Subst_> justification</h3><p>Here is the syntax for the <code>Subst_></code> rule. Just as with <code>Subst_&lt;</code>, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    m (     LHS_M == RHS_M  )   by SomeJustification,
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    n (     LINE_N          )   by SomeJustification,
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    p (     claim           )   by Subst_&gt;(m, n),
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Here, <code>(claim)</code> rewrites <code>LINE_N</code> by substituting all occurrences of <code>LHS_M</code> with <code>RHS_M</code>. We can think of it as indicating <code>LHS_M -> RHS_M</code> (showing that <code>LHS_M</code> is coming in for each <code>RHS_M</code>). Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x + 1 == y                      )   by SomeJustification,
</span></span><span class=line><span class=cl>    2 (     x*y == (x + 1) + y              )   by SomeJustification,
</span></span><span class=line><span class=cl>    3 (     x*(x + 1) == (x + 1) + x + 1    )   by Subst_&gt;(1, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We wrote line 3 by replacing each occurence of <code>y</code> with <code>x + 1</code>. Note that we put parentheses around our first replacement to ensure a product equivalent to the original statement.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=assignment-statements>Assignment Statements</h1><p>Assignment statements in a program come in two forms &ndash; with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.</p><p>For example, an increment statement like <code>x = x + 1</code> MUTATES the value of <code>x</code> by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of <code>x</code>.</p><p>In contrast, a statement like <code>y = x + 1</code> assigns to <code>y</code> one more than the value in <code>x</code>. We do not need to know the previous value of <code>y</code>, as we are not using it in the assignment statement. (We do need to know the value of <code>x</code>).</p><h2 id=assignments-without-mutation>Assignments without mutation</h2><p>We have already seen the steps necessary to process assignment statements that do not involve variable mutation. Recall that we can declare as a <code>Premise</code> any assignment statement or claim from a previous proof block involving variables that have not since changed.</p><p>For example, suppose we want to verify the following program so the assert statement at the end will hold (this example again eliminates the Logika mode notation and the necessary import statements, which we will continue to do in subsequent examples):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val y: Z = x + 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val z: Z = 10 - x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//the assert will not hold yet
</span></span><span class=line><span class=cl>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Since none of the statements involve variable mutation, we can do the verification in a single proof block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 4    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val y: Z = x + 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val z: Z = 10 - x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == 4          )   by Premise,     //assignment of unchanged variable
</span></span><span class=line><span class=cl>    2 (     y == x + 2      )   by Premise,     //assignment of unchanged variable
</span></span><span class=line><span class=cl>    3 (     z == 10 - x     )   by Premise,     //assignment of unchanged variable
</span></span><span class=line><span class=cl>    4 (     y == 4 + 2      )   by Subst_&lt;(1, 2),
</span></span><span class=line><span class=cl>    5 (     z == 10 - 4     )   by Subst_&lt;(1, 3),
</span></span><span class=line><span class=cl>    6 (     y == 6          )   by Algebra*(4),
</span></span><span class=line><span class=cl>    7 (     z == 6          )   by Algebra*(5),
</span></span><span class=line><span class=cl>    8 (     y == z          )   by Subst_&gt;(7, 6),
</span></span><span class=line><span class=cl>    9 (     y == z ∧ y == 6 )   by AndI(8, 6)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//now the assert will hold
</span></span><span class=line><span class=cl>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Note that we did need to do <code>AndI</code> so that the last claim was <code>y == z ∧ y == 6 </code>, even though we had previously established the claims <code>y == z</code> and <code>y == 6</code>. In order for an assert to hold (at least until we switch Logika modes in chapter 10), we need to have established EXACTLY the claim in the assert in a previous proof block.</p><h2 id=assignments-with-mutation>Assignments with mutation</h2><p>Assignments with mutation are trickier &ndash; we need to know the old value of a variable in order to reason about its new value. For example, if we have the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x = x + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//this assert will not hold yet
</span></span><span class=line><span class=cl>assert(x == 5)</span></span></code></pre></div><p>Then we might try to add the following proof blocks:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == 4      )   by Premise  //from previous variable assignment
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x = x + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == x + 1  )   by Premise, //NO! Need to distinguish between old x (right side) and new x (left side)
</span></span><span class=line><span class=cl>    2 (     x == 4      )   by Premise, //NO! x has changed since this claim
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//this assert will not hold yet
</span></span><span class=line><span class=cl>assert(x == 5)</span></span></code></pre></div><p>&mldr;but then we get stuck in the second proof block. There, <code>x</code> is supposed to refer to the CURRENT value of <code>x</code> (after being incremented), but both our attempted claims are untrue. The current value of <code>x</code> is not one more than itself (this makes no sense!), and we can tell from reading the code that <code>x</code> is now 5, not 4.</p><p>To help reason about changing variables, Logika has a special <code>Old(varName)</code> function that refers to the OLD value of a variable called <code>varName</code>, just before the latest update. In the example above, we can use <code>Old(x)</code> in the second proof block to refer to <code>x</code>&rsquo;s value just before it was incremented. We can now change our premises and finish the verification as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == 4      )   by Premise  //from previous variable assignment
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x = x + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == Old(x) + 1     )   by Premise, //Yes! x equals its old value plus 1
</span></span><span class=line><span class=cl>    2 (     Old(x) == 4         )   by Premise, //Yes! The old value of x was 4
</span></span><span class=line><span class=cl>    3 (     x == 4 + 1          )   by Subst_&lt;(2, 1),
</span></span><span class=line><span class=cl>    4 (     x == 5              )   by Algebra*(3)  //Could have skipped line 3 and used &#34;Algebra*(1, 2)&#34; instead
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//now the assert will hold
</span></span><span class=line><span class=cl>assert(x == 5)</span></span></code></pre></div><p>By the end of the proof block following a variable mutation, we need to express everything we know about the variable&rsquo;s current value WITHOUT using the <code>Old</code> terminology, as its scope will end when the proof block ends. Moreover, we only ever have one <code>Old</code> value available in a proof block &ndash; the variable that was most recently changed. This means we will need proof blocks after each variable mutation to process the changes to any related facts.</p><h2 id=variable-swap-example>Variable swap example</h2><p>Suppose we have the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = Z.read()
</span></span><span class=line><span class=cl>var y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val temp: Z = x
</span></span><span class=line><span class=cl>x = y
</span></span><span class=line><span class=cl>y = temp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//what do we want to assert we did?</span></span></code></pre></div><p>We can see that this program gets two user input values, <code>x</code> and <code>y</code>, and then swaps their values. So if <code>x</code> was originally 4 and <code>y</code> was originally 6, then at the end of the program <code>x</code> would be 6 and <code>y</code> would be 4.</p><p>We would like to be able to assert what we did &ndash; that <code>x</code> now has the original value from <code>y</code>, and that <code>y</code> now has the original value from <code>x</code>. To do this, we might invent dummy constants called <code>xOrig</code> and <code>yOrig</code> that represent the original values of those variables. Then we can add our assert:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = Z.read()
</span></span><span class=line><span class=cl>var y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//the original values of both inputs
</span></span><span class=line><span class=cl>val xOrig: Z = x
</span></span><span class=line><span class=cl>val yOrig: Z = y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val temp: Z = x
</span></span><span class=line><span class=cl>x = y
</span></span><span class=line><span class=cl>y = temp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//x and y have swapped
</span></span><span class=line><span class=cl>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span class=line><span class=cl>assert(x == yOrig ∧ y == xOrig)     //this assert will not yet hold</span></span></code></pre></div><p>We can complete the verification by adding proof blocks after assignment statements, being careful to update all we know (without using the <code>Old</code> value) by the end of each block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var x: Z = Z.read()
</span></span><span class=line><span class=cl>var y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//the original values of both inputs
</span></span><span class=line><span class=cl>val xOrig: Z = x
</span></span><span class=line><span class=cl>val yOrig: Z = y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     xOrig == x  )   by Premise,
</span></span><span class=line><span class=cl>    2 (     yOrig == y  )   by Premise
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//swap x and y
</span></span><span class=line><span class=cl>val temp: Z = x
</span></span><span class=line><span class=cl>x = y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == y              )   by Premise,     //from the assignment statement
</span></span><span class=line><span class=cl>    2 (     temp == Old(x)      )   by Premise,     //temp equaled the OLD value of x
</span></span><span class=line><span class=cl>    3 (     xOrig == Old(x)     )   by Premise,     //xOrig equaled the OLD value of x
</span></span><span class=line><span class=cl>    4 (     yOrig == y          )   by Premise,     //yOrig still equals y
</span></span><span class=line><span class=cl>    5 (     temp == xOrig       )   by Algebra*(2, 3),
</span></span><span class=line><span class=cl>    6 (     x == yOrig          )   by Algebra*(1, 4)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>y = temp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     y == temp           )   by Premise,     //from the assignment statement
</span></span><span class=line><span class=cl>    2 (     temp == xOrig       )   by Premise,     //from the previous proof block (temp and xOrig are unchanged since)
</span></span><span class=line><span class=cl>    3 (     yOrig == Old(y)     )   by Premise,     //yOrig equaled the OLD value of y
</span></span><span class=line><span class=cl>    4 (     x == xOrig          )   by Algebra*(1, 2),
</span></span><span class=line><span class=cl>    5 (     x == yOrig          )   by Premise,     //from the previous proof block (x and yOrig are unchanged since)  
</span></span><span class=line><span class=cl>    6 (     x == yOrig ∧ y == xOrig )   by AndI(5, 4)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//x and y have swapped
</span></span><span class=line><span class=cl>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span class=line><span class=cl>assert(x == yOrig ∧ y == xOrig)     //this assert will hold now</span></span></code></pre></div><p>Notice that in each proof block, we express as much as we can about all variables/values in the program. In the first proof block, even though <code>xOrig</code> and <code>yOrig</code> were not used in the previous assignment statement, we still expressed how the current values our other variables compared to <code>xOrig</code> and <code>yOrig</code>. It helps to think about what you are trying to claim in the final assert &ndash; since our assert involved <code>xOrig</code> and <code>yOrig</code>, we needed to relate the current values of our variables to those values as we progressed through the program.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=integer-division-and-modulo>Integer Division and Modulo</h1><p>We will see in this section that verifying programs with division and modulo requires extra care.</p><h2 id=division>Division</h2><p>Recall that <code>Z</code> (int) is the only numeric type for Logika verification, so any division is integer division. This means something like <code>9/2</code> evaluates to 4, just as it would in Java or C#.</p><h3 id=check-for-division-by-zero>Check for division by zero</h3><p>Before doing division of the form <code>numerator/denominator</code>, either in a line of code or in a proof block, you must have have shown in a previous proof block that <code>denominator</code> is not 0. The easiest way to do this is to prove the claim: <code>denominator != 0</code>. You are even required to do this when dividing by a constant value that is obviously not zero.</p><p>For example, if we do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 10 / 2</span></span></code></pre></div><p>Then Logika will give us an error complaining we have not proved that the denominator is not zero. We must add the claim <code>2 != 0</code> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    2 != 0      )   by Algebra*()
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 10 / 2</span></span></code></pre></div><p>Note that our justification is just, <code>Algebra*()</code>, as we don&rsquo;t need any extra information to claim that 2 is not equal to 0.</p><p>We could have instead claimed that 2 > 0 (again using <code>Algebra*()</code>), which would also prove that the denominator was not 0. However, claims such as <code>2 > 1</code> would not be accepted as proof that the denominator wasn&rsquo;t 0 (at least in Logika&rsquo;s manual mode).</p><h3 id=pitfalls>Pitfalls</h3><p>Be careful when making claims that involve division. For example, the following claim will not validate in Logika:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    x == (x/3)*3    )   by Algebra*()
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>While the claim <code>x == (x/3)*3</code> is certainly true in math, it is not true with integer division. For example, if <code>x</code> is 7, then <code>(x/3)*3</code> is 6 &ndash; so the two sides are not equal. In general, I recommend avoiding claims involving division if you can at all help it. Instead, try to find a way to express the same idea in a different way using multiplication.</p><h2 id=modulo>Modulo</h2><p>Modulo (%) works the same way in Scala (and Logika) as it does in other programming languages. For example, <code>20 % 6</code> evaluates to 2.</p><h3 id=modulo-checks-on-denominator>Modulo checks on denominator</h3><p>Before using the modulo operator in the form <code>numerator % denominator</code>, either in a line of code or as a claim in a proof block, you must have previously established one of the following:</p><ul><li><code>denominator != 0</code></li><li><code>denominator > 0</code></li></ul><p>This must be done even if the denominator is a literal value (like 2), and can be demonstrated in the same way as we did with division.</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    7 != 0      )   by Algebra*()
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x = a % 7</span></span></code></pre></div><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var num: Z = Z.prompt(&#34;Enter positive number: &#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assume(num &gt; 0)
</span></span><span class=line><span class=cl>val orig: Z = num
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>num = num * 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num % 2 == 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>num = num + 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num % 2 == 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>num = num/2 - 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num == orig)</span></span></code></pre></div><p>It can often be handy to walk through a program with sample numbers before trying to prove its correctness:</p><ul><li>Suppose our input value, <code>num</code>, is 11</li><li><code>orig</code> is initialized to be 11 also</li><li><code>num</code> is multiplied by 2, and is 22</li><li>It makes sense that <code>num</code> would be even, since any number times two is always even (and indeed, 22 is even)</li><li>We add 2 to <code>num</code>, so it is now 24</li><li>It makes sense that <code>num</code> would still be even, as it was even before and we added 2 (another even number) to it. Indeed, 24 is still even.</li><li>We update <code>num</code> by dividing it by 2 and subtracting 1, so <code>num</code> is now back to its original value of 11 (the same as <code>orig</code>). This step &ldquo;undoes&rdquo; the changes we have made to <code>num</code> &ndash; looking at the code, we can see that the final value of <code>num</code> is <code>orig*2 + 2</code>, so if we do <code>(orig*2 + 2) / 2 - 1</code>, we are left with <code>orig</code>.</li></ul><p>Here is the completed verification, with comments at each step:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var num: Z = Z.prompt(&#34;Enter positive number: &#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assume(num &gt; 0)
</span></span><span class=line><span class=cl>val orig: Z = num
</span></span><span class=line><span class=cl>num = num * 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    num == Old(num) * 2     )   by Premise,         //we updated num to be its old value times 2
</span></span><span class=line><span class=cl>    2  (    orig == Old(num)        )   by Premise,         //orig equaled the old value of num (before our change)
</span></span><span class=line><span class=cl>    3  (    num == orig * 2         )   by Algebra*(1, 2),  //express the new value of num without referring to &#34;Old&#34;
</span></span><span class=line><span class=cl>    4  (    2 != 0                  )   by Algebra*(),      //needed to use modulo in the assert
</span></span><span class=line><span class=cl>    5  (    num % 2 == 0            )   by Algebra*(1)      //we have showed num is now even (needed for next assert)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num % 2 == 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>num = num + 2 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    num == Old(num) + 2     )   by Premise,         //we updated num to be its old value plus 2
</span></span><span class=line><span class=cl>    2  (    Old(num) % 2 == 0       )   by Premise,         //from line 5 in previous block, but num has since changed
</span></span><span class=line><span class=cl>    3  (    num % 2 == 0            )   by Algebra*(1, 2),  //we have showed num is still even (needed for next assert)
</span></span><span class=line><span class=cl>    4  (    Old(num) == orig * 2    )   by Premise,         //from line 3 in block above, but num has since changed
</span></span><span class=line><span class=cl>    5  (    num - 2 == orig * 2     )   by Algebra*(1, 4)   //express new value of num without using &#34;Old&#34;
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num % 2 == 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//we have already established that 2!= 0, which is needed to divide by 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>num = num/2 - 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    num == Old(num) / 2 - 1         )   by Premise,         //we updated num to be its old value divided by 2 minus 1
</span></span><span class=line><span class=cl>    2  (    Old(num) - 2 == orig * 2        )   by Premise,         //from line 7 in previous block, but num has since changed
</span></span><span class=line><span class=cl>    3  (    Old(num) == orig * 2 + 2        )   by Algebra*(2),
</span></span><span class=line><span class=cl>    4  (    num == (orig * 2 + 2) / 2 - 1   )   by Algebra*(1, 3),  //express new value of num without using &#34;Old&#34;
</span></span><span class=line><span class=cl>    5  (    num == orig + 1 - 1             )   by Algebra*(4),
</span></span><span class=line><span class=cl>    6  (    num == orig                     )   by Algebra*(5)      //we have showed num is back to being orig (needed for last assert)
</span></span><span class=line><span class=cl>                                                                    //could have skipped straight here with &#34;Algebra*(1,2)&#34;
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num == orig)</span></span></code></pre></div><p>Sometimes it can be tricky to figure out what to do at each step in order to get assert statements to pass. If you are unsure what to do, I recommend:</p><ul><li><p>Walk through the program several times with sample numbers, keeping track of changes to variables. Why do the assert statements make sense to you? Convince yourself that they are valid claims before you worry about the formal verification.</p></li><li><p>Add a proof block after each variable mutation. Work from the top down:</p><ul><li>Write a premise for every variable assignment and assume statement since the previous proof block.</li><li>Find all claims in the proof block just before you that do not use an &ldquo;Old&rdquo; reference &ndash; pull each claim into your current block, using an &ldquo;Old&rdquo; reference as needed for the most recently changed variable.</li><li>Manipulate your claims that use an &ldquo;Old&rdquo; reference until you have statements that capture the current value of the recently changed variable that do not reference &ldquo;Old&rdquo;</li><li>If your next statement is an assert, manipulate your claims until you have exactly the claim in the assert.</li><li>If any claims</li></ul></li><li><p>Add a proof block before each use of division (<code>numerator / denominator</code>) and modulus (<code>numerator % denominator</code>). Pull in claims from previous blocks as described above to help you show the claim <code>denominator != 0</code>. If you can, avoid using division in proof block claims.</p></li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=conditional-statements>Conditional Statements</h1><p>To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. We will only consider programs with an if/else as opposed to an if/else if. However, you can simulate more than two branches by nesting another if/else inside the outer else.</p><h2 id=motivation>Motivation</h2><p>Before we formalize the details of verifying a program with a conditional statement, let&rsquo;s motivate the topic with an example.</p><h3 id=max-program>Max program</h3><p>Suppose we have a program that finds finds the maximum (<code>max</code>) between two user input numbers (<code>x</code> and <code>y</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = Z.read()
</span></span><span class=line><span class=cl>var y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var max: Z = 0  //give max a dummy starting value
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>if (x &gt; y) {
</span></span><span class=line><span class=cl>    max = x
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    max = y
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><h3 id=max-assert>Max assert</h3><p>Before worrying about how to do the verification, let&rsquo;s consider what we should assert at the end in order to be sure that <code>max</code> really does hold the biggest of the two inputs. Clearly, <code>max</code> should be greater than or equal to both inputs. So should our assert be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//Not quite all we want to say
</span></span><span class=line><span class=cl>assert(max &gt;= x ∧ max &gt;= y)</span></span></code></pre></div><p>Suppose <code>x</code> was 10, <code>y</code> was 15&mldr;and that <code>max</code> was 20. (Clearly this isn&rsquo;t what our code would do, but you can imagine writing something else for the max code that came up with such a calculation). In this case, <code>max</code> is indeed greater than or equal to both inputs&mldr;but it is just as clearly not the max. We know see that we also need to claim that <code>max</code> equals one of the two inputs. This makes our assert:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//Now we are sure we are describing the max between x and y
</span></span><span class=line><span class=cl>assert(max &gt;= x ∧ max &gt;= y ∧ (max == x ∨ max == y))</span></span></code></pre></div><h3 id=analyzing-max>Analyzing max</h3><p>Now, we need to prove that our assert holds no matter which branch we follow in the conditional statement. First, when we analyze the code in the if-branch, we have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>max = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     max == x    )   by Premise
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>and when we analyze the code in the else-branch, we have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>max = y
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     max == y    )   by Premise
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>These two deductions imply that, when the if/else statements finishes, one or the other property holds true:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>if (x &gt; y) {
</span></span><span class=line><span class=cl>    max = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     max == x    )   by Premise
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    max = y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     max == y    )   by Premise
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    //max == x in the IF, max == y in the ELSE
</span></span><span class=line><span class=cl>    1 (     max == x  v  max == y   )   by Premise 
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>This illustrates the first principle of conditional commands: the knowledge produced by the command is the disjunction (or) of the knowledge produced by each branch. In the section on propositional logic, we covered how to apply cases analyses on disjunctive assertions to extract useful knowledge.</p><p>Recall that the intent of the if/else statement was to set <code>max</code> so that it holds the larger of <code>x</code> and <code>y</code>, so that our assert would hold:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>assert(max &gt;= x ∧ max &gt;= y ∧ (max == x v max == y))</span></span></code></pre></div><p>The claim we proved so far satisifies the second part of our assert statement, but not the first part. This is because we ignored a critical feature of an if/else statement: By asking a question — the condition — the if/else statement generates new knowledge.</p><p>For the if-branch, we have the new knowledge that <code>x > y</code>; for the else-branch, we have that <code>¬(x > y)</code>, that is, <code>y >= x</code>. We can embed these assertions into the analysis of the conditional command, like this, and conclude that, in both cases, <code>max</code> is greater than or equal to both inputs:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = Z.read()
</span></span><span class=line><span class=cl>var y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var max: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>if (x &gt; y) {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     x &gt; y       )   by Premise      //the condition is true
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    max = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     max == x    )   by Premise,    //from the &#34;max = x&#34; assignment
</span></span><span class=line><span class=cl>        2 (     max &gt;= x    )   by Algebra*(1),
</span></span><span class=line><span class=cl>        3 (     x &gt; y       )   by Premise,    //condition is still true (x and y are unchanged)
</span></span><span class=line><span class=cl>        4 (     max &gt;= y    )   by Algebra*(1,3)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     ¬(x &gt; y)    )   by Premise,    //the condition is NOT true
</span></span><span class=line><span class=cl>        2 (     x &lt;= y      )   by Algebra*(2)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    max = y
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     max == y    )   by Premise,    //from the &#34;max = y&#34; assignment
</span></span><span class=line><span class=cl>        2 (     x &lt;= y      )   by Premise,    //pulled down from previous proof block (x and y are unchanged)
</span></span><span class=line><span class=cl>        3 (     max &gt;= x    )   by Algebra*(1, 2),
</span></span><span class=line><span class=cl>        4 (     max &gt;= y    )   by Algebra*(1)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//summary of what just happened
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    //max == x in the IF, max == y in the ELSE
</span></span><span class=line><span class=cl>    1 (     max == x ∨ max == y )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 (     max &gt;= x            )   by Premise,     //true in BOTH branches
</span></span><span class=line><span class=cl>    3 (     max &gt;= y            )   by Premise,     //true in BOTH branches
</span></span><span class=line><span class=cl>    4 (     max &gt;= x ∧ max &gt;= y )   by AndI(2, 3),
</span></span><span class=line><span class=cl>    5 (     max &gt;= x ∧ max &gt;= y) ∧ (max == x ∨ max == y )   by AndI(4, 1)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(max &gt;= x ∧ max &gt;= y ∧ (max == x v max == y))</span></span></code></pre></div><h2 id=rules-for-analyzing-programs-with-conditionals>Rules for analyzing programs with conditionals</h2><p>In this section, we will summarize how to analyze programs with conditional statements.</p><h3 id=declaring-condition-and-condition-as-premises>Declaring condition and ¬(condition) as premises</h3><p>If we have a program such as this with an if/else statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>if (C) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Then we can claim <code>C</code> as a premise immediately inside the if-branch and <code>¬(C)</code> as a premise immediately inside the else branch:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>if (C) {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     C       )   by Premise
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     ¬(C)    )   by Premise
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Be careful with the <code>else</code> case &ndash; you must claim exactly <code>¬(C)</code>, and not some claim you know to be equivalent. In our max example, <code>C</code> was <code>x &lt; y</code>, and we needed to claim exactly <code>¬(x &lt; y)</code> in the else &ndash; NOT <code>x >= y</code>. After you have pulled in the initial claim using the form <code>¬(C)</code>, you can use <code>Algebra*</code> to manipulate it into a different form.</p><h3 id=each-branch-reaches-a-different-conclusion>Each branch reaches a different conclusion</h3><p>If the if-branch reaches conclusion <code>Q1</code> and the else branch reaches conclusion <code>Q2</code>, then afterwards we can list as a premise that one of those conclusions is true (since we know that one of the branches in an if/else will ALWAYS execute):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>if (C) {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     Q1      )   by SomeJustification    //conclusion in if-branch
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     Q2      )   by SomeJustification   //conclusion in else-branch
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     Q1 ∨ Q2     )   by Premise     //Q1 from if, Q2 from else
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Note that order matters, and that we must claim <code>(if conclusion) ∨ (else conclusion)</code> &ndash; in the example above, we could not claim <code>Q2 ∨ Q1</code> afterwards.</p><h3 id=each-branch-reaches-the-same-conclusion>Each branch reaches the same conclusion</h3><p>If the if-branch and the else-branch both reach the SAME conclusion <code>Q</code>, then afterwards we can list <code>Q</code> as a premise. Here, we know that one of the branches in an if/else will ALWAYS execute &ndash; so if we get to the same conclusion in both cases, then we must always reach that conclusion:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>if (C) {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>        1 (     Q       )   by SomeJustification    //common conclusion reached in IF
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     Q       )    by SomeJustification   //common conclusion reached in ELSE
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     Q           )   by Premise     //Q was true in both the IF and the ELSE
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h2 id=example-programs-with-no-else>Example: programs with no &ldquo;else&rdquo;</h2><p>Some programs have just an if statement with no else. For example, consider this program to find the absolute value of a number:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var num: Z = Z.read()
</span></span><span class=line><span class=cl>var orig: Z = num
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>if (num &lt; 0) {
</span></span><span class=line><span class=cl>    num = num * -1
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//num is now the absolute value of the original input
</span></span><span class=line><span class=cl>//(num is nonnegative and either equals `orig` [the original input] or -1*orig)
</span></span><span class=line><span class=cl>assert(num &gt;= 0 ∧ (num == -1*orig ∨ num == orig))</span></span></code></pre></div><p>Even though an &ldquo;else&rdquo; is unnecessary in the implementation, we want an else statement in order to ensure our program works in the case that num is NOT less than 0. Our solution is to add an else statement that is solely to hold a proof block for that branch.</p><p>We add an else statement and complete our verification as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var num: Z = Z.read()
</span></span><span class=line><span class=cl>var orig: Z = num
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     orig == num     )   by Premise,     //from &#34;orig = num&#34; assignment
</span></span><span class=line><span class=cl>    2 (     num == orig     )   by Algebra*(1)  //switch order to match assert
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>if (num &lt; 0) {
</span></span><span class=line><span class=cl>    num = num * -1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1  (    Old(num) &lt; 0            )   by Premise,         //if condition (num just changed)
</span></span><span class=line><span class=cl>        2  (    num == Old(num) * -1    )   by Premise,         //from &#34;num = num * -1&#34; assignment
</span></span><span class=line><span class=cl>        3  (    orig == Old(num)        )   by Premise,         //orig did equal num (num just changed)
</span></span><span class=line><span class=cl>        4  (    num &gt;= 0                )   by Algebra*(1, 2),  //a negative number times -1 is nonnegative
</span></span><span class=line><span class=cl>        5  (    num == -1 * orig        )   by Algebra*(2, 3)   //needed for last part of assert
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //no code - just the proof block
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     ¬(num &lt; 0)              )   by Premise,         //negation of condition
</span></span><span class=line><span class=cl>        2 (     num == orig             )   by Premise,         //num is unchanged
</span></span><span class=line><span class=cl>        3 (     num &gt;= 0                )   by Algebra*(1)      //needed for assert
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     num &gt;= 0                        )   by Premise, //true in both branches
</span></span><span class=line><span class=cl>    2 (     num == -1*orig ∨ num == orig    )   by Premise  //LHS in if, RHS in else
</span></span><span class=line><span class=cl>    3 (     num &gt;= 0 ∧ (num == -1*orig ∨ num == orig)   )   by AndI(1, 2)   //match assert
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//num is now the absolute value of the original input
</span></span><span class=line><span class=cl>//(num is nonnegative and either equals `orig` [the original input] or -1*orig)
</span></span><span class=line><span class=cl>assert(num &gt;= 0 ∧ (num == -1*orig ∨ num == orig))</span></span></code></pre></div><h2 id=nested-conditionals>Nested conditionals</h2><p>We employ the same rules when analyzing programs with nested conditional statements. If we reach a common conclusion in both the if and else branches of an inner if/else statement, for example, then we can claim the common conclusion as a premise after that inner if/else statement (but still inside the outer if/else). The outline below summarizes what we can claim at various places in nested if/else statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>if (C1) {
</span></span><span class=line><span class=cl>    if (C2) {
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( C1  )   by Premise,     //outer if condition is true
</span></span><span class=line><span class=cl>            2 ( C2  )   by Premise      //inner if condition is true
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( common  )   by SomeJustification,
</span></span><span class=line><span class=cl>            2 ( Q1      )   by SomeJustification
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    else {
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( C1      )   by Premise,     //outer if condition is true
</span></span><span class=line><span class=cl>            2 ( ¬(C2)   )   by Premise      //inner if condition is false
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( common  )   by SomeJustification,
</span></span><span class=line><span class=cl>            2 ( Q2      )   by SomeJustification
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 ( common  )   by Premise,    //common conclusion in inner if/else
</span></span><span class=line><span class=cl>        2 ( Q1 ∨ Q2 )   by Premise     //Q1 from inner if, Q2 from inner else
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>} else {
</span></span><span class=line><span class=cl>    if (C3) {
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( ¬(C1)   )   by Premise,     //outer if condition is false
</span></span><span class=line><span class=cl>            2 ( C3      )   by Premise      //inner if condition is true
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( common  )   by SomeJustification,
</span></span><span class=line><span class=cl>            2 ( Q3      )   by SomeJustification
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    else {
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( ¬(C1)   )   by Premise,     //outer if condition is false
</span></span><span class=line><span class=cl>            2 ( ¬(C3)   )   by Premise      //inner if condition is false
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 ( common  )   by SomeJustification,
</span></span><span class=line><span class=cl>            2 ( Q4      )   by SomeJustification
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 ( common  )   by Premise,    //common conclusion in inner if/else
</span></span><span class=line><span class=cl>        2 ( Q3 ∨ Q4 )   by Premise     //Q1 from inner if, Q2 from inner else
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( common                  )   by Premise,     //&#34;common&#34; was true in both the outer IF and the outer ELSE 
</span></span><span class=line><span class=cl>    2 ( (Q1 ∨ Q2) ∨ (Q3 ∨ Q4)   )   by Premise      //(Q1 ∨ Q2) from outer if, (Q3 ∨ Q4) from else
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/dec4297d81df48b5e02e2640601321e923ab5f5b>Aug 10, 2023</a></p></div></div><script src=/cis301/js/clipboard.min.js?1741190549 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1741190549 defer></script><script src=/cis301/js/theme.js?1741190549 defer></script></body></html>