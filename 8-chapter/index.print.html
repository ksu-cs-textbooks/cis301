<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Intro to Programming Logic :: CIS 301 Textbook"><meta name=twitter:description content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/8-chapter/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Intro to Programming Logic :: CIS 301 Textbook"><meta property="og:description" content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Intro to Programming Logic :: CIS 301 Textbook"><meta itemprop=description content="Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements."><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T14:52:41-05:00"><meta itemprop=wordCount content="59"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Intro to Programming Logic :: CIS 301 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis301/8-chapter/index.html rel=canonical type=text/html title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/8-chapter/index.xml rel=alternate type=application/rss+xml title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/8-chapter/tele.html rel=alternate type=text/html title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/8-chapter/embed.html rel=alternate type=text/html title="Intro to Programming Logic :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1765567784 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1765567784 defer></script><script src=/cis301/js/search-lunr.min.js?1765567784 defer></script><script src=/cis301/js/search.min.js?1765567784 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1765567784"</script><script src=/cis301/js/lunr/lunr.min.js?1765567784 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1765567784 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1765567784 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1765567784 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1765567784 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1765567784 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1765567784 rel=stylesheet><link href=/cis301/css/theme.min.css?1765567784 rel=stylesheet><link href=/cis301/css/format-print.min.css?1765567784 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/8-chapter/index.html",window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1765567784 rel=stylesheet></head><body class="mobile-support embed print" data-url=/cis301/8-chapter/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 8-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=intro-to-programming-logic>Intro to Programming Logic</h1><h6 id=intro-to-programming-logic-assignments-and-conditionals>Intro to Programming Logic: Assignments and Conditionals</h6><p>For the rest of the course, we will switch gears back to something more familiar for most &ndash; computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Intro to Programming Logic</h1><article class=default><header class=headline></header><h1 id=programming-logic-goal>Programming Logic Goal</h1><p>In the next three chapters, we will learn how to reason about different kinds of program structures &ndash; assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs using a toy language that is a subset of Scala. While our toy language is not used in practice, the ideas that we will see to prove program correctness &ndash; preconditions, postconditions, loop invariants, and global invariants &ndash; can be used to specify functions in ANY language.</p><p>We will see that the process for formal specifications and proofs of correctness is rather tedious, even for relatively simple programs. And in practice, proving correctness of computer programs is rarely done. So why bother studying it?</p><h2 id=safety-critical-code>Safety critical code</h2><p>One case where reasoning about correctness is certainly relevant is the arena of <em>safety critical code</em> &ndash; where lives depend on a program working correctly. Certain medical devices, such as pacemakers and continuous glucose monitors, have a software component. If that software fails, then a person could die. We can&rsquo;t test the correctness of medical devices by installing them in a human body and trying them out &ndash; instead, we need to be absolutely sure they work correctly before they are used.</p><p>Similarly, there is software in things like shuttle launches. While that might not cost lives, it&rsquo;s also a process that can&rsquo;t be fully tested beforehand. After all, no one is going to spend over a billion dollar on a &ldquo;practice&rdquo; launch. Instead, we need a way to more formally demonstrate that the software will work correctly.</p><h2 id=specifications>Specifications</h2><p>In chapter 9, we will learn to write function <em>specifications</em>. These specifications list any requirements the function has in order to work correctly (<em>preconditions</em>) and descibe the impact of calling the function (<em>postconditions</em>) - most notably, what the function returns in terms of its inputs. Even in cases where we do not formally prove correctness of a program, it is very useful to write a specification for all functions. This can make it clear to any calling code what kinds of parameters should be passed, as well as what to expect about the returned value. By providing this structure, there will be fewer surprises and unintended errors.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logika-programs>Logika Programs</h1><p>As we study program logic, we will use Logika to verify a subset of programs that use the Scala language. Specifically, we will study verification of programs with the following features:</p><ul><li>Variables (booleans, ints, and sequences [which are like arrays/lists])</li><li>Printing and user input</li><li>Math operations</li><li>Conditional operations</li><li>If and if/else statements</li><li>While loops</li><li>Functions</li></ul><p>The Scala programs we verify should be saved with a .sc extension. To show we are using Logika for verification, the first line of the file should be:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika</span></span></code></pre></div><h2 id=verifying-logika-programs>Verifying Logika programs</h2><p>There are two modes in Logika &ndash; manual and automatic. In chapters 8 and 9, we will use manual mode. In chapter 10, we will use automatic mode. You will designate the verification mode on the second line of the Scala file (just below <code>// #Sireum #Logika</code>). To specify manual mode, you will write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//@Logika: --manual --background save</span></span></code></pre></div><p>And to specify automatic mode, you will delete the <code>--manual</code> from above, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//@Logika: --background save</span></span></code></pre></div><p>Logika verification <em>should</em> run automatically as you edit these programs and their proofs. If a program is verified, you will see a purple checkmark in the lower right corner just as you did in propositional and predicate logic proofs. If there are syntax or logic errors, you will see them highlighted in red.</p><p>Sometimes, the Logika verification needs to be run manually. If you don&rsquo;t see either red errors or a purple checkmark, right-click in the text area that contains the code and select &ldquo;Logika Check (All in File)&rdquo;.</p><h2 id=example-programs>Example programs</h2><p>This section contains four sample Scala programs that highlight the different language features that we will work with.</p><h3 id=example-1-user-input-printing-operations>Example 1: User input, printing, operations</h3><p>This first example gets a number as input from the user, adds one to it, and prints the result:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = Z.prompt(&#34;Enter a number: &#34;)
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(&#34;One more is &#34;, x)</span></span></code></pre></div><p>A few things to note:</p><ul><li>After the two comment lines to show we are using the Logika verification tool in manual mode, our program begins with an import statement: <code>import org.sireum._</code></li><li>The <code>var</code> keyword stands for variable, which is something that can be changed. Logika also has a <code>val</code> keyword, which creates a constant value that cannot be changed.</li><li>Lines do not end in semi-colons</li><li>The <code>Z.prompt(...)</code> function prints a prompt and returns the integer (<code>Z</code>) that was typed. The parameter to this function is the desired prompt. Alternately, the <code>Z.read()</code> function gets and returns an integer from user input without taking a prompt.</li><li>The code <code>var x: Z</code> creates a variable called <code>x</code> of type <code>Z</code> &ndash; as with the user input functions, the <code>Z</code> means <em>integer</em></li></ul><h3 id=example-2-ifelse-statements>Example 2: If/else statements</h3><p>Here is a Scala program that gets a number from the user, and uses an if/else statement to print whether the number is positive or negative/zero:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = Z.prompt(&#34;Enter a number: &#34;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (num &gt; 0) {
</span></span><span style=display:flex><span>    println(num, &#34; is positive&#34;)
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    println(num, &#34; is negative (or zero)&#34;)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>A couple of things to note here:</p><ul><li>The <code>else</code> statement MUST appear on the same line as the closing <code>}</code> of the previous if-statement</li><li>As mentioned above, the <code>val</code> keyword in this program means that <code>num</code> cannot be changed after being initialized</li></ul><h3 id=example-3-while-loops>Example 3: While loops</h3><p>Our next program uses a while loop to print the numbers from 10 down to 1:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var cur: Z = 10
</span></span><span style=display:flex><span>while (cur &gt;= 1) {
</span></span><span style=display:flex><span>  println(&#34;Next number: &#34;, cur)
</span></span><span style=display:flex><span>  cur = cur - 1
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=example-4-sequences-and-functions>Example 4: Sequences and functions</h3><p>Our final sample program demonstrates <em>sequences</em> (similar to an array or list) and functions. It contains a function, <code>sumSequence</code>, which takes a sequence of integers as a parameter and returns the sum of the numbers in the sequence. At the bottom, we can see our test code that creates a sample sequence and tries calling <code>sumSequence</code>. If you create this file, you will see an error about the sequence indices possibly being negative &ndash; this code cannot be run without some verification work:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def sumSequence(seq: ZS) : Z = {
</span></span><span style=display:flex><span>  var sum: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  var i: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  while (i &lt; seq.size) {
</span></span><span style=display:flex><span>    sum = sum + seq(i)
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////// Calling code ////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val list: ZS = ZS(1,2,3,4)
</span></span><span style=display:flex><span>val total: Z = sumSequence(list)
</span></span><span style=display:flex><span>println(&#34;Sum of elements:&#34;, total)</span></span></code></pre></div><p>A few things of note here:</p><ul><li><p>The definition <code>def sumSequence(seq: ZS) : Z</code> means that a function named <code>sumSequence</code> takes a parameter of type <code>ZS</code> (sequence of integers, <code>Z</code> = int and <code>S</code> = sequence) and returns something of type <code>Z</code> (int)</p></li><li><p>There is an <code>=</code> after the function header but before the opening <code>{</code> of the function</p></li><li><p>These functions are not part of a class - they are more similar to the structure in Python. We can include as many functions as we want in a file. At the bottom of the file (marked below the optional <code>////// Calling code ////////////</code>) is the <em>calling code</em>. When a Logika program runs, those calling code lines (which may call different functions) are executed. When the calling code lines are done, the program is done.</p></li></ul><h2 id=logika-program-proof-syntax>Logika program proof syntax</h2><p>In order to prove correctness of these Scala programs, we will add <em>Deduce blocks</em> to process what we have learned at different points in the program. In general, every time there is an assignment statement, there will be a following <code>Deduce</code> proof block updating all relevant facts.</p><h3 id=necessary-import-statements>Necessary import statements</h3><p>We have already seen that we must include the import statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>import org.sireum._</span></span></code></pre></div><p>Anytime we want to do anything with the Logika proof checker. There are three other import statements that you will commonly use:</p><ol><li><code>import org.sireum.justification._</code> is needed for any Deduce statements and basic justifications (<code>Premise</code>, etc.)</li><li><code>import org.sireum.justification.natded.prop._</code> is needed for any propositional logic justifications</li><li><code>import org.sireum.justification.natded.pred._</code> is needed for any predicate logic justifications</li></ol><h3 id=deduce-block>Deduce block</h3><p>Here is the syntax for a Deduce proof block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    claim       ) by Justification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Just as with our propositional and predicate logic proofs, we will number the lines in our proof blocks. Each line will contain a <em>claim</em> and a corresponding <em>justification</em> for that claim. We will still be able to use all of our propositional and predicate logic deduction rules, but we will learn new justifications for processing program statements. Each program may have multiple of these proof blocks to process each assignment statement.</p><h3 id=premise-justification>Premise justification</h3><p>Our first justification in programming logic is <em>Premise</em>. In a Deduce proof block, we use <code>Premise</code> as a justification in the following cases:</p><ul><li><p>To express an assignment statement (or other program statement)</p></li><li><p>To pull a claim established in a previous proof block into a later proof block</p></li></ul><p>In both cases, the claim must capture the current value of the involved variables.</p><p>For example, consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>x = x + 1</span></span></code></pre></div><p>We could insert a proof block between the two lines to express that <code>x</code> currently has the value 6:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6  ) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1</span></span></code></pre></div><p>But we could NOT have the same proof block after incrementing <code>x</code>, since <code>x</code>&rsquo;s value has changed since that claim was established:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this proof block is correct -- it captures the current value of x
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6  ) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//NO! This statement no longer captures the current value of x
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6  ) by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h3 id=using-previous-deduction-rules>Using previous deduction rules</h3><p>We can use any of our previous deduction rules in a Logika proof block. For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 7
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1 (   x == 6                ) by Premise,
</span></span><span style=display:flex><span>  2 (   y == 7                ) by Premise,
</span></span><span style=display:flex><span>  3 (   (x == 6) ∧ (y == 7)   ) by AndI(1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=assert-and-assume>Assert and Assume</h1><h2 id=assert-statements>Assert statements</h2><p>An <em>assert</em> statement in Scala uses the syntax <code>assert(expression)</code>, where <code>expression</code> is of type <code>bool</code>. The assert passes if the expression is true, and throws an error if the expression is false.</p><p>Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven.</p><p>Note that we are using these assert statements differently than assert statements in languages like Java and C# &ndash; in those languages, the code in the assert statement (which often includes test method calls) is actually run, and the assert statement checks whether those methods are returning the expected values. In Logika, assert statements only pass if we have previously PROVED what we are claiming &ndash; the code is never executed.</p><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 6
</span></span><span style=display:flex><span>val z: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert (x == y &amp; y &gt; z)</span></span></code></pre></div><p>While we can tell that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>, this code would fail in Logika (at least in its manual mode, which is what we are using now). In order for an assert to pass, we must have already proved EXACTLY the statement in the assert.</p><p>Why do WE know that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>? From looking at the code! We can tell that <code>x</code> and <code>y</code> are given the same value (6), and that <code>y</code>&rsquo;s value of 6 is bigger than <code>z</code>&rsquo;s value of 4.</p><p>So far, we know we can pull in the values of each variable as premises, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 6
</span></span><span style=display:flex><span>val z: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (x == 6) by Premise,
</span></span><span style=display:flex><span>    2  (y == 6) by Premise,
</span></span><span style=display:flex><span>    3  (z == 4) by Premise,
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    //how to say that x and y are equal, and that y is bigger than z?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>assert(x == y ∧ y &gt; z)</span></span></code></pre></div><p>But we don&rsquo;t yet know how to justify claims that describe how variables compare to one another. We will learn how to do that with the <code>Algebra</code> and <code>Subst</code> rules in section 8.4.</p><h3 id=using-conditional-operators>Using conditional operators</h3><p>Notice that the program above used an <code>∧</code> symbol for an AND operator in an assert statement. As with our propositional logic proofs, if we want to use a <code>∧</code> operator then we type the symbol <code>&</code>. This <code>&</code> is automatically changed to a <code>∧</code> when we view our program, just as it was in our deduction proofs. Similarly, we type <code>!</code> for NOT in asserts (which displays as <code>¬</code>) and <code>|</code> for OR (which displays as <code>∨</code>). However, we are not able to use an implies operator in an assert statement as it is not part of the Scala language (and our asserts are part of the program and not just a proof element).</p><p>If we wanted to write an assert statement that would be true when some variable <code>p</code> was even and/or was a positive two-digit number, we could say:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(p % 2 == 0 ∨ (p &gt; 9 ∧ p &lt; 100))</span></span></code></pre></div><p>As was mentioned above, the implies operator is not available in assert statements. However, we can make use of one of the equivalences we learned about in section 3.4: that <code>p → q</code> is equivalent to <code>¬p ∨ q</code>. So if we wanted to assert that if <code>p</code> was positive, then <code>q</code> was equal to <code>p</code>, then we could write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//expressing the implicaton ((p &gt; 0) → (q == p))
</span></span><span style=display:flex><span>assert(¬(p &gt; 0) ∨ (q == p))</span></span></code></pre></div><p>Or, equivalently, we could write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert((p &lt;= 0) ∨ (q == p))</span></span></code></pre></div><h2 id=assume-statement>Assume statement</h2><p>An <em>assume</em> statement in Scala uses the syntax <code>assume(expression)</code>. If the expression is satisfiable, then we can use <code>expression</code> as a premise in the following Logika proof block.</p><h3 id=assume-example>Assume example</h3><p>For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var a: Z = Z.read()
</span></span><span style=display:flex><span>assume (a &gt; 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (a &gt; 0)   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Assume statements are almost always used to make assumptions about user input. Perhaps our program only works correctly for certain values of input. If we can assume that the user really did enter acceptable values, then we can use that information (by pulling it in as a premise in the next proof block) to prove the correctness of the program based on that assumption.</p><h3 id=assumes-vs-wrapping-if-statements>Assumes vs. wrapping if-statements</h3><p>Toy programs often use assume in lieu of wrapping code in an if statement. The following two examples are equivalent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a : Z = Z.read()
</span></span><span style=display:flex><span>assume (a != 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1  (a != 0) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var b: Z = 20 / a</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//...is equivalent to:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a : Z = Z.read()
</span></span><span style=display:flex><span>var b : Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (a != 0) {
</span></span><span style=display:flex><span>    b = 20 / a
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>These examples also demonstrate a requirement when we use the division operator in Logika programs, we must first demonstrate that we are not dividing by zero.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=algebra-and-subst-rules>Algebra and Subst Rules</h1><p>In this section, we will learn our first two proof rules for programming logic &ndash; <code>Algebra</code> and <code>Subst</code>.</p><h2 id=verifying-simple-programs>Verifying simple programs</h2><p>Before we delve into our new proof rules, let&rsquo;s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the <code>// --></code> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>get user input / set initial variable values
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add assume statements to specify what must be true about the input
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program statement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program statement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>program statement
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add proof block to evaluate what has happened in the program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(...more program statements)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // --&gt; add assert statements to express what our program did</span></span></code></pre></div><p>We see that if our program involves user input, then we must consider whether our program will only work correctly for certain input values. In that situation, we express our assumptions using <code>assume</code> statements.</p><p>After each program statement, we must add a proof block to evaluate what changed on that line of code. We will see more details on these proof blocks throughout the rest of this chapter. Recall that the syntax for those proof blocks looks like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //@formatter:off
</span></span><span style=display:flex><span>    1  (    claim       ) by Justification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    //@formatter:on
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Finally, we add one or more <code>assert</code> statements to express what our program did. These are usually placed at the end of a program, but sometimes we have assert statements throughout the program to describe the progress up to that point.</p><h2 id=algebra-justification>Algebra justification</h2><p>The <code>Algebra*</code> justification can be used for ANY algebraic manipulation on previous claims. When using this justification, include all relevant proof line numbers in whatever order (you might use as few as zero line numbers or as many as 3+ line numbers).</p><h3 id=example>Example</h3><p>Consider this example (which eliminates the Logika mode notation and the necessary import statements):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>var y: Z = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert (y == 6)</span></span></code></pre></div><p>Following our process from above, we add proof blocks after each program statement. In these proof blocks, we start by listing the previous program statement as a premise:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    x == 6      )   by Premise,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var y: Z = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    y == x      )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //need claim &#34;y == 6&#34; for our assert to hold
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert (y == 6)</span></span></code></pre></div><p>For our assert to hold, we must have EXACTLY that claim in a previous proof block &ndash; so we know we want our second proof block to include the claim <code>y == 6</code>.</p><p>Here is the program with the second proof block completed &ndash; the assert statement will now hold.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    x == 6      )   by Premise,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var y: Z = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     y == x      )   by Premise,
</span></span><span style=display:flex><span>    2 (     x == 6      )   by Premise,         //established in a previous proof block, and x is unchanged since then
</span></span><span style=display:flex><span>    3 (     y == 6      )   by Algebra*(1, 2)   //we know y is 6 using the claims from lines 1 and 2
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will now hold yet
</span></span><span style=display:flex><span>assert (y == 6)</span></span></code></pre></div><p>We could have also deleted the first proof block in this example. We would still be able to claim <code>x == 6</code> as a premise in the last proof block, as <code>x</code> had not changed since being given that value.</p><h2 id=subst_-and-subst_>Subst_&lt; and Subst_></h2><p>We have two deduction rules that involve substitution &ndash; <code>Subst_&lt;</code> and <code>Subst_></code>. Both of these rules are similar to the find/replace feature in text editors. They preserve truth by replacing one proposition with an equivalent one.</p><p>The <code>Algebra*</code> justification will work for most mathematical manipulation. However, it will not work for any claim involving <code>∧</code>, <code>∨</code>, <code>→</code>, <code>F</code>, <code>∀</code>, <code>∃</code> &ndash; in those cases, we will be required to use substitution instead.</p><h3 id=subst_-justification>Subst_&lt; justification</h3><p>Here is the syntax for the <code>Subst_&lt;</code> rule. In the example below, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    m (     LHS_M == RHS_M  )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    n (     LINE_N          )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    p (     claim           )   by Subst_&lt;(m, n),
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p><code>(claim)</code> rewrites <code>LINE_N</code> by substituting all occurrences of <code>RHS_M</code> with <code>LHS_M</code>. The <code>_&lt;</code> part of the justification name indicates the direction of the find/replace. You can think of it as <code>LHS_M &lt;- RHS_M</code> (showing that <code>RHS_M</code> is coming in for each <code>LHS_M</code>). Here is an example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x + 1 == y - 4                          )   by SomeJustification,
</span></span><span style=display:flex><span>    2 (     x*(x + 1) == (x + 1) + y                )   by SomeJustification,
</span></span><span style=display:flex><span>    3 (     x*(y - 4) == (y - 4) + y                )   by Subst_&lt;(1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We wrote line 3 by replacing each occurence of <code>x + 1</code> with <code>y - 4</code>.</p><h3 id=subst_-justification-1>Subst_> justification</h3><p>Here is the syntax for the <code>Subst_></code> rule. Just as with <code>Subst_&lt;</code>, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    m (     LHS_M == RHS_M  )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    n (     LINE_N          )   by SomeJustification,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    p (     claim           )   by Subst_&gt;(m, n),
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, <code>(claim)</code> rewrites <code>LINE_N</code> by substituting all occurrences of <code>LHS_M</code> with <code>RHS_M</code>. We can think of it as indicating <code>LHS_M -> RHS_M</code> (showing that <code>LHS_M</code> is coming in for each <code>RHS_M</code>). Here is an example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x + 1 == y                      )   by SomeJustification,
</span></span><span style=display:flex><span>    2 (     x*y == (x + 1) + y              )   by SomeJustification,
</span></span><span style=display:flex><span>    3 (     x*(x + 1) == (x + 1) + x + 1    )   by Subst_&gt;(1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We wrote line 3 by replacing each occurence of <code>y</code> with <code>x + 1</code>. Note that we put parentheses around our first replacement to ensure a product equivalent to the original statement.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=assignment-statements>Assignment Statements</h1><p>Assignment statements in a program come in two forms &ndash; with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.</p><p>For example, an increment statement like <code>x = x + 1</code> MUTATES the value of <code>x</code> by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of <code>x</code>.</p><p>In contrast, a statement like <code>y = x + 1</code> assigns to <code>y</code> one more than the value in <code>x</code>. We do not need to know the previous value of <code>y</code>, as we are not using it in the assignment statement. (We do need to know the value of <code>x</code>).</p><h2 id=assignments-without-mutation>Assignments without mutation</h2><p>We have already seen the steps necessary to process assignment statements that do not involve variable mutation. Recall that we can declare as a <code>Premise</code> any assignment statement or claim from a previous proof block involving variables that have not since changed.</p><p>For example, suppose we want to verify the following program so the assert statement at the end will hold (this example again eliminates the Logika mode notation and the necessary import statements, which we will continue to do in subsequent examples):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val y: Z = x + 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val z: Z = 10 - x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the assert will not hold yet
</span></span><span style=display:flex><span>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Since none of the statements involve variable mutation, we can do the verification in a single proof block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 4    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val y: Z = x + 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val z: Z = 10 - x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 4          )   by Premise,     //assignment of unchanged variable
</span></span><span style=display:flex><span>    2 (     y == x + 2      )   by Premise,     //assignment of unchanged variable
</span></span><span style=display:flex><span>    3 (     z == 10 - x     )   by Premise,     //assignment of unchanged variable
</span></span><span style=display:flex><span>    4 (     y == 4 + 2      )   by Subst_&lt;(1, 2),
</span></span><span style=display:flex><span>    5 (     z == 10 - 4     )   by Subst_&lt;(1, 3),
</span></span><span style=display:flex><span>    6 (     y == 6          )   by Algebra*(4),
</span></span><span style=display:flex><span>    7 (     z == 6          )   by Algebra*(5),
</span></span><span style=display:flex><span>    8 (     y == z          )   by Subst_&gt;(7, 6),
</span></span><span style=display:flex><span>    9 (     y == z ∧ y == 6 )   by AndI(8, 6)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now the assert will hold
</span></span><span style=display:flex><span>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Note that we did need to do <code>AndI</code> so that the last claim was <code>y == z ∧ y == 6 </code>, even though we had previously established the claims <code>y == z</code> and <code>y == 6</code>. In order for an assert to hold (at least until we switch Logika modes in chapter 10), we need to have established EXACTLY the claim in the assert in a previous proof block.</p><h2 id=assignments-with-mutation>Assignments with mutation</h2><p>Assignments with mutation are trickier &ndash; we need to know the old value of a variable in order to reason about its new value. For example, if we have the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert(x == 5)</span></span></code></pre></div><p>Then we might try to add the following proof blocks:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 4      )   by Premise  //from previous variable assignment
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == x + 1  )   by Premise, //NO! Need to distinguish between old x (right side) and new x (left side)
</span></span><span style=display:flex><span>    2 (     x == 4      )   by Premise, //NO! x has changed since this claim
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//this assert will not hold yet
</span></span><span style=display:flex><span>assert(x == 5)</span></span></code></pre></div><p>&mldr;but then we get stuck in the second proof block. There, <code>x</code> is supposed to refer to the CURRENT value of <code>x</code> (after being incremented), but both our attempted claims are untrue. The current value of <code>x</code> is not one more than itself (this makes no sense!), and we can tell from reading the code that <code>x</code> is now 5, not 4.</p><p>To help reason about changing variables, Logika has a special <code>Old(varName)</code> function that refers to the OLD value of a variable called <code>varName</code>, just before the latest update. In the example above, we can use <code>Old(x)</code> in the second proof block to refer to <code>x</code>&rsquo;s value just before it was incremented. We can now change our premises and finish the verification as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 4      )   by Premise  //from previous variable assignment
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = x + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == Old(x) + 1     )   by Premise, //Yes! x equals its old value plus 1
</span></span><span style=display:flex><span>    2 (     Old(x) == 4         )   by Premise, //Yes! The old value of x was 4
</span></span><span style=display:flex><span>    3 (     x == 4 + 1          )   by Subst_&lt;(2, 1),
</span></span><span style=display:flex><span>    4 (     x == 5              )   by Algebra*(3)  //Could have skipped line 3 and used &#34;Algebra*(1, 2)&#34; instead
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now the assert will hold
</span></span><span style=display:flex><span>assert(x == 5)</span></span></code></pre></div><p>By the end of the proof block following a variable mutation, we need to express everything we know about the variable&rsquo;s current value WITHOUT using the <code>Old</code> terminology, as its scope will end when the proof block ends. Moreover, we only ever have one <code>Old</code> value available in a proof block &ndash; the variable that was most recently changed. This means we will need proof blocks after each variable mutation to process the changes to any related facts.</p><h2 id=variable-swap-example>Variable swap example</h2><p>Suppose we have the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val temp: Z = x
</span></span><span style=display:flex><span>x = y
</span></span><span style=display:flex><span>y = temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//what do we want to assert we did?</span></span></code></pre></div><p>We can see that this program gets two user input values, <code>x</code> and <code>y</code>, and then swaps their values. So if <code>x</code> was originally 4 and <code>y</code> was originally 6, then at the end of the program <code>x</code> would be 6 and <code>y</code> would be 4.</p><p>We would like to be able to assert what we did &ndash; that <code>x</code> now has the original value from <code>y</code>, and that <code>y</code> now has the original value from <code>x</code>. To do this, we might invent dummy constants called <code>xOrig</code> and <code>yOrig</code> that represent the original values of those variables. Then we can add our assert:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the original values of both inputs
</span></span><span style=display:flex><span>val xOrig: Z = x
</span></span><span style=display:flex><span>val yOrig: Z = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val temp: Z = x
</span></span><span style=display:flex><span>x = y
</span></span><span style=display:flex><span>y = temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//x and y have swapped
</span></span><span style=display:flex><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style=display:flex><span>assert(x == yOrig ∧ y == xOrig)     //this assert will not yet hold</span></span></code></pre></div><p>We can complete the verification by adding proof blocks after assignment statements, being careful to update all we know (without using the <code>Old</code> value) by the end of each block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//the original values of both inputs
</span></span><span style=display:flex><span>val xOrig: Z = x
</span></span><span style=display:flex><span>val yOrig: Z = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     xOrig == x  )   by Premise,
</span></span><span style=display:flex><span>    2 (     yOrig == y  )   by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//swap x and y
</span></span><span style=display:flex><span>val temp: Z = x
</span></span><span style=display:flex><span>x = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == y              )   by Premise,     //from the assignment statement
</span></span><span style=display:flex><span>    2 (     temp == Old(x)      )   by Premise,     //temp equaled the OLD value of x
</span></span><span style=display:flex><span>    3 (     xOrig == Old(x)     )   by Premise,     //xOrig equaled the OLD value of x
</span></span><span style=display:flex><span>    4 (     yOrig == y          )   by Premise,     //yOrig still equals y
</span></span><span style=display:flex><span>    5 (     temp == xOrig       )   by Algebra*(2, 3),
</span></span><span style=display:flex><span>    6 (     x == yOrig          )   by Algebra*(1, 4)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>y = temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     y == temp           )   by Premise,     //from the assignment statement
</span></span><span style=display:flex><span>    2 (     temp == xOrig       )   by Premise,     //from the previous proof block (temp and xOrig are unchanged since)
</span></span><span style=display:flex><span>    3 (     yOrig == Old(y)     )   by Premise,     //yOrig equaled the OLD value of y
</span></span><span style=display:flex><span>    4 (     y == xOrig          )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>    5 (     x == yOrig          )   by Premise,     //from the previous proof block (x and yOrig are unchanged since)  
</span></span><span style=display:flex><span>    6 (     x == yOrig ∧ y == xOrig )   by AndI(5, 4)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//x and y have swapped
</span></span><span style=display:flex><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style=display:flex><span>assert(x == yOrig ∧ y == xOrig)     //this assert will hold now</span></span></code></pre></div><p>Notice that in each proof block, we express as much as we can about all variables/values in the program. In the first proof block, even though <code>xOrig</code> and <code>yOrig</code> were not used in the previous assignment statement, we still expressed how the current values our other variables compared to <code>xOrig</code> and <code>yOrig</code>. It helps to think about what you are trying to claim in the final assert &ndash; since our assert involved <code>xOrig</code> and <code>yOrig</code>, we needed to relate the current values of our variables to those values as we progressed through the program.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=integer-division-and-modulo>Integer Division and Modulo</h1><p>We will see in this section that verifying programs with division and modulo requires extra care.</p><h2 id=division>Division</h2><p>Recall that <code>Z</code> (int) is the only numeric type for Logika verification, so any division is integer division. This means something like <code>9/2</code> evaluates to 4, just as it would in Java or C#.</p><h3 id=check-for-division-by-zero>Check for division by zero</h3><p>Before doing division of the form <code>numerator/denominator</code>, either in a line of code or in a proof block, you must have have shown in a previous proof block that <code>denominator</code> is not 0. The easiest way to do this is to prove the claim: <code>denominator != 0</code>. You are even required to do this when dividing by a constant value that is obviously not zero.</p><p>For example, if we do:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 10 / 2</span></span></code></pre></div><p>Then Logika will give us an error complaining we have not proved that the denominator is not zero. We must add the claim <code>2 != 0</code> as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    2 != 0      )   by Algebra*()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 10 / 2</span></span></code></pre></div><p>Note that our justification is just, <code>Algebra*()</code>, as we don&rsquo;t need any extra information to claim that 2 is not equal to 0.</p><p>We could have instead claimed that 2 > 0 (again using <code>Algebra*()</code>), which would also prove that the denominator was not 0. However, claims such as <code>2 > 1</code> would not be accepted as proof that the denominator wasn&rsquo;t 0 (at least in Logika&rsquo;s manual mode).</p><h3 id=pitfalls>Pitfalls</h3><p>Be careful when making claims that involve division. For example, the following claim will not validate in Logika:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    x == (x/3)*3    )   by Algebra*()
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>While the claim <code>x == (x/3)*3</code> is certainly true in math, it is not true with integer division. For example, if <code>x</code> is 7, then <code>(x/3)*3</code> is 6 &ndash; so the two sides are not equal. In general, I recommend avoiding claims involving division if you can at all help it. Instead, try to find a way to express the same idea in a different way using multiplication.</p><h2 id=modulo>Modulo</h2><p>Modulo (%) works the same way in Scala (and Logika) as it does in other programming languages. For example, <code>20 % 6</code> evaluates to 2.</p><h3 id=modulo-checks-on-denominator>Modulo checks on denominator</h3><p>Before using the modulo operator in the form <code>numerator % denominator</code>, either in a line of code or as a claim in a proof block, you must have previously established one of the following:</p><ul><li><code>denominator != 0</code></li><li><code>denominator > 0</code></li></ul><p>This must be done even if the denominator is a literal value (like 2), and can be demonstrated in the same way as we did with division.</p><p>For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    7 != 0      )   by Algebra*()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = a % 7</span></span></code></pre></div><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.prompt(&#34;Enter positive number: &#34;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assume(num &gt; 0)
</span></span><span style=display:flex><span>val orig: Z = num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num * 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num + 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num/2 - 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num == orig)</span></span></code></pre></div><p>It can often be handy to walk through a program with sample numbers before trying to prove its correctness:</p><ul><li>Suppose our input value, <code>num</code>, is 11</li><li><code>orig</code> is initialized to be 11 also</li><li><code>num</code> is multiplied by 2, and is 22</li><li>It makes sense that <code>num</code> would be even, since any number times two is always even (and indeed, 22 is even)</li><li>We add 2 to <code>num</code>, so it is now 24</li><li>It makes sense that <code>num</code> would still be even, as it was even before and we added 2 (another even number) to it. Indeed, 24 is still even.</li><li>We update <code>num</code> by dividing it by 2 and subtracting 1, so <code>num</code> is now back to its original value of 11 (the same as <code>orig</code>). This step &ldquo;undoes&rdquo; the changes we have made to <code>num</code> &ndash; looking at the code, we can see that the final value of <code>num</code> is <code>orig*2 + 2</code>, so if we do <code>(orig*2 + 2) / 2 - 1</code>, we are left with <code>orig</code>.</li></ul><p>Here is the completed verification, with comments at each step:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.prompt(&#34;Enter positive number: &#34;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assume(num &gt; 0)
</span></span><span style=display:flex><span>val orig: Z = num
</span></span><span style=display:flex><span>num = num * 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    num == Old(num) * 2     )   by Premise,         //we updated num to be its old value times 2
</span></span><span style=display:flex><span>    2  (    orig == Old(num)        )   by Premise,         //orig equaled the old value of num (before our change)
</span></span><span style=display:flex><span>    3  (    num == orig * 2         )   by Algebra*(1, 2),  //express the new value of num without referring to &#34;Old&#34;
</span></span><span style=display:flex><span>    4  (    2 != 0                  )   by Algebra*(),      //needed to use modulo in the assert
</span></span><span style=display:flex><span>    5  (    num % 2 == 0            )   by Algebra*(1)      //we have showed num is now even (needed for next assert)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num + 2 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    num == Old(num) + 2     )   by Premise,         //we updated num to be its old value plus 2
</span></span><span style=display:flex><span>    2  (    Old(num) % 2 == 0       )   by Premise,         //from line 5 in previous block, but num has since changed
</span></span><span style=display:flex><span>    3  (    num % 2 == 0            )   by Algebra*(1, 2),  //we have showed num is still even (needed for next assert)
</span></span><span style=display:flex><span>    4  (    Old(num) == orig * 2    )   by Premise,         //from line 3 in block above, but num has since changed
</span></span><span style=display:flex><span>    5  (    num - 2 == orig * 2     )   by Algebra*(1, 4)   //express new value of num without using &#34;Old&#34;
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num % 2 == 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//we have already established that 2!= 0, which is needed to divide by 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>num = num/2 - 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (    num == Old(num) / 2 - 1         )   by Premise,         //we updated num to be its old value divided by 2 minus 1
</span></span><span style=display:flex><span>    2  (    Old(num) - 2 == orig * 2        )   by Premise,         //from line 7 in previous block, but num has since changed
</span></span><span style=display:flex><span>    3  (    Old(num) == orig * 2 + 2        )   by Algebra*(2),
</span></span><span style=display:flex><span>    4  (    num == (orig * 2 + 2) / 2 - 1   )   by Algebra*(1, 3),  //express new value of num without using &#34;Old&#34;
</span></span><span style=display:flex><span>    5  (    num == orig + 1 - 1             )   by Algebra*(4),
</span></span><span style=display:flex><span>    6  (    num == orig                     )   by Algebra*(5)      //we have showed num is back to being orig (needed for last assert)
</span></span><span style=display:flex><span>                                                                    //could have skipped straight here with &#34;Algebra*(1,2)&#34;
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num == orig)</span></span></code></pre></div><p>Sometimes it can be tricky to figure out what to do at each step in order to get assert statements to pass. If you are unsure what to do, I recommend:</p><ul><li><p>Walk through the program several times with sample numbers, keeping track of changes to variables. Why do the assert statements make sense to you? Convince yourself that they are valid claims before you worry about the formal verification.</p></li><li><p>Add a proof block after each variable mutation. Work from the top down:</p><ul><li>Write a premise for every variable assignment and assume statement since the previous proof block.</li><li>Find all claims in the proof block just before you that do not use an &ldquo;Old&rdquo; reference &ndash; pull each claim into your current block, using an &ldquo;Old&rdquo; reference as needed for the most recently changed variable.</li><li>Manipulate your claims that use an &ldquo;Old&rdquo; reference until you have statements that capture the current value of the recently changed variable that do not reference &ldquo;Old&rdquo;</li><li>If your next statement is an assert, manipulate your claims until you have exactly the claim in the assert.</li><li>If any claims</li></ul></li><li><p>Add a proof block before each use of division (<code>numerator / denominator</code>) and modulus (<code>numerator % denominator</code>). Pull in claims from previous blocks as described above to help you show the claim <code>denominator != 0</code>. If you can, avoid using division in proof block claims.</p></li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=conditional-statements>Conditional Statements</h1><p>To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. We will only consider programs with an if/else as opposed to an if/else if. However, you can simulate more than two branches by nesting another if/else inside the outer else.</p><h2 id=motivation>Motivation</h2><p>Before we formalize the details of verifying a program with a conditional statement, let&rsquo;s motivate the topic with an example.</p><h3 id=max-program>Max program</h3><p>Suppose we have a program that finds finds the maximum (<code>max</code>) between two user input numbers (<code>x</code> and <code>y</code>):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var max: Z = 0  //give max a dummy starting value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (x &gt; y) {
</span></span><span style=display:flex><span>    max = x
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    max = y
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=max-assert>Max assert</h3><p>Before worrying about how to do the verification, let&rsquo;s consider what we should assert at the end in order to be sure that <code>max</code> really does hold the biggest of the two inputs. Clearly, <code>max</code> should be greater than or equal to both inputs. So should our assert be:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//Not quite all we want to say
</span></span><span style=display:flex><span>assert(max &gt;= x ∧ max &gt;= y)</span></span></code></pre></div><p>Suppose <code>x</code> was 10, <code>y</code> was 15&mldr;and that <code>max</code> was 20. (Clearly this isn&rsquo;t what our code would do, but you can imagine writing something else for the max code that came up with such a calculation). In this case, <code>max</code> is indeed greater than or equal to both inputs&mldr;but it is just as clearly not the max. We know see that we also need to claim that <code>max</code> equals one of the two inputs. This makes our assert:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//Now we are sure we are describing the max between x and y
</span></span><span style=display:flex><span>assert(max &gt;= x ∧ max &gt;= y ∧ (max == x ∨ max == y))</span></span></code></pre></div><h3 id=analyzing-max>Analyzing max</h3><p>Now, we need to prove that our assert holds no matter which branch we follow in the conditional statement. First, when we analyze the code in the if-branch, we have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     max == x    )   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>and when we analyze the code in the else-branch, we have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>max = y
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     max == y    )   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>These two deductions imply that, when the if/else statements finishes, one or the other property holds true:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (x &gt; y) {
</span></span><span style=display:flex><span>    max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == x    )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    max = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == y    )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style=display:flex><span>    1 (     max == x  v  max == y   )   by Premise 
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>This illustrates the first principle of conditional commands: the knowledge produced by the command is the disjunction (or) of the knowledge produced by each branch. In the section on propositional logic, we covered how to apply cases analyses on disjunctive assertions to extract useful knowledge.</p><p>Recall that the intent of the if/else statement was to set <code>max</code> so that it holds the larger of <code>x</code> and <code>y</code>, so that our assert would hold:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(max &gt;= x ∧ max &gt;= y ∧ (max == x v max == y))</span></span></code></pre></div><p>The claim we proved so far satisifies the second part of our assert statement, but not the first part. This is because we ignored a critical feature of an if/else statement: By asking a question — the condition — the if/else statement generates new knowledge.</p><p>For the if-branch, we have the new knowledge that <code>x > y</code>; for the else-branch, we have that <code>¬(x > y)</code>, that is, <code>y >= x</code>. We can embed these assertions into the analysis of the conditional command, like this, and conclude that, in both cases, <code>max</code> is greater than or equal to both inputs:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = Z.read()
</span></span><span style=display:flex><span>var y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var max: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (x &gt; y) {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     x &gt; y       )   by Premise      //the condition is true
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == x    )   by Premise,    //from the &#34;max = x&#34; assignment
</span></span><span style=display:flex><span>        2 (     max &gt;= x    )   by Algebra*(1),
</span></span><span style=display:flex><span>        3 (     x &gt; y       )   by Premise,    //condition is still true (x and y are unchanged)
</span></span><span style=display:flex><span>        4 (     max &gt;= y    )   by Algebra*(1,3)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     ¬(x &gt; y)    )   by Premise,    //the condition is NOT true
</span></span><span style=display:flex><span>        2 (     x &lt;= y      )   by Algebra*(1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    max = y
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     max == y    )   by Premise,    //from the &#34;max = y&#34; assignment
</span></span><span style=display:flex><span>        2 (     x &lt;= y      )   by Premise,    //pulled down from previous proof block (x and y are unchanged)
</span></span><span style=display:flex><span>        3 (     max &gt;= x    )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>        4 (     max &gt;= y    )   by Algebra*(1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//summary of what just happened
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style=display:flex><span>    1 (     max == x ∨ max == y )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 (     max &gt;= x            )   by Premise,     //true in BOTH branches
</span></span><span style=display:flex><span>    3 (     max &gt;= y            )   by Premise,     //true in BOTH branches
</span></span><span style=display:flex><span>    4 (     max &gt;= x ∧ max &gt;= y )   by AndI(2, 3),
</span></span><span style=display:flex><span>    5 (     max &gt;= x ∧ max &gt;= y) ∧ (max == x ∨ max == y )   by AndI(4, 1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(max &gt;= x ∧ max &gt;= y ∧ (max == x v max == y))</span></span></code></pre></div><h2 id=rules-for-analyzing-programs-with-conditionals>Rules for analyzing programs with conditionals</h2><p>In this section, we will summarize how to analyze programs with conditional statements.</p><h3 id=declaring-condition-and-condition-as-premises>Declaring condition and ¬(condition) as premises</h3><p>If we have a program such as this with an if/else statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Then we can claim <code>C</code> as a premise immediately inside the if-branch and <code>¬(C)</code> as a premise immediately inside the else branch:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     C       )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     ¬(C)    )   by Premise
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Be careful with the <code>else</code> case &ndash; you must claim exactly <code>¬(C)</code>, and not some claim you know to be equivalent. In our max example, <code>C</code> was <code>x &lt; y</code>, and we needed to claim exactly <code>¬(x &lt; y)</code> in the else &ndash; NOT <code>x >= y</code>. After you have pulled in the initial claim using the form <code>¬(C)</code>, you can use <code>Algebra*</code> to manipulate it into a different form.</p><h3 id=each-branch-reaches-a-different-conclusion>Each branch reaches a different conclusion</h3><p>If the if-branch reaches conclusion <code>Q1</code> and the else branch reaches conclusion <code>Q2</code>, then afterwards we can list as a premise that one of those conclusions is true (since we know that one of the branches in an if/else will ALWAYS execute):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Q1      )   by SomeJustification    //conclusion in if-branch
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Q2      )   by SomeJustification   //conclusion in else-branch
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     Q1 ∨ Q2     )   by Premise     //Q1 from if, Q2 from else
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that order matters, and that we must claim <code>(if conclusion) ∨ (else conclusion)</code> &ndash; in the example above, we could not claim <code>Q2 ∨ Q1</code> afterwards.</p><h3 id=each-branch-reaches-the-same-conclusion>Each branch reaches the same conclusion</h3><p>If the if-branch and the else-branch both reach the SAME conclusion <code>Q</code>, then afterwards we can list <code>Q</code> as a premise. Here, we know that one of the branches in an if/else will ALWAYS execute &ndash; so if we get to the same conclusion in both cases, then we must always reach that conclusion:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        1 (     Q       )   by SomeJustification    //common conclusion reached in IF
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     Q       )    by SomeJustification   //common conclusion reached in ELSE
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     Q           )   by Premise     //Q was true in both the IF and the ELSE
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h2 id=example-programs-with-no-else>Example: programs with no &ldquo;else&rdquo;</h2><p>Some programs have just an if statement with no else. For example, consider this program to find the absolute value of a number:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.read()
</span></span><span style=display:flex><span>var orig: Z = num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (num &lt; 0) {
</span></span><span style=display:flex><span>    num = num * -1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//num is now the absolute value of the original input
</span></span><span style=display:flex><span>//(num is nonnegative and either equals `orig` [the original input] or -1*orig)
</span></span><span style=display:flex><span>assert(num &gt;= 0 ∧ (num == -1*orig ∨ num == orig))</span></span></code></pre></div><p>Even though an &ldquo;else&rdquo; is unnecessary in the implementation, we want an else statement in order to ensure our program works in the case that num is NOT less than 0. Our solution is to add an else statement that is solely to hold a proof block for that branch.</p><p>We add an else statement and complete our verification as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = Z.read()
</span></span><span style=display:flex><span>var orig: Z = num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     orig == num     )   by Premise,     //from &#34;orig = num&#34; assignment
</span></span><span style=display:flex><span>    2 (     num == orig     )   by Algebra*(1)  //switch order to match assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (num &lt; 0) {
</span></span><span style=display:flex><span>    num = num * -1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1  (    Old(num) &lt; 0            )   by Premise,         //if condition (num just changed)
</span></span><span style=display:flex><span>        2  (    num == Old(num) * -1    )   by Premise,         //from &#34;num = num * -1&#34; assignment
</span></span><span style=display:flex><span>        3  (    orig == Old(num)        )   by Premise,         //orig did equal num (num just changed)
</span></span><span style=display:flex><span>        4  (    num &gt;= 0                )   by Algebra*(1, 2),  //a negative number times -1 is nonnegative
</span></span><span style=display:flex><span>        5  (    num == -1 * orig        )   by Algebra*(2, 3)   //needed for last part of assert
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //no code - just the proof block
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     ¬(num &lt; 0)              )   by Premise,         //negation of condition
</span></span><span style=display:flex><span>        2 (     num == orig             )   by Premise,         //num is unchanged
</span></span><span style=display:flex><span>        3 (     num &gt;= 0                )   by Algebra*(1)      //needed for assert
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     num &gt;= 0                        )   by Premise, //true in both branches
</span></span><span style=display:flex><span>    2 (     num == -1*orig ∨ num == orig    )   by Premise  //LHS in if, RHS in else
</span></span><span style=display:flex><span>    3 (     num &gt;= 0 ∧ (num == -1*orig ∨ num == orig)   )   by AndI(1, 2)   //match assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//num is now the absolute value of the original input
</span></span><span style=display:flex><span>//(num is nonnegative and either equals `orig` [the original input] or -1*orig)
</span></span><span style=display:flex><span>assert(num &gt;= 0 ∧ (num == -1*orig ∨ num == orig))</span></span></code></pre></div><h2 id=nested-conditionals>Nested conditionals</h2><p>We employ the same rules when analyzing programs with nested conditional statements. If we reach a common conclusion in both the if and else branches of an inner if/else statement, for example, then we can claim the common conclusion as a premise after that inner if/else statement (but still inside the outer if/else). The outline below summarizes what we can claim at various places in nested if/else statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>if (C1) {
</span></span><span style=display:flex><span>    if (C2) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( C1  )   by Premise,     //outer if condition is true
</span></span><span style=display:flex><span>            2 ( C2  )   by Premise      //inner if condition is true
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q1      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    else {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( C1      )   by Premise,     //outer if condition is true
</span></span><span style=display:flex><span>            2 ( ¬(C2)   )   by Premise      //inner if condition is false
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q2      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( common  )   by Premise,    //common conclusion in inner if/else
</span></span><span style=display:flex><span>        2 ( Q1 ∨ Q2 )   by Premise     //Q1 from inner if, Q2 from inner else
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>} else {
</span></span><span style=display:flex><span>    if (C3) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( ¬(C1)   )   by Premise,     //outer if condition is false
</span></span><span style=display:flex><span>            2 ( C3      )   by Premise      //inner if condition is true
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q3      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    else {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( ¬(C1)   )   by Premise,     //outer if condition is false
</span></span><span style=display:flex><span>            2 ( ¬(C3)   )   by Premise      //inner if condition is false
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 ( common  )   by SomeJustification,
</span></span><span style=display:flex><span>            2 ( Q4      )   by SomeJustification
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( common  )   by Premise,    //common conclusion in inner if/else
</span></span><span style=display:flex><span>        2 ( Q3 ∨ Q4 )   by Premise     //Q1 from inner if, Q2 from inner else
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( common                  )   by Premise,     //&#34;common&#34; was true in both the outer IF and the outer ELSE 
</span></span><span style=display:flex><span>    2 ( (Q1 ∨ Q2) ∨ (Q3 ∨ Q4)   )   by Premise      //(Q1 ∨ Q2) from outer if, (Q3 ∨ Q4) from else
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article></section></div></main></div><script src=/cis301/js/clipboard/clipboard.min.js?1765567784 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1765567784 defer></script><script src=/cis301/js/theme.min.js?1765567784 defer></script><script src=/cis301/js/embed-iframe.min.js?1765567784 defer></script></body></html>