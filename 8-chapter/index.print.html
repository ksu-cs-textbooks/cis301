




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Intro to Programming Logic :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/index.html" rel="canonical" type="text/html" title="Intro to Programming Logic :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/index.xml" rel="alternate" type="application/rss+xml" title="Intro to Programming Logic :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/tele.html" rel="alternate" type="text/html" title="Intro to Programming Logic :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/embed.html" rel="alternate" type="text/html" title="Intro to Programming Logic :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1700155505" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1700155505" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1700155505" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1700155505" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1700155505" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1700155505" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1700155505" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1700155505" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1700155505" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1700155505" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1700155505" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1700155505" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/format-print.css?1700155505" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1700155505" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1700155505"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1700155505"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1700155505" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/8-chapter/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/index.html"><span itemprop="name">CIS 301 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Intro to Programming Logic</span><meta itemprop="position" content="2"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 8</div>
<h1 id="intro-to-programming-logic">Intro to Programming Logic</h1>

<h6 id="intro-to-programming-logic-assignments-and-conditionals">Intro to Programming Logic: Assignments and Conditionals</h6>
<p>For the rest of the course, we will switch gears back to something more familiar for most &ndash; computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.</p>

            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Intro to Programming Logic</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="programming-logic-goal">Programming Logic Goal</h1>

<p>In the next three chapters, we will learn how to reason about different kinds of program structures &ndash; assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs using a toy language that is a subset of Scala. While our toy language is not used in practice, the ideas that we will see to prove program correctness &ndash; preconditions, postconditions, loop invariants, and global invariants &ndash; can be used to specify functions in ANY language.</p>
<p>We will see that the process for formal specifications and proofs of correctness is rather tedious, even for relatively simple programs. And in practice, proving correctness of computer programs is rarely done. So why bother studying it?</p>
<h2 id="safety-critical-code">Safety critical code</h2>
<p>One case where reasoning about correctness is certainly relevant is the arena of <em>safety critical code</em> &ndash; where lives depend on a program working correctly. Certain medical devices, such as pacemakers and continuous glucose monitors, have a software component. If that software fails, then a person could die. We can&rsquo;t test the correctness of medical devices by installing them in a human body and trying them out &ndash; instead, we need to be absolutely sure they work correctly before they are used.</p>
<p>Similarly, there is software in things like shuttle launches. While that might not cost lives, it&rsquo;s also a process that can&rsquo;t be fully tested beforehand. After all, no one is going to spend over a billion dollar on a &ldquo;practice&rdquo; launch. Instead, we need a way to more formally demonstrate that the software will work correctly.</p>
<h2 id="specifications">Specifications</h2>
<p>In chapter 9, we will learn to write function <em>specifications</em>. These specifications list any requirements the function has in order to work correctly (<em>preconditions</em>) and descibe the impact of calling the function (<em>postconditions</em>) - most notably, what the function returns in terms of its inputs. Even in cases where we do not formally prove correctness of a program, it is very useful to write a specification for all functions. This can make it clear to any calling code what kinds of parameters should be passed, as well as what to expect about the returned value. By providing this structure, there will be fewer surprises and unintended errors.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="logika-programs">Logika Programs</h1>

<p>As we study program logic, we will use a toy language within Logika. These Logika programs use a subset of the Scala language, and include the following features:</p>
<ul>
<li>Variables (booleans, ints, and sequences [which are like arrays/lists])</li>
<li>Printing and user input</li>
<li>Math operations</li>
<li>Conditional operations</li>
<li>If and if/else statements</li>
<li>While loops</li>
<li>Functions</li>
</ul>
<h2 id="running-logika-programs">Running Logika programs</h2>
<p>Logika programs should be saved with a .logika extension. To run a Logika program, right-click in the text area that contains the code and select &ldquo;Run Logika Program&rdquo;.</p>
<h2 id="verifying-logika-programs">Verifying Logika programs</h2>
<p>There are two modes in Logika &ndash; manual and SymExe. In chapters 8 and 9, we will use manual mode. In chapter 10, we will use SymExe mode. You can change the mode in Logika by going to File-&gt;Settings-&gt;Tools-&gt;Sireum-&gt;Logika.</p>
<p>For manual mode, uncheck &ldquo;Auto mode&rdquo; and mark the Checker kind as &ldquo;Forward.&rdquo;</p>
<p>For SymExe mode, check &ldquo;Auto mode&rdquo; and mark the Checker kind as &ldquo;Summarizing SymExe&rdquo;.</p>
<p>Logika verification <em>should</em> run automatically as you edit Logika programs and their proofs. If a program is verified, you will see a purple checkmark in the lower right corner just as you did in propositional and predicate logic proofs. If there are syntax or logic errors, you will see them highlighted in red.</p>
<p>Sometimes, the Logika verification needs to be run manually. If you don&rsquo;t see either red errors or a purple checkmark, right-click in the text area that contains the code and select &ldquo;Logika Check&rdquo;.</p>
<h2 id="example-programs">Example programs</h2>
<p>This section contains four sample Logika programs that highlight the different language features.</p>
<h3 id="example-1-user-input-printing-operations">Example 1: User input, printing, operations</h3>
<p>This first example gets a number as input from the user, adds one to it, and prints the result:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt(&#34;Enter a number: &#34;)
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>println(&#34;One more is &#34;, x)</span></span></code></pre></div><p>A few things to note:</p>
<ul>
<li>Each Logika program begins with an import statement: <code>import org.sireum.logika._</code></li>
<li>The <code>var</code> keyword stands for variable, which is something that can be changed. Logika also has a <code>val</code> keyword, which creates a constant value that cannot be changed.</li>
<li>Lines do not end in semi-colons</li>
<li>The parameter to the <code>readInt(...)</code> function call is a prompt telling the user what to type. This parameter is optional.</li>
<li>The code <code>var x: Z</code> creates a variable called <code>x</code> of type <code>Z</code> &ndash; the <code>Z</code> means <em>integer</em></li>
</ul>
<h3 id="example-2-ifelse-statements">Example 2: If/else statements</h3>
<p>Here is a Logika program that gets a number from the user, and uses an if/else statement to print whether the number is positive or negative/zero:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = readInt(&#34;Enter a number: &#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &gt; 0) {
</span></span><span style="display:flex;"><span>    println(num, &#34; is positive&#34;)
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    println(num, &#34; is negative (or zero)&#34;)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>A couple of things to note here:</p>
<ul>
<li>The <code>else</code> statement MUST appear on the same line as the closing <code>}</code> of the previous if-statement</li>
<li>As mentioned above, the <code>val</code> keyword in this program means that <code>x</code> cannot be changed after being initialized</li>
</ul>
<h3 id="example-3-while-loops">Example 3: While loops</h3>
<p>Our next Logika program uses a while loop to print the numbers from 10 down to 1. This program can&rsquo;t be run the way it appears below, as Logika wants you to do some verification work first. However, this program demonstrates what a while loop will look like:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var cur: Z = 10
</span></span><span style="display:flex;"><span>while (cur &gt;= 1) {
</span></span><span style="display:flex;"><span>    println(&#34;Next number: &#34;, cur)
</span></span><span style="display:flex;"><span>    cur = cur - 1
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="example-4-sequences-and-functions">Example 4: Sequences and functions</h3>
<p>Our final sample Logika program demonstrates <em>sequences</em> (Logika&rsquo;s version of an array or list) and functions. It contains a function, <code>sumSequence</code>, which takes a sequence of integers as a parameter and returns the sum of the numbers in the sequence. At the bottom, we can see our test code that creates a sample sequence and tries calling <code>sumSequence</code>. As in our third example, this code cannot be run without some verification work:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def sumSequence(seq: ZS) : Z = {
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var i: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i &lt; seq.size) {
</span></span><span style="display:flex;"><span>        sum = sum + seq(i)
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////// Calling code ////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val list: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>val total: Z = sumSequence(list)
</span></span><span style="display:flex;"><span>println(&#34;Sum of elements:&#34;, total)</span></span></code></pre></div><p>A few things of note here:</p>
<ul>
<li>
<p>The definition <code>def sumSequence(seq: ZS) : Z</code> means that a function named <code>sumSequence</code> takes a parameter of type <code>ZS</code> (sequence of integers, <code>Z</code> = int and <code>S</code> = sequence) and returns something of type <code>Z</code> (int)</p>
</li>
<li>
<p>There is an <code>=</code> after the function header but before the opening <code>{</code> of the function</p>
</li>
<li>
<p>Functions in Logika are not part of a class - they are more similar to the structure in Python. We can include as many functions as we want in a file. At the bottom of the file (marked below the optional <code>////// Calling code ////////////</code>) is the <em>calling code</em>. When a Logika program runs, those calling code lines (which may call different functions) are executed. When the calling code lines are done, the program is done.</p>
</li>
</ul>
<h2 id="logika-program-proof-syntax">Logika program proof syntax</h2>
<p>In order to prove correctness of Logika programs, we will add <em>Logika proof blocks</em> to process what we have learned at different points in the program. In general, every time there is an assignment statement, there will be a following Logika proof block updating all relevant facts.</p>
<h3 id="proof-block">Proof block</h3>
<p>Here is the syntax for a proof block:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    lineNumber. claim               justification
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Just as with our propositional and predicate logic proofs, we will number the lines in our proof blocks. Each line will contain a <em>claim</em> and a corresponding <em>justification</em> for that claim. We will still be able to use all of our propositional and predicate logic deduction rules, but we will learn new justifications for processing program statements. Each program may have multiple of these proof blocks to process each assignment statement.</p>
<h3 id="premise-justification">Premise justification</h3>
<p>Our first justification in programming logic is <em>premise</em>. In a Logika proof block, we use premise as a justification in the following cases:</p>
<ul>
<li>
<p>To express an assignment statement (or other program statement)</p>
</li>
<li>
<p>To pull a claim established in a previous proof block into a later proof block</p>
</li>
</ul>
<p>In both cases, the claim must capture the current value of the involved variables.</p>
<p>For example, consider the following program:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>x = x + 1</span></span></code></pre></div><p>We could insert a proof block between the two lines to express that <code>x</code> currently has the value 6:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1</span></span></code></pre></div><p>But we could NOT have the same proof block after incrementing <code>x</code>, since <code>x</code>&rsquo;s value has changed since that claim was established:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this proof block is correct -- it captures the current value of x
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//NO! This statement no longer captures the current value of x
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><h3 id="using-previous-deduction-rules">Using previous deduction rules</h3>
<p>We can use any of our previous deduction rules in a Logika proof block. For example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>val y: Z = 7
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>    2. y == 7               premise
</span></span><span style="display:flex;"><span>    3. (x == 6) ∧ (y == 7)  ∧i 1 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div>
            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="assert-and-assume">Assert and Assume</h1>

<h2 id="assert-statements">Assert statements</h2>
<p>An <em>assert</em> statement in Logika uses the syntax <code>assert(expression)</code>, where <code>expression</code> is of type <code>bool</code>. The assert passes if the expression is true, and throws an error if the expression is false.</p>
<p>Logika assert statements are different than assert statements in languages like Java and C# &ndash; in those languages, the code in the assert statement (which often includes test method calls) is actually run, and the assert statement checks whether those methods are returning the expected values. In Logika, assert statements only pass if we have previously PROVED what we are claiming &ndash; the code is never executed.</p>
<h3 id="example">Example</h3>
<p>Consider the following program:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>val y: Z = 6
</span></span><span style="display:flex;"><span>val z: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert (x == y &amp; y &gt; z)</span></span></code></pre></div><p>While we can tell that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>, this code would fail in Logika (at least in its manual mode, which is what we are using now). In order for an assert to pass, we must have already proved EXACTLY the statement in the assert.</p>
<p>Why do WE know that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>? From looking at the code! We can tell that <code>x</code> and <code>y</code> are given the same value (6), and that <code>y</code>&rsquo;s value of 6 is bigger than <code>z</code>&rsquo;s value of 4.</p>
<p>So far, we know we can pull in the values of each variable as premises, like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>val y: Z = 6
</span></span><span style="display:flex;"><span>val z: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6           premise
</span></span><span style="display:flex;"><span>    2. y == 6           premise
</span></span><span style="display:flex;"><span>    3. z == 4           premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //how to say that x and y are equal, and that y is bigger than z?
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert (x == y &amp; y &gt; z)</span></span></code></pre></div><p>But we don&rsquo;t yet know how to justify claims that describe how variables compare to one another. We will learn how to do that with the <code>algebra</code> and <code>subst</code> rules in section 8.4.</p>
<h3 id="using-conditional-operators">Using conditional operators</h3>
<p>Notice that the program above used an <code>&amp;</code> symbol for an AND operator in an assert statement. Because asserts are part of the program and not part of a proof block, they will use the same conditional operators as in Logika programs. Here is a summary:</p>
<table>
<thead>
<tr>
<th>Meaning</th>
<th>Operator in proofs</th>
<th>Operator in Logika programs/assumes/asserts</th>
</tr>
</thead>
<tbody>
<tr>
<td>p AND q</td>
<td><code>p ∧ q</code></td>
<td><code>p &amp; q</code></td>
</tr>
<tr>
<td>p OR q</td>
<td><code>p ∨ q</code></td>
<td><code>p | q</code></td>
</tr>
<tr>
<td>NOT p</td>
<td><code>¬p</code></td>
<td><code>!p</code></td>
</tr>
<tr>
<td>p IMPLIES q</td>
<td><code>p → q</code></td>
<td>not available</td>
</tr>
</tbody>
</table>
<p>If we wanted to write an assert statement that would be true when some variable <code>p</code> was even and/or was a positive two-digit number, we could say:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(p % 2 == 0 | (p &gt; 9 &amp; p &lt; 100))</span></span></code></pre></div><p>The implies operator is not available in assert statements. However, we can make use of one of the equivalences we learned about in section 3.4: that <code>p → q</code> is equivalent to <code>¬ p ∨ q</code>. So if we wanted to assert that if <code>p</code> was positive, then <code>q</code> was equal to <code>p</code>, then we could write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//expressing the implicaton ((p &gt; 0) → (q == p))
</span></span><span style="display:flex;"><span>assert(!(p &gt; 0) | (q == p))</span></span></code></pre></div><p>Or, equivalently, we could write:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert((p &lt;= 0) | (q == p))</span></span></code></pre></div><h2 id="assume-statement">Assume statement</h2>
<p>An <em>assume</em> statement in Logika uses the syntax <code>assume(expression)</code>. If the expression is satisfiable, then we can use <code>expression</code> as a premise in the following Logika proof block.</p>
<h3 id="assume-example">Assume example</h3>
<p>For example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var a: Z = readInt()
</span></span><span style="display:flex;"><span>assume (a &gt; 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. a &gt; 0            premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Assume statements are almost always used to make assumptions about user input. Perhaps our program only works correctly for certain values of input. If we can assume that the user really did enter acceptable values, then we can use that information (by pulling it in as a premise in the next logic block) to prove the correctness of the program based on that assumption.</p>
<h3 id="assumes-vs-wrapping-if-statements">Assumes vs. wrapping if-statements</h3>
<p>Toy programs often use assume in lieu of wrapping code in an if statement. The following two examples are equivalent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var a : Z = readInt()
</span></span><span style="display:flex;"><span>assume (a != 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. a != 0  premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var b: Z = 20 / a</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//...is equivalent to:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var a : Z = readInt()
</span></span><span style="display:flex;"><span>var b : Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (a != 0) {
</span></span><span style="display:flex;"><span>    b = 20 / a
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>These examples also demonstrate a requirement when we use the division operator in Logika programs, we must first demonstrate that we are not dividing by zero.</p>
<h3 id="unsatisfiable-assume">Unsatisfiable assume</h3>
<p>You will see an error in Logika if your assume statement is not satisfiable. For example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var a: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assume(a &gt; 0)
</span></span><span style="display:flex;"><span>assume (a == 0)</span></span></code></pre></div><p>If you try verifying this program, you will get a Logika error on the second <code>assume</code> statement. This is because we already assumed that <code>a</code> was greater than 0, and it is not possible for <code>a</code> to also be equal to 0.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="algebra-and-subst-rules">Algebra and subst Rules</h1>

<p>In this section, we will learn our first two proof rules for programming logic &ndash; <code>algebra</code> and <code>subst</code>.</p>
<h2 id="verifying-simple-programs">Verifying simple programs</h2>
<p>Before we delve into our new proof rules, let&rsquo;s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the <code>// --&gt;</code> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>get user input / set initial variable values
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add assume statements to specify what must be true about the input
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program statement
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add logic block to evaluate what has happened in the program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program statement
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add logic block to evaluate what has happened in the program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program statement
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add logic block to evaluate what has happened in the program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(...more program statements)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add assert statements to express what our program did</span></span></code></pre></div><p>We see that if our program involves user input, then we must consider whether our program will only work correctly for certain input values. In that situation, we express our assumptions using <code>assume</code> statements.</p>
<p>After each program statement, we must add a logic block to evaluate what changed on that line of code. We will see more details on these logic blocks throughout the rest of this chapter. Recall that the syntax for those logic blocks looks like:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    lineNumber. claim               justification
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // ... (more claims/justifications)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Finally, we add one or more <code>assert</code> statements to express what our program did. These are usually placed at the end of a program, but sometimes we have assert statements throughout the program to describe the progress up to that point.</p>
<h2 id="algebra-justification">Algebra justification</h2>
<p>The <code>algebra</code> justification can be used for ANY algebraic manipulation on previous claims. When using this justification, include all relevant proof line numbers in whatever order (you might use as few as zero line numbers or as many as 3+ line numbers).</p>
<h3 id="example">Example</h3>
<p>Consider this example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 6
</span></span><span style="display:flex;"><span>var y: Z = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert (y == 6)</span></span></code></pre></div><p>Following our process from above, we add logic blocks after each program statement. In these logic blocks, we start by listing the previous program statement as a premise:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var y: Z = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == x               premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //need claim &#34;y == 6&#34; for our assert to hold
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert (y == 6)</span></span></code></pre></div><p>For our assert to hold, we must have EXACTLY that claim in a previous logic block &ndash; so we know we want our second logic block to include the claim <code>y == 6</code>.</p>
<p>Here is the program with the second logic block completed &ndash; the assert statement will now hold.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var y: Z = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == x               premise
</span></span><span style="display:flex;"><span>    2. x == 6               premise     //established in a previous logic block, and x is unchanged since then
</span></span><span style="display:flex;"><span>    3. y == 6               algebra 1 2 //we know y is 6 using the claims from lines 1 and 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will hold
</span></span><span style="display:flex;"><span>assert (y == 6)</span></span></code></pre></div><p>We could have also deleted the first logic block in this example. We would still be able to claim <code>x == 6</code> as a premise in the last logic block, as <code>x</code> had not changed since being given that value.</p>
<h2 id="subst">subst</h2>
<p>We have two deduction rules that involve substitution &ndash; <code>subst1</code> and <code>subst2</code>. Both of these rules are similar to the find/replace feature in text editors. They preserve truth by replacing one proposition with an equivalent one.</p>
<p>The <code>algebra</code> justification will work for most mathematical manipulation. However, it will not work for any claim involving <code>∧</code>, <code>∨</code>, <code>→</code>, <code>⊥</code>, <code>∀</code>, <code>∃</code> &ndash; in those cases, we will be required to use substitution instead.</p>
<h3 id="subst1-justification">subst1 justification</h3>
<p>Here is the syntax for the <code>subst1</code> rule. In the example below, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    m. LHS_M == RHS_M       (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    n. LINE_N               (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    p. (claim)              subst1 m n
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p><code>(claim1)</code> rewrites <code>LINE_N</code> by substituting all ocurrences of <code>LHS_M</code> (the FIRST side of line <code>m</code>) with <code>RHS_M</code>. Here is an example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x + 1 == y - 4                       (some justification)
</span></span><span style="display:flex;"><span>    2. x*(x + 1) == (x + 1) + y             (some justification)
</span></span><span style="display:flex;"><span>    3. x*(y - 4) == (y - 4) + y             subst1 1 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>We wrote line 2 by replacing each occurence of <code>x + 1</code> with <code>y - 4</code>.</p>
<h3 id="subst2-justification">subst2 justification</h3>
<p>Here is the syntax for the <code>subst2</code> rule. Just as with <code>subst1</code>, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    m. LHS_M == RHS_M       (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    n. LINE_N               (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    p. (claim)              subst2 m n
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p><code>(claim1)</code> rewrites <code>LINE_N</code> by substituting all ocurrences of <code>RHS_M</code> (the SECOND side of line <code>m</code>) with <code>LHS_M</code>. Here is an example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x + 1 == y                               (some justification)
</span></span><span style="display:flex;"><span>    2. y*(x + 1) == (x + 1) + y                 (some justification)
</span></span><span style="display:flex;"><span>    3. (x + 1)*(x + 1) == (x + 1) + (x + 1)     subst2 1 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>We wrote line 2 by replacing each occurence of <code>y</code> with <code>x + 1</code>. Note that we put parentheses around our first replacement to ensure a product equivalent to the original statement.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="assignment-statements">Assignment Statements</h1>

<p>Assignment statements in a program come in two forms &ndash; with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.</p>
<p>For example, an increment statement like <code>x = x + 1</code> MUTATES the value of <code>x</code> by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of <code>x</code>.</p>
<p>In contrast, a statement like <code>y = x + 1</code> assigns to <code>y</code> one more than the value in <code>x</code>. We do not need to know the previous value of <code>y</code>, as we are not using it in the assignment statement. (We do need to know the value of <code>x</code>).</p>
<h2 id="assignments-without-mutation">Assignments without mutation</h2>
<p>We have already seen the steps necessary to process assignment statements that do not involve variable mutation. Recall that we can declare as a <code>premise</code> any assignment statement or claim from a previous logic block involving variables that have not since changed.</p>
<p>For example, suppose we want to verify the following program so the assert statement at the end will hold:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val y: Z = x + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val z: Z = 10 - x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the assert will not hold yet
</span></span><span style="display:flex;"><span>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Since none of the statements involve variable mutation, we can do the verification in a single logic block:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 4    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val y: Z = x + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val z: Z = 10 - x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    2. y == x + 2           premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    3. z == 10 - x          premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    4. y == 4 + 2           subst1 1 2
</span></span><span style="display:flex;"><span>    5. z == 10 - 4          subst1 1 3
</span></span><span style="display:flex;"><span>    6. y == 6               algebra 4
</span></span><span style="display:flex;"><span>    7. z == 6               algebra 5
</span></span><span style="display:flex;"><span>    8. y == z               subst2 7 6
</span></span><span style="display:flex;"><span>    9. y == z ∧ y == 6      ∧i 8 6
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now the assert will hold
</span></span><span style="display:flex;"><span>assert(y == z &amp; y == 6)</span></span></code></pre></div><p>Note that we did need to do <code>∧i</code> so that the last claim was <code>y == z ∧ y == 6 </code>, even though we had previously established the claims <code>y == z</code> and <code>y == 6</code>. In order for an assert to hold (at least until we switch Logika modes in chapter 10), we need to have established EXACTLY the claim in the assert in a previous logic block.</p>
<h2 id="assignments-with-mutation">Assignments with mutation</h2>
<p>Assignments with mutation are trickier &ndash; we need to know the old value of a variable in order to reason about its new value. For example, if we have the following program:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert(x == 5)</span></span></code></pre></div><p>Then we might try to add the following logic blocks:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //from previous variable assignment
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == x + 1           premise     //NO! Need to distinguish between old x (right side) and new x (left side)
</span></span><span style="display:flex;"><span>    2. x == 4               premise     //NO! x has changed since this claim
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert(x == 5)</span></span></code></pre></div><p>&hellip;but then we get stuck in the second logic block. There, <code>x</code> is supposed to refer to the CURRENT value of <code>x</code> (after being incremented), but both our attempted claims are untrue. The current value of <code>x</code> is not one more than itself (this makes no sense!), and we can tell from reading the code that <code>x</code> is now 5, not 4.</p>
<p>To help reason about changing variables, Logika has a special <code>name_old</code> value that refers to the OLD value of a variable called <code>name</code>, just before the latest update. In the example above, we can use <code>x_old</code> in the second logic block to refer to <code>x</code>&rsquo;s value just before it was incremented. We can now change our premises and finish the verification as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //from previous variable assignment
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == x_old + 1       premise     //Yes! x equals its old value plus 1
</span></span><span style="display:flex;"><span>    2. x_old == 4           premise     //Yes! The old value of x was 4
</span></span><span style="display:flex;"><span>    3. x == 4 + 1           subst1 2 1  
</span></span><span style="display:flex;"><span>    4. x == 5               algebra 3   //Could have skipped line 3 and used &#34;algebra 1 2&#34; instead
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now the assert will hold
</span></span><span style="display:flex;"><span>assert(x == 5)</span></span></code></pre></div><p>By the end of the logic block following a variable mutation, we need to express everything we know about the variable&rsquo;s current value WITHOUT using the <code>_old</code> terminology, as its scope will end when the logic block ends. Moreover, we only ever have one <code>_old</code> value available in a logic block &ndash; the variable that was most recently changed. This means we will need logic blocks after each variable mutation to process the changes to any related facts.</p>
<h2 id="variable-swap-example">Variable swap example</h2>
<p>Suppose we have the following Logika program:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//what do we want to assert we did?</span></span></code></pre></div><p>We can see that this program gets two user input values, <code>x</code> and <code>y</code>, and then swaps their values. So if <code>x</code> was originally 4 and <code>y</code> was originally 6, then at the end of the program <code>x</code> would be 6 and <code>y</code> would be 4.</p>
<p>We would like to be able to assert what we did &ndash; that <code>x</code> now has the original value from <code>y</code>, and that <code>y</code> now has the original value from <code>x</code>. To do this, we might invent dummy constants called <code>xOrig</code> and <code>yOrig</code> that represent the original values of those variables. Then we can add our assert:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the original values of both inputs
</span></span><span style="display:flex;"><span>val xOrig: Z = x
</span></span><span style="display:flex;"><span>val yOrig: Z = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//x and y have swapped
</span></span><span style="display:flex;"><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style="display:flex;"><span>assert(x == yOrig &amp; y == xOrig)     //this assert will not yet hold</span></span></code></pre></div><p>We can complete the verification by adding logic blocks after assignment statements, being careful to update all we know (without using the <code>_old</code> value) by the end of each block:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the original values of both inputs
</span></span><span style="display:flex;"><span>val xOrig: Z = x
</span></span><span style="display:flex;"><span>val yOrig: Z = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. xOrig == x           premise
</span></span><span style="display:flex;"><span>    2. yOrig == y           premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//swap x and y
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == y                   premise     //from the assignment statement
</span></span><span style="display:flex;"><span>    2. temp == x_old            premise     //temp equaled the OLD value of x
</span></span><span style="display:flex;"><span>    3. xOrig == x_old           premise     //xOrig equaled the OLD value of x
</span></span><span style="display:flex;"><span>    4. yOrig == y               premise     //yOrig still equals y
</span></span><span style="display:flex;"><span>    5. temp == xOrig            algebra 2 3
</span></span><span style="display:flex;"><span>    6. x == yOrig               algebra 1 4
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == temp                premise     //from the assignment statement
</span></span><span style="display:flex;"><span>    2. temp == xOrig            premise     //from the previous logic block (temp and xOrig are unchanged since then)
</span></span><span style="display:flex;"><span>    3. yOrig == y_old           premise     //yOrig equaled the OLD value of y
</span></span><span style="display:flex;"><span>    4. y == xOrig               algebra 1 2
</span></span><span style="display:flex;"><span>    5. x == yOrig               premise     //from the previous logic block (x and yOrig are unchanged since then)
</span></span><span style="display:flex;"><span>    6. x == yOrig ^ y == xOrig  ^i 5 4
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//x and y have swapped
</span></span><span style="display:flex;"><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style="display:flex;"><span>assert(x == yOrig &amp; y == xOrig)     //this assert will hold now</span></span></code></pre></div><p>Notice that in each logic block, we express as much as we can about all variables/values in the program. In the first logic block, even though <code>xOrig</code> and <code>yOrig</code> were not used in the previous assignment statement, we still expressed how the current values our other variables compared to <code>xOrig</code> and <code>yOrig</code>. It helps to think about what you are trying to claim in the final assert &ndash; since our assert involved <code>xOrig</code> and <code>yOrig</code>, we needed to relate the current values of our variables to those values as we progressed through the program.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="integer-division-and-modulo">Integer Division and Modulo</h1>

<p>Working with division and modulo requires extra care, as Logika is finicky about both.</p>
<h2 id="division">Division</h2>
<p>Recall that <code>Z</code> (int) is the only numeric type in Logika, so any division is integer division. This means something like <code>9/2</code> evaluates to 4, just as it would in Java or C#.</p>
<h3 id="check-for-division-by-zero">Check for division by zero</h3>
<p>Before doing division of the form <code>numerator/denominator</code>, either in a line of code or in a logic block, you must have a line in a previous logic block that states: <code>denominator != 0</code>. Other forms, such as <code>denominator &gt; 0</code> or <code>0 != denominator</code>, will not work. You are even required to do this when dividing by a constant value that is obviously not zero.</p>
<p>For example, if we do:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 10 / 2</span></span></code></pre></div><p>Then Logika will give us an error complaining we have not proved that the denominator is not zero. We must add the claim <code>2 != 0</code> as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 != 0           algebra
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 10 / 2</span></span></code></pre></div><p>Note that our justification is just, <code>algebra</code>, as we don&rsquo;t need any extra information to claim that 2 is not equal to 0.</p>
<h3 id="pitfalls">Pitfalls</h3>
<p>Be careful when making claims that involve division. For example, the following claim will not validate in Logika:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == (x/3)*3         algebra     //NO!
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>While the claim <code>x == (x/3)*3</code> is certainly true in math, it is not true with integer division. For example, if <code>x</code> is 7, then <code>(x/3)*3</code> is 6 &ndash; so the two sides are not equal. In general, I recommend avoiding claims involving division if you can at all help it. Instead, try to find a way to express the same idea in a different way using multiplication.</p>
<h2 id="modulo">Modulo</h2>
<p>Modulo (%) works the same way in Logika as it does in other programming languages. For example, <code>20 % 6</code> evaluates to 2.</p>
<h3 id="modulo-checks-on-numerator-and-denominator">Modulo checks on numerator and denominator</h3>
<p>Before using the modulo operator in the form <code>numerator % denominator</code>, either in a line of code or as a claim in a logic block, you must have EXACTLY these claims in the previous logic block:</p>
<ul>
<li><code>numerator &gt;= 0</code></li>
<li><code>denominator &gt; 0</code></li>
</ul>
<p>For example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 &gt; 0           algebra
</span></span><span style="display:flex;"><span>    2. a &gt;= 0          (some justification)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = a % 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...</span></span></code></pre></div><h3 id="example">Example</h3>
<p>Consider the following Logika program:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt(&#34;Enter positive number: &#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assume(num &gt; 0)
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num * 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num/2 - 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == orig)</span></span></code></pre></div><p>It can often be handy to walk through a program with sample numbers before trying to prove its correctness:</p>
<ul>
<li>Suppose our input value, <code>num</code>, is 11</li>
<li><code>orig</code> is initialized to be 11 also</li>
<li><code>num</code> is multiplied by 2, and is 22</li>
<li>It makes sense that <code>num</code> would be even, since any number times two is always even (and indeed, 22 is even)</li>
<li>We add 2 to <code>num</code>, so it is now 24</li>
<li>It makes sense that <code>num</code> would still be even, as it was even before and we added 2 (another even number) to it. Indeed, 24 is still even.</li>
<li>We update <code>num</code> by dividing it by 2 and subtracting 1, so <code>num</code> is now back to its original value of 11 (the same as <code>orig</code>). This step &ldquo;undoes&rdquo; the changes we have made to <code>num</code> &ndash; looking at the code, we can see that the final value of <code>num</code> is <code>orig*2 + 2</code>, so if we do <code>(orig*2 + 2) / 2 - 1</code>, we are left with <code>orig</code>.</li>
</ul>
<p>Here is the completed verification, with comments at each step:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt(&#34;Enter positive number: &#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assume(num &gt; 0)
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>num = num * 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == num_old * 2           premise     //we updated num to be its old value times 2
</span></span><span style="display:flex;"><span>    2. orig == num_old              premise     //orig equaled the old value of num (before our change)
</span></span><span style="display:flex;"><span>    3. num == orig * 2              algebra 1 2 //express the new value of num without referring to &#34;_old&#34;
</span></span><span style="display:flex;"><span>    4. 2 &gt; 0                        algebra     //needed to use modulo in step 7
</span></span><span style="display:flex;"><span>    5. num_old &gt; 0                  premise     //we assumed the old value of num (before its change) was &gt; 0
</span></span><span style="display:flex;"><span>    6. num &gt;= 0                     algebra 1 5 //needed to use modulo in step 7
</span></span><span style="display:flex;"><span>    7. num % 2 == 0                 algebra 1   //we have showed num is now even (needed for next assert)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num + 2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == num_old + 2               premise     //we updated num to be its old value plus 2
</span></span><span style="display:flex;"><span>    2. num_old &gt;= 0                     premise     //from line 6 in previous block, but num has since changed
</span></span><span style="display:flex;"><span>    3. num_old % 2 == 0                 premise     //from line 7 in previous block, but num has since changed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we know 2 &gt; 0 from previous block - don&#39;t need to restate here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    4. num &gt;= 0                         algebra 1 2 //needed to use modulo in step 5 (need to redo since num has changed)
</span></span><span style="display:flex;"><span>    5. num % 2 == 0                     algebra 1 3 //we have showed num is still even (needed for next assert)
</span></span><span style="display:flex;"><span>    6. num_old == orig * 2              premise     //from line 3 in block above, but num has since changed
</span></span><span style="display:flex;"><span>    7. num - 2 == orig * 2              algebra 1 6 //express new value of num without using &#34;_old&#34;
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 != 0                       algebra     //needed for dividing by 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num/2 - 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == num_old/2 - 1             premise     //we updated num to be its old value divided by 2 minus 1
</span></span><span style="display:flex;"><span>    2. num_old - 2 == orig * 2          premise     //from line 7 in previous block, but num has since changed
</span></span><span style="display:flex;"><span>    3. num_old == orig * 2 + 2          algebra 2
</span></span><span style="display:flex;"><span>    4. num == (orig * 2 + 2)/2 - 1      algebra 1 3 //express new value of num without using &#34;_old&#34;
</span></span><span style="display:flex;"><span>    5. num == orig + 1 - 1              algebra 4
</span></span><span style="display:flex;"><span>    6. num == orig                      algebra 5   //we have showed num is back to being orig (needed for last assert)
</span></span><span style="display:flex;"><span>                                                    //could have skipped straight here with &#34;algebra 1 2&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == orig)</span></span></code></pre></div><p>Sometimes it can be tricky to figure out what to do at each step in order to get assert statements to pass. If you are unsure what to do, I recommend:</p>
<ul>
<li>
<p>Walk through the program several times with sample numbers, keeping track of changes to variables. Why do the assert statements make sense to you? Convince yourself that they are valid claims before you worry about the formal verification.</p>
</li>
<li>
<p>Add a logic block after each variable mutation. Work from the top down:</p>
<ul>
<li>Write a premise for every variable assignment and assume statement since the previous logic block.</li>
<li>Find all claims in the logic block just before you that do not use an &ldquo;_old&rdquo; reference &ndash; pull each claim into your current block, using an &ldquo;_old&rdquo; reference as needed for the most recently changed variable.</li>
<li>Manipulate your claims that use an &ldquo;_old&rdquo; reference until you have statements that capture the current value of the recently changed variable that do not reference &ldquo;_old&rdquo;</li>
<li>If your next statement is an assert, manipulate your claims until you have exactly the claim in the assert.</li>
<li>If any claims</li>
</ul>
</li>
<li>
<p>Add a logic block before each use of division (<code>numerator / denominator</code>) and modulus (<code>numerator % denominator</code>). Pull in claims from previous blocks as described above to help you show what is needed about <code>numerator</code> and <code>denominator</code>:</p>
<ul>
<li>For division, build to the claim <code>denominator != 0</code></li>
<li>For modulo, build to the claims <code>numerator &gt;= 0</code> and <code>denominator &gt; 0</code></li>
<li>If you can, avoid using division in logic block claims</li>
</ul>
</li>
</ul>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="conditional-statements">Conditional Statements</h1>

<p>To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. Recall that Logika does not have an if/else if statement. However, you can simulate more than two branches by nesting another if/else inside the outer else.</p>
<h2 id="motivation">Motivation</h2>
<p>Before we formalize the details of verifying a program with a conditional statement, let&rsquo;s motivate the topic with an example.</p>
<h3 id="max-program">Max program</h3>
<p>Suppose we have a Logika program that finds finds the maximum (<code>max</code>) between two user input numbers (<code>x</code> and <code>y</code>):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var max: Z = 0  //give max a dummy starting value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (x &gt; y) {
</span></span><span style="display:flex;"><span>    max = x
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    max = y
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="max-assert">Max assert</h3>
<p>Before worrying about how to do the verification, let&rsquo;s consider what we should assert at the end in order to be sure that <code>max</code> really does hold the biggest of the two inputs. Clearly, <code>max</code> should be greater than or equal to both inputs. So should our assert be:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//Not quite all we want to say
</span></span><span style="display:flex;"><span>assert(max &gt;= x &amp; max &gt;= y)</span></span></code></pre></div><p>Suppose <code>x</code> was 10, <code>y</code> was 15&hellip;and that <code>max</code> was 20. (Clearly this isn&rsquo;t what our code would do, but you can imagine writing something else for the max code that came up with such a calculation). In this case, <code>max</code> is indeed greater than or equal to both inputs&hellip;but it is just as clearly not the max. We know see that we also need to claim that <code>max</code> equals one of the two inputs. This makes our assert:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//Now we are sure we are describing the max between x and y
</span></span><span style="display:flex;"><span>assert(max &gt;= x &amp; max &gt;= y &amp; (max == x | max == y))</span></span></code></pre></div><h3 id="analyzing-max">Analyzing max</h3>
<p>Now, we need to prove that our assert holds no matter which branch we follow in the conditional statement. First, when we analyze the code in the if-branch, we have:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>max = x
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. max == x         premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>and when we analyze the code in the else-branch, we have:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>max = y
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. max == y         premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>These two deductions imply that, when the if/else statements finishes, one or the other property holds true:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (x &gt; y) {
</span></span><span style="display:flex;"><span>    max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == x         premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    max = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == y         premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style="display:flex;"><span>    1 . max == x  v  max == y premise 
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>This illustrates the first principle of conditional commands: the knowledge produced by the command is the disjunction (or) of the knowledge produced by each branch. In the section on propositional logic, we covered how to apply cases analyses on disjunctive assertions to extract useful knowledge.</p>
<p>Recall that the intent of the if/else statement was to set <code>max</code> so that it holds the larger of <code>x</code> and <code>y</code>, so that our assert would hold:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(max &gt;= x &amp; max &gt;= y &amp; (max == x | max == y))</span></span></code></pre></div><p>The claim we proved so far satisifies the second part of our assert statement, but not the first part. This is because we ignored a critical feature of an if/else statement: By asking a question — the condition — the if/else statement generates new knowledge.</p>
<p>For the if-branch, we have the new knowledge that <code>x &gt; y</code>; for the else-branch, we have that <code>¬(x &gt; y)</code>, that is, <code>y &gt;= x</code>. We can embed these assertions into the analysis of the conditional command, like this, and conclude that, in both cases, <code>max</code> is greater than or equal to both inputs:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var max: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (x &gt; y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        2. x &gt; y            premise     //the condition is true
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == x         premise     //from the &#34;max = x&#34; assignment
</span></span><span style="display:flex;"><span>        2. max &gt;= x         algebra 1
</span></span><span style="display:flex;"><span>        3. x &gt; y            premise     //condition is still true (x and y are unchanged)
</span></span><span style="display:flex;"><span>        4. max &gt;= y         algebra 1 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        2. ¬(x &gt; y)         premise     //the condition is NOT true
</span></span><span style="display:flex;"><span>        3. x &lt;= y           algebra 2
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    max = y
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == y         premise     //from the &#34;max = y&#34; assignment
</span></span><span style="display:flex;"><span>        2. x &lt;= y           premise     //pulled down from previous logic block (x and y are unchanged)
</span></span><span style="display:flex;"><span>        3. max &gt;= x         algebra 1 2
</span></span><span style="display:flex;"><span>        4. max &gt;= y         algebra 1
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//summary of what just happened
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style="display:flex;"><span>    1. max == x ∨ max == y      premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    2. max &gt;= x                 premise     //true in BOTH branches
</span></span><span style="display:flex;"><span>    3. max &gt;= y                 premise     //true in BOTH branches
</span></span><span style="display:flex;"><span>    4. max &gt;= x ∧ max &gt;= y      ^i 2 3
</span></span><span style="display:flex;"><span>    5. (max &gt;= x ∧ max &gt;= y) ∧ (max == x ∨ max == y)    ^i 4 1
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert((max &gt;= x &amp; max &gt;= y) &amp; (max == x | max == y))</span></span></code></pre></div><h2 id="rules-for-analyzing-programs-with-conditionals">Rules for analyzing programs with conditionals</h2>
<p>In this section, we will summarize how to analyze programs with conditional statements.</p>
<h3 id="declaring-condition-and-condition-as-premises">Declaring condition and ¬(condition) as premises</h3>
<p>If we have a program such as this with an if/else statement:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Then we can claim <code>C</code> as a premise immediately inside the if-branch and <code>¬(C)</code> as a premise immediately inside the else branch:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. C            premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ¬(C)         premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Be careful with the <code>else</code> case &ndash; you must claim exactly <code>¬(C)</code>, and not some claim you know to be equivalent. In our max example, <code>C</code> was <code>x &lt; y</code>, and we needed to claim exactly <code>¬(x &lt; y)</code> in the else &ndash; NOT <code>x &gt;= y</code>. After you have pulled in the initial claim using the form <code>¬(C)</code>, you can use <code>algebra</code> to manipulate it into a different form.</p>
<h3 id="each-branch-reaches-a-different-conclusion">Each branch reaches a different conclusion</h3>
<p>If the if-branch reaches conclusion <code>Q1</code> and the else branch reaches conclusion <code>Q2</code>, then afterwards we can list as a premise that one of those conclusions is true (since we know that one of the branches in an if/else will ALWAYS execute):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q1           (some justification)    //conclusion in if-branch
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q2           (some justification)    //conclusion in else-branch
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. Q1 ∨ Q2          premise     //Q1 from if, Q2 from else
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Note that order matters, and that we must claim <code>(if conclusion) ∨ (else conclusion)</code> &ndash; in the example above, we could not claim <code>Q2 ∨ Q1</code> afterwards.</p>
<h3 id="each-branch-reaches-the-same-conclusion">Each branch reaches the same conclusion</h3>
<p>If the if-branch and the else-branch both reach the SAME conclusion <code>Q</code>, then afterwards we can list <code>Q</code> as a premise. Here, we know that one of the branches in an if/else will ALWAYS execute &ndash; so if we get to the same conclusion in both cases, then we must always reach that conclusion:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q            (some justification)    //common conclusion reached in IF
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q            (some justification)    //common conclusion reached in ELSE
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. Q                premise     //Q was true in both the IF and the ELSE
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><h2 id="example-programs-with-no-else">Example: programs with no &ldquo;else&rdquo;</h2>
<p>Suppose we have an if-statement with no &ldquo;else&rdquo;. Afterwards, we know that either the if-branch was executed (which happens when the condition is true), or that the condition was false. If we reach some conclusion <code>Q</code> in the if-branch, then afterwards we know that either <code>Q</code> is true or that the if-statemention condition is not true. Similarly, if some claim <code>old</code> was true before an if-statement without an else, then afterwards we know that we either reached <code>Q</code> in the if-branch or that our <code>old</code> statement is still true.</p>
<p>We can pull in these claims as premises after an if-statement as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. old              (some justification)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q            (some justification)    //conclusion in if-branch
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. Q ∨ ¬(C)          premise    //either we reached Q in the if, or the condition was false
</span></span><span style="display:flex;"><span>    2. Q ∨ old           premise    //either we reached Q in the if, or &#34;old&#34; is still true
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>For example, suppose we have a program that finds the absolute value of an input number:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt()
</span></span><span style="display:flex;"><span>var orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &lt; 0) {
</span></span><span style="display:flex;"><span>    num = num * -1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//num is now the absolute value of the original input</span></span></code></pre></div><p>Afterwards, we want to assert that <code>num</code> is the absolute value of the original input &ndash; that <code>num</code> is nonnegative and either equals <code>orig</code> (the original input) or <code>-1*orig</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(num &gt;= 0 &amp; (num == -1*orig | num == orig))</span></span></code></pre></div><p>We start our verification as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt()
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. orig == num                  premise         //from &#34;orig = num&#34; assignment
</span></span><span style="display:flex;"><span>    2. num == orig                  algebra 1       //switch order to match assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &lt; 0) {
</span></span><span style="display:flex;"><span>    num = num * -1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. num_old &lt; 0              premise         //if condition (num just changed)
</span></span><span style="display:flex;"><span>        2. num == num_old * -1      premise         //from &#34;num = num * -1&#34; assignment
</span></span><span style="display:flex;"><span>        3. orig == num_old          premise         //orig did equal num (num just changed)
</span></span><span style="display:flex;"><span>        4. num &gt;= 0                 algebra 1 2     //a negative number times -1 is nonnegative
</span></span><span style="display:flex;"><span>        5. num == -1*orig           algebra 2 3     //needed for last part of assert
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num &gt;= 0 ∨ ¬(num &lt; 0)            premise         //conclusion from if OR !(condition)
</span></span><span style="display:flex;"><span>    2. num == -1*orig ∨ num == orig     premise         //conclusion from if OR num still equals orig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //incomplete    
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//num is now nonnegative
</span></span><span style="display:flex;"><span>assert(num &gt;= 0 &amp; (num == orig | num == -1*orig))</span></span></code></pre></div><p>In our final logic block, we need to reach the claim <code>num &gt;= 0</code> so we can combine it with <code>num == -1*orig ∨ num == orig</code> to match our assert. We can do this with OR elimination on <code>num &gt;= 0 ∨ ¬(num &lt; 0)</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt()
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. orig == num                  premise         //from &#34;orig = num&#34; assignment
</span></span><span style="display:flex;"><span>    2. num == orig                  algebra 1       //switch order to match assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &lt; 0) {
</span></span><span style="display:flex;"><span>    num = num * -1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. num_old &lt; 0              premise         //if condition (num just changed)
</span></span><span style="display:flex;"><span>        2. num == num_old * -1      premise         //from &#34;num = num * -1&#34; assignment
</span></span><span style="display:flex;"><span>        3. orig == num_old          premise         //orig did equal num (num just changed)
</span></span><span style="display:flex;"><span>        4. num &gt;= 0                 algebra 1 2     //a negative number times -1 is nonnegative
</span></span><span style="display:flex;"><span>        5. num == -1*orig           algebra 2 3     //needed for last part of assert
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num &gt;= 0 ∨ ¬(num &lt; 0)            premise     //conclusion from if OR !(condition)
</span></span><span style="display:flex;"><span>    2. num == -1*orig ∨ num == orig     premise     //conclusion from if OR num still equals orig
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. num &gt;= 0                     assume
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    5. {
</span></span><span style="display:flex;"><span>        6. ¬(num &lt; 0)                   assume
</span></span><span style="display:flex;"><span>        7. num &gt;= 0                     algebra 6
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. num &gt;= 0                         ∨e 1 3 5
</span></span><span style="display:flex;"><span>    9. num &gt;= 0 ∧ (num == -1*orig ∨ num == orig)    ∧i 8 2  //match assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//num is now nonnegative
</span></span><span style="display:flex;"><span>assert(num &gt;= 0 &amp; (num == -1*orig | num == orig))</span></span></code></pre></div><h2 id="nested-conditionals">Nested conditionals</h2>
<p>We employ the same rules when analyzing programs with nested conditional statements. If we reach a common conclusion in both the if and else branches of an inner if/else statement, for example, then we can claim the common conclusion as a premise after that inner if/else statement (but still inside the outer if/else). The outline below summarizes what we can claim at various places in nested if/else statement:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C1) {
</span></span><span style="display:flex;"><span>    if (C2) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. C1       premise     //outer if condition is true
</span></span><span style="display:flex;"><span>            2. C2       premise     //inner if condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q1       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. C1       premise     //outer if condition is true
</span></span><span style="display:flex;"><span>            2. ¬(C2)    premise     //inner if condition is false
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q2       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. common       premise     //common conclusion in inner if/else
</span></span><span style="display:flex;"><span>        2. Q1 ∨ Q2      premise     //Q1 from inner if, Q2 from inner else
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    if (C3) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. ¬(C1)    premise     //outer if condition is false
</span></span><span style="display:flex;"><span>            2. C3       premise     //inner if condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q3       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. ¬(C1)    premise     //outer if condition is false
</span></span><span style="display:flex;"><span>            2. ¬(C3)    premise     //inner if condition is false
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q4       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. common       premise     //common conclusion in inner if/else
</span></span><span style="display:flex;"><span>        2. Q3 ∨ Q4      premise     //Q1 from inner if, Q2 from inner else
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. common                   premise     //&#34;common&#34; was true in both the outer IF and the outer ELSE 
</span></span><span style="display:flex;"><span>    2. (Q1 ∨ Q2) ∨ (Q3 ∨ Q4)    premise     //(Q1 ∨ Q2) from outer if, (Q3 ∨ Q4) from else
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div>
            <footer class="footline">

            </footer>
          </article>

          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/dec4297d81df48b5e02e2640601321e923ab5f5b">Aug 10, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1700155505" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1700155505" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1700155505" defer></script>
  </body>
</html>
