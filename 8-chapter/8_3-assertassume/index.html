<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Assert statements An assert statement in Scala uses the syntax assert(expression), where expression is of type bool. The assert passes if the expression is true, and throws an error if the expression is false.
Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Assert and Assume :: CIS 301 Textbook"><meta name=twitter:description content="Assert statements An assert statement in Scala uses the syntax assert(expression), where expression is of type bool. The assert passes if the expression is true, and throws an error if the expression is false.
Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/8-chapter/8_3-assertassume/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Assert and Assume :: CIS 301 Textbook"><meta property="og:description" content="Assert statements An assert statement in Scala uses the syntax assert(expression), where expression is of type bool. The assert passes if the expression is true, and throws an error if the expression is false.
Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Intro to Programming Logic"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-04-25T17:02:46-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Assert and Assume :: CIS 301 Textbook"><meta itemprop=description content="Assert statements An assert statement in Scala uses the syntax assert(expression), where expression is of type bool. The assert passes if the expression is true, and throws an error if the expression is false.
Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-04-25T17:02:46-05:00"><meta itemprop=wordCount content="909"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Assert and Assume :: CIS 301 Textbook</title><link href=/cis301/8-chapter/8_3-assertassume/index.xml rel=alternate type=application/rss+xml title="Assert and Assume :: CIS 301 Textbook"><link href=/cis301/8-chapter/8_3-assertassume/index.print.html rel=alternate type=text/html title="Assert and Assume :: CIS 301 Textbook"><link href=/cis301/8-chapter/8_3-assertassume/tele.html rel=alternate type=text/html title="Assert and Assume :: CIS 301 Textbook"><link href=/cis301/8-chapter/8_3-assertassume/embed.html rel=alternate type=text/html title="Assert and Assume :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1755885657 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1755885657 defer></script><script src=/cis301/js/search-lunr.min.js?1755885657 defer></script><script src=/cis301/js/search.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1755885657"</script><script src=/cis301/js/lunr/lunr.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1755885657 rel=stylesheet><link href=/cis301/css/theme.min.css?1755885657 rel=stylesheet><link href=/cis301/css/format-html.min.css?1755885657 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/8-chapter/8_3-assertassume/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["auto","light-theme","dark-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!0,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1755885657 rel=stylesheet></head><body class="mobile-support html" data-url=/cis301/8-chapter/8_3-assertassume/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#assert-statements>Assert statements</a><ul><li><a href=#example>Example</a></li><li><a href=#using-conditional-operators>Using conditional operators</a></li></ul></li><li><a href=#assume-statement>Assume statement</a><ul><li><a href=#assume-example>Assume example</a></li><li><a href=#assumes-vs-wrapping-if-statements>Assumes vs. wrapping if-statements</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><a itemprop=item href=/cis301/index.html><span itemprop=name>CIS 301 Textbook</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/8-chapter/index.html><span itemprop=name>Intro to Programming Logic</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Assert and Assume</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/8-chapter/8_3-assertAssume.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/8-chapter/8_3-assertassume/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/8-chapter/8_2-logikaprograms/index.html title="Logika Programs (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/8-chapter/8_4-algebrasubst/index.html title="Algebra and Subst Rules (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/8-chapter/8_3-assertassume/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/8-chapter/8_3-assertassume/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 8-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=assert-and-assume>Assert and Assume</h1><h2 id=assert-statements>Assert statements</h2><p>An <em>assert</em> statement in Scala uses the syntax <code>assert(expression)</code>, where <code>expression</code> is of type <code>bool</code>. The assert passes if the expression is true, and throws an error if the expression is false.</p><p>Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven.</p><p>Note that we are using these assert statements differently than assert statements in languages like Java and C# &ndash; in those languages, the code in the assert statement (which often includes test method calls) is actually run, and the assert statement checks whether those methods are returning the expected values. In Logika, assert statements only pass if we have previously PROVED what we are claiming &ndash; the code is never executed.</p><h3 id=example>Example</h3><p>Consider the following program:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 6
</span></span><span style=display:flex><span>val z: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert (x == y &amp; y &gt; z)</span></span></code></pre></div><p>While we can tell that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>, this code would fail in Logika (at least in its manual mode, which is what we are using now). In order for an assert to pass, we must have already proved EXACTLY the statement in the assert.</p><p>Why do WE know that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>? From looking at the code! We can tell that <code>x</code> and <code>y</code> are given the same value (6), and that <code>y</code>&rsquo;s value of 6 is bigger than <code>z</code>&rsquo;s value of 4.</p><p>So far, we know we can pull in the values of each variable as premises, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = 6
</span></span><span style=display:flex><span>val y: Z = 6
</span></span><span style=display:flex><span>val z: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1  (x == 6) by Premise,
</span></span><span style=display:flex><span>    2  (y == 6) by Premise,
</span></span><span style=display:flex><span>    3  (z == 4) by Premise,
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    //how to say that x and y are equal, and that y is bigger than z?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>assert(x == y ∧ y &gt; z)</span></span></code></pre></div><p>But we don&rsquo;t yet know how to justify claims that describe how variables compare to one another. We will learn how to do that with the <code>Algebra</code> and <code>Subst</code> rules in section 8.4.</p><h3 id=using-conditional-operators>Using conditional operators</h3><p>Notice that the program above used an <code>∧</code> symbol for an AND operator in an assert statement. As with our propositional logic proofs, if we want to use a <code>∧</code> operator then we type the symbol <code>&</code>. This <code>&</code> is automatically changed to a <code>∧</code> when we view our program, just as it was in our deduction proofs. Similarly, we type <code>!</code> for NOT in asserts (which displays as <code>¬</code>) and <code>|</code> for OR (which displays as <code>∨</code>). However, we are not able to use an implies operator in an assert statement as it is not part of the Scala language (and our asserts are part of the program and not just a proof element).</p><p>If we wanted to write an assert statement that would be true when some variable <code>p</code> was even and/or was a positive two-digit number, we could say:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(p % 2 == 0 ∨ (p &gt; 9 ∧ p &lt; 100))</span></span></code></pre></div><p>As was mentioned above, the implies operator is not available in assert statements. However, we can make use of one of the equivalences we learned about in section 3.4: that <code>p → q</code> is equivalent to <code>¬p ∨ q</code>. So if we wanted to assert that if <code>p</code> was positive, then <code>q</code> was equal to <code>p</code>, then we could write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//expressing the implicaton ((p &gt; 0) → (q == p))
</span></span><span style=display:flex><span>assert(¬(p &gt; 0) ∨ (q == p))</span></span></code></pre></div><p>Or, equivalently, we could write:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert((p &lt;= 0) ∨ (q == p))</span></span></code></pre></div><h2 id=assume-statement>Assume statement</h2><p>An <em>assume</em> statement in Scala uses the syntax <code>assume(expression)</code>. If the expression is satisfiable, then we can use <code>expression</code> as a premise in the following Logika proof block.</p><h3 id=assume-example>Assume example</h3><p>For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var a: Z = Z.read()
</span></span><span style=display:flex><span>assume (a &gt; 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (a &gt; 0)   by Premise
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Assume statements are almost always used to make assumptions about user input. Perhaps our program only works correctly for certain values of input. If we can assume that the user really did enter acceptable values, then we can use that information (by pulling it in as a premise in the next proof block) to prove the correctness of the program based on that assumption.</p><h3 id=assumes-vs-wrapping-if-statements>Assumes vs. wrapping if-statements</h3><p>Toy programs often use assume in lieu of wrapping code in an if statement. The following two examples are equivalent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a : Z = Z.read()
</span></span><span style=display:flex><span>assume (a != 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>  1  (a != 0) by Premise
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var b: Z = 20 / a</span></span></code></pre></div><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//...is equivalent to:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var a : Z = Z.read()
</span></span><span style=display:flex><span>var b : Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>if (a != 0) {
</span></span><span style=display:flex><span>    b = 20 / a
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>These examples also demonstrate a requirement when we use the division operator in Logika programs, we must first demonstrate that we are not dividing by zero.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/3ee7d6e929803e183bc58287cbf71613bf7528ae>Apr 25, 2024</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class=default-animation><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/index.html><input type=checkbox id=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9 aria-controls=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9><label for=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/index.html><b>0. </b>Getting Started</a><ul id=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9 class=collapsible-menu><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/index.html><a class=padding href=/cis301/0-chapter/0_1-toolsguide/index.html>0.1. Tools Guide</a></li><li data-nav-id=/cis301/0-chapter/0_2-gitinstall/index.html><a class=padding href=/cis301/0-chapter/0_2-gitinstall/index.html>0.2. git Install</a></li></ul></li><li data-nav-id=/cis301/1-chapter/index.html><input type=checkbox id=R-section-cbcda2db56d129074f1e03beb13f9103 aria-controls=R-subsections-cbcda2db56d129074f1e03beb13f9103><label for=R-section-cbcda2db56d129074f1e03beb13f9103><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/index.html><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-cbcda2db56d129074f1e03beb13f9103 class=collapsible-menu><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/index.html><a class=padding href=/cis301/1-chapter/1_1-logicbasics/index.html>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/index.html><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/index.html>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/index.html><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/index.html>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/index.html><input type=checkbox id=R-section-d672bd5f3e40d734b815889ecb0b088e aria-controls=R-subsections-d672bd5f3e40d734b815889ecb0b088e><label for=R-section-d672bd5f3e40d734b815889ecb0b088e><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/index.html><b>2. </b>Truth Tables</a><ul id=R-subsections-d672bd5f3e40d734b815889ecb0b088e class=collapsible-menu><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/index.html><a class=padding href=/cis301/2-chapter/2_1-opscircuits/index.html>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/index.html><a class=padding href=/cis301/2-chapter/2_2-logikatruth/index.html>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/index.html><a class=padding href=/cis301/2-chapter/2_3-satis/index.html>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/index.html><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/index.html>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/index.html><a class=padding href=/cis301/2-chapter/2_5-sementail/index.html>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/index.html><input type=checkbox id=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73 aria-controls=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73><label for=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/index.html><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73 class=collapsible-menu><li data-nav-id=/cis301/3-chapter/3_1-propatom/index.html><a class=padding href=/cis301/3-chapter/3_1-propatom/index.html>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/index.html><a class=padding href=/cis301/3-chapter/3_2-notandor/index.html>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/index.html><a class=padding href=/cis301/3-chapter/3_3-implies/index.html>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/index.html><a class=padding href=/cis301/3-chapter/3_4-equiv/index.html>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/index.html><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/index.html>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/index.html><input type=checkbox id=R-section-a0d0660e4f5f539642b53fac77ff44c7 aria-controls=R-subsections-a0d0660e4f5f539642b53fac77ff44c7><label for=R-section-a0d0660e4f5f539642b53fac77ff44c7><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/index.html><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-a0d0660e4f5f539642b53fac77ff44c7 class=collapsible-menu><li data-nav-id=/cis301/4-chapter/4_1-intro/index.html><a class=padding href=/cis301/4-chapter/4_1-intro/index.html>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/index.html><a class=padding href=/cis301/4-chapter/4_2-andrules/index.html>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/index.html><a class=padding href=/cis301/4-chapter/4_3-orrules/index.html>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/index.html><a class=padding href=/cis301/4-chapter/4_4-impliesrules/index.html>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/index.html><a class=padding href=/cis301/4-chapter/4_5-notrules/index.html>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/index.html><a class=padding href=/cis301/4-chapter/4_6-strategies/index.html>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/index.html><a class=padding href=/cis301/4-chapter/4_7-theorems/index.html>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/index.html><a class=padding href=/cis301/4-chapter/4_8-equivalence/index.html>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/index.html><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/index.html>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/index.html><input type=checkbox id=R-section-589c35b8ff6263b7311a10a4d0fa83a9 aria-controls=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9><label for=R-section-589c35b8ff6263b7311a10a4d0fa83a9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/index.html><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9 class=collapsible-menu><li data-nav-id=/cis301/5-chapter/5_1-motivation/index.html><a class=padding href=/cis301/5-chapter/5_1-motivation/index.html>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/index.html><a class=padding href=/cis301/5-chapter/5_2-predsyntax/index.html>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/index.html><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/index.html>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/index.html><a class=padding href=/cis301/5-chapter/5_4-multquant/index.html>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/index.html><input type=checkbox id=R-section-55edc31437b1ec5edead9beb4ef7d1fa aria-controls=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa><label for=R-section-55edc31437b1ec5edead9beb4ef7d1fa><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/index.html><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa class=collapsible-menu><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/index.html><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/index.html>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/index.html><a class=padding href=/cis301/6-chapter/6_1-univrules/index.html>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/index.html><a class=padding href=/cis301/6-chapter/6_2-existrules/index.html>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/index.html><a class=padding href=/cis301/6-chapter/6_3-nested/index.html>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/index.html><a class=padding href=/cis301/6-chapter/6_4-equiv/index.html>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/index.html><a class=padding href=/cis301/6-chapter/6_5-strategies/index.html>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/index.html><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/index.html>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/index.html><input type=checkbox id=R-section-cbba04bde749b4229ea56fb5a7c6a953 aria-controls=R-subsections-cbba04bde749b4229ea56fb5a7c6a953><label for=R-section-cbba04bde749b4229ea56fb5a7c6a953><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/index.html><b>7. </b>Mathematical Induction</a><ul id=R-subsections-cbba04bde749b4229ea56fb5a7c6a953 class=collapsible-menu><li data-nav-id=/cis301/7-chapter/7_1-process/index.html><a class=padding href=/cis301/7-chapter/7_1-process/index.html>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/index.html><a class=padding href=/cis301/7-chapter/7_2-algebraex/index.html>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/index.html><a class=padding href=/cis301/7-chapter/7_3-divex/index.html>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/index.html><a class=padding href=/cis301/7-chapter/7_4-setex/index.html>7.4. Set example</a></li></ul></li><li class=parent data-nav-id=/cis301/8-chapter/index.html><input type=checkbox id=R-section-010016ee1ce3fc8b575a95f1204dba7b aria-controls=R-subsections-010016ee1ce3fc8b575a95f1204dba7b checked><label for=R-section-010016ee1ce3fc8b575a95f1204dba7b><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/index.html><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-010016ee1ce3fc8b575a95f1204dba7b class=collapsible-menu><li data-nav-id=/cis301/8-chapter/8_1-goal/index.html><a class=padding href=/cis301/8-chapter/8_1-goal/index.html>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/index.html><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/index.html>8.2. Logika Programs</a></li><li class=active data-nav-id=/cis301/8-chapter/8_3-assertassume/index.html><a class=padding href=/cis301/8-chapter/8_3-assertassume/index.html>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/index.html><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/index.html>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/index.html><a class=padding href=/cis301/8-chapter/8_5-assignment/index.html>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/index.html><a class=padding href=/cis301/8-chapter/8_6-divmod/index.html>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/index.html><a class=padding href=/cis301/8-chapter/8_7-conditionals/index.html>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/index.html><input type=checkbox id=R-section-6864880b2cc643485ab906a5e309eaaf aria-controls=R-subsections-6864880b2cc643485ab906a5e309eaaf><label for=R-section-6864880b2cc643485ab906a5e309eaaf><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/index.html><b>9. </b>Functions and Loops</a><ul id=R-subsections-6864880b2cc643485ab906a5e309eaaf class=collapsible-menu><li data-nav-id=/cis301/9-chapter/9_1-functions/index.html><a class=padding href=/cis301/9-chapter/9_1-functions/index.html>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/index.html><a class=padding href=/cis301/9-chapter/9_2-recursion/index.html>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/index.html><a class=padding href=/cis301/9-chapter/9_3-loops/index.html>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/index.html><a class=padding href=/cis301/9-chapter/9_4-logikafacts/index.html>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/index.html><a class=padding href=/cis301/9-chapter/9_5-summary/index.html>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/index.html><input type=checkbox id=R-section-b363793b1b72566b579f69cd488e8039 aria-controls=R-subsections-b363793b1b72566b579f69cd488e8039><label for=R-section-b363793b1b72566b579f69cd488e8039><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/index.html><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-b363793b1b72566b579f69cd488e8039 class=collapsible-menu><li data-nav-id=/cis301/10-chapter/10_1-modes/index.html><a class=padding href=/cis301/10-chapter/10_1-modes/index.html>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/index.html><a class=padding href=/cis301/10-chapter/10_2-intosequences/index.html>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/index.html><a class=padding href=/cis301/10-chapter/10_3-seqfn/index.html>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/index.html><a class=padding href=/cis301/10-chapter/10_4-seqloop/index.html>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/index.html><a class=padding href=/cis301/10-chapter/10_5-globals/index.html>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/index.html><a class=padding href=/cis301/10-chapter/10_6-termination/index.html>10.6 Termination</a></li></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul><li class=R-variantswitcher><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.relearn.markVariant()</script></li></ul></div><div id=R-footer><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></aside><script src=/cis301/js/clipboard/clipboard.min.js?1755885657 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1755885657 defer></script><script src=/cis301/js/theme.min.js?1755885657 defer></script></body></html>