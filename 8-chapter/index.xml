<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Intro to Programming Logic :: CIS 301 Textbook</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/index.html</link><description>Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 29 Apr 2025 11:46:26 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis301/8-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Programming Logic Goal</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_1-goal/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_1-goal/index.html</guid><description>In the next three chapters, we will learn how to reason about different kinds of program structures – assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs using a toy language that is a subset of Scala. While our toy language is not used in practice, the ideas that we will see to prove program correctness – preconditions, postconditions, loop invariants, and global invariants – can be used to specify functions in ANY language.</description></item><item><title>Logika Programs</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_2-logikaprograms/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_2-logikaprograms/index.html</guid><description>As we study program logic, we will use Logika to verify a subset of programs that use the Scala language. Specifically, we will study verification of programs with the following features:
Variables (booleans, ints, and sequences [which are like arrays/lists]) Printing and user input Math operations Conditional operations If and if/else statements While loops Functions The Scala programs we verify should be saved with a .sc extension. To show we are using Logika for verification, the first line of the file should be:</description></item><item><title>Assert and Assume</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_3-assertassume/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_3-assertassume/index.html</guid><description>Assert statements An assert statement in Scala uses the syntax assert(expression), where expression is of type bool. The assert passes if the expression is true, and throws an error if the expression is false.
Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven.</description></item><item><title>Algebra and Subst Rules</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_4-algebrasubst/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_4-algebrasubst/index.html</guid><description>In this section, we will learn our first two proof rules for programming logic – Algebra and Subst.
Verifying simple programs Before we delve into our new proof rules, let’s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the // --> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.</description></item><item><title>Assignment Statements</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_5-assignment/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_5-assignment/index.html</guid><description>Assignment statements in a program come in two forms – with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.
For example, an increment statement like x = x + 1 MUTATES the value of x by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of x.</description></item><item><title>Integer Division and Modulo</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_6-divmod/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_6-divmod/index.html</guid><description>We will see in this section that verifying programs with division and modulo requires extra care.
Division Recall that Z (int) is the only numeric type for Logika verification, so any division is integer division. This means something like 9/2 evaluates to 4, just as it would in Java or C#.
Check for division by zero Before doing division of the form numerator/denominator, either in a line of code or in a proof block, you must have have shown in a previous proof block that denominator is not 0. The easiest way to do this is to prove the claim: denominator != 0. You are even required to do this when dividing by a constant value that is obviously not zero.</description></item><item><title>Conditional Statements</title><link>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_7-conditionals/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/8-chapter/8_7-conditionals/index.html</guid><description>To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. We will only consider programs with an if/else as opposed to an if/else if. However, you can simulate more than two branches by nesting another if/else inside the outer else.
Motivation Before we formalize the details of verifying a program with a conditional statement, let’s motivate the topic with an example.</description></item></channel></rss>