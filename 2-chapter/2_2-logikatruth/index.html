<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Now that we’ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.
Operator precedence Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.
Here is the precedence of the logical operators, from most important (do first) to least important (do last):"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Truth Tables in Logika :: CIS 301 Textbook"><meta name=twitter:description content="Now that we’ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.
Operator precedence Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.
Here is the precedence of the logical operators, from most important (do first) to least important (do last):"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/2-chapter/2_2-logikatruth/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Truth Tables in Logika :: CIS 301 Textbook"><meta property="og:description" content="Now that we’ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.
Operator precedence Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.
Here is the precedence of the logical operators, from most important (do first) to least important (do last):"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Truth Tables"><meta property="article:modified_time" content="2025-01-16T15:05:00-06:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Truth Tables in Logika :: CIS 301 Textbook"><meta itemprop=description content="Now that we’ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.
Operator precedence Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.
Here is the precedence of the logical operators, from most important (do first) to least important (do last):"><meta itemprop=dateModified content="2025-01-16T15:05:00-06:00"><meta itemprop=wordCount content="1912"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Truth Tables in Logika :: CIS 301 Textbook</title><link href=/cis301/2-chapter/2_2-logikatruth/index.xml rel=alternate type=application/rss+xml title="Truth Tables in Logika :: CIS 301 Textbook"><link href=/cis301/2-chapter/2_2-logikatruth/index.print.html rel=alternate type=text/html title="Truth Tables in Logika :: CIS 301 Textbook"><link href=/cis301/2-chapter/2_2-logikatruth/tele.html rel=alternate type=text/html title="Truth Tables in Logika :: CIS 301 Textbook"><link href=/cis301/2-chapter/2_2-logikatruth/embed.html rel=alternate type=text/html title="Truth Tables in Logika :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1755885657 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1755885657 defer></script><script src=/cis301/js/search-lunr.min.js?1755885657 defer></script><script src=/cis301/js/search.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1755885657"</script><script src=/cis301/js/lunr/lunr.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1755885657 rel=stylesheet><link href=/cis301/css/theme.min.css?1755885657 rel=stylesheet><link href=/cis301/css/format-html.min.css?1755885657 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/2-chapter/2_2-logikatruth/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["auto","light-theme","dark-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!0,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1755885657 rel=stylesheet></head><body class="mobile-support html" data-url=/cis301/2-chapter/2_2-logikatruth/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#operator-precedence>Operator precedence</a></li><li><a href=#top-level-operator>Top-level operator</a></li><li><a href=#classifying-truth-tables>Classifying truth tables</a></li><li><a href=#logika-syntax>Logika syntax</a></li><li><a href=#logical-operators-in-logika>Logical operators in Logika</a></li><li><a href=#logika-mishandling-of-implies-operator>Logika mishandling of implies operator</a></li><li><a href=#example>Example</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><a itemprop=item href=/cis301/index.html><span itemprop=name>CIS 301 Textbook</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/2-chapter/index.html><span itemprop=name>Truth Tables</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Truth Tables in Logika</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/2-chapter/2_2-logikaTruth.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/2-chapter/2_2-logikatruth/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/2-chapter/2_1-opscircuits/index.html title="Operators and Circuits (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/2-chapter/2_3-satis/index.html title="Satisfiability (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/2-chapter/2_2-logikatruth/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/2-chapter/2_2-logikatruth/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 2-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=truth-tables-in-logika>Truth Tables in Logika</h1><p>Now that we&rsquo;ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.</p><h2 id=operator-precedence>Operator precedence</h2><p>Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.</p><p>Here is the precedence of the logical operators, from most important (do first) to least important (do last):</p><ol><li>Parentheses</li><li>Not operator, <code>¬</code></li><li>And operator, <code>∧</code></li><li>Or operator, <code>∨</code></li><li>Implies operator, <code>→</code></li></ol><p>For example, in the statement <code>(p ∨ q) ∧ ¬p</code>, we would evaluate the operators in the following order:</p><ol><li>The parentheses (which would resolve the <code>(p ∨ q)</code> expression)</li><li>The not, <code>¬</code></li><li>The and, <code>∧</code></li></ol><p>Sometimes we have more than one of the same operator in a single statement. For example: <code>p ∨ q ∨ r</code>. Different operators have different rules for resolving multiple occurrences:</p><ol><li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li><li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li><li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li><li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li><li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li></ol><h2 id=top-level-operator>Top-level operator</h2><p>In a logical statement, the <em>top-level operator</em> is the operator that is applied last (after following the precedence rules above).</p><p>For example, in the statement:</p><p><code>p ∨ q → ¬p ∧ r</code></p><p>We would evaluate first the <code>¬</code>, then the <code>∧</code>, then the <code>∨</code>, and lastly the <code>→</code>. Thus the <code>→</code> is the top-level operator.</p><h2 id=classifying-truth-tables>Classifying truth tables</h2><p>In our study of logic, it will be convenient to characterize logical formula with a description of their truth tables. We will classify each logical formula in one of three ways:</p><ul><li><em>Tautology</em> - when all truth assignments for a logical formula are true</li><li><em>Contradictory</em> - when all truth assignments for a logical formula are false</li><li><em>Contingent</em> - when some truth assignments for a logical formula are true and some are false.</li></ul><p>For example, <code>p ∨ ¬ p</code> is a <em>tautology</em>. Whether <code>p</code> is true or false, <code>p ∨ ¬ p</code> is always true.</p><p>On the other hand, <code>p ∧ ¬ p</code> is <em>contradictory</em>. Whether <code>p</code> is true or false, <code>p ∧ ¬ p</code> is always false.</p><p>Finally, something like <code>p ∨ q</code> is <em>contingent</em>. When <code>p</code> and <code>q</code> are both false, then <code>p ∨ q</code> is false. However, <code>p ∨ q</code> is true in every other case.</p><p>If all truth assignments for a logical formula are True, the formula is said to be a tautology.</p><h2 id=logika-syntax>Logika syntax</h2><p>From this point forward, the course will expect you to use Logika formatted truth tables. The Logika truth table for the formula <code>¬(p ∧ q)</code> is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>p q # !(p &amp; q)
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>T T # F T T T
</span></span><span style=display:flex><span>T F # T T F F
</span></span><span style=display:flex><span>F T # T F F T
</span></span><span style=display:flex><span>F F # T F F F
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T F] [F T] [F F]
</span></span><span style=display:flex><span>F: [T T]</span></span></code></pre></div><p>Logika truth tables have standard format (syntax) and semantic meanings. All elements of the truth table must be included to be considered correct.</p><ol><li><p>The first line should have a single asterisk (*) over the top-level operator in the formula.</p></li><li><p>Next is a line of - (minus sign) characters, which must be at least as long as the third line to avoid getting errors.</p></li><li><p>The third line contains <code>variables | formula</code>. As Logika uses some capital letters as reserved words, you should use lower-case letters as variable names. Additionally, variables should be listed alphabetically.</p></li><li><p>The fourth line is another row of -, which is the same length as the second line.</p></li><li><p>Next come the truth assignments. Under the variables, list all possible combinations of T and F. Start with all T and progress linearly to all F. (T and F must be capitalized.)
After the Truth assignments is another row of -. Using each truth assignment, fill in truth assignments (T or F) under each operator in the formula in order of precedence (with the top-level operator applied last). Optionally, you can fill in the values for each variable under the forumla (as in the example above). However, it is only required that you fill in the truth assignments under each operator. Be careful to line up the truth assignments DIRECTLY below each operator, as Logika will reject truth tables that aren&rsquo;t carefully lined up.</p></li><li><p>Under the truth assignments, put another line of - (minus sign) characters, which should be the same length as the second line.</p></li><li><p>Finally, classify the formula as either <code>Tautology</code> (if everything under the top-level operator is T), <code>Contradictory</code> (if everything under the top-level operator is F), or <code>Contingent</code> (if there is a mix of T and F under the top-level operator). If the formula is contingent, you must also list which truth assignments made the formula true (i.e., which truth assignments made the top-level operator T) and which truth assignments made the formula false. Follow the image above for the syntax of how to list the truth assignments for contingent examples.</p></li></ol><h2 id=logical-operators-in-logika>Logical operators in Logika</h2><p>You may notice that the example above appears to use the <code>!</code> operator for NOT and the <code>&</code> operator for AND. However, what is shown above demonstrates what we TYPE into Logika, and not what is actually displayed. If we copy and paste the example into a new Logika file, it will look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>      *
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>p q # ¬(p ∧ q)
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>T T # F T T T
</span></span><span style=display:flex><span>T F # T T F F
</span></span><span style=display:flex><span>F T # T F F T
</span></span><span style=display:flex><span>F F # T F F F
</span></span><span style=display:flex><span>-----------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T F] [F T] [F F]
</span></span><span style=display:flex><span>F: [T T]</span></span></code></pre></div><p>Here is a summary of what keys to type in Logika for each traditional logical operator:</p><table><thead><tr><th>Logical operator</th><th>What to TYPE in Logika</th><th>What you will SEE in Logika</th></tr></thead><tbody><tr><td>NOT</td><td><code>!</code></td><td><code>¬</code></td></tr><tr><td>OR</td><td><code>|</code></td><td><code>∨</code></td></tr><tr><td>AND</td><td><code>&</code></td><td><code>∧</code></td></tr><tr><td>IMPLIES</td><td><code>->:</code></td><td><code>→:</code></td></tr></tbody></table><p>In the remainder of this book, my examples will be of what you will SEE in Logika.</p><h2 id=logika-mishandling-of-implies-operator>Logika mishandling of implies operator</h2><p>While the correct order of operations for logical operations is NOT, AND, OR, IMPLIES (from highest precedence to lowest precedence), the Logika tool does not handle the precedence of the implies operator correctly. The characters used for the implies operator in Logika are <code>->:</code> &ndash; however, since Logika takes advantage of Scala&rsquo;s operator precedence, this means that it interprets an implies operation as having the same (higher) precedence as a minus operation. In this class, we will always use parentheses to force the implies to have the correct precedence.</p><p>This incorrect precedence will only be present in our unit on truth tables &ndash; other proofs in Logika will use a different operator for implies (<code>__>:</code>) to avoid the issue of being interpreted as a minus operation. (We cannot use <code>__>:</code> in truth tables as the rendering makes the column alignment unclear.)</p><h2 id=example>Example</h2><p>Suppose we want to write a Logika truth table for:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(p ∧ q) → ¬r</span></span></code></pre></div><p>First, we make sure we have a new file in Sireum with the <code>.logika</code> extension. Then, we construct this truth table shell:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p ∧ q) →: ¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #
</span></span><span style=display:flex><span>T T F #
</span></span><span style=display:flex><span>T F T #
</span></span><span style=display:flex><span>T F F #
</span></span><span style=display:flex><span>F T T #
</span></span><span style=display:flex><span>F T F #
</span></span><span style=display:flex><span>F F T #
</span></span><span style=display:flex><span>F F F #
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>In the table above, we noticed that the <code>→</code> operator was the top-level operator according to our operator precedence rules.</p><p>Next, we fill in the output for the corresponding truth assignment under each operator, from highest precedence to lowest precedence. First, we evaluate the parentheses, which have the highest precedence. For example, we put a <code>T</code> under the <code>∧</code> in the first row, as <code>p</code> and <code>q</code> are both <code>T</code> in that row, and <code>T ∧ T</code> is <code>T</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p ∧ q) →: ¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T
</span></span><span style=display:flex><span>T T F #    T
</span></span><span style=display:flex><span>T F T #    F
</span></span><span style=display:flex><span>T F F #    F
</span></span><span style=display:flex><span>F T T #    F
</span></span><span style=display:flex><span>F T F #    F
</span></span><span style=display:flex><span>F F T #    F
</span></span><span style=display:flex><span>F F F #    F
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>In this example, we are only filling in under each operator (instead of also transcribing over each variable value), but either approach is acceptable.</p><p>Next, we fill in under the ¬ operator, which has the next-highest precedence:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p ∧ q) →: ¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T       F
</span></span><span style=display:flex><span>T T F #    T       T
</span></span><span style=display:flex><span>T F T #    F       F
</span></span><span style=display:flex><span>T F F #    F       T
</span></span><span style=display:flex><span>F T T #    F       F
</span></span><span style=display:flex><span>F T F #    F       T
</span></span><span style=display:flex><span>F F T #    F       F
</span></span><span style=display:flex><span>F F F #    F       T
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>Then, we fill in under our top-level operator, the <code>→</code>. Notice that we must line up the <code>T/F</code> values under the <code>→</code> in the <code>→:</code> symbol. For example, we put a <code>F</code> under the <code>→:</code> on the first row, as <code>(p ∧ q)</code> is <code>T</code> there and <code>¬r</code> is <code>F</code>, and we know that <code>T→F</code> is <code>F</code> because it describes a broken promise.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p ∧ q) →: ¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T    F  F
</span></span><span style=display:flex><span>T T F #    T    T  T
</span></span><span style=display:flex><span>T F T #    F    T  F
</span></span><span style=display:flex><span>T F F #    F    T  T
</span></span><span style=display:flex><span>F T T #    F    T  F
</span></span><span style=display:flex><span>F T F #    F    T  T
</span></span><span style=display:flex><span>F F T #    F    T  F
</span></span><span style=display:flex><span>F F F #    F    T  T
</span></span><span style=display:flex><span>----------------------</span></span></code></pre></div><p>Lastly, we examine the list of outputs under the top-level operator. We see that some truth assignments made the formula true, and that others (one) made the formula false. Thus, the formula is contingent. We label it as such, and list which truth assignments made the formula true and which made it false:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                *
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>p q r # (p ∧ q) →: ¬r
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>T T T #    T    F  F
</span></span><span style=display:flex><span>T T F #    T    T  T
</span></span><span style=display:flex><span>T F T #    F    T  F
</span></span><span style=display:flex><span>T F F #    F    T  T
</span></span><span style=display:flex><span>F T T #    F    T  F
</span></span><span style=display:flex><span>F T F #    F    T  T
</span></span><span style=display:flex><span>F F T #    F    T  F
</span></span><span style=display:flex><span>F F F #    F    T  T
</span></span><span style=display:flex><span>----------------------
</span></span><span style=display:flex><span>Contingent
</span></span><span style=display:flex><span>T: [T T F] [T F T] [T F F] [F T T] [F T F] [F F T] [F F F]
</span></span><span style=display:flex><span>F: [T T T]</span></span></code></pre></div><p>If you typed everything correctly and run a Logika check (<code>Ctrl-Shift-W</code> in Windows and <code>Command-Shift-W</code> on Mac), you should see a popup in Sireum logika that says: &ldquo;Logika Verified&rdquo; (yours will not have the purple checkmark, but will have the same text)</p><p><a href=#R-image-64771e6f824fc190de53b41f266e34cd class=lightbox-link><img alt="truth table verified" class="border lazy lightbox figure-image" loading=lazy src=/cis301/images/ttVerified.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-64771e6f824fc190de53b41f266e34cd><img alt="truth table verified" class="border lazy lightbox lightbox-image" loading=lazy src=/cis301/images/ttVerified.png></a></p><p>If you instead see red error markings, hover over them and read the explanations &ndash; it means there are errors in your truth table.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/467475d6e999a85d25219cbac9ed04ab55a2f0d0>Jan 16, 2025</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class=default-animation><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/index.html><input type=checkbox id=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9 aria-controls=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9><label for=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/index.html><b>0. </b>Getting Started</a><ul id=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9 class=collapsible-menu><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/index.html><a class=padding href=/cis301/0-chapter/0_1-toolsguide/index.html>0.1. Tools Guide</a></li><li data-nav-id=/cis301/0-chapter/0_2-gitinstall/index.html><a class=padding href=/cis301/0-chapter/0_2-gitinstall/index.html>0.2. git Install</a></li></ul></li><li data-nav-id=/cis301/1-chapter/index.html><input type=checkbox id=R-section-cbcda2db56d129074f1e03beb13f9103 aria-controls=R-subsections-cbcda2db56d129074f1e03beb13f9103><label for=R-section-cbcda2db56d129074f1e03beb13f9103><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/index.html><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-cbcda2db56d129074f1e03beb13f9103 class=collapsible-menu><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/index.html><a class=padding href=/cis301/1-chapter/1_1-logicbasics/index.html>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/index.html><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/index.html>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/index.html><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/index.html>1.3. Other Puzzles</a></li></ul></li><li class=parent data-nav-id=/cis301/2-chapter/index.html><input type=checkbox id=R-section-d672bd5f3e40d734b815889ecb0b088e aria-controls=R-subsections-d672bd5f3e40d734b815889ecb0b088e checked><label for=R-section-d672bd5f3e40d734b815889ecb0b088e><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/index.html><b>2. </b>Truth Tables</a><ul id=R-subsections-d672bd5f3e40d734b815889ecb0b088e class=collapsible-menu><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/index.html><a class=padding href=/cis301/2-chapter/2_1-opscircuits/index.html>2.1. Operators and Circuits</a></li><li class=active data-nav-id=/cis301/2-chapter/2_2-logikatruth/index.html><a class=padding href=/cis301/2-chapter/2_2-logikatruth/index.html>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/index.html><a class=padding href=/cis301/2-chapter/2_3-satis/index.html>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/index.html><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/index.html>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/index.html><a class=padding href=/cis301/2-chapter/2_5-sementail/index.html>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/index.html><input type=checkbox id=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73 aria-controls=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73><label for=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/index.html><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73 class=collapsible-menu><li data-nav-id=/cis301/3-chapter/3_1-propatom/index.html><a class=padding href=/cis301/3-chapter/3_1-propatom/index.html>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/index.html><a class=padding href=/cis301/3-chapter/3_2-notandor/index.html>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/index.html><a class=padding href=/cis301/3-chapter/3_3-implies/index.html>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/index.html><a class=padding href=/cis301/3-chapter/3_4-equiv/index.html>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/index.html><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/index.html>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/index.html><input type=checkbox id=R-section-a0d0660e4f5f539642b53fac77ff44c7 aria-controls=R-subsections-a0d0660e4f5f539642b53fac77ff44c7><label for=R-section-a0d0660e4f5f539642b53fac77ff44c7><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/index.html><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-a0d0660e4f5f539642b53fac77ff44c7 class=collapsible-menu><li data-nav-id=/cis301/4-chapter/4_1-intro/index.html><a class=padding href=/cis301/4-chapter/4_1-intro/index.html>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/index.html><a class=padding href=/cis301/4-chapter/4_2-andrules/index.html>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/index.html><a class=padding href=/cis301/4-chapter/4_3-orrules/index.html>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/index.html><a class=padding href=/cis301/4-chapter/4_4-impliesrules/index.html>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/index.html><a class=padding href=/cis301/4-chapter/4_5-notrules/index.html>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/index.html><a class=padding href=/cis301/4-chapter/4_6-strategies/index.html>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/index.html><a class=padding href=/cis301/4-chapter/4_7-theorems/index.html>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/index.html><a class=padding href=/cis301/4-chapter/4_8-equivalence/index.html>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/index.html><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/index.html>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/index.html><input type=checkbox id=R-section-589c35b8ff6263b7311a10a4d0fa83a9 aria-controls=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9><label for=R-section-589c35b8ff6263b7311a10a4d0fa83a9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/index.html><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9 class=collapsible-menu><li data-nav-id=/cis301/5-chapter/5_1-motivation/index.html><a class=padding href=/cis301/5-chapter/5_1-motivation/index.html>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/index.html><a class=padding href=/cis301/5-chapter/5_2-predsyntax/index.html>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/index.html><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/index.html>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/index.html><a class=padding href=/cis301/5-chapter/5_4-multquant/index.html>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/index.html><input type=checkbox id=R-section-55edc31437b1ec5edead9beb4ef7d1fa aria-controls=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa><label for=R-section-55edc31437b1ec5edead9beb4ef7d1fa><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/index.html><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa class=collapsible-menu><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/index.html><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/index.html>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/index.html><a class=padding href=/cis301/6-chapter/6_1-univrules/index.html>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/index.html><a class=padding href=/cis301/6-chapter/6_2-existrules/index.html>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/index.html><a class=padding href=/cis301/6-chapter/6_3-nested/index.html>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/index.html><a class=padding href=/cis301/6-chapter/6_4-equiv/index.html>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/index.html><a class=padding href=/cis301/6-chapter/6_5-strategies/index.html>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/index.html><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/index.html>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/index.html><input type=checkbox id=R-section-cbba04bde749b4229ea56fb5a7c6a953 aria-controls=R-subsections-cbba04bde749b4229ea56fb5a7c6a953><label for=R-section-cbba04bde749b4229ea56fb5a7c6a953><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/index.html><b>7. </b>Mathematical Induction</a><ul id=R-subsections-cbba04bde749b4229ea56fb5a7c6a953 class=collapsible-menu><li data-nav-id=/cis301/7-chapter/7_1-process/index.html><a class=padding href=/cis301/7-chapter/7_1-process/index.html>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/index.html><a class=padding href=/cis301/7-chapter/7_2-algebraex/index.html>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/index.html><a class=padding href=/cis301/7-chapter/7_3-divex/index.html>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/index.html><a class=padding href=/cis301/7-chapter/7_4-setex/index.html>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/index.html><input type=checkbox id=R-section-010016ee1ce3fc8b575a95f1204dba7b aria-controls=R-subsections-010016ee1ce3fc8b575a95f1204dba7b><label for=R-section-010016ee1ce3fc8b575a95f1204dba7b><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/index.html><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-010016ee1ce3fc8b575a95f1204dba7b class=collapsible-menu><li data-nav-id=/cis301/8-chapter/8_1-goal/index.html><a class=padding href=/cis301/8-chapter/8_1-goal/index.html>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/index.html><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/index.html>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/index.html><a class=padding href=/cis301/8-chapter/8_3-assertassume/index.html>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/index.html><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/index.html>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/index.html><a class=padding href=/cis301/8-chapter/8_5-assignment/index.html>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/index.html><a class=padding href=/cis301/8-chapter/8_6-divmod/index.html>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/index.html><a class=padding href=/cis301/8-chapter/8_7-conditionals/index.html>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/index.html><input type=checkbox id=R-section-6864880b2cc643485ab906a5e309eaaf aria-controls=R-subsections-6864880b2cc643485ab906a5e309eaaf><label for=R-section-6864880b2cc643485ab906a5e309eaaf><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/index.html><b>9. </b>Functions and Loops</a><ul id=R-subsections-6864880b2cc643485ab906a5e309eaaf class=collapsible-menu><li data-nav-id=/cis301/9-chapter/9_1-functions/index.html><a class=padding href=/cis301/9-chapter/9_1-functions/index.html>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/index.html><a class=padding href=/cis301/9-chapter/9_2-recursion/index.html>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/index.html><a class=padding href=/cis301/9-chapter/9_3-loops/index.html>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/index.html><a class=padding href=/cis301/9-chapter/9_4-logikafacts/index.html>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/index.html><a class=padding href=/cis301/9-chapter/9_5-summary/index.html>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/index.html><input type=checkbox id=R-section-b363793b1b72566b579f69cd488e8039 aria-controls=R-subsections-b363793b1b72566b579f69cd488e8039><label for=R-section-b363793b1b72566b579f69cd488e8039><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/index.html><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-b363793b1b72566b579f69cd488e8039 class=collapsible-menu><li data-nav-id=/cis301/10-chapter/10_1-modes/index.html><a class=padding href=/cis301/10-chapter/10_1-modes/index.html>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/index.html><a class=padding href=/cis301/10-chapter/10_2-intosequences/index.html>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/index.html><a class=padding href=/cis301/10-chapter/10_3-seqfn/index.html>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/index.html><a class=padding href=/cis301/10-chapter/10_4-seqloop/index.html>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/index.html><a class=padding href=/cis301/10-chapter/10_5-globals/index.html>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/index.html><a class=padding href=/cis301/10-chapter/10_6-termination/index.html>10.6 Termination</a></li></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul><li class=R-variantswitcher><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.relearn.markVariant()</script></li></ul></div><div id=R-footer><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></aside><script src=/cis301/js/clipboard/clipboard.min.js?1755885657 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1755885657 defer></script><script src=/cis301/js/theme.min.js?1755885657 defer></script></body></html>