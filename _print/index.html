<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.0.3+tip">




	
	
			

	
	
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Homepage :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/" rel="canonical" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/index.xml" rel="alternate" type="application/rss+xml" title="CIS 301 Textbook">
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1662576092" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1662576092" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1662576092" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <noscript>
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1662576092" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1662576092" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1662576092" rel="stylesheet">
    </noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1662576092" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1662576092" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1662576092" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1662576092" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-light-theme.css?1662576092" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1662576092" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1662576092" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1662576092" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1662576092"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis301/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1662576092" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/jquery.min.js?1662576092" defer></script>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/">
    
    
    <div id="body" class="default-animation">
      
      
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/" title="Getting Started (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <span class="nav nav-prev"><i class="fa fa-chevron-left fa-fw"></i></span>
          </div>
          <div id="top-print-link">
            <a class="print-link" title='Print whole chapter (CTRL+ALT+p)' href="https://ksu-cs-textbooks.github.io/cis301/_print/">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="top-github-link">
            <a class="github-link" title='Edit (CTRL+ALT+e)' href="https://gitlab.cs.ksu.edu/-/ide/project/cs-textbooks/cis301-textbook/edit/master/-/content//_index.md" target="blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/" aria-disabled="true"><span itemprop="name">Homepage</span></a></li>
            </ol>
          </div>
        </div>
      </nav>
      
      
      <main id="body-inner" class="highlightable home" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
    
          <article class="home deprecated">

<h1 id="cis-301-textbook">CIS 301 Textbook</h1>
<p>Julie Thornton <br>
Department of Computer Science <br>
Kansas State University</p>
<p>Email: 

<a href="mailto:juliet@ksu.edu">juliet@ksu.edu</a></p>
<p>This is the textbook for CIS 301, <em>Logical Foundations of Programming</em>, at Kansas State University. It is adapted from two previous versions of the course text:</p>
<ul>
<li>
<p>

<a href="https://people.cs.ksu.edu/~schmidt/301s14/Lectures/home.html" target="_blank" rel="noopener">CIS 301 Lecture Notes</a>, by Dr. David Schmidt</p>
</li>
<li>
<p>

<a href="http://logika.v3.sireum.org/dschmidt/" target="_blank" rel="noopener">Logika: Programming Logics</a> adpated from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi</p>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

            <section>
    
    
    
          <article class="chapter deprecated">

<h1 id="getting-started">Getting Started</h1>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Tools Guide</h1>
    
    
<h2 id="github-account">GitHub account</h2>
<p>First, you will need to create a GitHub account 

<a href="https://github.com/" target="_blank" rel="noopener">here</a>. If you already have one, you can use your existing account.</p>
<p>Your GitHub account will need to be set up to use two-factor authentication (a new requirement). When logged into your GitHub account (link above), click your icon in the upper-left corner (it will say &ldquo;Signed in as&hellip;(your account name)&rdquo;). Select &ldquo;Settings&rdquo; and then &ldquo;Account security&rdquo;. Scroll down until you find &ldquo;Two-factor authentication&rdquo;. If it is disabled, then enable it. I use an SMS number, but you are welcome to use an authenticator app instead (I&rsquo;m not familiar with that process, though).</p>
<h2 id="sireum-logika">Sireum Logika</h2>
<p>In CIS 301, we will use a tool called Logika, which is a verifier and a proof checker for propositional, predicate, and programming logic. You will need to install the IntelliJ-based Sireum IVE (Integrated Verification Environment), which contains Logika.</p>
<p>First, watch 

<a href="http://files.sireum.org/media/sireum-ive-win64.mp4" target="_blank" rel="noopener">this video</a> on the installation process.</p>
<p>Next, go 

<a href="http://logika.v3.sireum.org/doc/01-getting-started/index.html" target="_blank" rel="noopener">here</a> to install Logika.</p>
<p>Under 1.1.1 Installation, with the Release tab selected, choose either IVE for Windows or IVE for macOS. The instructions below should update based on your selection. For Windows, you will see:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/downloadSireum.png" alt="download Sireum"></p>
<p>Follow the instructions to download and run Logika. For Windows, uncompress the download DIRECTLY on the C:\ drive (not in any subfolders). For Mac, put the Sireum application into the Applications folder.</p>
<p>For Windows users, I recommend pinning the Sireum IVE to your taskbar. After you run the exe file, you can right-click the icon in the taskbar and select &ldquo;pin to taskbar&rdquo;.</p>
<p>Most Windows users will want to run <em>idea64.exe</em>. If you get a &ldquo;Windows protected your PC&rdquo; message, click &ldquo;More info&rdquo; and then &ldquo;Run anyway&rdquo;.</p>
<h2 id="using-github-to-start-homework-assignments">Using GitHub to start homework assignments</h2>
<p>To start a homework assignment (or to clone any existing repository, including homework solutions and lecture examples), first:</p>
<ul>
<li>Click to &ldquo;accept the assignment&rdquo; from the link in Canvas (if you are cloning a homework assignment or solution).</li>
<li>Go to the URL created for your assignment (or to the URL of the repository you want to clone).</li>
<li>You should be looking at a website that looks something like this:</li>
</ul>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/gitHubAssign.png" alt="GitHub assignment"></p>
<p>Click the Green <em>Code</em> button, so that you see something like this:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/gitHubClone.png" alt="GitHub clone"></p>
<p>Click the clipboard icon nest to the listed URL to copy it to your clipboard.
Next, open Sireum IVE. You should see:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/openSireum.png" alt="Open Sireum"></p>
<p>Click <em>Get from VCS</em>. Now you should see something like:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/getFromVCS.png" alt="Get from VCS"></p>
<p>Paste the URL you copied from GitHub in the <em>URL</em> textbox above.
Under <em>Directory</em>, navigate to a folder on your computer specifically for CIS 301 (create one if it doesn&rsquo;t exist). Create a new empty folder within that CIS 301 folder to hold this new project. Select that new folder in the <em>Directory</em> box, so that you now have something like this:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/cloneToSireum.png" alt="Clone to Sireum"></p>
<p>Click <em>Clone</em>. You should see a popup like this:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/loginViaGitHub.png" alt="Login via GitHub"></p>
<p>Click <em>Use Token</em>. Now you see:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/generateToken.png" alt="Generate token"></p>
<p>Click <em>Generate&hellip;</em> This will bring up a browser asking you to login to your GitHub account. Do so there. It will then bring up a page about a <em>New personal access token</em>. Edit the expiration date of the token so that it expires after the end of the semester. Scroll down to the bottom of that page and click <em>Generate token</em>.</p>
<p>This should bring a new page that says <em>Personal access tokens</em>. There should be a token that is highlighted in green with a clipboard icon next to it. Click the clipboard icon to copy the token. If you get an error in the GitHub page when creating your token that says, <em>Note has already been taken</em>, just change the listed note to anything else (it says <em>IntelliJ IDEA GitHub integration plugin</em> by default, but you can edit it to whatever you want.</p>
<p>Go back to the dialog in Sireum/IntelliJ and paste in your token in the textbox. Click <em>Log In</em>.  You should see something like this:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/openProject.png" alt="Open project "></p>
<p>If you don&rsquo;t see the panel on the left side, click the <em>Project</em> label on the left border. Expand the <em>src</em> folder to see your starting files. Now you can double-click one of those src files to view and edit it.</p>
<h2 id="check-your-github-settings-in-sireum-ive">Check your GitHub settings in Sireum IVE</h2>
<p>After successfully cloning a GitHub repository, check your GitHub settings in Sireum/IntelliJ. Go to File→Settings, then Version Control, then GitHub. If you see your GitHub account listed, like this, then you are done:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/checkSettings.png" alt="Check settings"></p>
<p>If you don&rsquo;t see your GitHub account, click the + icon and then <em>Login with token&hellip;</em>. Paste in the same personal access token you used before, and select <em>Add Account</em>:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/addAccount.png" alt="Add account"></p>
<h2 id="committing-and-pushing-changes">Committing and pushing changes</h2>
<p>When you are finished working, commit and push your changes to GitHub. (I recommend doing this anytime you are at a stopping point, as well as when you are completely done.)</p>
<p>To do this, select <em>Git</em> in the menu, then <em>Commit</em>. Type in something under <em>Commit Message</em>. Click the down arrow next to the Commit button at the bottom, and select <em>Commit and Push</em>:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/commitAndPush.png" alt="Commit and push"></p>
<p>In the resulting dialog, click <em>Push</em>. The first time you commit and push in IntelliJ, it will likely ask you to enter your name and email (this is just for documentation purposes in your repository). Enter them in the dialog and say OK.</p>
<p>If you go back to the URL of your GitHub repository and refresh the page, you should see your latest work.</p>
<p>Homework 0 will help you test the GitHub process.</p>
<h2 id="cloning-additional-repositories">Cloning additional repositories</h2>
<p>Sireum IVE looks a little different after it has been run the first time. If you want to clone a second (or third, etc.) repository, first open Sireum. It will automatically open your most recent project.</p>
<p>To clone a new project, select <em>File→New→Project</em> from <em>Version control</em>. Then, follow the instructions in <em>Using GitHub to start homework assignments</em> above. You will likely not have to do anything with a personal access token or with entering information about your GitHub account. If you do have trouble working with additional repositories, though, I recommend trying to generate a new personal access token when prompted.</p>
<h2 id="using-sireum-ive-in-the-lab-classrooms">Using Sireum IVE in the lab classrooms</h2>
<p>Sireum IVE(with Logika) is available in the CS computer lab classrooms (DUE 1114, 1116, and 1117). To find it, open a File Explorer, then open the C:\ drive. You will see a Sireum folder – double-click it (just plain <em>Sireum</em>, not with any v2 or v3). From there, you should see the file idea64.bat. Double-click it to run Sireum IVE.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-1">Chapter 1</h3>
<h1 id="basics-and-logic-puzzles">Basics and Logic Puzzles</h1>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Basic Logical Reasoning</h1>
    
    
<h2 id="what-is-logical-reasoning">What is logical reasoning?</h2>
<p>Logical reasoning is an analysis of an argument according to a set of rules. In this course, we will be learning several sets of rules for more formal anlaysis, but for now we will informally analyze English sentences and logic puzzles. This will help us practice the careful and rigorous thinking that we will need in formal proofs and in computer science in general.</p>
<h2 id="premises-and-conclusions">Premises and conclusions</h2>
<p>A <em>premise</em> is a piece of information that we are given in a logical argument. In our reasoning, we assume premises are true &ndash; even if they make no sense!</p>
<p>A <em>conclusion</em> in a logical argument is a statement whose validity we are checking. Sometimes we are given a conclusion, and we are trying to see whether that conclusion makes sense when we assume our premises are true. Other times, we are asked to come up with our own (valid) conclusion that we can deduce from our premises.</p>
<h2 id="example">Example</h2>
<p>Suppose we are given the following premises:</p>
<ul>
<li>Premise 1: <em>If a person wears a red shirt, then they don&rsquo;t like pizza.</em></li>
<li>Premise 2: <em>Fred is wearing a red shirt.</em></li>
</ul>
<p>Given those pieces of information, can we conclude the following?</p>
<p><em>Fred doesn&rsquo;t like pizza.</em></p>
<p>Yes! We take the premises at face value and assume them to be true (even though it is kind of ridiculous that shirt color has anything to do with a dislike of pizza). The first premise PROMISES that any time we have a person with a red shirt, then that person does not like pizza. Since Fred is such a person, we can conclude that Fred doesn&rsquo;t like pizza.</p>
<h2 id="logical-arguments-with-or">Logical arguments with &ldquo;OR&rdquo;</h2>
<p>Interpreting English sentences that use the word &ldquo;or&rdquo; can be tricky &ndash; the or can either be an <em>inclusive or</em> or an <em>exclusive or</em>. In programming, we are used to using an inclusive or &ndash; a statement like <code>p || q</code> is true as long as at least one of <code>p</code> or <code>q</code> is true, even if both are true. The only time a statement like <code>p || q</code> is false is if both <code>p</code> and <code>q</code> are false.</p>
<p>In English, however, the word &ldquo;or&rdquo; often implies an exclusive or. If a restaurant advertises that customers can choose &ldquo;chips or fries&rdquo; as the side for their meal, they are certainly not intending that a customer demand both sides.</p>
<p><b>However, since this course is focused on formal logic and analyzing computer programs and not so much on resolving language ambiguity, we will adopt the stance that the word &ldquo;or&rdquo; always means <em>inclusive or</em> unless otherwise specified.</b></p>
<h3 id="or-example-1">Or example #1</h3>
<p>With that in mind, suppose we have the following premises:</p>
<ul>
<li><em>I have a dog or I have a cat.</em></li>
<li><em>I do not have a cat.</em></li>
</ul>
<p>What can we conclude?</p>
<p>The only time an &ldquo;or&rdquo; statement true is when at least one of its parts is true. Since we already know that the right side of the or (&ldquo;I have a cat&rdquo;) is false, then we can conclude that the left side MUST be true. So we conclude:</p>
<p><em>I have a dog.</em></p>
<p>In general, if you have an or statement as a premise and you also know that one side of the or is NOT true, then you can always conclude that the other side of the or IS true.</p>
<h3 id="or-example-2">Or example #2</h3>
<p>Suppose we have the following premises:</p>
<ul>
<li><em>I have a bike or I have a car.</em></li>
<li><em>I have a bike.</em></li>
</ul>
<p>Can we conclude anything new?</p>
<p>First of all, I acknowledge that the most natural interpretation of the first premise is an exclusive or &ndash; that I have EITHER a bike OR a car, but not both. I think that is how most people would naturally interpret that sentence as well. However, in this course we will always consider &ldquo;or&rdquo; to be an inclusive or, unless we specifically use words like &ldquo;but not both&rdquo;.</p>
<p>With that in mind, the second premise is already sufficient to make the first premise true. Since I have a bike, the statement &ldquo;I have a bike or I have a car&rdquo; is already true, whether or not I have a car. Because of this, we can&rsquo;t draw any further conclusions beyond our premises.</p>
<h2 id="or-example-3">Or example 3</h2>
<p>Suppose we have the following premises:</p>
<ul>
<li><em>I either have a bike or a car, but not both.</em></li>
<li><em>I have a bike.</em></li>
</ul>
<p>What can we conclude?</p>
<p>This is the sentence structure I will use if I mean an exclusive or &ndash; &ldquo;either p or q but not both&rdquo;.</p>
<p>In this setup, we CAN conclude that I do not have a car. This is because an exclusive or is FALSE when both sides are true, and I already know that one side is true (I have a bike). The only way for the first premise to be true is when I do not also have a car.</p>
<h2 id="logical-arguments-with-ifthen-aka-implies-">Logical arguments with <em>if/then</em> (aka <em>implies</em>, →)</h2>
<p>Statements with of the form, <em>if p, then q</em> are making a promise &ndash; that if <em>p</em> is true, then they promise that <em>q</em> will also be true. We will later see this structure using the logical <em>implies</em> operator.</p>
<h3 id="ifthen-example-1">If/then example 1</h3>
<p>Suppose we have the following premises:</p>
<ul>
<li><em>If it is raining, then I will get wet.</em></li>
<li><em>It is raining.</em></li>
</ul>
<p>What can I conclude?</p>
<p>The first premises PROMISES that if it is raining, then I will get wet. Since we assume this premise is true, then we must keep the promise. Since the second premise tells us that it IS raining, then we can conclude:</p>
<p><em>I will get wet.</em></p>
<h3 id="ifthen-example-2">If/then example 2</h3>
<p>Suppose we have the following premises:</p>
<ul>
<li><em>If I don&rsquo;t hear my alarm, then I will be late for class.</em></li>
<li><em>I am late for class.</em></li>
</ul>
<p>Can we conclude anything new?</p>
<p>The first premise promises that if I don&rsquo;t hear my alarm, then I will be late for class. And if we knew that I didn&rsquo;t hear my alarm, then we would be able to conclude that I will be late for class (in order to keep the promise).</p>
<p>However, we do NOT know that I don&rsquo;t hear my alarm. All we are told is that I am late for class. I might be late for class for many reasons &ndash; maybe I got stuck in traffic, or my car broke down, or I got caught up playing a video game. We don&rsquo;t have enough information to conclude WHY I&rsquo;m late for class, and in fact we can&rsquo;t conclude anything new at at all.</p>
<h3 id="ifthen-example-3">If/then example 3</h3>
<p>Suppose we have the following premises:</p>
<ul>
<li><em>If I don&rsquo;t hear my alarm, then I will be late for class.</em></li>
<li><em>I&rsquo;m not late for class.</em></li>
</ul>
<p>What can we conclude?</p>
<p>This is a trickier example. We saw previously that the first premise promised that anytime I didn&rsquo;t hear my alarm, then I would be late for class. But we can interpret this another way &ndash; since I&rsquo;m NOT late for class, then I must have heard my alarm. After all, if I DIDN&rsquo;T hear my alarm, then I would have been late. But I&rsquo;m not late, so the opposite must be true. So we can conclude that:</p>
<p><em>I hear my alarm.</em></p>
<p>Reframing an if/then statement like that is called writing its <em>contrapositive</em>. Any time we have a statement of the form <em>if p, then q</em> then we can write the equivalent statement <em>if not q, then not p</em>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Knights and Knaves</h1>
    
    
<p>We will now move to solving several kinds of logic puzzles. While these puzzles aren&rsquo;t strictly necessary to understand the remaining course content, they require the same rigorous analysis that we will use when doing more formal truth tables and proofs. Plus, they&rsquo;re fun!</p>
<p>The puzzles in this section and the rest of this chapter are all either from or inspired by: <em>What is the Name of This Book?</em>, by Raymond Smullyan.</p>
<h2 id="island-of-knights-and-knaves">Island of Knights and Knaves</h2>
<p>This section will involve knights and knaves puzzles, where we meet different inhabitants of the mythical island of Knights and Knaves. Each inhabitant of this island is either a <em>knight</em> or a <em>knave</em>.</p>
<p>Knights ALWAYS tell the truth, and knaves ALWAYS lie.</p>
<h2 id="example-1">Example 1</h2>
<p>Can any inhabitant of the island of Knights and Knaves say, &ldquo;I&rsquo;m a knave&rdquo;?</p>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>No! A knight couldn&rsquo;t make that statement, as knights always tell the truth. And a knave couldn&rsquo;t make that statement either, since it would be true &ndash; and knaves always lie.</p>
</details>
<h2 id="example-2">Example 2</h2>
<p>You see two inhabitants of the island of Knights and Knaves &ndash; Ava and Bob.</p>
<ul>
<li>Ava says that Bob is a knave.</li>
<li>Bob says, &ldquo;Neither Ava nor I are knaves.&rdquo;</li>
</ul>
<p>What types are Ava and Bob?</p>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>Suppose Ava is a knight. Then her statement must be true, so Bob must be a knave. In this case, Bob&rsquo;s statement would be a lie (since he is a knave), which is what we want.</p>
<p>Let&rsquo;s make sure there aren&rsquo;t any other answers that work.</p>
<p>Suppose instead that Ava is a knave. Then her statement must be a lie, so Bob must be a knight. This would mean that Bob&rsquo;s statement should be true, but it&rsquo;s not &ndash; Ava <em>is</em> a knave.</p>
<p>We can conclude that Ava is a knight and Bob is a knave.</p>
</details>
<h2 id="example-3">Example 3</h2>
<p>If you see an &ldquo;or&rdquo; statement in a knights and knaves puzzle, assume that it means an <em>inclusive</em> or. This will match the <em>or</em> logical operator in our later truth tables and proofs, and will also match the or operator in programmimg.</p>
<p>You see two different inhabitants &ndash; Eve and Fred.</p>
<ul>
<li>Eve says, &ldquo;I am a knave or Fred is a knight.&rdquo;</li>
</ul>
<p>What types are Eve and Fred?</p>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>Suppose first that Eve is a knight. Then her statement must be true. Since she isn&rsquo;t a knave, the only way for her statement to be true is if Fred is a knight.</p>
<p>Let&rsquo;s make sure there aren&rsquo;t any other answers that work.</p>
<p>Suppose instead that Eve is a knave. Already we are in trouble &ndash; Eve&rsquo;s statement is already true no matter what type Fred is. Since Eve would lie if she was a knave, we know she must not be knave.</p>
<p>We can conclude that Eve and Fred are both knights.</p>
</details>
<h2 id="example-4">Example 4</h2>
<p>You see three new inhabitants &ndash; Sarah, Bill, and Mae.</p>
<ul>
<li>Sarah tells you that only a knave would say that Bill is a knave.</li>
<li>Bill claims that it&rsquo;s false that Mae is a knave.</li>
<li>Mae tells you, &ldquo;Bill would tell you that I am a knave.&rdquo;</li>
</ul>
<p>What types are Sarah, Bill, and Mae?</p>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>Before starting on this puzzle, it might help to rephrase Sarah&rsquo;s and Bill&rsquo;s statements. Sarah&rsquo;s statement that only a knave would say that Bill is knave is really saying that it is FALSE that Bill is a knave (since knaves lie). Another way to say it&rsquo;s false that Bill is a knave is to say that Bill is a knight. Similarly, we can rewrite Bill&rsquo;s statemnet to say that Mae is a knight.</p>
<p>Now we have the following statements:</p>
<ul>
<li>Sarah tells you that Bill is a knight.</li>
<li>Bill claims that Mae is a knight.</li>
<li>Mae tells you, &ldquo;Bill would tell you that I am a knave.&rdquo;</li>
</ul>
<p>Suppose Sarah is a knight. Then her statement is true, so Bill must also be a knight. This would mean Bill&rsquo;s statement would also be true, so Mae is a knight as well. But Mae says that Bill would say she&rsquo;s a knave, and that&rsquo;s not true &ndash; Bill would truthfully say that Mae is a knight.</p>
<p>Suppose instead that Sarah is a knave. Then her statement is false, so Bill must be a knave. This would make Bill&rsquo;s claim false as well, so Mae must be a knave. Mae knows that Bill would say she was a knight (since Bill is a knave, and would lie), and if Mae was a knave then she would indeed lie and say that Bill would say she was a knave.</p>
<p>We can conclude that all three are knaves.</p>
</details>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Other Puzzles</h1>
    
    
<p>We will look at a variety of other logic puzzles, each of which involve some statements being false and some statements being true.</p>
<h2 id="lion-and-unicorn">Lion and Unicorn</h2>
<p>The setup for a Lion and Unicorn puzzle can vary, but the idea is that both Lion and Unicorn have specific days that they tell only lies, and other specific days that they only tell the truth.</p>
<p>Here is one example:</p>
<blockquote>
<p>Lion always lies on Mondays, Tuesdays, and Wednesdays.<br>
Lion always tells the truth on other days.<br>
Unicorn always lies on Thursdays, Fridays, and Saturdays, and always tells the truth on other days. <br><br>
On Sunday, everyone tells the truth.
<br><br>
Lion says:  &ldquo;Yesterday was one of my lying days.&quot;<br>
Unicorn says:  &ldquo;Yesterday was one of my lying days, too.&rdquo;
<br><br>
What day is it?</p>
</blockquote>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>To solve this puzzle, we consider what Lion&rsquo;s and Unicorn&rsquo;s statements would mean on each different day of the week.</p>
<ul>
<li>
<p>Suppose it is Sunday. Then Lion&rsquo;s statement would be a lie (Lion does not lie on Saturday), and yet Lion is supposed to be telling the truth on Sunday.</p>
</li>
<li>
<p>Suppose it is Monday. Then both Lion&rsquo;s and Unicorn&rsquo;s statements would be lies, since they both told the truth yesterday (Sunday).</p>
</li>
<li>
<p>Suppose it is either Tuesday or Wednesday. Then Lion&rsquo;s statement would be true &ndash; but Lion is supposed to lie on both Tuesday and Wednesday.</p>
</li>
<li>
<p>Suppose it is Thursday. Then Lion&rsquo;s statement would be true (Wednesday was one of their lying days), which is good since Lion is supposed to be telling the truth on Thursdays. Similarly, Unicorn&rsquo;s statement would be false (Unicorn does not lie on Thursdays), which works out since Unicorn DOES lie on Thursdays.</p>
</li>
<li>
<p>Suppose it is either Friday or Saturday. Then Lion&rsquo;s statement would be a lie (Lion doesn&rsquo;t lie on either Thursday or Friday), but Lion should be telling the truth on Friday and Saturday.</p>
</li>
</ul>
<p>We can conclude that it must be Thursday.</p>
</details>
<h2 id="tweedledee-and-tweedledum">Tweedledee and Tweedledum</h2>
<p>The Tweedledee and Tweedledum puzzles originate from <em>Through the Looking-glass and What Alice Found There</em>, by Lewis Carroll. There are different versions of these puzzles as well, but all of them involve the identical twin creatures, Tweedledee and Tweedledum. Like with Lion and Unicorn, there are different days on which Tweedledee and Tweedledum either only lie or only tell the truth (and often one creature is lying while the other is telling the truth).</p>
<h3 id="example-1">Example 1</h3>
<p>Consider this puzzle:</p>
<blockquote>
<p>Tweedledee and Tweedledum are identical. You know that one of them lies Mon/Tues/Wed,and that the other lies Thurs/Fri/Sat. (They tell the truth on non-lying days.)
<br><br>
You don&rsquo;t know which is which.
<br><br>
You see both of them together. <br>
The first one says:  &ldquo;I&rsquo;m Tweedledum.&quot;<br>
The second one says:  &ldquo;I&rsquo;m Tweedledee.&rdquo;
<br><br>
Which is which?  What day is it?</p>
</blockquote>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>Answer: Since the two creatures gave different answers, we can conclude that they must both be lying or both telling the truth. (Otherwise, both creatures would give you the same name.) Sunday is the only such day.</p>
<p>Each is telling the truth, so the first twin is Tweedledum and the second is Tweedledee.</p>
</details>
<h3 id="example-2">Example 2</h3>
<p>Consider a second puzzle, with the same setup as to which days each twin lies and tells the truth.</p>
<blockquote>
<p>You know that either Tweedledum or Tweedledee has lost a rattle. You find it, and want to return it to the correct one. You don&rsquo;t know what day it is, but are sure that it isn&rsquo;t Sunday (so one must be lying and one must be telling the truth).
<br><br>
The first one says:  &ldquo;Tweedledee owns the rattle.&rdquo;
<br><br>
The second one says: &ldquo;I&rsquo;m Tweedledee ¬&rdquo;
<br><br>
Who gets the rattle?</p>
</blockquote>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>To solve this puzzle, we can explore the possibilities for each twin lying or telling the truth.</p>
<p>Suppose the first twin is telling the truth. Since it isn&rsquo;t Sunday, we know the second twin must be lying. If the second twin&rsquo;s statement is a lie, then the second is Tweedledum. Since the first twin is telling the truth, then they are Tweedledee (and the owner of the rattle).</p>
<p>Suppose instead that the first twin is lying. Again, since it isn&rsquo;t Sunday, we know the second twin must be telling the truth. This would make the second twin Tweedledee, and the first twin Tweedledum. It would also mean that TweedleDUM owns the rattle (since the first statement is a lie), which is the first twin.</p>
<p>We don&rsquo;t have enough information to determine which twin is which, but it doesn&rsquo;t matter &ndash; in both cases, the first twin is the owner of the rattle.</p>
</details>
<h2 id="portias-caskets">Portia&rsquo;s Caskets</h2>
<p>This type of puzzle originates from <em>The Merchant of Venice</em>, by William Shakespeare. In the play, Portia&rsquo;s father devised riddles to test potential suitors for his daughter.</p>
<p>Here is one such puzzle:</p>
<blockquote>
<p>There are three caskets – one gold, one silver, and one lead. One of the caskets contains a portrait (of Portia). Each casket has a message on it, and you know that at most one of the messages is true.
<br><br>
Gold casket message: &ldquo;The portrait is in this casket.&rdquo;
Silver casket message: &ldquo;The portrait is not in this casket.&rdquo;
Lead casket message: &ldquo;The portrait is not in the gold casket.&rdquo;
<br><br>
Where is the portrait?</p>
</blockquote>
<details>
    <summary> <b> -→ Click for solution </b></summary>
<p>To solve this puzzle, we recognize that there are only three possibilities &ndash; the portrait must be in either the gold casket, the silver casket, or the lead casket. We consider the implications of each:</p>
<p>Suppose the portrait is in the gold casket. Then the messages on both the gold and silver caskets would be true. This isn&rsquo;t possible, as we know that at most one of the messages is true.</p>
<p>Suppose instead that the portait is in the silver casket. Then the messages on the gold and silver caskets would be false, and the message on the lead casket would be true. Only one message is true, so this is a possibility.</p>
<p>Finally, suppose the portrait is in the lead casket. Then the messages on all three caskets would be true, so this isn&rsquo;t possible.</p>
<p>We conclude that the portrait must be in the silver casket.</p>
</details>
            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-2">Chapter 2</h3>
<h1 id="truth-tables">Truth Tables</h1>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Operators and Circuits</h1>
    
    
<p>In this chapter, we review basic notions about gates and learn the relationship between circuits and assignment-based computer programs. This sets the stage for analyzing modern programs.</p>
<h2 id="logical-operators">Logical operators</h2>
<p>There are four basic logic gates, with corresponding logical operators:</p>
<table>
<thead>
<tr>
<th>Meaning</th>
<th>Logical Operator</th>
<th>Logic Gate</th>
</tr>
</thead>
<tbody>
<tr>
<td>p AND q</td>
<td><code>p ∧ q</code></td>
<td><img src="https://ksu-cs-textbooks.github.io/cis301/images/AND.png" alt="AND gate"></td>
</tr>
<tr>
<td>p OR q</td>
<td><code>p ∨ q</code></td>
<td><img src="https://ksu-cs-textbooks.github.io/cis301/images/OR.png" alt="OR gate"></td>
</tr>
<tr>
<td>NOT p</td>
<td><code>¬p</code></td>
<td><img src="https://ksu-cs-textbooks.github.io/cis301/images/NOT.png" alt="NOT gate"></td>
</tr>
<tr>
<td>p IMPLIES q</td>
<td><code>p → q</code></td>
<td><img src="https://ksu-cs-textbooks.github.io/cis301/images/IMPLIES.png" alt="IMPLIES gate"></td>
</tr>
</tbody>
</table>
<p>In the above drawings, the input wires are labelled with the names P and Q. The output that is computed is emitted from the rightmost wire which exits the gate. For these simple gates, it is possible to exhaustively test every permutation of potential inputs and summarize results in a table, called a truth table.</p>
<p>Let&rsquo;s examine the AND gate. The AND gate emits a high voltage (1) exactly when high voltages are sensed at input wires P and Q; otherwise low voltage (0) is emitted. The gate&rsquo;s physical behavior is summarized by in the following table:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>AND: P Q |
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>     1 1 | 1
</span></span><span style="display:flex;"><span>     1 0 | 0
</span></span><span style="display:flex;"><span>     0 1 | 0
</span></span><span style="display:flex;"><span>     0 0 | 0
</span></span></code></pre></div><h2 id="truth-tables">Truth tables</h2>
<p>For the remainder of this course, we will use T (read &ldquo;true&rdquo;) for 1 and F (read &ldquo;false&rdquo;) for 0. This is because we will examine applications that go far beyond circuit theory and base-two arithmetic. Here are the truth tables for the AND, OR, NOT and IMPLIES gates:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>AND: P Q |
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>     T T | T
</span></span><span style="display:flex;"><span>     T F | F
</span></span><span style="display:flex;"><span>     F T | F
</span></span><span style="display:flex;"><span>     F F | F
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>OR: P Q |
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>     T T | T
</span></span><span style="display:flex;"><span>     T F | T
</span></span><span style="display:flex;"><span>     F T | T
</span></span><span style="display:flex;"><span>     F F | F
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NOT: P |
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>     T | F
</span></span><span style="display:flex;"><span>     T | T
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IMPLIES: P Q |
</span></span><span style="display:flex;"><span>-----------------
</span></span><span style="display:flex;"><span>         T T | T
</span></span><span style="display:flex;"><span>         T F | F
</span></span><span style="display:flex;"><span>         F T | T
</span></span><span style="display:flex;"><span>         F F | T
</span></span></code></pre></div><p>A few comments:</p>
<ul>
<li>
<p>The OR gate is inclusive &ndash; as long as one of its inputs is true, then its output is true.</p>
</li>
<li>
<p>You might be confused by the IMPLIES gate. We&rsquo;ll cover it in detail below.</p>
</li>
<li>
<p>In the next section, we will learn to write our truth tables in a slightly different format so they can be automatically checked by Sireum Logika.</p>
</li>
</ul>
<h2 id="implies-operator">Implies operator</h2>
<p>The implies operator can be difficult to understand. It helps to think of it as a promise: we write <code>P → Q</code>, but we mean <em>If <code>P</code> is true, then I promise that <code>Q</code> will also be true.</em> If we BREAK our promise (i.e., if <code>P</code> is true but <code>Q</code> is false), then the output of an implies gate is false. In <em>every other situation</em>, the output of the implies gate is true.</p>
<p>As a reminder, here is the truth table for the implies operator, → :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>P Q | P → Q
</span></span><span style="display:flex;"><span>-----------------
</span></span><span style="display:flex;"><span>T T |   T
</span></span><span style="display:flex;"><span>T F |   F
</span></span><span style="display:flex;"><span>F T |   T
</span></span><span style="display:flex;"><span>F F |   T
</span></span></code></pre></div><p>It is likely clear why <code>P → Q</code> is true when both <code>P</code> and <code>Q</code> are true &ndash; in this situation, we have kept our promise.</p>
<p>It is also easy to understand why <code>P → Q</code> is false when <code>P</code> is true and <code>Q</code> is false. Here, we have broken our promise &ndash; <code>P</code> happened, but <code>Q</code> did not.</p>
<p>In the other two cases for <code>P → Q</code> we have that <code>P</code> is false (and <code>Q</code> is either true or false). Here, <code>P → Q</code> is true simply because we haven&rsquo;t broken our promise. In these cases, the implication is said to be <em>vacuously true</em> because we have no evidence to prove that it is false.</p>
<h2 id="circuits">Circuits</h2>
<p>We can also compose the gates to define new operations.</p>
<p>For example, this circuit:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/circuit1.png" alt="circuit combo"></p>
<p>Written <code>¬(P ∧ Q)</code>, defines this computation of outputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>P Q | ¬(P ∧ Q)
</span></span><span style="display:flex;"><span>-----------------
</span></span><span style="display:flex;"><span>T T | F
</span></span><span style="display:flex;"><span>T F | T
</span></span><span style="display:flex;"><span>F T | T
</span></span><span style="display:flex;"><span>F F | T
</span></span></code></pre></div><p>We can work out the outputs in stages, like this:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/NotLogikaTT.png" alt="circuit stages"></p>
<p>We begin by writing the value of each set of inputs on the left, under their corresponding symbol on the right. Next we apply the operator (gate) with the highest precedence (covered in <em>Operator Precedence</em> in the next section). In our case the <code>()</code> make the AND ( <code>∧</code> ) symbol the highest.</p>
<p>A truth assignment is a unique permutation of the possible inputs for a system. For the <code>∧</code>-gate, it is a 2-variable sequence. Considering the first row we see we have <code>T ∧ T</code>. Looking that up in the <code>∧</code>-gate truth table we see the result is also &ldquo;T&rdquo;, and we record that under the <code>∧</code> symbol. We do the same thing all the other truth assignments.</p>
<p>After the initial transcribing of the truth values under their respective variables, we look up the truth-values in the gate tables, not the variables. Also observe that while <code>∧</code> is symmetric &ndash; i.e. <code>T ∧ F</code> and <code>F ∧ T</code> are both false &ndash; the IMPLIES gate is not.</p>
<p>Now we look up the value under the <code>∧</code> symbol in the ¬ gate table. In the first row we see that the truth assignment for the first row, &ldquo;T&rdquo;, is &ldquo;F&rdquo; and record it under the <code>¬</code> symbol. Do this for every row and we are done.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Truth Tables in Logika</h1>
    
    
<p>Now that we&rsquo;ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.</p>
<h2 id="operator-precedence">Operator precedence</h2>
<p>Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.</p>
<p>Here is the precedence of the logical operators, from most important (do first) to least important (do last):</p>
<ol>
<li>Parentheses</li>
<li>Not operator, <code>¬</code></li>
<li>And operator, <code>∧</code></li>
<li>Or operator, <code>∨</code></li>
<li>Implies operator, <code>→</code></li>
</ol>
<p>For example, in the statement <code>(p ∨ q) ∧ ¬p</code>, we would evaluate the operators in the following order:</p>
<ol>
<li>The parentheses (which would resolve the <code>(p ∨ q)</code> expression)</li>
<li>The not, <code>¬</code></li>
<li>The and, <code>∧</code></li>
</ol>
<p>Sometimes we have more than one of the same operator in a single statement. For example: <code>p ∨ q ∨ r</code>. Different operators have different rules for resolving multiple occurrences:</p>
<ol>
<li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li>
<li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li>
<li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li>
<li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li>
<li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li>
</ol>
<h2 id="top-level-operator">Top-level operator</h2>
<p>In a logical statement, the <em>top-level operator</em> is the operator that is applied last (after following the precedence rules above).</p>
<p>For example, in the statement:</p>
<p><code>p ∨ q → ¬p ∧ r</code></p>
<p>We would evaluate first the <code>¬</code>, then the <code>∧</code>, then the <code>∨</code>, and lastly the <code>→</code>. Thus the <code>→</code> is the top-level operator.</p>
<h2 id="classifying-truth-tables">Classifying truth tables</h2>
<p>In our study of logic, it will be convenient to characterize logical formula with a description of their truth tables. We will classify each logical formula in one of three ways:</p>
<ul>
<li><em>Tautology</em> - when all truth assignments for a logical formula are true</li>
<li><em>Contradictory</em> - when all truth assignments for a logical formula are false</li>
<li><em>Contingent</em> - when some truth assignments for a logical formula are true and some are false.</li>
</ul>
<p>For example, <code>p ∨ ¬ p</code> is a <em>tautology</em>. Whether <code>p</code> is true or false, <code>p ∨ ¬ p</code> is always true.</p>
<p>On the other hand, <code>p ∧ ¬ p</code> is <em>contradictory</em>. Whether <code>p</code> is true or false, <code>p ∧ ¬ p</code> is always false.</p>
<p>Finally, something like <code>p ∨ q</code> is <em>contingent</em>. When <code>p</code> and <code>q</code> are both false, then <code>p ∨ q</code> is false. However, <code>p ∨ q</code> is true in every other case.</p>
<p>If all truth assignments for a logical formula are True, the formula is said to be a tautology.</p>
<h2 id="logika-syntax">Logika syntax</h2>
<p>From this point forward, the course will expect you to use Logika formatted truth tables. The Logika truth table for the formula <code>¬(p ∧ q)</code> is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>      *
</span></span><span style="display:flex;"><span>-----------------
</span></span><span style="display:flex;"><span>p q | ¬(p ∧ q)
</span></span><span style="display:flex;"><span>-----------------
</span></span><span style="display:flex;"><span>T T | F T T T
</span></span><span style="display:flex;"><span>T F | T T F F
</span></span><span style="display:flex;"><span>F T | T F F T
</span></span><span style="display:flex;"><span>F F | T F F F
</span></span><span style="display:flex;"><span>-----------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>- T: [T F] [F T] [F F]
</span></span><span style="display:flex;"><span>- F: [T T]
</span></span></code></pre></div><p>Logika truth tables have standard format (syntax) and semantic meanings. All elements of the truth table must be included to be considered correct.</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/LogikaTTexplain.png" alt="truth table syntax"></p>
<ol>
<li>
<p>The first line should have a single asterisk (*) over the top-level operator in the formula.</p>
</li>
<li>
<p>Next is a line of - (minus sign) characters, which must be at least as long as the third line to avoid getting errors.</p>
</li>
<li>
<p>The third line contains <code>variables | formula</code>. As Logika uses some capital letters as reserved words, you should use lower-case letters as variable names. Additionally, variables should be listed alphabetically.</p>
</li>
<li>
<p>The fourth line is another row of -, which is the same length as the second line.</p>
</li>
<li>
<p>Next come the truth assignments. Under the variables, list all possible combinations of T and F. Start with all T and progress linearly to all F. (T and F must be capitalized.)
After the Truth assignments is another row of -. Using each truth assignment, fill in truth assignments (T or F) under each operator in the formula in order of precedence (with the top-level operator applied last). Optionally, you can fill in the values for each variable under the forumla (as in the example above). However, it is only required that you fill in the truth assignments under each operator. Be careful to line up the truth assignments DIRECTLY below each operator, as Logika will reject truth tables that aren&rsquo;t carefully lined up.</p>
</li>
<li>
<p>Under the truth assignments, put another line of - (minus sign) characters, which should be the same length as the second line.</p>
</li>
<li>
<p>Finally, classify the formula as either <code>Tautology</code> (if everything under the top-level operator is T), <code>Contradictory</code> (if everything under the top-level operator is F), or <code>Contingent</code> (if there is a mix of T and F under the top-level operator). If the formula is contingent, you must also list which truth assignments made the formula true (i.e., which truth assignments made the top-level operator T) and which truth assignments made the formula false. Follow the image above for the syntax of how to list the truth assignments for contingent examples.</p>
</li>
</ol>
<h2 id="alternative-logical-operators">Alternative logical operators</h2>
<p>In order to type each traditional logical operator in Logika, you must insert a special Unicode symbol. You can do this by typing: <code>Shift-Command-Ctrl-Semicolon</code> and then a letter corresponding to a specific symbol. Here is how to insert each operator:</p>
<ul>
<li>NOT, <code>¬</code>. <code>Shift-Command-Ctrl-Semicolon-N</code></li>
<li>OR, <code>∨</code>. <code>Shift-Command-Ctrl-Semicolon-V</code></li>
<li>AND, <code>∧</code>, <code>Shift-Command-Ctrl-Semicolon-∧</code></li>
<li>IMPLIES, <code>→</code>, <code>Shift Command Ctrl -</code> (the last symbol is a dash, -)</li>
</ul>
<p>This can be tedious. While you can create 

<a href="https://www.jetbrains.com/help/idea/settings-keymap.html#decda373" target="_blank" rel="noopener">keyboard shortcuts</a> in IntelliJ for certain keystrokes, it is easier to use one of the available ASCII replacements instead. Here are alternatives for each operator:</p>
<ul>
<li>NOT: <code>!</code>, <code>~</code>, <code>not</code></li>
<li>OR: <code>V</code> (a capital V), <code>|</code>, <code>or</code></li>
<li>AND: <code>∧</code>, <code>&amp;</code>, <code>and</code></li>
<li>IMPLIES: <code>→</code>, <code>implies</code></li>
</ul>
<p>In the remainder of this book, I will often use these ASCII replacement characters because they are easier to type.</p>
<h2 id="example">Example</h2>
<p>Suppose we want to write a Logika truth table for:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p ∧ q) →  ¬r
</span></span></code></pre></div><p>First, we make sure we have a new file in Sireum with the <code>.logika</code> extension. Then, we construct this truth table shell:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | (p ∧ q) →  ¬r
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |
</span></span><span style="display:flex;"><span>T T F |
</span></span><span style="display:flex;"><span>T F T |
</span></span><span style="display:flex;"><span>T F F |
</span></span><span style="display:flex;"><span>F T T |
</span></span><span style="display:flex;"><span>F T F |
</span></span><span style="display:flex;"><span>F F T |
</span></span><span style="display:flex;"><span>F F F |
</span></span><span style="display:flex;"><span>----------------------
</span></span></code></pre></div><p>In the table above, we noticed that the <code>→</code> operator was the top-level operator according to our operator precedence rules.</p>
<p>Next, we fill in the output for the corresponding truth assignment under each operator, from highest precedence to lowest precedence. First, we evaluate the parentheses, which have the highest precedence. For example, we put a <code>T</code> under the <code>∧</code> in the first row, as <code>p</code> and <code>q</code> are both <code>T</code> in that row, and <code>T ∧ T</code> is <code>T</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | (p ∧ q) →  ¬r
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |    T
</span></span><span style="display:flex;"><span>T T F |    T
</span></span><span style="display:flex;"><span>T F T |    F
</span></span><span style="display:flex;"><span>T F F |    F
</span></span><span style="display:flex;"><span>F T T |    F
</span></span><span style="display:flex;"><span>F T F |    F
</span></span><span style="display:flex;"><span>F F T |    F
</span></span><span style="display:flex;"><span>F F F |    F
</span></span><span style="display:flex;"><span>----------------------
</span></span></code></pre></div><p>In this example, we are only filling in under each operator (instead of also transcribing over each variable value), but either approach is acceptable.</p>
<p>Next, we fill in under the  ¬ operator, which has the next-highest precedence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | (p ∧ q) →  ¬r
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |    T       F
</span></span><span style="display:flex;"><span>T T F |    T       T
</span></span><span style="display:flex;"><span>T F T |    F       F
</span></span><span style="display:flex;"><span>T F F |    F       T
</span></span><span style="display:flex;"><span>F T T |    F       F
</span></span><span style="display:flex;"><span>F T F |    F       T
</span></span><span style="display:flex;"><span>F F T |    F       F
</span></span><span style="display:flex;"><span>F F F |    F       T
</span></span><span style="display:flex;"><span>----------------------
</span></span></code></pre></div><p>Then, we fill in under our top-level operator, the <code>→</code>. Notice that we must line up the <code>T/F</code> values under the <code>-</code> in the <code>→</code> symbol. For example, we put a <code>F</code> under the <code>→</code> on the first row, as <code>(p ∧ q)</code> is <code>T</code> there and <code> ¬r</code> is <code>F</code>, and we know that <code>T→F</code> is <code>F</code> because it describes a broken promise.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | (p ∧ q) →  ¬r
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |    T    F  F
</span></span><span style="display:flex;"><span>T T F |    T    T  T
</span></span><span style="display:flex;"><span>T F T |    F    T  F
</span></span><span style="display:flex;"><span>T F F |    F    T  T
</span></span><span style="display:flex;"><span>F T T |    F    T  F
</span></span><span style="display:flex;"><span>F T F |    F    T  T
</span></span><span style="display:flex;"><span>F F T |    F    T  F
</span></span><span style="display:flex;"><span>F F F |    F    T  T
</span></span><span style="display:flex;"><span>----------------------
</span></span></code></pre></div><p>Lastly, we examine the list of outputs under the top-level operator. We see that some truth assignments made the formula true, and that others (one) made the formula false. Thus, the formula is contingent. We label it as such, and list which truth assignments made the formula true and which made it false:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | (p ∧ q) → ¬r
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |    T    F F
</span></span><span style="display:flex;"><span>T T F |    T    T T
</span></span><span style="display:flex;"><span>T F T |    F    T F
</span></span><span style="display:flex;"><span>T F F |    F    T T
</span></span><span style="display:flex;"><span>F T T |    F    T F
</span></span><span style="display:flex;"><span>F T F |    F    T T
</span></span><span style="display:flex;"><span>F F T |    F    T F
</span></span><span style="display:flex;"><span>F F F |    F    T T
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T T F] [T F T] [T F F] [F T T] [F T F] [F F T] [F F F]
</span></span><span style="display:flex;"><span>- F: [T T T]
</span></span></code></pre></div><p>If you typed everything correctly, you should see a popup in Sireum logika that says: &ldquo;Logika Verified&rdquo; with a purple checkmark:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/ttVerified.png" alt="truth table verified"></p>
<p>If you instead see red error markings, hover over them and read the explanations &ndash; it means there are errors in your truth table.</p>
<p>If you see no errors and no purple check, you will need to manually run Logika. Right-click in the text area that contains your truth table, and select &ldquo;Logika check&rdquo;.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Satisfiability</h1>
    
    
<p>We say that a logical statement is <em>satisfiable</em> when there exists at least one truth assignment that makes the overall statement true.</p>
<p>In our Logika truth tables, this corresponds to statements that are either <em>contingent</em> or a <em>tautology</em>. (<em>Contradictory</em> statements are NOT satisfiable.)</p>
<p>For example, consider the following truth tables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>          *
</span></span><span style="display:flex;"><span>-----------------------
</span></span><span style="display:flex;"><span>p q r | p → q V ¬r ∧ p
</span></span><span style="display:flex;"><span>-----------------------
</span></span><span style="display:flex;"><span>T T T |   T   T F  F
</span></span><span style="display:flex;"><span>T T F |   T   T T  T
</span></span><span style="display:flex;"><span>T F T |   F   F F  F
</span></span><span style="display:flex;"><span>T F F |   T   T T  T
</span></span><span style="display:flex;"><span>F T T |   T   T F  F
</span></span><span style="display:flex;"><span>F T F |   T   T T  F
</span></span><span style="display:flex;"><span>F F T |   T   F F  F
</span></span><span style="display:flex;"><span>F F F |   T   F T  F
</span></span><span style="display:flex;"><span>------------------------
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T T T] [T T F] [T F F] [F T T] [F T F] [F F T] [F F F]
</span></span><span style="display:flex;"><span>- F: [T F T]
</span></span></code></pre></div><p>And</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>      *
</span></span><span style="display:flex;"><span>------------
</span></span><span style="display:flex;"><span>p | p V ¬p 
</span></span><span style="display:flex;"><span>------------
</span></span><span style="display:flex;"><span>T |   T F
</span></span><span style="display:flex;"><span>F |   T T
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Tautology
</span></span></code></pre></div><p>Both of these statements are satisfiable, as they have at least one (or more than one) truth assignment that makes the overall statement true.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Logical Equivalence</h1>
    
    
<p>Two (or more) logical statements are said to be <em>logically equivalent</em> IFF (if and only if, ↔) they have the same truth value for every truth assignment; i.e., their truth tables evaluate exactly the same. (We sometimes refer to this as <em>semantic equivalence</em>.)</p>
<p>An example of logically equivalent statements are <code>q ∧ p</code> and <code>p ∧ (q ∧ p)</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>         *
</span></span><span style="display:flex;"><span>--------------
</span></span><span style="display:flex;"><span>p q | (p ∧ q)
</span></span><span style="display:flex;"><span>--------------
</span></span><span style="display:flex;"><span>T T |  T T T
</span></span><span style="display:flex;"><span>T F |  T F F
</span></span><span style="display:flex;"><span>F T |  F F T
</span></span><span style="display:flex;"><span>F F |  F F F
</span></span><span style="display:flex;"><span>---------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>- T : [T T]
</span></span><span style="display:flex;"><span>- F : [F F] [F T] [T F]
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>         *
</span></span><span style="display:flex;"><span>-------------------
</span></span><span style="display:flex;"><span>p q |  p ∧ (q ∧ p)
</span></span><span style="display:flex;"><span>-------------------
</span></span><span style="display:flex;"><span>T T |  T T  T T T
</span></span><span style="display:flex;"><span>T F |  T F  F F T
</span></span><span style="display:flex;"><span>F T |  F F  T F F
</span></span><span style="display:flex;"><span>F F |  F F  F F F
</span></span><span style="display:flex;"><span>--------------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>- T : [T T]
</span></span><span style="display:flex;"><span>- F : [F F] [F T] [T F]
</span></span></code></pre></div><p>In these examples, notice that exactly the same set of truth assignments makes both statements true, and that exactly the same set of truth assignments makes both statements false.</p>
<p>Finding equivalent logical statements of fewer gates (states) is important to several fields. In computer science, fewer states can lead to less memory, fewer operations and smaller programs. In computer engineering, fewer gates means fewer circuits less power and less heat.</p>
<h2 id="common-equivalences">Common equivalences</h2>
<p>We can similarly use truth tables to show the following common logical equivalences:</p>
<ul>
<li>Double negative: <code>¬ ¬ p</code> and <code>p</code></li>
<li>Contrapositive: <code>p → q</code> and <code>¬ q → ¬ p</code></li>
<li>Expressing an implies using an OR: <code>p → q</code> and <code>¬ p ∨ q</code></li>
<li>One of DeMorgan&rsquo;s laws: <code>¬ (p ∧ q)</code> and <code>( ¬ p ∨ ¬ q)</code></li>
<li>Another of DeMorgan&rsquo;s laws: <code>¬ (p ∨ q)</code> and <code>( ¬ p ∧ ¬ q)</code></li>
</ul>
<h2 id="expressing-additional-operators">Expressing additional operators</h2>
<p>The bi-implication (<code>↔</code>) and exclusive or (<code>⊕</code>) operators are not directly used in this course. However, we can simulate both operators using a combination of <code>¬</code>, <code>∧</code>, <code>∨</code>, and <code>→</code>:</p>
<ul>
<li><code>p ↔ q</code>, which means &ldquo;p if and only if q&rdquo;, can be expressed as <code>(p → q) ∧ (q → p)</code></li>
<li><code>p ⊕ q</code>, which means &ldquo;p exclusive or q&rdquo;, can be expressed as <code>(p ∨ q) ∧ ¬(p ∧ q)</code></li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Semantic Entailment</h1>
    
    
<h2 id="definition">Definition</h2>
<p>We say a set of premises, <code>p1</code>, <code>p2</code>, &hellip;, <code>pn</code> semantically entail a conclusion <code>c</code>, and we write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p1, p2, ..., pn ⊨ c
</span></span></code></pre></div><p>if whenever we have a truth assignment that makes <code>p1</code>, <code>p2</code>, &hellip;, <code>pn</code> all true, then <code>c</code> is also true for that truth assignment.</p>
<p>(Note: we can use the ASCII replacement <code>|=</code> instead of the Unicode <code>⊨</code>, if we want.)</p>
<h2 id="showing-semantic-entailment">Showing semantic entailment</h2>
<p>Suppose we have premises <code>p ∧ q</code> and <code>p → r</code>. We want to see if these premises necessarily entail the conclusion <code>r ∧ q</code>.</p>
<p>First, we could make truth tables for each premise (being sure to list the variables <code>p</code>, <code>q</code> and <code>r</code> in each case, as that is the overall set of variables in the problem):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//truth table for premise, p ∧ q
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | p ∧ q
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |   T
</span></span><span style="display:flex;"><span>T T F |   T
</span></span><span style="display:flex;"><span>T F T |   F
</span></span><span style="display:flex;"><span>T F F |   F
</span></span><span style="display:flex;"><span>F T T |   F
</span></span><span style="display:flex;"><span>F T F |   F
</span></span><span style="display:flex;"><span>F F T |   F
</span></span><span style="display:flex;"><span>F F F |   F
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T T T] [T T F]
</span></span><span style="display:flex;"><span>- F: [T F T] [T F F] [F T T] [F T F] [F F T] [F F F]
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//truth table for premise, p → r
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | p → r
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |   T
</span></span><span style="display:flex;"><span>T T F |   F
</span></span><span style="display:flex;"><span>T F T |   T
</span></span><span style="display:flex;"><span>T F F |   F
</span></span><span style="display:flex;"><span>F T T |   T
</span></span><span style="display:flex;"><span>F T F |   T
</span></span><span style="display:flex;"><span>F F T |   T
</span></span><span style="display:flex;"><span>F F F |   T
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T T T] [T F T] [F T T] [F T F] [F F T] [F F F]
</span></span><span style="display:flex;"><span>- F: [T T F] [T F F]
</span></span></code></pre></div><p>Now, we notice that the truth assignment <code>[T T T]</code> is the only one that makes both premises true. Next, we make a truth table for our potential conclusion, <code>r ∧ q</code> (again, being sure to include all variables used in the problem):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//truth table for potential conclusion, r ∧ q
</span></span><span style="display:flex;"><span>          *
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>p q r | r ∧ q
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>T T T |   T
</span></span><span style="display:flex;"><span>T T F |   F
</span></span><span style="display:flex;"><span>T F T |   F
</span></span><span style="display:flex;"><span>T F F |   F
</span></span><span style="display:flex;"><span>F T T |   T
</span></span><span style="display:flex;"><span>F T F |   F
</span></span><span style="display:flex;"><span>F F T |   F
</span></span><span style="display:flex;"><span>F F F |   F
</span></span><span style="display:flex;"><span>----------------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T T T] [F T T]
</span></span><span style="display:flex;"><span>- F: [T T F] [T F T] [T F F] [F T F] [F F T] [F F F]
</span></span></code></pre></div><p>Here, we notice that the truth assignment <code>[T T T]</code> makes the conclusion true as well. So we see that whenever there is a truth assignment that makes all of our premises true, then that same truth assignment also makes our conclusion true.</p>
<p>Thus, <code>p ∧ q</code> and <code>p → r</code> semantically entail the conclusion <code>r ∧ q</code>, and we can write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q, p → r ⊨ r ∧ q
</span></span></code></pre></div><h2 id="semantic-entailment-with-one-truth-table">Semantic entailment with one truth table</h2>
<p>The process of making separate truth tables for each premise and the conclusion, and then examining each one to see if any truth assignment that makes all the premises true also makes the conclusion true, is fairly tedious.</p>
<p>We are trying to show that IF each premise is true, THEN we promise the conclusion is true. This sounds exactly like an IMPLIES statement, and in fact that is what we can use to simplify our process. If we are trying to show that  <code>p1</code>, <code>p2</code>, &hellip;, <code>pn</code> semantically entail a conclusion <code>c</code> (i.e., that <code>p1, p2, ..., pn ⊨ c</code>), then we can instead create ONE truth table for the statement:</p>
<p><code>(p1 ∧ p2 ∧ ... ∧ pn) → c</code></p>
<p>If this statement is a tautology (which would mean that anytime all the premises were true, then the conclusion was also true), then we would also have that the premises semantically entail the conclusion.</p>
<p>In our previous example, we create a truth table for the statement <code>(p ∧ q) ∧ (p → r) → r ∧ q</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                           *
</span></span><span style="display:flex;"><span>--------------------------------------
</span></span><span style="display:flex;"><span>p q r | (p ∧ q) ∧ (p → r) → r ∧ q
</span></span><span style="display:flex;"><span>--------------------------------------
</span></span><span style="display:flex;"><span>T T T |    T    T    T     T    T
</span></span><span style="display:flex;"><span>T T F |    T    F    F     T    F
</span></span><span style="display:flex;"><span>T F T |    F    F    T     T    F
</span></span><span style="display:flex;"><span>T F F |    F    F    F     T    F
</span></span><span style="display:flex;"><span>F T T |    F    F    T     T    T 
</span></span><span style="display:flex;"><span>F T F |    F    F    T     T    F
</span></span><span style="display:flex;"><span>F F T |    F    F    T     T    F
</span></span><span style="display:flex;"><span>F F F |    F    F    T     T    F
</span></span><span style="display:flex;"><span>---------------------------------------
</span></span><span style="display:flex;"><span>Tautology
</span></span></code></pre></div><p>Then we see that it is indeed a tautology.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-3">Chapter 3</h3>
<h1 id="propositional-logic-translations">Propositional Logic Translations</h1>
<p>A <em>propositional logic statement</em> is a set of <em>propositional atoms</em> (statements with no logical connectives that can be true or false) connected by logical operators.</p>
<p>In this chapter, we will see how to translate English sentences into such propositional logic statements, which will resemble the logical statements (like <code>p ∧ q → r</code>) we saw when working with truth tables. These statements are also called <em>propositions</em>.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Propositional Atoms</h1>
    
    
<h2 id="definition">Definition</h2>
<p>A <em>propositional atom</em> is statement that is either true or false, and that contains no logical connectives (like and, or, not, if/then).</p>
<h2 id="examples-of-propositional-atoms">Examples of propositional atoms</h2>
<p>For example, the following are propositional atoms:</p>
<ul>
<li>My shirt is red.</li>
<li>It is sunny.</li>
<li>Pigs can fly.</li>
<li>I studied for the test.</li>
</ul>
<h2 id="examples-of-what-are-not-propositional-atoms">Examples of what are NOT propositional atoms</h2>
<p>Propositional atoms should not contain any logical connectives. If they did, this would mean would could have further subdivided the statement into multiple propositional atoms that could be joined with logical operators. For example, the following are NOT propositional atoms:</p>
<ul>
<li>It is not summer. (<em>contains a not</em>)</li>
<li>Bob has brown hair and brown eyes. (<em>contains an and</em>)</li>
<li>I walk to school unless it rains. (<em>contains the word <code>unless</code>, which has if&hellip;then information</em>)</li>
</ul>
<p>Propositional atoms also must be either true or false &ndash; they cannot be questions, commands, or sentence fragments. For example, the following are NOT propositional atoms:</p>
<ul>
<li>What time is it? (<em>contains a question - not a true/false statement</em>)</li>
<li>Go to the front of the line. (<em>contains a command - not a true/false statement</em>)</li>
<li>Fluffy cats (<em>contains a sentence fragment - not a true/false statement</em>)</li>
</ul>
<h2 id="identifying-propositional-atoms">Identifying propositional atoms</h2>
<p>If we are given several sentences, we identify its propositional atoms by finding the key statements that can be either true or false. We further ensure that these statements do not contain any logical connectives (and, or, not, if/then information) - if they do, we break the statement down further. We then assign letters to each proposition.</p>
<p>For example, if we have the sentences:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>My jacket is red and green. I only wear my jacket when it is snowing. It did not snow today.
</span></span></code></pre></div><p>Then we identify the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: My jacket is red
</span></span><span style="display:flex;"><span>q: My jacket is green
</span></span><span style="display:flex;"><span>r: I wear my jacket
</span></span><span style="display:flex;"><span>s: It is snowing
</span></span><span style="display:flex;"><span>t: It snowed today
</span></span></code></pre></div><p>Notice that the first sentence, &ldquo;My jacke is red and green&rdquo;, contained the logical connective &ldquo;and&rdquo;. Thus, we broke that idea into its components, and got propositions <code>p</code> and <code>q</code>. The second sentence, &ldquo;I only wear my jacket when it is snowing&rdquo;, contained if/then information about when I would wear my jacket. We broke that sentence into two parts as well, and got propositions <code>r</code> and <code>s</code>. Finally, the last sentence, &ldquo;It did not snow today&rdquo;, contained the logical connective &ldquo;not&rdquo; &ndash; so we removed it and kept the remaining information for proposition <code>t</code>.</p>
<p>Each propositional atom is a true/false statement, just as is required.</p>
<p>In the next section, we will see how to complete our translation from English to propositional logic by connecting our propositional atoms with logical operators.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>NOT, AND, OR Translations</h1>
    
    
<p>Now that we have seen how to identify propositional atoms in English sentences, we will learn how to connect these propositions with logical operators in order to complete the process of translating from English to propositional logic.</p>
<h2 id="not-translations">NOT translations</h2>
<p>When you see the word &ldquo;not&rdquo; and the prefixes &ldquo;un-&rdquo; and &ldquo;ir-&rdquo;, those should be replaced with a NOT operator.</p>
<h3 id="example-1">Example 1</h3>
<p>For example, if we have the sentence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>I am not going to work today.
</span></span></code></pre></div><p>Then we would first identify the propositional atom:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: I am going to work today
</span></span></code></pre></div><p>and would then use a NOT operator to express the negation. Our full translation to propositional logic would be: <code> ¬p</code></p>
<h3 id="example-2">Example 2</h3>
<p>As another example, suppose we have the sentence</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>My sweater is irreplaceable.
</span></span></code></pre></div><p>We would identify the propositional atom:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: My sweater is replaceable.
</span></span></code></pre></div><p>And again, our complete translation would be: <code> ¬p</code></p>
<h2 id="and-translations">AND translations</h2>
<p>When you see the words &ldquo;and&rdquo;, &ldquo;but&rdquo;, &ldquo;however&rdquo;, &ldquo;moreover&rdquo;, &ldquo;nevertheless&rdquo;, etc., then the English sentence is expressing a conjunction of ideas. When translating to propositional logic, all of these words should be replaced with a logical AND operator.</p>
<p>It might seem strange that the sentences &ldquo;It is cold and it is sunny&rdquo; and &ldquo;It is cold but it is sunny&rdquo; should be translated the same way &ndash; but really, both sentences are expressing two facts:</p>
<ol>
<li>It is cold</li>
<li>It is sunny</li>
</ol>
<p>Using &ldquo;but&rdquo; instead of &ldquo;and&rdquo; in English adds a subtle comparison of the first fact to the second fact, but such nuances are beyond the capabilities of propositional logic (and are somewhat ambiguous anyway).</p>
<h3 id="example-1-1">Example 1</h3>
<p>Suppose we want to translate the following sentence to propositional logic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>I like cake but I don&#39;t like cupcakes.
</span></span></code></pre></div><p>We would first identify two propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: I like cake
</span></span><span style="display:flex;"><span>q: I like cupcakes
</span></span></code></pre></div><p>We would then translate the clause &ldquo;I don&rsquo;t like cupcakes&rdquo; to <code> ¬q</code>, and then would translate the connective &ldquo;but&rdquo; to a logical AND operator. We would finish with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧  ¬q
</span></span></code></pre></div><h3 id="example-2-1">Example 2</h3>
<p>Suppose we want to translate the following sentence to propositional logic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>The school doesn&#39;t have both a pool and a track.
</span></span></code></pre></div><p>We would first identify two propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: The school has a pool
</span></span><span style="display:flex;"><span>q: The school has a track
</span></span></code></pre></div><p>We would then see that we are really taking the sentence, &ldquo;The school has a pool and a track&rdquo; and negating it, which leaves us with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> ¬(p ∧ q)
</span></span></code></pre></div><h2 id="or-translations">OR translations</h2>
<p>When you see the word &ldquo;or&rdquo; in a sentence, or some other clear disjunction of statements, then you will translate it to a logical OR operator. Because the word &ldquo;or&rdquo; in English can be ambiguous, We first need to determine whether the &ldquo;or&rdquo; is <em>inclusive</em> (in which case we would replace it with a regular OR operator) or <em>exclusive</em> (in which case we need to add a clause to explicitly express that both statements cannot be true).</p>
<p>As we saw in 

<a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_1-logicbasics/">section 1.1</a>, the word &ldquo;or&rdquo; in an English sentence is usually meant to be exclusive. However, because the logical OR is <em>INclusive</em>, and since the purpose of this class is not to have you wrestle with subtleties of the English language, then you can assume that an &ldquo;or&rdquo; in a sentence is <em>inclusive</em> unless clearly stated otherwise.</p>
<h3 id="inclusive-or-statements">Inclusive OR statements</h3>
<p>Suppose we want to translate the following sentence to propositional logic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>You watch a movie and/or eat a snack.
</span></span></code></pre></div><p>We would first identify two propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: You watch a movie
</span></span><span style="display:flex;"><span>q: You eat a snack
</span></span></code></pre></div><p>The &ldquo;and/or&rdquo; in our sentence makes it extremely clear that the intent is an inclusive or, since the sentence is true if you both watch a movie and eat a snack. This leaves us with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p V q
</span></span></code></pre></div><h3 id="exclusive-or-statements">Exclusive OR statements</h3>
<p>In this class, if the meaning of &ldquo;or&rdquo; in a sentence is meant to be exclusive, then the sentence will clearly state that the two statements aren&rsquo;t both true.</p>
<p>For example, suppose we want to translate the following sentence to propositional logic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>On Saturday, Jane goes for a run or plays basketball, but not both.
</span></span></code></pre></div><p>We would first identify two propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: Jane goes for a run on Saturday
</span></span><span style="display:flex;"><span>q: Jane plays basketball on Saturday
</span></span></code></pre></div><p>We then apply our equivalence for simulating an exclusive or operator, which we saw in 

<a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/">section 2.4</a>. This leaves us with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p V q) ∧  ¬(p ∧ q)
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Implies Translations</h1>
    
    
<p>In this section, we will learn when to use an implies (→) operator when translating from English to propositional logic. In general, you will want to use an implies operator any time a sentence is making a promise &ndash; if one thing happens, then we promise that another thing will happen. The trick is to figure out the direction of the promise &ndash; promising that if p happens, then q will happen is subtly different from promising that if q happens, then p will happen.</p>
<p>Look for the words &ldquo;if&rdquo;, &ldquo;only if&rdquo;, &ldquo;unless&rdquo;, &ldquo;except&rdquo;, and &ldquo;provided&rdquo; as clues that the propositional logic translation will use an implies operator.</p>
<h2 id="if-p-then-q-statements">IF p THEN q statements</h2>
<p>An &ldquo;IF p THEN q&rdquo; statement is promising that if <code>p</code> is true, then we can infer that <code>q</code> is also true. (It is making NO claims about what we can infer if we know <code>q</code> is true.)</p>
<p>For example, consider the following sentence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>If it is hot today, then I&#39;ll get ice cream.
</span></span></code></pre></div><p>We first identify the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: It is hot today
</span></span><span style="display:flex;"><span>q: I&#39;ll get ice cream
</span></span></code></pre></div><p>To determine the order of the implication, we think about what is being promised &ndash; if it is hot, then we can infer that ice cream will happen. But if we get ice cream, then we have no idea what the weather is like. It might be hot, but it might also be cold and I just decided to get ice cream anyway. Thus we finish with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q
</span></span></code></pre></div><p>Alternatively, if we don&rsquo;t get ice cream, we can be certain that it wasn&rsquo;t hot &ndash; since we are promsied that if it is hot, then we will get ice cream. So an equivalent translation is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> ¬q →  ¬p
</span></span></code></pre></div><p>(This form is called the <em>contrapositive</em>, which we learned about it in 

<a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/">section 2.4</a>). We&rsquo;ll study it and other equivalent translations more in the next section.)</p>
<h2 id="p-if-q-statements">p IF q statements</h2>
<p>A &ldquo;p IF q&rdquo; statement is promising that if <code>q</code> is true, then we can infer that <code>p</code> is also true. (It is making NO claims about what we can infer if we know <code>p</code> is true.) Equivalent ways of expressing the same promise are &ldquo;p PROVIDED q&rdquo; and &ldquo;p WHEN q&rdquo;.</p>
<p>For example, consider the following sentence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>You can login to a CS lab computer if you have a CS account.
</span></span></code></pre></div><p>We first identify the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: You can login to a CS lab computer
</span></span><span style="display:flex;"><span>q: You have a CS account
</span></span></code></pre></div><p>To determine the order of the implication, we think about what conditions need to be met in order for me to be promised that I can login. We see that if we have a CS account, then we are promised to be able to login. Thus we finish with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>q → p
</span></span></code></pre></div><p>In this example, if we knew we could login to a CS lab computer, we wouldn&rsquo;t be certain that we had a CS account. There might be other reasons we can login &ndash; maybe you can use your eID account instead, for example.</p>
<p>Alternatively, if we can&rsquo;t login, we can be certain that we don&rsquo;t have a CS account. After all, we are guaranteed to be able to login if we do have a CS account. So another valid translation is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> ¬p →  ¬q
</span></span></code></pre></div><h2 id="p-only-if-q">p ONLY IF q</h2>
<p>A &ldquo;p ONLY IF q&rdquo; statement is promising that the only time <code>p</code> happens is when <code>q</code> also happens. So if <code>p</code> does happen, it must be the case that <code>q</code> did too (since <code>p</code> can&rsquo;t happen without <code>q</code> happening too).</p>
<p>For example, consider the following sentence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Wilma eats cookies only if Evelyn makes them.
</span></span></code></pre></div><p>We first identify the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: Wilma eats cookies
</span></span><span style="display:flex;"><span>q: Evelyn makes cookies
</span></span></code></pre></div><p>What conditions need to be met for Wilma to eat cookies? If Wilma is eating cookies, Evelyn must have made cookies &ndash; after all, we know that Wilma only eats Evelyn&rsquo;s cookies. Thus we finish with the following translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q
</span></span></code></pre></div><p>Equivalently, we are certain that if Evelyn DOESN&rsquo;T make cookies, then Wilma won&rsquo;t eat them &ndash; since she only eats Evelyn&rsquo;s cookies. We can also write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> ¬q →  ¬p
</span></span></code></pre></div><p>However, if we know that Evelyn makes cookies, we can&rsquo;t be sure that Wilma will eat them. We know she won&rsquo;t eat any other kind of cookie, but maybe Wilma is full today and won&rsquo;t even eat Evelyn&rsquo;s cookies&hellip;we can&rsquo;t be sure.</p>
<h2 id="p-unless-b-p-except-if-q">p UNLESS b, p EXCEPT IF q</h2>
<p>The statements &ldquo;p UNLESS q&rdquo; and &ldquo;p EXCEPT IF q&rdquo; are equivalent&hellip;and both can sometimes be ambiguous. For example, consider the following sentence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>I will bike to work unless it is raining.
</span></span></code></pre></div><p>We first identify the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: I will bike to work
</span></span><span style="display:flex;"><span>q: It is raining
</span></span></code></pre></div><p>Next, we consider what exactly is being promised:</p>
<ul>
<li><em>If it isn&rsquo;t raining, will I bike to work?</em>   YES ¬ I promise to bike to work whenever it isn&rsquo;t raining.</li>
<li><em>If I don&rsquo;t bike to work, is it raining?</em>   YES ¬ I always bike when it&rsquo;s not raining, so if I don&rsquo;t bike, it must be raining.</li>
<li><em>If it&rsquo;s raining, will I necessarily not bike to work?</em>   Well, maybe? Some people might interpret the sentence as saying I&rsquo;ll get to work in another way if it&rsquo;s raining, and others might think no promise has been made if it is raining.</li>
<li><em>If I bike to work, is it necessarily not raining?</em>   Again, maybe? It&rsquo;s not clear if I&rsquo;m promising to only bike in non-rainy weather.</li>
</ul>
<p>As we did with ambiguous OR statements, we will establish a rule in this class for intrepeting &ldquo;unless&rdquo; statements that will let us resolve ambiguity.</p>
<p><strong>If you see the word <em>unless</em> when you are doing a translation, replace it with the words <em>unless possibly if</em>.</strong></p>
<p>If we rephrase the sentence as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>I will bike to work *unless possibly if* it is raining.
</span></span></code></pre></div><p>We see that there is clearly NO promise about whether I will bike in the rain. I might, or I might not &ndash; but the only thing that I am promising is that I <em>will</em> bike if it is <em>not</em> raining, or that IF it&rsquo;s not raining, THEN I will bike. With that in mind, we can complete our translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> ¬q →  ¬p
</span></span></code></pre></div><p>Equivalently, if we don&rsquo;t bike, then we are certain that it must be raining &ndash; since we have promised to ride our bike every other time. We can also write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> ¬p →  ¬q
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Equivalent Translations</h1>
    
    
<p>As we saw in 

<a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/">section 2.4</a>), two logical statements are said to be <em>logically equivalent</em> if and only if they have the same truth value for every truth assignment.</p>
<p>We can extend this idea to our propositional logic translations &ndash; two (English) statements are said to be <em>equivalent</em> iff they have the same underlying meaning, and iff their translations to propositional logic are logically equivalent.</p>
<h2 id="common-equivalences-revisited">Common equivalences, revisited</h2>
<p>We previously identified the following common logical equivalences:</p>
<ul>
<li>Double negative: <code>¬ ¬ p</code> and <code>p</code></li>
<li>Contrapositive: <code>p → q</code> and <code>¬ q → ¬ p</code></li>
<li>Expressing an implies using an OR: <code>p → q</code> and <code>¬ p ∨ q</code></li>
<li>One of DeMorgan&rsquo;s laws: <code>¬ (p ∧ q)</code> and <code>( ¬ p ∨ ¬ q)</code></li>
<li>Another of DeMorgan&rsquo;s laws: <code>¬ (p ∨ q)</code> and <code>( ¬ p ∧ ¬ q)</code></li>
</ul>
<h2 id="equivalence-example-1">Equivalence example 1</h2>
<p>Suppose we have the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: I get cold
</span></span><span style="display:flex;"><span>q: It is summer
</span></span></code></pre></div><p>Consider the following three statements:</p>
<ul>
<li><em>I get cold except possibly if it is summer.</em></li>
<li><em>If it&rsquo;s not summer, then I get cold.</em></li>
<li><em>I get cold or it is summer.</em></li>
</ul>
<p>We translate each sentence to propositional logic:</p>
<ul>
<li>
<p><em>I get cold except possibly if it is summer.</em></p>
<ul>
<li><code>p →  ¬q</code></li>
<li>Meaning: I promise that if I get cold, then it must not be summer&hellip;because I am always cold when it&rsquo;s not summer.</li>
</ul>
</li>
<li>
<p><em>If it&rsquo;s not summer, then I get cold.</em></p>
<ul>
<li><code> ¬q → p</code></li>
<li>Meaning: I promise that anytime it isn&rsquo;t summer, then I will get cold.</li>
</ul>
</li>
<li>
<p><em>I get cold or it is summer.</em></p>
<ul>
<li><code>p V q</code></li>
<li>Meaning: I&rsquo;m either cold or it&rsquo;s summer&hellip;because my being cold is true every time it isn&rsquo;t summer.</li>
</ul>
</li>
</ul>
<p>As we can see, each of these statements is expressing the same idea.</p>
<h2 id="equivalence-example-2">Equivalence example 2</h2>
<p>Suppose we have the following propositional atoms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: I eat chips
</span></span><span style="display:flex;"><span>q: I eat fries
</span></span></code></pre></div><p>Consider the following two statements:</p>
<ul>
<li><em>I don&rsquo;t eat both chips and fries.</em></li>
<li><em>I don&rsquo;t eat chips and/or I don&rsquo;t eat fries.</em></li>
</ul>
<p>We translate each sentence to propositional logic:</p>
<ul>
<li>
<p><em>I don&rsquo;t eat both chips and fries.</em></p>
<ul>
<li><code> ¬(p ∧ q)</code></li>
</ul>
</li>
<li>
<p><em>I don&rsquo;t eat chips and/or I don&rsquo;t eat fries.</em></p>
<ul>
<li><code> ¬p V  ¬q</code></li>
</ul>
</li>
</ul>
<p>These statements are clearly expressing the same idea &ndash; if it&rsquo;s not the case that I eat both, then it&rsquo;s also true that there is at least one of the foods that I don&rsquo;t eat. This is an application of one of DeMorgan&rsquo;s laws: that <code>¬ (p ∧ q)</code> is equivalent to <code>( ¬ p ∨ ¬ q)</code>.</p>
<p>If we were to create truth tables for both <code> ¬(p ∧ q)</code> and <code> ¬p V  ¬q</code>, we would see that they are <em>logically equivalent</em> (that the same truth assignments make each statement true).</p>
<h2 id="equivalence-example-3">Equivalence example 3</h2>
<p>Using the same propositional atoms as example 2, we consider two more statements:</p>
<ul>
<li><em>I don&rsquo;t eat chips or fries.</em></li>
<li><em>I don&rsquo;t eat chips and I don&rsquo;t eat fries.</em></li>
</ul>
<p>We translate each sentence to propositional logic:</p>
<ul>
<li>
<p><em>I don&rsquo;t eat chips or fries.</em></p>
<ul>
<li><code> ¬(p V q)</code></li>
</ul>
</li>
<li>
<p><em>I don&rsquo;t eat chips and I don&rsquo;t eat fries.</em></p>
<ul>
<li><code> ¬p ∧  ¬q</code></li>
</ul>
</li>
</ul>
<p>These propositions are clearly expressing the same idea &ndash; I have two foods (chips and fries), and I don&rsquo;t eat either one. This demonstrates another of DeMorgan&rsquo;s laws: that <code>¬ (p ∨ q)</code> is equivalent to <code>( ¬ p ∧ ¬ q)</code>. If we were to create truth tables for each proposition, we would see that they are logically equivalent as well.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Knights and Knaves, revisited</h1>
    
    
<p>Recall the Knights and Knaves puzzles from 

<a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_2-knightsknaves/">section 1.2</a>. In addition to solving these puzzle by hand, we can devise a strategy to first translate a Knights and Knaves puzzle to propositional logic, and then solve the puzzle using a truth table.</p>
<h2 id="identifying-propositional-atoms">Identifying propositional atoms</h2>
<p>To translate a Knights and Knaves puzzle to propositional logic, we first create a propositional atom for each person that represented whether that person was a knight. For example, if our puzzle included the people &ldquo;Adam&rdquo;, &ldquo;Bob&rdquo;, and &ldquo;Carly&rdquo;, then we might create propositional atoms <code>a</code>, <code>b</code>, and <code>c</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>a: Adam is a knight
</span></span><span style="display:flex;"><span>b: Bob is a knight
</span></span><span style="display:flex;"><span>c: Carly is a knight
</span></span></code></pre></div><h2 id="translating-statements">Translating statements</h2>
<p>Once we have our propositional atoms, we can translate each statement in the puzzle to propositional logic. For each one, we want to capture that the statement is true IF AND ONLY IF the person speaking is a knight. (That way, the statement would be false whenever the person was not a knight &ndash; i.e., when they were a knave.) We recall that we can express <em>if and only if</em> using a conjunction of implications. So if we want to write <code>p if and only if q</code>, then we can say <code>(p → q) ∧ (q → p)</code>.</p>
<p>As an example, suppose we have the following statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Adam says: Bob is a knight and Carly is a knave.
</span></span></code></pre></div><p>Adam&rsquo;s statement should be true if and only if he is a knight, so we can translate it as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(a → (b ∧  ¬c)) ∧ ((b ∧  ¬c) → a)
</span></span></code></pre></div><p>Which reads as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>If I am a knight, then Bob is a knight and Carly is a knave. Also, if Bob is a knight and Carly is a knave, then I am a knight.
</span></span></code></pre></div><p>We repeat this process for each statement in the puzzle. Finally, since we solve a Knights and Knaves puzzle by finding a truth assignment (i.e., assignment of who is a knight and who is a knave) that works for ALL statements, then we finish by AND-ing together our translations for each speaker. When we fill in the truth table for our final combined proposition, then a valid solution to the puzzle is any truth assignment that makes the overall proposition true. If it was a well-made puzzle, then there should only be one such truth assignment.</p>
<h2 id="full-example">Full example</h2>
<p>Suppose we meet two people on the Island of Knights and Knaves &ndash; Ava and Bob.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Ava says, &#34;Bob and I are not the same&#34;.
</span></span><span style="display:flex;"><span>Bob says, &#34;Of Ava and I, exactly one is a knight.&#34;
</span></span></code></pre></div><p>We first create a propositional atom for each person:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>a: Ava is a knight
</span></span><span style="display:flex;"><span>b: Bob is a knight
</span></span></code></pre></div><p>Then, we translate each statement:</p>
<ul>
<li><em>Bob and I are not the same</em>
<ul>
<li>Translation: <code>(a → (a ∧ ¬b V ¬a ∧ b)) ∧ ((a ∧ ¬b V ¬a ∧ b) → a)</code></li>
<li>Meaning: If Ava is a knight, then either Ava is a knight and Bob is a knave, or Ava is a knave and Bob is a knight (so they aren&rsquo;t the same type). Also, if Ava and Bob aren&rsquo;t the same type, then Ava must be a knight (because her statement would be true).</li>
</ul>
</li>
<li><em>Bob says, &ldquo;Of Ava and I, exactly one is a knight.</em>
<ul>
<li>Bob is really saying the same thing as Ava&hellip;if exactly one is a knight, then either Ava is a knight and Bob is a knave, or Ava is a knave and Bob is a knight.</li>
<li>Translation: <code>(b → (a ∧ ¬b V ¬a ∧ b)) ∧ ((a ∧ ¬b V ¬a ∧ b) → b)</code></li>
</ul>
</li>
</ul>
<p>We combine our translations for Ava and Bob and end up with the following propositional logic statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(a → (a ∧ ¬b V ¬a ∧ b)) ∧ ((a ∧ ¬b V ¬a ∧ b) → a) ∧ (b → (a ∧ ¬b V ¬a ∧ b)) ∧ ((a ∧ ¬b V ¬a ∧ b) → b)`
</span></span></code></pre></div><p>We then complete the truth table for that proposition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                                                                                  *
</span></span><span style="display:flex;"><span>---------------------------------------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>a b | (a → (a ∧ ¬b V ¬a ∧ b)) ∧ ((a ∧ ¬b V ¬a ∧ b) → a) ∧ (b → (a ∧ ¬b V ¬a ∧ b)) ∧ ((a ∧ ¬b V ¬a ∧ b) → b)
</span></span><span style="display:flex;"><span>---------------------------------------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>T T |    F    F F  F F  F     F     F F  F F  F    T    F    F    F F  F F  F     F     F F  F F  F    T
</span></span><span style="display:flex;"><span>T F |    T    T T  T F  F     T     T T  T F  F    T    T    T    T T  T F  F     F     T T  T F  F    F
</span></span><span style="display:flex;"><span>F T |    T    F F  T T  T     F     F F  T T  T    F    F    T    F F  T T  T     F     F F  T T  T    T
</span></span><span style="display:flex;"><span>F F |    T    F T  F T  F     T     F T  F T  F    T    T    T    F T  F T  F     T     F T  F T  F    T
</span></span><span style="display:flex;"><span>---------------------------------------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [F F]
</span></span><span style="display:flex;"><span>- F: [T T] [T F] [F T]
</span></span></code></pre></div><p>And we see that there is only one truth assignment that satisfies the proposition &ndash; <code>[F F]</code>, which corresponds to Ava being a knave and Bob being a knave.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see, solving a Knights and Knaves problem by translating each statement to propositional logic is a tedious process. We ended up with a very involved final formula that made filling in the truth table somewhat arduous. Such problems are usually much simpler to solve by hand &ndash; but this process demonstrates that we <em>can</em> apply a systematic approach to solve Knights and Knaves problems with translations and truth tables.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-4">Chapter 4</h3>
<h1 id="propositional-logic-proofs">Propositional Logic Proofs</h1>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Introduction</h1>
    
    
<p>In this chapter, we will learn the process of <em>natural deduction</em> in propositional logic. This will allow us to start with a set of known facts (<em>premises</em>) and apply a series of rules to see if we can reach some goal <em>conclusion</em>. Essentially, we will be able to see whether a given conclusion necessarily follows from a set of premises.</p>
<h2 id="sequents-premises-and-conclusions">Sequents, premises, and conclusions</h2>
<p>A <em>sequent</em> is a mathematical term for an assertion. We use the notation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p0, p1, ..., pm ⊢ c
</span></span></code></pre></div><p>The <em>p0, p1, &hellip;, pm</em> are called <em>premises</em> and <em>c</em> is called the <em>conclusion</em>. The <code>⊢</code> is called the <em>turnstile operator</em>, and we read it as &ldquo;prove&rdquo;. The full sequent is read as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Statements p0, p1, ..., pm PROVE c
</span></span></code></pre></div><p>A sequent is saying that if we accept statements <em>p0, p1, &hellip;, pm</em> as facts, then we guarantee that <em>c</em> is a fact as well.</p>
<p>For example, in the sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q , ¬ q  ⊢  ¬ p
</span></span></code></pre></div><p>The premises are: <code>p → q</code> and <code> ¬q</code>, and the conclusion is <code> ¬p</code>.</p>
<p>(Shortcut: we can use <code>|-</code> in place of the <code>⊢</code> turnstile operator.)</p>
<h2 id="sequent-validity">Sequent validity</h2>
<p>A sequent is said to be <em>valid</em> if, for every truth assignment which make the premises true, then the conclusion is also true.</p>
<p>For example, consider the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q , ¬ q  ⊢  ¬ p
</span></span></code></pre></div><p>To check if this sequent is valid, we must find all truth assignments for which both premises are true, and then ensure that those truth assignments also make the conclusion true.</p>
<p>Here is a (non-Logika syntax) type of truth table that combines all three statements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p q | (p → q) | ( ¬q) |  ¬p
</span></span><span style="display:flex;"><span>---------------------------
</span></span><span style="display:flex;"><span>T T |    T     |  F   | F
</span></span><span style="display:flex;"><span>T F |    F     |  T   | F
</span></span><span style="display:flex;"><span>F T |    T     |  F   | T
</span></span><span style="display:flex;"><span>F F |    T     |  T   | T
</span></span></code></pre></div><p>Examining each row in the above truth table, we see that only the truth assignment [F F] makes both premises (<code>p → q</code> and <code> ¬q</code>) true. We look right to see that the same truth assignment also makes the conclusion (<code> ¬p</code>) true, which means that the sequent is valid.</p>
<h2 id="using-logika-for-proof-verification">Using Logika for proof verification</h2>
<p>Each Logika proof should be written in a separate file with a .logika extension. Logika verification knows each of the deduction rules we will see in the next few chapters, and will automatically check to ensure that your steps obey these deduction rules as you type your proof. If a proof is correct, you will see a purple checkmark in the lower right corner that says &ldquo;Logika verified&rdquo;. If you have logic errors, you will see them highlighted in red.</p>
<p>Sometimes, the Logika verification needs to be run manually. If you don&rsquo;t see either red errors or a purple checkmark, right-click in the text area that contains the proof and select &ldquo;Logika Check&rdquo;.</p>
<h2 id="logika-proof-syntax">Logika proof syntax</h2>
<p>Sequents in Logika have the following form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>&lt; 0 or more premises, separated by commas &gt; ⊢ &lt; 1 conclusion &gt;
</span></span></code></pre></div><p>Proofs in Logika are structured in two columns, with claims on the left and their supporting justification on the right:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>premises ⊢ conclusion
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. claim_a          justification_a
</span></span><span style="display:flex;"><span>    2. claim_b          justification_b
</span></span><span style="display:flex;"><span>       ...              ...
</span></span><span style="display:flex;"><span>    736. conclusion     justification_ef
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Each claim is given a number, and these numbers are generally in order. However, the only rule is that claim numbers be unique (they may be out of order and/or non-consecutive). Once we have justified a claim in a proof, we will refer to it as a <em>fact</em>.</p>
<p>We will see more details of Logika proof syntax as we progress through chapter 4.</p>
<h2 id="premise-justification">Premise justification</h2>
<p>The most basic justification for a claim in a proof is &ldquo;premise&rdquo;. This justification is used when you pull in a premise from the sequent and introduce it into your proof. All, some or none of the premises can be introduced at any time in any order. Please note that only one premise may be entered per claim.</p>
<p>For example, we might bring in the premises from our sequent like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q,  ¬r |- p ∧ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p            premise
</span></span><span style="display:flex;"><span>    2. q            premise
</span></span><span style="display:flex;"><span>    3.  ¬r           premise
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We could also bring in the same premise multiple times, if we wanted. We could also use non-sequential line numbers, as long as each line number was unique:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q,  ¬r |- p ∧ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    7. p            premise
</span></span><span style="display:flex;"><span>    10. q           premise
</span></span><span style="display:flex;"><span>    2.  ¬r           premise
</span></span><span style="display:flex;"><span>    8. p            premise
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We could only bring in some portion of our premises, if we wanted:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q,  ¬r |- p ∧ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p            premise
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But we can only list one premise in each claim. For example, the following is not allowed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q,  ¬r |- p ∧ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    //THIS IS WRONG ¬
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    1. p, q,  ¬r         premise
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="deduction-rules">Deduction rules</h2>
<p>The logical operators (AND, OR, NOT, IMPLIES) are a kind of language for building propositions from basic, primitive propositional atoms. For this reason, we must have laws for constructing propositions and for disassembling them. These laws are called <em>inference</em> rules or <em>deduction</em> rules. A <em>natural deduction system</em> is a set of inference rules, such that for each logical operator, there is a rule for constructing a proposition with that operator (this is called an <em>introduction rule</em>) and there is a rule for disassembling a proposition with that operator (this is called an <em>elimination rule</em>).</p>
<p>For the sections that follow, we will see the introduction and elimination rules for each logical operator. We will then learn how to use these deduction rules to write a formal proof showing that a sequent is valid.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>AND Rules</h1>
    
    
<p>In this section, we will see the deduction rules for the AND operator.</p>
<h2 id="and-introduction">AND introduction</h2>
<p>Clearly, when both <code>p</code> and <code>q</code> are facts, then so is the proposition <code>p ∧ q</code>. This makes logical sense &ndash; if two propositions are independently true, then their conjunction (AND) must also be true. The AND introduction rule, <code>∧i</code>, formalizes this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        P   Q   
</span></span><span style="display:flex;"><span>∧i :  ---------   
</span></span><span style="display:flex;"><span>        P ∧ Q
</span></span></code></pre></div><p>We will use the format above when introducing each of our natural deduction rules:</p>
<ul>
<li><code>P</code> and <code>Q</code> are not necessarily individual variables &ndash; they are placeholders for some propositional statement, which may itself involve several logical operators.</li>
<li>On the left side is the rule name (in this case, <code>∧i</code>)</li>
<li>On the top of the right side we see what we already need to have established as facts in order to use this rule (in this case, <code>P</code> and also <code>Q</code> ). These facts can appear anywhere in our scope of the proof, in whatever order. (For now, all previous lines in the proof will be within our scope, but this will change when we get to more complex rules that involve subproofs).</li>
<li>On the bottom of the right side, we see what we can claim by using that proof rule.</li>
</ul>
<p>Here is a simple example of a Logika proof that uses <code>∧i</code>. It proves that if propositional atoms <code>p</code>, <code>q</code>, and <code>r</code> are all true, then the proposition <code>r ∧ (q ∧ p)</code> is also true:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q, r ⊢ r ∧ (q ∧ p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p                    premise
</span></span><span style="display:flex;"><span>    2. q                    premise
</span></span><span style="display:flex;"><span>    3. r                    premise
</span></span><span style="display:flex;"><span>    4. q ∧ p                ∧i 2 1
</span></span><span style="display:flex;"><span>    5. r ∧ (q ∧ p)          ∧i 3 4
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can read line 4 like this: &ldquo;from the fact <code>q</code> stated on line 2 and the fact <code>p</code> stated on line 1, we deduce <code>q ∧ p</code> by applying the <code>∧i</code> rule&rdquo;. Lines 4 and 5 construct new facts from the starting facts (premises) on lines 1-3.</p>
<p>Note that if I had instead tried:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q, r ⊢ r ∧ (q ∧ p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p                    premise
</span></span><span style="display:flex;"><span>    2. q                    premise
</span></span><span style="display:flex;"><span>    3. r                    premise
</span></span><span style="display:flex;"><span>    4. q ∧ p                ∧i 1 2
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then line 4 would not have been accepted. The line numbers cited after the <code>∧i</code> rule must match the order of the resulting AND statement. The left-hand side of our resulting AND statement must correspond to the first line number in <code>∧i</code> justification, and the right-hand side of our resulting AND statement must corresponding to the second line number in the justification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    4. p			        (some justification)
</span></span><span style="display:flex;"><span>    5. q			        (some justification)
</span></span><span style="display:flex;"><span>    6. p ⋀ q                ⋀i 5 6
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    9. q ⋀ p                ⋀i 6 5
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="and-elimination">AND elimination</h2>
<p>The idea of the AND elimination rules is that if we have a proposition <code>p ⋀ q</code> as a fact, then we can separately claim both <code>p</code> and <code>q</code> as individual facts. After all, the only time <code>p ⋀ q</code> is true in a truth table is when both <code>p</code> and <code>q</code> are individually true. There are two AND elimination rules &ndash; <code>∧e1</code> and <code>∧e2</code>. <code>∧e1</code> allows us to claim that the left (first) side of an AND statement is individually true, and <code>∧e2</code> allows us to do the same with the right (second) side. Here is the formalization of each rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        P ∧ Q              P ∧ Q
</span></span><span style="display:flex;"><span> ∧e1 : ---------    ∧e2 : ---------
</span></span><span style="display:flex;"><span>          P                  Q
</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∧e1</code> rule in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ⊢ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ q            premise
</span></span><span style="display:flex;"><span>    2. p                ∧e1 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can read the justification <code>∧e1 1</code> as: AND-elimination 1 from line 1, or &ldquo;take the AND statement on line 1 and extract its first (left) side&rdquo;.</p>
<p>Here is a simple example showing the syntax of the <code>∧e2</code> rule in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ⊢ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ q            premise
</span></span><span style="display:flex;"><span>    2. q                ∧e2 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can read the justification <code>∧e2 1</code> as: AND-elimination 2 from line 1, or &ldquo;take the AND statement on line 1 and extract its second (right) side&rdquo;.</p>
<h2 id="example-1">Example 1</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∧ r) ⊢ r ∧ p
</span></span></code></pre></div><p>Whenever we approach a proof, a good first strategy is to see what we can extract from the premises. If we have a premise that is an AND statement, then we can use <code>∧e1</code> and then <code>∧e2</code> to extract both its left and right side as separate claims. So we start our proof like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∧ r) ⊢ r ∧ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ (q ∧ r)          premise
</span></span><span style="display:flex;"><span>    2. p                    ∧e1 1
</span></span><span style="display:flex;"><span>    3. q ∧ r                ∧e2 1
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But now we have a new AND statement as a claim &ndash; <code>q ∧ r</code>. We can again use both <code>∧e1</code> and <code>∧e2</code> to extract each side separately:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∧ r) ⊢ r ∧ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ (q ∧ r)          premise
</span></span><span style="display:flex;"><span>    2. p                    ∧e1 1
</span></span><span style="display:flex;"><span>    3. q ∧ r                ∧e2 1
</span></span><span style="display:flex;"><span>    4. q                    ∧e1 3
</span></span><span style="display:flex;"><span>    5. r                    ∧e2 3
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have done all we can with our premises and the resulting statements, we examine our conclusion. Whenever our conclusion is a conjunction (AND statement), we know that we must separately show both the left side and the right side of that conclusion. Then, we can use <code>∧i</code> to put those sides together into our goal AND statement.</p>
<p>In this example, we have already proved both sides of our goal AND statement &ndash; <code>r</code> (from line 5) and <code>p</code> (from line 2). All that remains is to use <code>∧i</code> to put them together:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∧ r) ⊢ r ∧ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ (q ∧ r)          premise
</span></span><span style="display:flex;"><span>    2. p                    ∧e1 1
</span></span><span style="display:flex;"><span>    3. q ∧ r                ∧e2 1
</span></span><span style="display:flex;"><span>    4. q                    ∧e1 3
</span></span><span style="display:flex;"><span>    5. r                    ∧e2 3
</span></span><span style="display:flex;"><span>    6. r ∧ p                ∧i 5 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="example-2">Example 2</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ∧ r, a ∧ (t ∨ s) ⊢ q ∧ (t ∨ s)
</span></span></code></pre></div><p>We again try to use AND-elimination to extract what we can from our premises. We might try something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ∧ r, a ∧ (t ∨ s) ⊢ q ∧ (t ∨ s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ q ∧ r            premise
</span></span><span style="display:flex;"><span>    2. p ∧ (t ∨ s)          premise
</span></span><span style="display:flex;"><span>    3. p                    ∧e1 1   //NO ¬ Won&#39;t work.
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, we get into trouble when we try to use <code>∧e1</code> to extract the left side of the premise <code>p ∧ q ∧ r</code>. The problem has to do with operator precedence &ndash; we recall that <code>∧</code> operators are processed from left to right, which means that <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>. By reminding ourselves of the &ldquo;hidden parentheses&rdquo;, we see that when we use <code>∧e1</code> on the premise <code>p ∧ q ∧ r</code>, we extract <code>p ∧ q</code>. Similarly, <code>∧e2</code> will extract <code>r</code>.</p>
<p>We try again to extract what we can from our premises:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ∧ r, a ∧ (t ∨ s) ⊢ q ∧ (t ∨ s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ q ∧ r            premise
</span></span><span style="display:flex;"><span>    2. p ∧ (t ∨ s)          premise
</span></span><span style="display:flex;"><span>    3. p ∧ q                ∧e1 1 
</span></span><span style="display:flex;"><span>    4. r                    ∧e2 1                     
</span></span><span style="display:flex;"><span>    5. a                    ∧e1 2 
</span></span><span style="display:flex;"><span>    6. t ∨ s                ∧e2 2
</span></span><span style="display:flex;"><span>    ...  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, we look at our resulting claims &ndash; we see a <code>p ∧ q</code>, and we know that we can use AND elimination again to extract both sides. Now we have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ∧ r, a ∧ (t ∨ s) ⊢ q ∧ (t ∨ s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ q ∧ r            premise
</span></span><span style="display:flex;"><span>    2. p ∧ (t ∨ s)          premise
</span></span><span style="display:flex;"><span>    3. p ∧ q                ∧e1 1 
</span></span><span style="display:flex;"><span>    4. r                    ∧e2 1                     
</span></span><span style="display:flex;"><span>    5. a                    ∧e1 2 
</span></span><span style="display:flex;"><span>    6. t ∨ s                ∧e2 2
</span></span><span style="display:flex;"><span>    7. p                    ∧e1 3
</span></span><span style="display:flex;"><span>    8. q                    ∧e2 3
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, we look at what we are trying to prove &ndash; <code>q ∧ (t ∨ s)</code>. Since its top-level operator is the AND, we know that we must separately prove <code>q</code> and <code>t ∨ s</code>. Then, we can use AND introduction to put the two pieces together to match our conclusion. We see that we already have <code>q</code> on line 8 and <code>t ∨ s</code> on line 6, so we add our final line to finish the proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ q ∧ r, a ∧ (t ∨ s) ⊢ q ∧ (t ∨ s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ q ∧ r            premise
</span></span><span style="display:flex;"><span>    2. p ∧ (t ∨ s)          premise
</span></span><span style="display:flex;"><span>    3. p ∧ q                ∧e1 1 
</span></span><span style="display:flex;"><span>    4. r                    ∧e2 1                     
</span></span><span style="display:flex;"><span>    5. a                    ∧e1 2 
</span></span><span style="display:flex;"><span>    6. t ∨ s                ∧e2 2
</span></span><span style="display:flex;"><span>    7. p                    ∧e1 3
</span></span><span style="display:flex;"><span>    8. q                    ∧e2 3
</span></span><span style="display:flex;"><span>    9. q ∧ (t ∨ s)          ∧i 8 6
</span></span></code></pre></div><p>You might notice that lines 5 and 7 were not needed, as both <code>p</code> and <code>a</code> were not part of the conclusion. That&rsquo;s true &ndash; we could have eliminated those steps. However, it&rsquo;s a good idea to extract as much information as possible while you are getting used to doing these proofs &ndash; it doesn&rsquo;t hurt to have extra claims, and you may find that you end up needing them.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>OR Rules</h1>
    
    
<p>In this section, we will see the deduction rules for the OR operator.</p>
<h2 id="or-introduction">OR introduction</h2>
<p>If we know that a proposition <code>P</code> is true, then it will also be the case that both <code>P ∨ Q</code> and <code>Q ∨ P</code> are also true. It doesn&rsquo;t matter what <code>Q</code> is &ndash; it might even be something that is know to be false. Because <code>P</code> is true, it will make the overall OR statement true as well.</p>
<p>There are two OR introduction rules &ndash; <code>∨i1</code> and <code>∨i2</code>. <code>∨i1</code> allows us to claim an OR statement with some previous fact on the left (first) side, and <code>∨i2</code> allows us to do the same with the right (second) side. Here is the formalization of each rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>         P                  Q     
</span></span><span style="display:flex;"><span>∨i1 : --------    ∨i2 :  -------- 
</span></span><span style="display:flex;"><span>       P ∨ Q              P ∨ Q 
</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∨i1</code> rule in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ⊢ p ∨ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p                premise
</span></span><span style="display:flex;"><span>    2. p ∨ q            ∨i1 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can read the justification <code>∨i1 1</code> as: OR introduction 1 from line 1, or &ldquo;create a OR statement that puts the claim from line 1 on the first (left) side, and puts something new on the second side&rdquo;.</p>
<p>Here is a simple example showing the syntax of the <code>∨i2</code> rule in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ⊢ q ∨ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p                premise
</span></span><span style="display:flex;"><span>    2. q ∨ p            ∨i2 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can read the justification <code>∨i2 1</code> as: OR introduction 2 from line 1, or &ldquo;create a OR statement that puts the claim from line 1 on the second (right) side, and puts something new on the first side&rdquo;.</p>
<h2 id="or-elimination">OR elimination</h2>
<p>The OR elimination rule is used when we have an OR statement of the form <code>P ∨ Q</code>, and we wish to use it to extract new information. In real life, we call the rule &ldquo;case analysis&rdquo;. For example, say that you have either 12 quarters in your pocket or 30 dimes in your pocket. In either case, you can buy a $3.00 coffee. Why? You do a case analysis:</p>
<ul>
<li>In the case you have 12 quarters, that totals $3.00, and you can buy the coffee;</li>
<li>In the case you have 30 dimes, that totals $3.00, and you can buy the coffee.</li>
</ul>
<p>So, in both cases, you can buy the coffee.</p>
<p>We can formalize the idea behind the OR elimination rule as follows:</p>
<ul>
<li>In order to the OR statement <code>P ∨ Q</code> to be true, at least one of <code>P</code> and <code>Q</code> must be individually true</li>
<li>If we are able to reach some conclusion <code>R</code> if we assume <code>P</code> is true, and we are able to reach the SAME conclusion <code>R</code> if we assume <code>Q</code> is true&hellip;</li>
<li>&hellip;Then no matter what, <code>R</code> will be true.</li>
</ul>
<h3 id="subproofs">Subproofs</h3>
<p>OR elimination will be our first proof rule that uses subproofs. Subproofs are tools for case analysis or what-if excursions, used to support justification for later claims. In propositional logic, they will always contain one assumption. This assumption is a proposition whose scope is limited to the subproof. The syntax of a subproof in Logika looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>premises ⊢ consequent
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. fact_A       justification_1
</span></span><span style="display:flex;"><span>    ...             ...
</span></span><span style="display:flex;"><span>    17. {
</span></span><span style="display:flex;"><span>        18. fact_ D     assume
</span></span><span style="display:flex;"><span>        ...             ...
</span></span><span style="display:flex;"><span>        25. fact_G      some_rule  using claim 1 // this is ok
</span></span><span style="display:flex;"><span>        ...             ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...             ...
</span></span><span style="display:flex;"><span>    45. fact_R      some_rule using claim 25   // this is NOT ok
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Opening and closing braces, <code>{...}</code>,  define the scope of claims. Other than the first <code>{</code> which goes directly under the sequent, the opening brace is given a claim number, but no justification. Closing braces are not given claim numbers. The use of braces is analogous to their use to define scope in Java, C# and C.</p>
<p>In the example above, the subproof starting on line 17 creates an environment where fact_D is true. The justification used on claim number 25, which uses claim 1, is valid. The scope of claim 1 includes subproof 17.</p>
<p>However, the justification for line number 45 is invalid. Fact_G on line number 25 was proven true in an environment where fact_D is true (ie subproof 17).  That environment ends (falls out of scope) when the closing brace for the subproof is reached. This happens before line 45.</p>
<p>Only specific deduction rules allow you to close a scope and create a new claim based on that subproof in the enclosing (outer) scope. These rules always take a subproof (i.e &ldquo;17&rdquo;) as part of the justification.</p>
<h3 id="syntax">Syntax</h3>
<p>Here is the OR elimination rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                 { P assume       { Q assume
</span></span><span style="display:flex;"><span>      P ∨ Q        ... R    }      ... R     }
</span></span><span style="display:flex;"><span>∨e : -------------------------------------------
</span></span><span style="display:flex;"><span>                         R
</span></span></code></pre></div><p>In order to use the <code>∨e</code> rule, we must have three things:</p>
<ul>
<li>An OR statement of the form <code>P ∨ Q</code></li>
<li>A subproof that begins by assuming the left side of the OR statement (<code>P</code>) and ends with some claim <code>R</code></li>
<li>A subproof that begins by assuming the right side of the OR statement (<code>Q</code>) and ends with the same claim <code>R</code></li>
</ul>
<p>If we have all three parts, we can use the <code>∨e</code> and cite the OR statement and both subproofs to claim that <code>R</code> is true no matter what.</p>
<p>Here is a simple example showing the syntax of the <code>∨e</code> rule in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∨ q ⊢ q ∨ p 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∨ q            premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. p            assume
</span></span><span style="display:flex;"><span>        4. q ∨ p        ∨i2 3
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    5. {
</span></span><span style="display:flex;"><span>        6. q            assume
</span></span><span style="display:flex;"><span>        7. q ∨ p        ∨i1 6
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. q ∨ p            ∨e 1 2 5
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, we have the OR statement <code>p ∨ q</code>. We then have two subproofs where we separately assume that the two sides or the OR are true. The first subproof on line 2 starts by assuming the left side of the OR, <code>p</code>. It then uses OR introduction to reach the goal conclusion, <code>q ∨ p</code>. After reaching our goal, we end the first subproof and immediately start a second subproof. In the second subproof, we assume that the the right side of our OR statement is true, <code>q</code>. We then use the other form of OR introduction to reach the SAME conclusion as we did in the first subproof &ndash; <code>q ∨ p</code>. We end the second subproof and can now use <code>∨e</code> to state that our conclusion <code>q ∨ p</code> must be true no matter what. After all, we knew that at least one of <code>p</code> or <code>q</code> was true, and we were able to reach the conclusion <code>q ∨ p</code> in both cases.</p>
<p>When using the justification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∨e 1 2 5
</span></span></code></pre></div><p>The first line number corresponds to our original OR statement (line 1 with <code>p ∨ q</code> for us), the second line number corresponds to the subproof where we assumed the first (left) side of that OR statement (line 2 for us, which starts the subproof where we assumed <code>p</code>), and the third line number corresponds to the subproof where we assumed the second (right) side of that OR statement (line 5 for us, which starts the subproof where we assumed <code>q</code>)</p>
<p>This proof shows that the OR operator is commutative.</p>
<h2 id="example-1">Example 1</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∨ r) ⊢ (p ∧ q) ∨ (p ∧ r)
</span></span></code></pre></div><p>As we have done before, we start by extracting whatever we can from our premises:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∨ r) ⊢ (p ∧ q) ∨ (p ∧ r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ (q ∨ r)                  premise
</span></span><span style="display:flex;"><span>    2. p                            ∧e1 1
</span></span><span style="display:flex;"><span>    3. q ∨ r                        ∧e2 1
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, we look at what we are trying to prove, and see that its top-level operator is an OR. If we already had either side of our goal OR statement (i.e., either <code>p ∧ q</code> or <code>p ∧ r</code>), then we could use <code>∧i</code> to create the desired proposition. This isn&rsquo;t the case for us, though, so we need to use a different strategy.</p>
<p>The next consideration when we want to prove an OR statement is whether we have another OR statement, either as a premise or a fact we have already established. If we do, then we can attempt to use OR elimination with that OR statement to build our goal conclusion (<code>(p ∧ q) ∨ (p ∧ r)</code>). We have the OR statement <code>q ∨ r</code> available, so we&rsquo;ll try to use OR elimination &ndash; we&rsquo;ll have a subproof where we assume <code>q</code> and try to reach <code>(p ∧ q) ∨ (p ∧ r)</code>, and then a subproof where we assume <code>r</code> and try to reach <code>(p ∧ q) ∨ (p ∧ r)</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∧ (q ∨ r) ⊢ (p ∧ q) ∨ (p ∧ r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∧ (q ∨ r)                  premise
</span></span><span style="display:flex;"><span>    2. p                            ∧e1 1
</span></span><span style="display:flex;"><span>    3. q ∨ r                        ∧e2 1
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. q                        assume
</span></span><span style="display:flex;"><span>        6. p ∧ q                    ∧i2 5
</span></span><span style="display:flex;"><span>        7. (p ∧ q) ∨ (p ∧ r)        ∨i1 6
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. {
</span></span><span style="display:flex;"><span>        9. r                        assume
</span></span><span style="display:flex;"><span>        10. p ∧ r                   ∧i2 9
</span></span><span style="display:flex;"><span>        11. (p ∧ q) ∨ (p ∧ r)       ∨i2 10
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    12. (p ∧ q) ∨ (p ∧ r)           ∨e 3 4 8
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can make our final claim:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>12. (p ∧ q) ∨ (p ∧ r)           ∨e 3 4 8
</span></span></code></pre></div><p>Because we had an OR statement on line 3 (<code>q ∨ r</code>), assumed the left side of that OR (<code>q</code>) in subproof 4 and reached the conclusion of <code>(p ∧ q) ∨ (p ∧ r)</code>, and then assumed the right side of our OR (<code>r</code>) in subproof 8 and reached the SAME conclusion of <code>(p ∧ q) ∨ (p ∧ r)</code>.</p>
<h2 id="example-2">Example 2</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p ∨ q) ∧ (p ∨ r) ⊢ p ∨ (q ∧ r)
</span></span></code></pre></div><p>Note that this is the same as the previous example, but the premises are switched with the conclusion. If we prove this direction too, we will have shown that <code>(p ∨ q) ∧ (p ∨ r)</code> is equivalent to <code>p ∨ (q ∧ r)</code>. We&rsquo;ll learn more about this process in section 4.8.</p>
<p>We start by pulling in our premises and extracting whatever information we can:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p ∨ q) ∧ (p ∨ r) ⊢ p ∨ (q ∧ r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. (p ∨ q) ∧ (p ∨ r)                premise
</span></span><span style="display:flex;"><span>    2. p ∨ q                            ∧e1 1
</span></span><span style="display:flex;"><span>    3. p ∨ r                            ∧e2 1
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We see that the top-level operator of our conclusion (<code>p ∨ (q ∧ r)</code>) is an OR, so we apply the same strategy we did in the previous example &ndash; we see if we have an OR statement already available as a claim, and then try to use OR elimination on it to build to our conclusion in both subproofs. In this case, though, we have TWO or statements &ndash; <code>p ∨ q</code> and <code>p ∨ r</code>. We will see that it doesn&rsquo;t matter which of these we choose, so let&rsquo;s pick the first one &ndash; <code>p ∨ q</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p ∨ q) ∧ (p ∨ r) ⊢ p ∨ (q ∧ r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. (p ∨ q) ∧ (p ∨ r)                premise
</span></span><span style="display:flex;"><span>    2. p ∨ q                            ∧e1 1
</span></span><span style="display:flex;"><span>    3. p ∨ r                            ∧e2 1
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p                            assume
</span></span><span style="display:flex;"><span>        6. p ∨ (q ∧ r)                  ∨i1 5
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    7. {
</span></span><span style="display:flex;"><span>        8. q                            assume
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        //what do we do now?
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We are able to finish the first subproof, but it&rsquo;s not clear what to do in the second subproof. We assume <code>q</code>, and know we have the goal of reaching the same conclusion as we did in the first subproof, <code>p ∨ (q ∧ r)</code>&hellip;but we don&rsquo;t have enough information yet to get there. The only piece of information that we haven&rsquo;t used that might help us is our second OR statement &ndash; <code>p ∨ r</code>. We are already inside a subproof, but we can still nest other subproofs &ndash; just as we can nest conditional statements in computer programs.</p>
<p>We start on a nested OR elimination approach with <code>p ∨ r</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p ∨ q) ∧ (p ∨ r) ⊢ p ∨ (q ∧ r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. (p ∨ q) ∧ (p ∨ r)                premise
</span></span><span style="display:flex;"><span>    2. p ∨ q                            ∧e1 1
</span></span><span style="display:flex;"><span>    3. p ∨ r                            ∧e2 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //OR elimination for p ∨ q
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p                            assume
</span></span><span style="display:flex;"><span>        6. p ∨ (q ∧ r)                  ∨i1 5
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    7. {
</span></span><span style="display:flex;"><span>        8. q                            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //start on OR elimination with p ∨ r
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. p                       assume
</span></span><span style="display:flex;"><span>            11. p ∨ (q ∧ r)             ∨i1 10
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        12. {
</span></span><span style="display:flex;"><span>            13. r                       assume
</span></span><span style="display:flex;"><span>            14. q ∧ r                   ∧i 8 13
</span></span><span style="display:flex;"><span>            15. p ∨ (q ∧ r)             ∨i2 14
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        16. p ∨ (q ∧ r)                 ∨e 3 9 12
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    17. p ∨ (q ∧ r)                     ∨e 2 4 7
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that we use the ∨e rule twice &ndash; on line 16 to tie together subproofs 9 and 12 (where we processed the OR statement <code>p ∨ r</code>), and on line 17 to tie together subproofs 4 and 7 (where we processed the OR statement <code>p ∨ q</code>).</p>
<p>When we first started this problem, we mentioned that it didn&rsquo;t matter which OR statement we chose to work with &ndash; <code>p ∨ q</code> or <code>p ∨ r</code>. Indeed, we could have chosen <code>p ∨ r</code> instead &ndash; but we would end up nesting another OR elimination for <code>p ∨ q</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p ∨ q) ∧ (p ∨ r) ⊢ p ∨ (q ∧ r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. (p ∨ q) ∧ (p ∨ r)                premise
</span></span><span style="display:flex;"><span>    2. p ∨ q                            ∧e1 1
</span></span><span style="display:flex;"><span>    3. p ∨ r                            ∧e2 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //OR elimination for p ∨ r
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p                            assume
</span></span><span style="display:flex;"><span>        6. p ∨ (q ∧ r)                  ∨i1 5
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    7. {
</span></span><span style="display:flex;"><span>        8. r                            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //start on OR elimination with p ∨ q
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. p                       assume
</span></span><span style="display:flex;"><span>            11. p ∨ (q ∧ r)             ∨i1 10
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        12. {
</span></span><span style="display:flex;"><span>            13. q                       assume
</span></span><span style="display:flex;"><span>            14. q ∧ r                   ∧i 13 8
</span></span><span style="display:flex;"><span>            15. p ∨ (q ∧ r)             ∨i2 14
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        16. p ∨ (q ∧ r)                 ∨e 2 9 12
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    17. p ∨ (q ∧ r)                     ∨e 3 4 7
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Implies Rules</h1>
    
    
<p>In this section, we will see the deduction rules for the implies operator.</p>
<h2 id="implies-elimination">Implies elimination</h2>
<p>Remember that <code>→</code> is a kind of logical &ldquo;if-then&rdquo;. Here, we understand <code>p → q</code> to mean that <code>p</code> holds knowledge sufficient to deduce <code>q</code> – so, whenever <code>p</code> is proved to be a fact, then <code>p → q</code> enables <code>q</code> to be proved a fact, too. This is the implies elimination rule, <code>→e</code>, and we can formalize it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       P → Q    P
</span></span><span style="display:flex;"><span> →e :  ------------
</span></span><span style="display:flex;"><span>             Q
</span></span></code></pre></div><p>Here is a simple example of a Logika proof that shows the syntax of the <code>→e</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>a, a → b ⊢ b
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. a                    premise
</span></span><span style="display:flex;"><span>    2. a → b                premise
</span></span><span style="display:flex;"><span>    3. b                    →e 2 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that when we use <code>→e</code>, we first list the line number of the implies statement, and then list the line number that contains the left side of that implies statement. The  <code>→e</code> allows us to claim the right side of that implies statement.</p>
<h2 id="implies-introduction">Implies introduction</h2>
<p>The idea behind the next deduction rule, implies introduction, is that we would be introducing a new implies statement of the form <code>P → Q</code>. In order to do this, we must be able to show our logical &ldquo;if-then&rdquo; &ndash; that IF <code>P</code> exists, THEN we promise that <code>Q</code> will also exist. We do this by way of a subproof where we assume <code>P</code>. If we can reach <code>Q</code> by the end of that subproof, we will have shown that anytime <code>P</code> is true, then <code>Q</code> is also true. We will be able to close the subproof by introducing <code>P → Q</code> with the <code>→i</code> rule. We can formalize the rule like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       { P assume   
</span></span><span style="display:flex;"><span>         ... Q    } 
</span></span><span style="display:flex;"><span>→i : -------------- 
</span></span><span style="display:flex;"><span>          P → Q 
</span></span></code></pre></div><p>Here is a simple example of a Logika proof that shows the syntax of the <code>→i</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>a → b, b → c ⊢ a → c
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. a → b               premise
</span></span><span style="display:flex;"><span>    2. b → c               premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        //we want to prove a → c, so we start by assuming a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        4. a                assume
</span></span><span style="display:flex;"><span>        5. b                →e 1 4
</span></span><span style="display:flex;"><span>        6. c                →e 2 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //...and try to end with c
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //then we can conclude that anytime a is true, then c is also true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    7. a → c                →i 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that when we use <code>→i</code>, we list the line number of the subproof we just finished. We must have started that subproof by assuming the left side of the implies statement we are introducing, and ended that subproof with the right side of the implies statement we are introducing.</p>
<h2 id="example-1">Example 1</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (q ∧ p) → r
</span></span></code></pre></div><p>We start by listing our premise:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (q ∧ p) → r
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → (q → r)          premise
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can&rsquo;t extract any information from the premise, so we shift to examining our conclusion. The top-level operator of our conclusion is an implies statement, so this tells us that we will need to use the <code>→i</code> rule. We want to prove <code>(q ∧ p) → r</code>, so we need to show that whenever <code>q ∧ p</code> is true, then <code>r</code> is also rule. We open a subproof and assume the left side of our goal implies statement (<code>q ∧ p</code>). If we can reach <code>r</code> by the end of the subproof, then we can use <code>→i</code> to conclude <code>(q ∧ p) → r</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (q ∧ p) → r
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → (q → r)          premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. q ∧ p            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to r
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (q ∧ p) → r
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we can complete the proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (q ∧ p) → r
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → (q → r)          premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. q ∧ p            assume
</span></span><span style="display:flex;"><span>        4. q                ∧e1 3
</span></span><span style="display:flex;"><span>        5. p                ∧e2 3
</span></span><span style="display:flex;"><span>        6. q → r            →e 1 5
</span></span><span style="display:flex;"><span>        7. r                →e 6 4 
</span></span><span style="display:flex;"><span>        //goal: get to r
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (q ∧ p) → r
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    8. r                    →i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="example-2">Example 2</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (p → q) → (p → r)
</span></span></code></pre></div><p>We see that we will have no information to extract from the premises. The top-level operator is an implies statement, so we start a subproof to introduce that implies statement. In our subproof, we will assume the left side of our goal implies statement (<code>p → q</code>) and will try to reach the right side of our goal (<code>p → r</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (p → q) → (p → r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → (q → r)          premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. p → q            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to p → r
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → (p → r)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can see that our goal is to reach <code>p → r</code> in our subproof &ndash; so we see that we need to introduce another implies statement. This tells us that we need to nest another subproof &ndash; in this one, we&rsquo;ll assume the left side of our <em>current</em> goal implies statement (<code>p</code>), and then try to reach the right side of that current goal (<code>r</code>). Then, we&rsquo;d be able to finish that inner subproof by using <code>→i</code> to conclude <code>p → r</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (p → q) → (p → r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → (q → r)          premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. p → q            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. p            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: get to r
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //use →i to conclude p → r
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to p → r
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → (p → r)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we can complete the proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → (q → r) ⊢ (p → q) → (p → r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → (q → r)          premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. p → q            assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. p            assume
</span></span><span style="display:flex;"><span>            6. q            →e 3 5
</span></span><span style="display:flex;"><span>            7. q → r        →e 1 5 
</span></span><span style="display:flex;"><span>            8. r            →e 7 6  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: get to r
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //use →i to conclude p → r
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        9. p → r             →i 4   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to p → r
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → (p → r)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    10. (p → q) → (p → r)   →i 2 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="example-3">Example 3</h2>
<p>Here is one more example, where we see we can nest a <code>→i</code> subproof and a <code>∨e</code> subproof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → r, q → r ⊢ (p ∨ q) → r
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → r                premise
</span></span><span style="display:flex;"><span>    2. q → r                premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        //assume p ∨ q, try to get to r 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        4. p ∨ q             assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //nested subproof for OR elimination on p ∨ q
</span></span><span style="display:flex;"><span>        //try to get to r in both cases
</span></span><span style="display:flex;"><span>        5. {
</span></span><span style="display:flex;"><span>            6. p            assume
</span></span><span style="display:flex;"><span>            7. r            →e 1 6
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. {
</span></span><span style="display:flex;"><span>            9.  q           assume
</span></span><span style="display:flex;"><span>            10. r           →e 2 9
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        11. r                ∨e 4 5 8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to r
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p ∨ q) → r
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    12. (p ∨ q) → r         →i 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Negation Rules</h1>
    
    
<p>In this section, we will see the deduction rules for the NOT operator. In this section, we will introduce the contradiction symbol (<code>⊥</code>, or <code>_|_</code> in ASCII). This symbol is also referred to as the <em>bottom operator</em>. We will be able to claim that a <em>contradiction</em> occurs when, for some proposition <code>P</code>, we have proved both the facts <code>P</code> and <code>¬ P</code>. This indicates that we are in an impossible situation, and often means that we have made a bad previous assumption.</p>
<h2 id="not-elimination">Not elimination</h2>
<p>The not elimination rule allows you to claim that you have reached a contradiction. We can formalize the rule like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        P   ¬ P
</span></span><span style="display:flex;"><span>¬ e : -----------
</span></span><span style="display:flex;"><span>          ⊥
</span></span></code></pre></div><p>Here is a simple example of a Logika proof that shows the syntax of the <code>¬ e</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>q, ¬ q ⊢ ⊥
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. q                premise
</span></span><span style="display:flex;"><span>    2. ¬ q              premise
</span></span><span style="display:flex;"><span>    3. ⊥                ¬ e 1 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We use the <code>¬ e</code> rule when we have facts for both <code>P</code> and <code>¬ P</code> for some proposition <code>P</code>. When we use the justification, we first list the line number of the claim for <code>P</code> (line 1, in our case) and then the line number of the claim for <code>¬ P</code> (line 2, in our case).</p>
<p>Sometimes, the proposition <code>P</code> itself has a NOT operator. Consider this example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬ q, ¬ ¬ q ⊢ ⊥
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬ q              premise
</span></span><span style="display:flex;"><span>    2. ¬ ¬ q            premise
</span></span><span style="display:flex;"><span>    3. ⊥                ¬ e 1 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, our proposition <code>P</code> is the claim <code>¬ q</code>, and our proposition that is of the form <code>¬ P</code> is the claim <code>¬ ¬ q</code>.</p>
<h2 id="not-introduction">Not introduction</h2>
<p>The not introduction rule allows us to introduce a NOT operation. If assuming some proposition <code>P</code> leads to a contradiction, then we must have made a bad assumption &ndash; <code>P</code> must NOT be true after all. We can then introduce the fact <code>¬ P</code>. We can formalize the not introduction rule like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       { P assume
</span></span><span style="display:flex;"><span>         ... ⊥  }
</span></span><span style="display:flex;"><span>¬ i:   --------------
</span></span><span style="display:flex;"><span>           ¬ P
</span></span></code></pre></div><p>Here is a simple example of a Logika proof that shows the syntax of the <code>¬ i</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p,  q → ¬ p  ⊢  ¬ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p            premise
</span></span><span style="display:flex;"><span>    2. q → ¬ p      premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. q        assume
</span></span><span style="display:flex;"><span>        5. ¬ p      →e 2 4
</span></span><span style="display:flex;"><span>        6. ⊥        ¬e 1 5
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    7. ¬ q          ¬i 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that the not introduction rule involves a subproof &ndash; if we wish to prove <code>¬ P</code> for some proposition <code>P</code>, then we start a subproof where we assume <code>P</code>. If we are able to reach a contradiciton on the last line of that subproof, then we can use the <code>¬ i</code> rule after the subproof ends to claim that our assumption was bad and that it is actually <code>¬ P</code> that is true. When we use <code>¬i</code> as a justification, we list the line number corresponding to this subproof.</p>
<h2 id="bottom-elimination">Bottom elimination</h2>
<p>There is a special law for reasoning forwards from an impossible situation — the ⊥e law — which says, in the case of a contradiction, everything becomes a fact. (That is, &ldquo;if False is a fact, so is everything else ¬&rdquo;.) This rule is called &ldquo;bottom elimination&rdquo;, and is written as <code>⊥e</code>. Here is a formalization of the rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>         ⊥
</span></span><span style="display:flex;"><span>⊥e :  ------  for any proposition, Q, at all
</span></span><span style="display:flex;"><span>         Q
</span></span></code></pre></div><p>Here is a simple example of a Logika proof that shows the syntax of the <code>⊥e</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, ¬ p  ⊢ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p            premise
</span></span><span style="display:flex;"><span>    2. ¬ p          premise
</span></span><span style="display:flex;"><span>    3. ⊥            ¬ e 1 2
</span></span><span style="display:flex;"><span>    4. q            ⊥e 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that when we use <code>⊥e</code> as the justification, we list the line number of where we reached a contradiction (<code>⊥</code>).</p>
<p>The bottom elimination rule works well with case analysis, where we discover that one case is impossible. Here is a classic example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p ∨ q, ¬ p ⊢ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p ∨ q        premise
</span></span><span style="display:flex;"><span>    2. ¬ p          premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. p        assume
</span></span><span style="display:flex;"><span>        5. ⊥        ¬e 4 2
</span></span><span style="display:flex;"><span>        6. q        ⊥e 5
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    7. {
</span></span><span style="display:flex;"><span>        8. q        assume
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. q            ∨e 1 3 7
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Considering the premise, <code>p ∨ q</code>, we analyze our two cases by starting OR elimination. The first case, where <code>p</code> holds true, is impossible, because it causes a contradiction. The <code>⊥e</code>-rule lets us gracefully prove <code>q</code> in this &ldquo;impossible case&rdquo;. (You can read lines 4-6 as saying, &ldquo;in the case when <code>p</code> might hold true, there is a contradiction, and in such an impossible situation, we can deduce whatever we like, so we deduce <code>q</code> to finish this impossible case&rdquo;.)</p>
<p>The second case, that <code>q</code> holds true, is the only realistic case, and it immediately yields the conclusion. The proof finishes the two-case analysis with the <code>∨e</code> rule.</p>
<h2 id="proof-by-contradiction">Proof by contradiction</h2>
<p>The proof by contraction rule, <code>pbc</code>, says that when assuming <code>¬ P</code> leads to a contradiction for some proposition <code>P</code>, then we made a bad assumption and thus <code>P</code> must be true. It is very similar to the <code>¬ i</code> rule, except <code>pbc</code> has us assuming <code>¬ P</code> and eventually concluding <code>P</code>, while the <code>¬ i</code> rule has us assuming <code>P</code> and evntually concluding <code>¬ P</code>.</p>
<p>Here is a formalization of <code>pbc</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        { ¬ P assume
</span></span><span style="display:flex;"><span>          ... ⊥   }
</span></span><span style="display:flex;"><span>pbc:   ---------------
</span></span><span style="display:flex;"><span>             P
</span></span></code></pre></div><p>And here is a Logika example that demonstrates the syntax of the rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬ ¬ p ⊢ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬ ¬ p        premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ¬ p      assume
</span></span><span style="display:flex;"><span>        4. ⊥        ¬e 3 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    5. p            pbc 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When we use the <code>pbc</code> rule as a justification for a claim <code>P</code>, we cite the line number of the subproof where we assumed <code>¬ P</code> and ended in a contradiction.</p>
<h2 id="example-1">Example 1</h2>
<p>Suppose we want to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬p ∧ ¬q |- ¬(p ∨ q)
</span></span></code></pre></div><p>We start by listing our premise, and extracting the two sides of the AND statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬p ∧ ¬q ⊢ ¬(p ∨ q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬p ∧ ¬q          premise
</span></span><span style="display:flex;"><span>    2. ¬p               ∧e1 1
</span></span><span style="display:flex;"><span>    3. ¬q               ∧e2 1
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, we see that our conclusion has the form NOT (something), so this tells us that we will need to introduce a NOT (using the <code>¬ i</code> rule). In fact, ANY time we wish to prove a proposition of the form NOT (something), we will always use the <code>¬ i</code> rule. (We will discuss proof strategies in detail in the next section.) Since we want to prove <code>¬ (p ∨ q)</code>, then we open a subproof where we assume <code>p ∨ q</code>. If we can end that subproof with a contradiction, then we can use <code>¬ i</code> afterwards to conclude <code>¬(p ∨ q)</code>.</p>
<p>We know that we want this proof structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬p ∧ ¬q ⊢ ¬(p ∨ q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬p ∧ ¬q          premise
</span></span><span style="display:flex;"><span>    2. ¬p               ∧e1 1
</span></span><span style="display:flex;"><span>    3. ¬q               ∧e2 1
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p ∨ q        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //want to reach a contradiction
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //will use ¬ i to conclude ¬(p ∨ q)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We know we must reach a contradiction in our subproof. We see that we have claims <code>¬p</code>, <code>¬q</code>, and <code>p ∨ q </code>. Since at least one of <code>p ∨ q </code> is true, and since either one would yield a contradiction with one of <code>¬p</code> or <code>¬q</code>, then we start on OR elimination:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬p ∧ ¬q ⊢ ¬(p ∨ q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬p ∧ ¬q          premise
</span></span><span style="display:flex;"><span>    2. ¬p               ∧e1 1
</span></span><span style="display:flex;"><span>    3. ¬q               ∧e2 1
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p ∨ q        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //OR elimination subproofs on p ∨ q
</span></span><span style="display:flex;"><span>        6. {
</span></span><span style="display:flex;"><span>            7. p        assume
</span></span><span style="display:flex;"><span>            8. ⊥        ⊥e 7 2
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. q       assume
</span></span><span style="display:flex;"><span>            11. ⊥       ⊥e 10 3
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use ∨e rule to tie together subproofs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //want to reach a contradiction
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //will use ¬ i to conclude ¬(p ∨ q)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We see that both OR elimination subproofs ended with a contradiction (<code>⊥</code>). Just like any other use of <code>∨e</code>, we restate that common conclusion after the two subproofs. We knew at least one of <code>p</code> or <code>q</code> were true, and both ended in a contradiction &ndash; so the contradiction holds no matter what:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬p ∧ ¬q ⊢ ¬(p ∨ q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬p ∧ ¬q          premise
</span></span><span style="display:flex;"><span>    2. ¬p               ∧e1 1
</span></span><span style="display:flex;"><span>    3. ¬q               ∧e2 1
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p ∨ q        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //OR elimination subproofs on p ∨ q
</span></span><span style="display:flex;"><span>        6. {
</span></span><span style="display:flex;"><span>            7. p        assume
</span></span><span style="display:flex;"><span>            8. ⊥        ⊥e 7 2
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. q       assume
</span></span><span style="display:flex;"><span>            11. ⊥       ⊥e 10 3
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use ∨e rule to tie together subproofs
</span></span><span style="display:flex;"><span>        12. ⊥           ∨e 5 6 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //want to reach a contradiction
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //will use ¬ i to conclude ¬(p ∨ q)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All that remains is the use the <code>¬ i</code> rule to finish subproof 4, as that subproof ended with a contradiction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬p ∧ ¬q ⊢ ¬(p ∨ q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬p ∧ ¬q          premise
</span></span><span style="display:flex;"><span>    2. ¬p               ∧e1 1
</span></span><span style="display:flex;"><span>    3. ¬q               ∧e2 1
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. p ∨ q        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //OR elimination subproofs on p ∨ q
</span></span><span style="display:flex;"><span>        6. {
</span></span><span style="display:flex;"><span>            7. p        assume
</span></span><span style="display:flex;"><span>            8. ⊥        ⊥e 7 2
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. q       assume
</span></span><span style="display:flex;"><span>            11. ⊥       ⊥e 10 3
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use ∨e rule to tie together subproofs
</span></span><span style="display:flex;"><span>        12. ⊥           ∨e 5 6 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //want to reach a contradiction
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //will use ¬ i to conclude ¬(p ∨ q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    13. ¬(p ∨ q)        ¬ i 4
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="example-2">Example 2</h2>
<p>When doing propositional logic translations, we learned that <code>p → q</code> is equivalent to its <em>contrapositive</em>, <code>¬q → ¬p</code>. We will prove one direction of this equivalence (to show two statements are <em>provably equivalent,</em> which we will see in section 4.8, we would need to prove both directions):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q ⊢ ¬q → ¬p
</span></span></code></pre></div><p>We notice that the top-level operator of our conclusion is an IMPLIES operator, so we know that we need to introduce an implies operator. We saw in the previous section that the blueprint for introducing an implies operator is with a subproof: assume the left side of the goal implies statement, and try to reach the right side of the goal implies statement by the end of the subproof.</p>
<p>We have this proof structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q ⊢ ¬q → ¬p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → q                premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ¬q               assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach ¬p
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude ¬q → ¬p
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We see that our goal in the subproof is the show ¬p &ndash; if we could do that, then we could tie together that subproof with the →i rule. Since our intermediate goal is to prove NOT (something), then we use our strategy for not introduction as an inner subproof. We finish the proof as shown:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q ⊢ ¬q → ¬p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → q                premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ¬q               assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use ¬i strategy to prove ¬p
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. p            assume
</span></span><span style="display:flex;"><span>            6. q            →e 1 5
</span></span><span style="display:flex;"><span>            7. ⊥            ⊥e 6 3
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. ¬p               ¬i 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach ¬p
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude ¬q → ¬p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    9. ¬q → ¬p              →i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="example-3">Example 3</h2>
<p>Suppose we want to prove the sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(¬p ∨ ¬q) ⊢ p ∧ q
</span></span></code></pre></div><p>We see that there is nothing to extract from our premise, and that the top-level operator of the conclusion (<code>p ∧ q</code>) is an AND. We see that we will need to introduce an AND statement &ndash; but the only way we can create <code>p ∧ q</code> is to separately prove both <code>p</code> and <code>q</code>.</p>
<p>It is not immediately clear how to prove either <code>p</code> or <code>q</code>. We will discuss proof strategies in more detail in the next section, but <code>pbc</code> is a good fallback option if you don&rsquo;t have a clear path for how to prove something and some of the claims in the proof involve negation. Since we wish to prove <code>p</code>, then will will assume <code>¬p</code> in a subproof. If we can reach a contradiction, then we can use <code>pbc</code> to conclude <code>p</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(¬p ∨ ¬q) ⊢ p ∧ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬(¬p ∨ ¬q)           premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ¬p               assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: contradiction
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use pbc to conclude p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //similarly prove q
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //use ∧i to conclude p ∧ q
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In subproof 2, we know we need to end with a contradiction. The only propositions we have to work with are <code>¬(¬p ∨ ¬q)</code> and <code>¬p</code>. But if we use <code>∨i1</code> with <code>¬p</code>, then we could have <code>¬p ∨ ¬q</code> &ndash; and then we could claim a contradiction ¬ We complete the proof as shown (using the same strategy to prove <code>q</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(¬p ∨ ¬q) ⊢ p ∧ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬(¬p ∨ ¬q)           premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ¬p               assume
</span></span><span style="display:flex;"><span>        4. ¬p ∨ ¬q          ∨i1 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: contradiction
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use pbc to conclude p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    5. p                    pbc 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //similarly prove q
</span></span><span style="display:flex;"><span>    6. {
</span></span><span style="display:flex;"><span>        7. ¬q               assume
</span></span><span style="display:flex;"><span>        8. ¬p ∨ ¬q          ∨i2 7
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. q                    pbc 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //use ∧i to conclude p ∧ q
</span></span><span style="display:flex;"><span>    10. p ∧ q               ∧i 5 9
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="law-of-the-excluded-middle">Law of the excluded middle</h2>
<p>The <em>law of the excluded middle (LEM)</em> is famous consequence of <code>pbc</code>: from no starting premises at all, we can prove <code>p ∨ ¬ p</code> for any proposition we can imagine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ p ∨ ¬ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. ¬ (p ∨ ¬ p)      assume
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. p            assume
</span></span><span style="display:flex;"><span>            5. p ∨ ¬ p      ∨i1 4
</span></span><span style="display:flex;"><span>            6. ⊥            ¬e 5 2
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        7.  ¬ p             ¬i 3
</span></span><span style="display:flex;"><span>        8.  p ∨ ¬ p         ∨i2 7
</span></span><span style="display:flex;"><span>        9.  ⊥               ¬e 8 2
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    10. p ∨ ¬ p             pbc 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In other proofs involving negation and no clear path forward, it is sometimes useful to first derive LEM (this is possible since no premises are needed). If we have the claim <code>p ∨ ¬ p</code> in a proof, then we can use OR elimination where we separately assume <code>p</code> and then <code>¬ p</code> to try to reach the same conclusion. Here is one such example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → q ⊢ ¬ p ∨ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → q                premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    2. {                             // start of previous p ∨ ¬ p proof
</span></span><span style="display:flex;"><span>        3. ¬ (p ∨ ¬ p)      assume
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. p            assume
</span></span><span style="display:flex;"><span>            6. p ∨ ¬ p      ∨i1 5
</span></span><span style="display:flex;"><span>            7. ⊥            ¬e 6 3
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8.  ¬ p             ¬i 4
</span></span><span style="display:flex;"><span>        9.  p ∨ ¬ p         ∨i2 8
</span></span><span style="display:flex;"><span>        10. ⊥               ¬e 9 3
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    11. p ∨ ¬ p             pbc 2    // conclusion of p ∨ ¬ p proof
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    12. {
</span></span><span style="display:flex;"><span>        13. p               assume
</span></span><span style="display:flex;"><span>        14. q               →e 1 13
</span></span><span style="display:flex;"><span>        15. ¬ p ∨ q         ∨i2 14
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    16. {
</span></span><span style="display:flex;"><span>        17. ¬ p             assume
</span></span><span style="display:flex;"><span>        18. ¬ p ∨ q         ∨i1 17
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    19. ¬ p ∨ q             ∨e 11 12 16
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Summary and Strategies</h1>
    
    
<p>When examining more complex propositional logic sequents, it can be challenging to know where to start. In this section, we summarize all available rules in propositional logic, and discuss stratgies for approaching proofs.</p>
<h2 id="and-rules">AND rules</h2>
<p>Rule summaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        P   Q               P ∧ Q                  P ∧ Q  
</span></span><span style="display:flex;"><span>∧i :  ---------     ∧e1 : ----------      ∧e2 : ---------- 
</span></span><span style="display:flex;"><span>        P ∧ Q                 P                      Q
</span></span></code></pre></div><p>Logika syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    x. p		    (...)
</span></span><span style="display:flex;"><span>    y. q			(...)
</span></span><span style="display:flex;"><span>    z. p ∧ q        ∧i x y
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    x. p ∧ q	    (...)
</span></span><span style="display:flex;"><span>    y. p            ∧e1 x
</span></span><span style="display:flex;"><span>    z. q            ∧e2 x
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="or-rules">OR rules</h2>
<p>Rule summaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                                                           { P assume     { Q assume
</span></span><span style="display:flex;"><span>          P                   Q                  P ∨ Q       ... R   }      ... R   }
</span></span><span style="display:flex;"><span>∨i1 : ---------     ∨i2 : ----------      ∨e : --------------------------------------- 
</span></span><span style="display:flex;"><span>        P ∨ Q               P ∨ Q                                R
</span></span></code></pre></div><p>Logika syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    x. p		    (...)
</span></span><span style="display:flex;"><span>    y. p ∨ q        ∨i1 x
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    x. q		    (...)
</span></span><span style="display:flex;"><span>    y. p ∨ q        ∨i2 x
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    a. p ∨ q        (...)
</span></span><span style="display:flex;"><span>    b. {
</span></span><span style="display:flex;"><span>        c. p        assume
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        d. r        (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    f. {
</span></span><span style="display:flex;"><span>        g. q        assume
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        h. r        (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    i. r            ∨e a b f
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="implies-rules">Implies rules</h2>
<p>Rule summaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                           { P assume 
</span></span><span style="display:flex;"><span>      P → Q    P             ... Q   }
</span></span><span style="display:flex;"><span> →e : -----------     →i : ------------    
</span></span><span style="display:flex;"><span>           Q                  P → Q   
</span></span></code></pre></div><p>Logika syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    x. p → q	        (...)
</span></span><span style="display:flex;"><span>    y. p                (...)
</span></span><span style="display:flex;"><span>    z. q                →e x y
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    a. {
</span></span><span style="display:flex;"><span>        b. p            assume
</span></span><span style="display:flex;"><span>        ///
</span></span><span style="display:flex;"><span>        c. q            (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    d. p → q            →i a
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="negation-rules">Negation rules</h2>
<p>Rule summaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                           { P assume                             { ¬ P assume
</span></span><span style="display:flex;"><span>        P   ¬ P             ... ⊥   }             ⊥e                ... ⊥     }
</span></span><span style="display:flex;"><span> ¬ e : ----------    ¬ i : -----------    ⊥e : --------     pbc:  --------------
</span></span><span style="display:flex;"><span>           ⊥                   ¬ P                 Q                    P
</span></span></code></pre></div><p>Logika syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    x. p            (...)
</span></span><span style="display:flex;"><span>    y. ¬ p          (...)
</span></span><span style="display:flex;"><span>    z. ⊥            ¬ e x y 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    a. {
</span></span><span style="display:flex;"><span>        b. p        assume
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        c. ⊥        (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    d. ¬ p          ¬ i a
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    x. ⊥            (...)
</span></span><span style="display:flex;"><span>    z. q            ⊥e x
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    a. {
</span></span><span style="display:flex;"><span>        b. ¬ p      assume
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        c. ⊥        (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    d. p            pbc a
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="strategies">Strategies</h2>
<ol>
<li>Write down all premises first. Can you extract anything from the premises?
<ul>
<li>If you have <code>p∧q</code>, use <code>∧e1</code> to extract <code>p</code> by itself and then <code>∧e2</code> to extract <code>q</code> by itself.</li>
<li>If you have <code>p→q</code> and <code>p</code>, use <code>→e</code> to get <code>q</code>.</li>
<li>If you have <code>p</code> and <code>¬p</code>, use <code>¬e</code> to claim a contradiction, <code>⊥</code>.</li>
</ul>
</li>
<li>Look at the top-level operator of what you are trying to prove.
<ul>
<li>
<p>Are you trying to prove something of the form <code>p→q</code>?</p>
<ul>
<li>Use <code>→i</code>. Open a subproof, assume <code>p</code>, and get to <code>q</code> by the end of the subproof. After the subproof, use <code>→i</code> to conclude <code>p→q</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>¬p</code>?</p>
<ul>
<li>Use <code>¬i</code>. Open a subproof, assume <code>p</code>, and get a contradiction, <code>⊥</code>, by the end of the subproof. After the subproof, use <code>¬i</code> to conclude <code>¬p</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p ∧ q</code>?</p>
<ul>
<li>Try to prove <code>p</code> by itself and then <code>q</code> by itself. Afterward, use <code>∧i</code> to conclude <code>p ∧ q</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p ∨ q</code>?</p>
<ul>
<li>See if you have either <code>p</code> or <code>q</code> by itself &ndash; if you do, use either <code>∨i1</code> or <code>∨i2</code> to conclude <code>p ∨ q</code>.</li>
</ul>
</li>
</ul>
</li>
<li>You&rsquo;ll need to nest the approaches from step 2. Once you are in a subproof, think about what you are <em>trying to prove by the end of that subproof</em>. Follow the strategy in step 2 to prove your current goal, nesting subproofs as needed. As you work, stop and scan the propositions that you have available. See if you can extract anything from them as you did for the premises in step 1.</li>
<li>No match, or still stuck?
<ul>
<li>Do you have an OR statement available? Try using OR elimination to prove your goal conclusion.</li>
<li>Do your propositions have NOT operators, but don&rsquo;t fit the form for using <code>¬i</code>? Try using <code>pbc</code>. If you are trying to prove something of the form <code>p</code>, open a subproof, assume <code>¬p</code>, and try to reach a contradiction by the end of the subproof. Afterward, use <code>pbc</code> to conclude <code>p</code>.</li>
<li>As a last resort, try pasting in the proof for the law of the excluded middle (see section 4.5). Then use OR elimination on <code>p ∨ ¬p</code>.</li>
</ul>
</li>
</ol>
<p>Proofs can be quite challenging. You might follow one approach, get stuck, and not be able to make progress. If this happens, backtrack and follow a different approach. As you are working, make sure Logika does not mark any lines in the proof in red – this means that you&rsquo;ve made an invalid conclusion along the way, or that your justification for a particular line doesn&rsquo;t follow the expected format. Try to fix these errors before continuing on with the proof.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Theorems</h1>
    
    
<h2 id="definition">Definition</h2>
<p>A <em>theorem</em> in propositional logic is something that is always true with no need for premises. The truth table for a theorem is always a <em>tautology</em> &ndash; it is true for any truth assignment.</p>
<p>To express a theorem as a sequent, we write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (theorem)
</span></span></code></pre></div><p>This shows that we are trying to prove our theorem with NO premises. Such a proof will always immediately begin with a subproof, as there are no premises to process.</p>
<h2 id="law-of-the-excluded-middle-revisited">Law of the excluded middle, revisited</h2>
<p>For example, the law of the excluded middle (LEM), <code>p ∨ ¬p</code>, is a theorem. We proved in section 4.5 that <code>p ∨ ¬p</code> is always true with no premises:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ p ∨ ¬ p
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. ¬ (p ∨ ¬ p)      assume
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. p            assume
</span></span><span style="display:flex;"><span>            5. p ∨ ¬ p      ∨i1 4
</span></span><span style="display:flex;"><span>            6. ⊥            ¬e 5 2
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        7.  ¬ p             ¬i 3
</span></span><span style="display:flex;"><span>        8.  p ∨ ¬ p         ∨i2 7
</span></span><span style="display:flex;"><span>        9.  ⊥               ¬e 8 2
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    10. p ∨ ¬ p             pbc 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We also see that the truth table for LEM is a tautology:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>      *
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>p | p ∨ ¬ p
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>T |   T F
</span></span><span style="display:flex;"><span>F |   T T
</span></span><span style="display:flex;"><span>-------------
</span></span><span style="display:flex;"><span>Tautology
</span></span></code></pre></div><h2 id="another-example">Another example</h2>
<p>Suppose we wish to prove the following theorem of propositional logic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>(p → q) → ((¬p → q) → q)
</span></span></code></pre></div><p>We would need to prove the sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span></code></pre></div><p>We see that the top-level operator of what we are trying to prove is an implies operator. So, we begin our proof using the strategy for implies introduction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Inside subproof 1, we are trying to prove <code>(¬p → q) → q</code>. The top-level operator of that statement is an implies, so we nest another subproof with the goal of using implies introduction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. ¬p → q           assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: reach q
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use →i to conclude (¬p → q) → q
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we must prove <code>q</code> in subproof 3. We have available propositions <code>p → q</code> and <code>¬p → q</code> &ndash; we can see that if we had LEM (<code>p ∨ ¬p</code>) available, then we could use OR elimination to get our <code>q</code> in both cases. We insert the LEM proof into subproof 3:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. ¬p → q                   assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //Begin LEM proof, p ∨ ¬p
</span></span><span style="display:flex;"><span>            5. {
</span></span><span style="display:flex;"><span>                6. ¬ (p ∨ ¬ p)          assume
</span></span><span style="display:flex;"><span>                7. {
</span></span><span style="display:flex;"><span>                    8. p                assume
</span></span><span style="display:flex;"><span>                    9. p ∨ ¬ p          ∨i1 8
</span></span><span style="display:flex;"><span>                    10. ⊥               ¬e 9 6
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                11.  ¬ p                ¬i 7
</span></span><span style="display:flex;"><span>                12.  p ∨ ¬ p            ∨i2 11
</span></span><span style="display:flex;"><span>                13.  ⊥                  ¬e 12 6
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            14. p ∨ ¬ p                 pbc 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //End LEM proof for p ∨ ¬p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //use OR elimination on p ∨ ¬p 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: reach q
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use →i to conclude (¬p → q) → q
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, we do OR elimination with <code>p ∨ ¬p</code> and tie together the rest of the proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>⊢ (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. {
</span></span><span style="display:flex;"><span>        2. p → q                        assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. {
</span></span><span style="display:flex;"><span>            4. ¬p → q                   assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //Begin LEM proof, p ∨ ¬p
</span></span><span style="display:flex;"><span>            5. {
</span></span><span style="display:flex;"><span>                6. ¬ (p ∨ ¬ p)          assume
</span></span><span style="display:flex;"><span>                7. {
</span></span><span style="display:flex;"><span>                    8. p                assume
</span></span><span style="display:flex;"><span>                    9. p ∨ ¬ p          ∨i1 8
</span></span><span style="display:flex;"><span>                    10. ⊥               ¬e 9 6
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                11.  ¬ p                ¬i 7
</span></span><span style="display:flex;"><span>                12.  p ∨ ¬ p            ∨i2 11
</span></span><span style="display:flex;"><span>                13.  ⊥                  ¬e 12 6
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            14. p ∨ ¬ p                 pbc 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //End LEM proof for p ∨ ¬p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //use OR elimination on p ∨ ¬p, try to reach q
</span></span><span style="display:flex;"><span>            15. {
</span></span><span style="display:flex;"><span>                16. p               assume
</span></span><span style="display:flex;"><span>                17. q               →e 2 16
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            18. {
</span></span><span style="display:flex;"><span>                19. ¬ p             assume
</span></span><span style="display:flex;"><span>                20. q               →e 4 19
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            21. q                   ∨e 14 15 18
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: reach q
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //use →i to conclude (¬p → q) → q
</span></span><span style="display:flex;"><span>        22. (¬p → q) → q            →i 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: reach (¬p → q) → q
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use →i to conclude (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    23. (p → q) → ((¬p → q) → q)    →i 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we complete a truth table for <code>(p → q) → ((¬p → q) → q)</code>, we also see that it is a tautology:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>              *
</span></span><span style="display:flex;"><span>-------------------------------
</span></span><span style="display:flex;"><span>p q | (p → q) → ((¬p → q) → q)
</span></span><span style="display:flex;"><span>-------------------------------
</span></span><span style="display:flex;"><span>T T |    T    T   F  T    T
</span></span><span style="display:flex;"><span>T F |    F    T   F  T    F
</span></span><span style="display:flex;"><span>F T |    T    T   T  T    T
</span></span><span style="display:flex;"><span>F F |    T    T   T  F    T
</span></span><span style="display:flex;"><span>------------------------------
</span></span><span style="display:flex;"><span>Tautology
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Equivalence</h1>
    
    
<p>In this section, we will revisit the notion of equivalence. In chapter 2, we saw how we could use truth tables to show that two logical formulae are equivalent. Here, we will see that we can also show they are equivalent using our natural deduction proof rules.</p>
<h2 id="semantic-equivalence">Semantic equivalence</h2>
<p>We saw in section 2.4 that two (or more) logical statements <code>S1</code> and <code>S2</code> were said to be <em>semantically equivalent</em> if and only if:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>S1 ⊨ S2
</span></span></code></pre></div><p>and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>S2 ⊨ S1
</span></span></code></pre></div><p>As a reminder, the <code>S1 ⊨ S2</code> means <em><code>S1</code> semantically entails <code>S2</code></em>, which means that every truth assignment that satisfies <code>S1</code> also satisfies <code>S2</code>.</p>
<p>Semantic equivalence between <code>S1</code> and <code>S2</code> means that each proposition semantically entails the other &ndash; that <code>S1</code> and <code>S2</code> have the same truth value for every truth assignment; i.e., their truth tables evaluate exactly the same.</p>
<h3 id="showing-semantic-equivalence-with-two-truth-tables">Showing semantic equivalence with two truth tables</h3>
<p>For example, if we wished to show that the propositions <code>p → ¬ q</code> and <code>¬ (p ∧ q)</code> were semantically equivalent, then we could create truth tables for each proposition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>        *
</span></span><span style="display:flex;"><span>--------------
</span></span><span style="display:flex;"><span>p q | p → ¬ q
</span></span><span style="display:flex;"><span>--------------
</span></span><span style="display:flex;"><span>T T |  F  F
</span></span><span style="display:flex;"><span>T F |  T  T
</span></span><span style="display:flex;"><span>F T |  T  F
</span></span><span style="display:flex;"><span>F F |  T  T
</span></span><span style="display:flex;"><span>--------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T F] [F T] [F F]
</span></span><span style="display:flex;"><span>- F: [T T]
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>      *
</span></span><span style="display:flex;"><span>----------------
</span></span><span style="display:flex;"><span>p q | ¬ (p ∧ q)
</span></span><span style="display:flex;"><span>----------------
</span></span><span style="display:flex;"><span>T T | F    T
</span></span><span style="display:flex;"><span>T F | T    F
</span></span><span style="display:flex;"><span>F T | T    F
</span></span><span style="display:flex;"><span>F F | T    F
</span></span><span style="display:flex;"><span>----------------
</span></span><span style="display:flex;"><span>Contingent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- T: [T F] [F T] [F F]
</span></span><span style="display:flex;"><span>- F: [T T]
</span></span></code></pre></div><p>We see that the same set of truth assignments, <code>[T F] [F T] [F F]</code>, satisfies both <code>p → ¬ q</code> and <code>¬ (p ∧ q)</code>.</p>
<h3 id="showing-semantic-equivalence-with-one-truth-table">Showing semantic equivalence with one truth table</h3>
<p>To show that propositions <code>S1</code> and <code>S2</code> are semantically equivalent, we need to show that if <code>S1</code> is true, then so is <code>S2</code>, and that if <code>S2</code> is true, then so is <code>S1</code>. Instead of comparing the truth tables of both <code>S1</code> and <code>S2</code>, we could instead express our requirements as a bi-implication: <code>S1 ↔ S2</code>. Logika doesn&rsquo;t have a bi-implication operator, so we can instead express our requirements as a conjunction of two implications: <code>(S1 → S2) ∧ (S2 → S1)</code>. If this proposition is a tautology, then it tells us that if one proposition is true, then the other one is too &ndash; that <code>S1</code> and <code>S2</code> are semantically equivalent.</p>
<p>Below, we show that <code>p → ¬ q</code> and <code>¬ (p ∧ q)</code> are semantically equivalent using one truth table:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                              *
</span></span><span style="display:flex;"><span>-------------------------------------------------------
</span></span><span style="display:flex;"><span>p q | ((p → ¬ q) → ¬ (p ∧ q)) ∧ (¬ (p ∧ q) → (p → ¬ q))
</span></span><span style="display:flex;"><span>-------------------------------------------------------
</span></span><span style="display:flex;"><span>T T |     F F    T F    T     T  F    T    T    F F 
</span></span><span style="display:flex;"><span>T F |     T T    T T    F     T  T    F    T    T T
</span></span><span style="display:flex;"><span>F T |     T F    T T    F     T  T    F    T    T F
</span></span><span style="display:flex;"><span>F F |     T T    T T    F     T  T    F    T    T T
</span></span><span style="display:flex;"><span>-------------------------------------------------------
</span></span><span style="display:flex;"><span>Tautology
</span></span></code></pre></div><h2 id="provable-equivalence">Provable equivalence</h2>
<p>Two propositional logic statements <code>S1</code> and <code>S2</code> are <em>provably equivalent</em> if and only if we can prove both of the following sequents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>S1 ⊢ S2
</span></span></code></pre></div><p>and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>S2 ⊢ S1
</span></span></code></pre></div><p>We can also write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>S2 ⟛ S1
</span></span></code></pre></div><p>For example, suppose we wish to show that the propositions <code>p → ¬ q</code> and <code>¬ (p ∧ q)</code> are provably equivalent. We must prove the following sequents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → ¬ q ⊢ ¬ (p ∧ q)
</span></span></code></pre></div><p>and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬ (p ∧ q) ⊢ p → ¬ q
</span></span></code></pre></div><p>We complete both proofs below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p → ¬ q ⊢ ¬ (p ∧ q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. p → ¬ q              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. p ∧ q            assume
</span></span><span style="display:flex;"><span>        4. p                ∧e1 3
</span></span><span style="display:flex;"><span>        5. q                ∧e2 3
</span></span><span style="display:flex;"><span>        6. ¬ q              →e 1 4
</span></span><span style="display:flex;"><span>        7. ⊥                ¬ e 5 6  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. ¬ (p ∧ q)            ¬ i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬ (p ∧ q) ⊢ p → ¬ q
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬ (p ∧ q)            premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. p                assume
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. q            assume
</span></span><span style="display:flex;"><span>            6. p ∧ q        ∧i 3 5
</span></span><span style="display:flex;"><span>            7. ⊥            ¬ e 6 1
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. ¬ q              ¬ i 4
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. p → ¬ q              →i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Soundness and Completeness</h1>
    
    
<p>Section 4.8 showed us that we can prove two statements are <em>semantically equivalent</em> with truth tables and <em>provably equivalent</em> with deduction proofs. Does it matter which approach we use? Will there ever be a time when two statements are semantically equivalent but not provably equivalent, or vice versa? Will there ever be a time when a set of premises semantically entails a conclusion, but that the premises do not prove (using our deduction proofs) the conclusion, or vice versa?</p>
<p>These questions lead us to the notions of <em>soundness</em> and <em>completeness</em>. Formal treatment of both concepts is beyond the scope of this course, but we will introduce both definitions and a rough idea of the proofs of soundness and completeness in propositional logic.</p>
<h2 id="soundness">Soundness</h2>
<p>A proof system is <em>sound</em> if everything that is provable is actually true. Propositional logic is sound if when we use deduction rules to prove that <code>P1, P2, ..., Pn ⊢ C</code> (that a set of premises proves a conclusion) then we can also use a truth table to show that <code>P1, P2, ..., Pn ⊨ C</code> (that a set of premises semantically entails a conclusion).</p>
<p><strong>Propositional logic is, in fact, sound.</strong></p>
<p>To get an idea of the proof, consider the <code>∧e1</code> deduction rule. It allows us to directly prove:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>P ∧ Q ⊢ P
</span></span></code></pre></div><p>I.e., if we have <code>P ∧ Q</code> as a premise or as a claim in part of a proof, then we can use <code>∧e1</code> to conclude <code>P</code>. We must also show that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>P ∧ Q ⊨ P
</span></span></code></pre></div><p>I.e., that any time <code>P ∧ Q</code> is true in a truth table, then <code>P</code> is also true. And of course, we can examine the truth table for <code>P ∧ Q</code>, and see that it is only true in the cases that <code>P</code> is also true.</p>
<p>Consider the <code>∧i</code> deduction ule next. It allows us to directly prove:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>P, Q ⊢ P ∧ Q
</span></span></code></pre></div><p>I.e., if we have both <code>P</code> and <code>Q</code> as premises or claims in part of a proof, then we can use <code>∧i</code> to conclude <code>P ∧ Q</code>. We must also show that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>P, Q ⊢ P ⊨ Q
</span></span></code></pre></div><p>I.e., that any time both <code>P</code> and <code>Q</code> are true in a truth table, then <code>P ∧ Q</code> is also true. And of course, we can examine the truth table for <code>P ∧ Q</code> and see that whenever <code>P</code> and <code>Q</code> are true, then <code>P ∧ Q</code> is also true.</p>
<p>To complete the soundness proof, we would need to examine the rest of our deduction rules in a similar process. We would then use an approach called <em>mathematical induction</em> (which we will see for other applications in Chapter 7) to extend the idea to a proof that applies multiple deduction rules in a row.</p>
<h2 id="completeness">Completeness</h2>
<p>A proof system is <em>complete</em> if everything that is true can be proved. Propositional logic is complete if when we can use a truth table to show that <code>P1, P2, ..., Pn ⊨ C</code>, then we can also use deduction rules to prove that <code>P1, P2, ..., Pn ⊢ C</code>.</p>
<p><strong>Propositional logic is also complete.</strong></p>
<p>We assume that <code>P1, P2, ..., Pn ⊨ C</code>, and we consider the truth table for <code>(P1 ∧ P2 ∧ ... ∧ Pn) → C</code> (since that will be a tautology whenever <code>P1, P2, ..., Pn ⊨ C</code>). In order to show propositional logic is complete, we must show that we can use our deduction rules to prove <code>P1, P2, ..., Pn ⊢ C</code>.</p>
<p>The idea is to use LEM for each propositional atom <code>A</code> to obtain <code>A ∨ ¬A</code> (corresponding to the truth assignments in the <code>(P1 ∧ P2 ∧ ... ∧ Pn) → C</code> truth table). We then use OR elimination on each combination of truth assignments, with separate cases for each logical operator being used.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-5">Chapter 5</h3>
<h1 id="predicate-logic-translations">Predicate Logic Translations</h1>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Motivation</h1>
    
    
<p>In this chapter, we will learn to further decompose statements in terms of their verbs (called <em>predicates</em>) and their nouns (called <em>individuals</em>). This leads to <em>predicate logic</em> (also called <em>first-order logic</em>).</p>
<p>As a motivation of why we want more expressive power, suppose we wanted to translate the following statements to propositional logic:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>All humans are mortal.
</span></span><span style="display:flex;"><span>Socrates is a human.
</span></span><span style="display:flex;"><span>Socrates is mortal.
</span></span></code></pre></div><p>Unfortunately, each statement would be a propositional atom:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p: All humans are mortal.
</span></span><span style="display:flex;"><span>q: Socrates is a human.
</span></span><span style="display:flex;"><span>r: Socrates is mortal.
</span></span></code></pre></div><p>But what if we wanted to prove that given the premises: &ldquo;All humans are mortal&rdquo; and &ldquo;Socrates is a human&rdquo;, that the conclusion &ldquo;Socrates is mortal&rdquo; naturally followed? This logical argument makes sense &ndash; Socrates is a human, and all such individuals are supposed to be mortal, so it should follow that Socrates is mortal. If we tried to write such a proof in propositional logic, though, we would have the sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p, q ⊢ r
</span></span></code></pre></div><p>&hellip;and we clearly don&rsquo;t have enough information to complete this proof.</p>
<p>We need a richer language, which we will get with predicate logic.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Syntax</h1>
    
    
<p>In this section, we will examine the syntax for translating English sentences to predicate logic. We will still create propositions (statements that are either true or false) using logical connectives (<code>∧</code>, <code>∨</code>, <code>→</code>, and <code>¬</code>), but now we will identify the following from our English sentences</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>predicates: these will be the verbs in the sentences
</span></span><span style="display:flex;"><span>individuals: these will be the nouns in the sentences
</span></span><span style="display:flex;"><span>quantifiers: these will help us specify if we mean all individuals or at least one individual
</span></span></code></pre></div><h2 id="domains">Domains</h2>
<p>Predicate logic involves expressing truth about a set of individuals. But the same statement might be true for one group of individuals, but false for others. Thus, we first need to consider which set of individuals we are discussing &ndash; called the <strong>domain</strong>.</p>
<p>A domain might be the set of all humans, the set of all animals, the set of all college classes, etc.</p>
<h2 id="individuals">Individuals</h2>
<p>An <strong>individual</strong> is an element within a specified domain. For example, if our domain is the set of all people, then <code>Bob</code> might be a particular individual. If our domain is the set of all college classes, then <code>CIS301</code> might be a particular individual.</p>
<h2 id="predicates">Predicates</h2>
<p>A <strong>predicate</strong> is a function that returns a boolean. It can have one or many parameters, each of which are individuals in a particular domain. A predicate will describe a characteristic of an individual or a comparison betwen multiple individuals.</p>
<p>For example, suppose our domain is the set of people. Suppose <code>Alice</code>, <code>Bob</code>, and <code>Carla</code> are individuals in our domain. <code>Alice</code> is <code>Bob</code>&rsquo;s mother, and <code>Carla</code> is an unrelated individual. <code>Carla</code> is 5'10 and 20 years old, <code>Alice</code> is 5'5 and 35 years old, and <code>Bob</code> is 4'10 and 10 years old.</p>
<p>Suppose we have the predicates:</p>
<ul>
<li><code>isAdult(person)</code> - returns whether <code>person</code> is an adult</li>
<li><code>isMotherOf(person1, person2)</code> - returns whether <code>person1</code> is the mother of <code>person2</code></li>
<li><code>isTallerThan(person1, person2)</code> - returns whether <code>person1</code> is taller than <code>person2</code></li>
</ul>
<p>Using our individuals above, we would have that:</p>
<ul>
<li><code>isAdult(Alice)</code> is true, since <code>Alice</code> is 35 years old</li>
<li><code>isAdult(Bob)</code> is false, since <code>Bob</code> is 10 years old</li>
<li><code>isMotherOf(Alice, Bob)</code> is true, since <code>Alice</code> is <code>Bob</code>&rsquo;s mother</li>
<li><code>isMotherOf(Alice, Bob)</code> is false, since <code>Carla</code> is not <code>Bob</code>&rsquo;s mother</li>
<li><code>isTallerThan(Carla, Alice)</code> is true, since <code>Carla</code> is 5'10 and <code>Alice</code> is 5'5.</li>
</ul>
<h2 id="quantifiers">Quantifiers</h2>
<p>We will introduce two <strong>quantifiers</strong> in predicate logic, which help us make claims about a domain of individuals.</p>
<h3 id="universal-quantifier">Universal quantifier</h3>
<p>The <code>∀</code> quantifier, called the <strong>universal quantifier</strong> and read as <em>for all</em>, lets us write propositions that pertain to ALL individuals in a domain.</p>
<p><code>∀ n P(n)</code> means: for every individual <code>n</code> (in some domain), <code>P(n)</code> is true. Here, <code>n</code> is a variable that stands for a particular individual in the domain. You can think of it like a foreach loop in C#:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>foreach(type n in domain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    //P(n) is true every time
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>where <code>n</code> is initially the first individual in the domain, then <code>n</code> is the second individual in the domain, etc.</p>
<h3 id="existential-quantifier">Existential quantifier</h3>
<p>The <code>∃</code> quantifier, called the <strong>existential quantifier</strong> and read as <em>there exists</em>, lets us write propositions that pertain to AT LEAST ONE individual in a domain.</p>
<p><code>∃ n P(n)</code> means: there exists at least one individual <code>n</code> (in some domain) where <code>P(n)</code> is true. You can again think of it as a foreach loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>foreach(type n in domain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    //we can find at least one time where P(n) is true
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="universal-quantifier-example">Universal quantifier example</h3>
<p>For example, suppose our domain is all candy bars, and that we have the predicate <code>isSweet(bar)</code>, which returns whether <code>bar</code> is sweet. We might write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x isSweet(x)
</span></span></code></pre></div><p>Which we would read as: <em>for all candy bars x, x is sweet</em>, or, more compactly, as: <em>all candy bars are sweet</em>.</p>
<h3 id="existential-quantifier-example">Existential quantifier example</h3>
<p>If instead we wrote:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x isSweet(x)
</span></span></code></pre></div><p>We would read it as: <em>there exists at least one candy bar x where x is sweet</em>, or, more compactly, as <em>there exists at least one sweet candy bar</em>.</p>
<h2 id="early-examples">Early examples</h2>
<p>Suppose our domain is animals, and that we have the following two predicates:</p>
<ul>
<li><code>isDog(x)</code>: whether animal x is a dog</li>
<li><code>hasFourLegs(x)</code>: whether animal x has four legs</li>
</ul>
<p>Let&rsquo;s consider what several predicate logic statements would mean in words:</p>
<ul>
<li><code>∀ x isDog(x)</code> - translates to: <em>All animals are dogs</em>. This means that EVERY SINGLE ANIMAL in my domain is a dog (which is probably unlikely).</li>
<li><code>∃ x hasFourLegs(x)</code> - translates to: <em>There exists at least one animal that has four legs.</em></li>
</ul>
<p>Next, consider the following proposition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isDog(x) ∧ hasFourLegs(x))
</span></span></code></pre></div><p>This translates to: <em>All animals are dogs and have four legs</em>. This means that EVERY SINGLE ANIMAL in my domain is a dog and also has four legs. While it is possible that this is true depending on our domain, it is unlikely. What if our domain of animals included cats, chicken,, etc.?</p>
<p>Perhaps instead we intended to say: <em>All dogs have four legs.</em> Another way to phrase this is, &ldquo;For all animals, IF that animal is a dog, THEN it has for legs.&rdquo; We can see from the IF&hellip;THEN that we will need to use an implies statement. Here is the correct translation for <em>All dogs have four legs</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isDog(x) → hasFourLegs(x))
</span></span></code></pre></div><p>We will usually want to use the <code>→</code> operator instead of the <code>∧</code> operator when making a claim about ALL individuals.</p>
<p>Finally, consider this proposition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (isDog(x) → hasFourLegs(x))
</span></span></code></pre></div><p>This translates to: <em>There exists an animal x, and if that animal is a dog, then it has four legs.</em> Recall that an implies statement <code>p→q</code> is true whenever <code>p</code> and <code>q</code> are both true AND whenever <code>p</code> is false. So this claim is true in two cases:</p>
<ul>
<li>If our domain includes a dog that has four legs</li>
<li>If our domain includes an animal that is not a dog</li>
</ul>
<p>We likely only meant to include the first case. In that case, we would want to say, <em>There exists a dog that has four legs</em> &ndash; here is that translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (isDog(x) ∧ hasFourLegs(x))
</span></span></code></pre></div><p>We will usually want to use the <code>∧</code> operator instead of the <code>→</code> operator when writing a proposition about one/some individuals.</p>
<h2 id="predicates-from-math">Predicates from math</h2>
<p>All of our examples in this section involved predicates over domains like people, animals, or living things. A different domain that we are used to working with is some set of numbers: the integers, the positive numbers, the rational numbers, etc.</p>
<p>Perhaps our domain is the set of all integers. Then <code>&gt;</code> is a predicate with two parameters &ndash; <code>x &gt; y</code> is defined as whether <code>x</code> is bigger than <code>y</code>, for two integers <code>x</code> and <code>y</code>. We might write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (x + 1 &gt; x)
</span></span></code></pre></div><p>Because for all integers, <code>x + 1</code> is bigger than <code>x</code>. We might also write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (x &gt; x * x)
</span></span></code></pre></div><p>Because for -4 (or any negative number), -4 &gt; -4 * -4.</p>
<p>Other common predicates in math are: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, and <code>!=</code>.</p>
<h2 id="quantifier-symbols">Quantifier symbols</h2>
<p>The official symbol for the universal quantifier (&ldquo;for all&rdquo;) is an upside-down A, like this: <code>∀</code>. You are welcome to substitute either a capital <code>A</code>, or with the word <code>all</code> or <code>forall</code>. This will be especially handy when we reach Chapter 6 on writing proofs in predicate logic.</p>
<p>The official symbol for the existential quantifier (&ldquo;there exists&rdquo;) is a backwards E, like this: <code>∃</code>. You are welcome to substitute either a capital <code>E</code>, or with the word <code>some</code> or <code>exists</code>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Single Quantifier</h1>
    
    
<p>In this section, we will see how to translate simpler statements between English to predicate logic. These translations will involve a single quantifier.</p>
<h2 id="example-predicate-logic-to-english">Example: Predicate logic to English</h2>
<p>Suppose our domain is animals and that we have the following two predicates:</p>
<ul>
<li><code>isMouse(x)</code>: whether animal <code>x</code> is a mouse</li>
<li><code>inHouse(x)</code>: whether animal <code>x</code> is in the house</li>
</ul>
<p>Suppose we also have that <code>Squeaky</code> is an individual in our domain.</p>
<p>We will practice translating from predicate logic to English. Think about what the following propositions mean, and click to reveal each answer:</p>
<ul>
<li>
<p><code>isMouse(Squeaky) ∧ ¬inHouse(Squeaky)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Squeaky is a mouse, and Squeaky is not in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is a mouse".
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x isMouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is not a mouse."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x ¬isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is an animal that is not a mouse".
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "All animals are mice."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x isMouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Not all animals are mice."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x ¬isMouse(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "All animals are not mice."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (isMouse(x) → inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "All mice are in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (isMouse(x) ∧ inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Every animal is a mouse and is in the house." (We usually don't want ∧ with ∀.)
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x (isMouse(x) → inHouse(x)))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Not all mice are in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (inHouse(x) → isMouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Everything in the house is a mouse."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x (inHouse(x) → isMouse(x)))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "Not everything in the house is a mouse."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x (isMouse(x) ∧ inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is a mouse in the house."
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x (isMouse(x) → inHouse(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There exists an animal, and if that animal is a mouse, then it is in the house." Recall that this statement will be true if there is an animal that is NOT a mouse (since the → would be vacuously true) as well as being true if there is a mouse in the house.
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x (isMouse(x) ∧ inHouse(x)))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      --> "There is not a mouse in the house."
  </details>
  <br>
</li>
</ul>
</li>
</ul>
<h2 id="translation-guide">Translation guide</h2>
<p>When translating from English to predicate logic, you can look for particular wording in your sentences to see how to choose a quantifier and/or negation placement. We will also see that certain phrases can be translated multiple (equivalent) ways.</p>
<ul>
<li>
<p><em>Every/all/each/any</em> is translated as: <code>∀ x ...</code></p>
</li>
<li>
<p><em>Some/at least one/there exists/there is</em> is translated as: <code>∃ x ...</code></p>
</li>
<li>
<p><em>None/no/there does not exist</em> can be translated as either <code>¬(∃ x ...)</code> or <code>∀ x ¬(...)</code></p>
</li>
<li>
<p><em>Not every/not all</em> can be translated as either <code>¬(∀ x ...)</code> or <code>∃ x ¬(...)</code></p>
</li>
<li>
<p><em>Some P-ish thing is a Q-ish thing</em> is translated as: <code>∃ x (P(x) ∧ Q(x))</code></p>
</li>
<li>
<p><em>All P-ish things are Q-ish things</em> is translated as: <code>∀ x (P(x) → Q(x))</code></p>
</li>
<li>
<p><em>No P-ish thing is a Q-ish thing</em> can be translated as either <code>¬(∃ x (P(x) ∧ Q(x)))</code> or <code>∀ x ¬(P(x) → Q(x))</code></p>
</li>
<li>
<p><em>Not all P-ish things are Q-ish things</em> can be translated as either <code>¬(∀ x (P(x) → Q(x)))</code> or <code>∃ x ¬(P(x) ∧ Q(x))</code></p>
</li>
</ul>
<h2 id="demorgans-laws-for-quantifiers">DeMorgan&rsquo;s laws for quantifiers</h2>
<p>In the translation guide above, we saw that we could often translate the same statement two different ways &ndash; one way using an existential quantifier and one way using a universal quantifier. These equivalencies are another iteration of DeMorgan&rsquo;s laws, this time applied to predicate logic.</p>
<p>Suppose we have some domain, and that <code>P(x)</code> is a predicate for individuals in that domain. DeMorgan&rsquo;s laws give us the following equivalencies:</p>
<ul>
<li><code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code></li>
<li><code>¬(∀ x P(x))</code> is equivalent to <code>∃ x ¬P(x)</code></li>
</ul>
<p>In Chapter 6, we will learn to prove that these translations are indeed equivalent.</p>
<h2 id="example-english-to-predicate-logic">Example: English to predicate logic</h2>
<p>Suppose our domain is people and that we have the following two predicates:</p>
<ul>
<li><code>K(x)</code>: whether person <code>x</code> is a kid</li>
<li><code>M(x)</code>: whether person <code>x</code> likes marshmallows</li>
</ul>
<p>We will practice translating from English to predicate logic. Think about what the following sentences mean, and click to reveal each answer:</p>
<ul>
<li><em>No kids like marshmallows.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>¬(∃ x (K(x) ∧ M(x))</code>, or equivalently, <code>∀ x ¬(K(x) → M(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Not all kids like marshmallows.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>¬(∀ x (K(x) → M(x))</code>, or equivalently, <code>∃ x (K(x) ∧ ¬M(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Everyone who likes marshmallows is a kid.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∀ x (M(x) → K(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Some people who like marshmallows are not kids.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∃ x (M(x) ∧ ¬K(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Some kids don&rsquo;t like marshmallows.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∃ x (K(x) ∧ ¬M(x)))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li><em>Anyone who doesn&rsquo;t like marshmallows is not a kid.</em>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∀ x (¬M(x) → ¬K(x))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
</ul>
<h2 id="evaluating-predicate-logic-statements-on-a-toy-domain">Evaluating predicate logic statements on a toy domain</h2>
<p>Suppose we have the following toy domain of people with the following characteristics:</p>
<ul>
<li>Bob, age 10, lives in Kansas, has siblings, has brown hair</li>
<li>Jane, age 25, lives in Delaware, has no siblings, has blonde hair</li>
<li>Alice, age 66, lives in Kansas, has siblings, has gray hair</li>
<li>Joe, age 50, lives in Nebraska, has siblings, has black hair</li>
</ul>
<p>Now suppose that we have the following predicates for individuals in our domain:</p>
<ul>
<li><code>Ad(x)</code>: whether person <code>x</code> is an adult (adults are age 18 and older)</li>
<li><code>KS(x)</code>: whether person <code>x</code> lives in Kansas</li>
<li><code>Sib(x)</code>: whether person <code>x</code> has siblings</li>
<li><code>Red(x)</code>: whether person <code>x</code> has red hair</li>
</ul>
<p>We will practice evaluating predicate logic statements on our domain of people. Think about whether the following propositions would be true or false over our domain, and then click to reveal each answer:</p>
<ul>
<li>
<p><code>∀ x Ad(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "All people are adults". This is false for our domain, as we have one person (Bob) who is not an adult.
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x ¬Ad(x)</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "All people are not adults". This is false for our domain, as we have three people (Jane, Alice, and Joe) are are adults.
  </details>
  <br>       
</li>
</ul>
</li>
<li>
<p><code>¬(∀ x Ad(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "Not all people are adults". This is true for our domain, as we can find a person (Bob) who is not an adult.
  </details>
  <br>       
</li>
</ul>
</li>
<li>
<p><code>∀ x (KS(x) → Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "Everyone who lives in Kansas has siblings". This is true for our domain, as we have two people who live in Kansas (Bob and Alice), and both of them have siblings.
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><code>∃ x (¬KS(x) ∧ Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "There is a person who doesn't live in Kansas and has siblings". This is true for our domain, as Joe lives in Nebraska and has siblings.
  </details>
  <br>  
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x (KS(x) ∧ ¬Ad(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "There does not exist a person who lives in Kansas and is not an adult". This is false for our domain, as Bob lives in Kansas and is not an adult.
  <br> 
</li>
</ul>
</li>
<li>
<p><code>¬(∃ x (Sib(x) ∧ Red(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "There does not exist a person with siblings who has red hair". This is true for our domain, as no one with siblings (Bob, Alice, or Joe) has red hair.
  <br>
</li>
</ul>
</li>
<li>
<p><code>∀ x (Red(x) → Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "All people with red hair have siblings". This is true for our domain, as no one has red hair. This means that the implies statement is vacuously true for every person (since `Red(x)` is false for each person), which makes the overall proposition true.
  <br> 
</li>
</ul>
</li>
<li>
<p><code>∀ x (KS(x) ∨ Sib(x))</code></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
      This proposition translates as, "Everyone lives in Kansas and/or has siblings". This is false for our domain -- there is one person, Jane, who doesn't live in Kansas and also doesn't have siblings.
  <br> </li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Multiple Quantifiers</h1>
    
    
<p>Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:</p>
<ul>
<li>Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiiers)</li>
<li>Translations that mix quantifiers</li>
</ul>
<p>In many of the sections, we will using the predicates below (which are over the domain of shapes):</p>
<ul>
<li><code>isCircle(x)</code> - whether shape x is a circle</li>
<li><code>isSquare(x)</code> - whether shape x is a square</li>
<li><code>isRectangle(x)</code> - whether shape x is a rectangle</li>
<li><code>biggerThan(x, y)</code> - whether shape x is bigger than shape y</li>
</ul>
<h2 id="several-of-the-same-quantifier">Several of the same quantifier</h2>
<p>First, we consider translations that involve several of the same quantifier. There are two ways we can translates such statements &ndash; either using prenex form (quantifiers out front) or Aristotlian form (quantifiers nested).</p>
<h3 id="prenex-form">Prenex form</h3>
<p>The <em>prenex form</em> of a predicate logic translation lists all the quantifiers at the beginning of the statement. This is only recommended when all the quantifiers are the same type &ndash; either all universal or all existential.</p>
<h4 id="prenex-example-1">Prenex example 1</h4>
<p>Suppose we wished to translate, <em>Some circle is bigger than some square</em>. Here, we are making three claims:</p>
<ul>
<li>There exists a shape that is a circle</li>
<li>There exists a shape that is a square</li>
<li>The shape that is a circle is bigger than the shape that is a square</li>
</ul>
<p>With that in mind, we can see that we will use two existential quantifiers. We can translate the statement as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∃ y (isCircle(x) ∧ isSquare(x) ∧ biggerThan(x, y))
</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where x is a circle, y is a square, and x (which is a circle) is bigger than y (which is a square).</em></p>
<p>Equivalently, we could have written:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∃ y (isCircle(y) ∧ isSquare(x) ∧ biggerThan(y, x))
</span></span></code></pre></div><p>Which reads: <em>There are two shapes, x and y, where y is a circle, x is a square, and y (which is a circle) is bigger than x (which is a square).</em></p>
<h4 id="prenex-example-2">Prenex example 2</h4>
<p>Next, suppose we wished to translate: <em>Every circle is bigger than all rectangles</em>. Again, we are quantifying two things &ndash; ALL circles and also ALL squares. We can see that we will need to use two universal quantifiers. We can translate the statement as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y ((isCircle(x) ∧ isSquare(x)) → biggerThan(x, y))
</span></span></code></pre></div><p>Which reads: <em>For each combination (x, y) of shapes, if x is a circle and y is a square, then x (which is a circle) is bigger than y (which is a square).</em></p>
<h3 id="aristotlian-form">Aristotlian form</h3>
<p>The <em>Aristotlian form</em> of a predicate logic translation embeds the quantifiers within the translation. This format is possible for any kind of translation &ndash; whether the quantifiers are all the same type or mixed types.</p>
<h4 id="aristotlian-form-example-1">Aristotlian form example 1</h4>
<p>Suppose we wished to translate, <em>Some circle is bigger than some square</em> using Aristotlian form. We know that will will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p>
<p>We can translate the statement using Aristotlian form as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (isCircle(x) ∧ (∃ y (isSquare(y) ∧ biggerThan(x, y)))
</span></span></code></pre></div><p>Which reads as: <em>There exists a shape x that is a circle and there exists a shape y that is a square, and x (which is a circle) is bigger than y (which is a square)</em>.</p>
<h4 id="aristotlian-form-example-2">Aristotlian form example 2</h4>
<p>Let&rsquo;s repeat our translation for, <em>Every circle is bigger than all rectangles</em> using Aristotlian form. We know that will will still need two existential quantifiers, but we will only introduce each quantifier just before the corresponding variable is needed in a predicate.</p>
<p>We can translate the statement using Aristotlian form as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isCircle(x) → (∀ y (isSquare(y) → biggerThan(x, y))))
</span></span></code></pre></div><p>Which reads as: <em>For every shape x, if x is a circle, then for every shape y, if y is s square, then x (which is a circle) is bigger than y (which is a square).</em></p>
<h2 id="mixed-quantifiers">Mixed quantifiers</h2>
<p>Now, we will turn to examples that mix universal and existential quantifiers. We will see below that quantifier order matters in this case, so it is safest to translate such statements using embedded quantifiiers. The embedded form can be tricky to write, so we will see a way to systematically translated any statement that needs multiple quantifiers into predicate logic (using Aristotlian form).</p>
<h3 id="systematic-translation">Systematic translation</h3>
<p>Suppose we wish to translate, <em>Every circle is bigger than at least one square</em>. We see that we are first making a claim about all circles. Without worrying about the rest of the statement, we know that for all circles, we are saying <em>something</em>. So we write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>For all circles, SOMETHING
</span></span></code></pre></div><p>Trying to formalize a bit more, we assign a variable to the current circle we are describing (<code>x</code>). For each circle x, we are saying <em>something</em> about that circle. So we express SOMETHING(x) as some claim about our current circle, and write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>For each circle x, SOMETHING(x)
</span></span></code></pre></div><p>We see that we will need a universal quantifier since we are talking about ALL circles, and we also follow the guide of using an implies statement to work with a for-all statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isCircle(x) → SOMETHING(x))
</span></span></code></pre></div><p>Next, we describe what <code>SOMETHING(x)</code> means for a particular circle, <code>x</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>SOMETHING(x): x is bigger than at least one square
</span></span></code></pre></div><p>Trying to formalize a bit more about the square, we write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>SOMETHING(x): There exists a square y, and x is bigger than y
</span></span></code></pre></div><p>Now we can use an existential quantifier to describe our square, and plug in our isSquare and biggerThan predicates to have a translation for SOMETHING(x):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>SOMETHING(x): ∃ y (isSquare(y) ∧ biggerThan(x, y))
</span></span></code></pre></div><p>Now, we can plug SOMETHING(x) into our first partial translation, <code>∀ x (isCircle(x) → SOMETHING(x))</code>. The complete translation for <em>Every circle is bigger than at least one square</em> is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isCircle(x) → (∃ y (isSquare(y) ∧ biggerThan(x, y))))
</span></span></code></pre></div><h3 id="follow-up-examples">Follow-up examples</h3>
<p>In these examples, suppose our domain is animals and that we have the following predicates:</p>
<ul>
<li><code>El(x)</code>: whether animal x is an elephant</li>
<li><code>Hi(x)</code>: whether animal x is a hippo</li>
<li><code>W(x, y)</code>: whether animal x weighs more than animal y</li>
</ul>
<p>Suppose we wish to translate: <em>There is exactly one hippo.</em> We might first try saying: <code>∃ x Hi(x)</code>. But this proposition would be true even if we had 100 hippos, so we need something more restricted. What we are really trying to say is:</p>
<ul>
<li>There exists a hippo</li>
<li>AND, any other hippo is the same one</li>
</ul>
<p>Let&rsquo;s use our systematic approach, streamlining a few of the steps:</p>
<ul>
<li>There exists an animal x that is a hippo, and SOMETHING(x)</li>
<li><code>∃ x (Hi(x) ∧ SOMETHING(x))</code></li>
</ul>
<p>To translate SOMETHING(x), the claim we are making about our hippo x:</p>
<ul>
<li><code>SOMETHING(x)</code>: any other hippo is the same as x</li>
<li><code>SOMETHING(x)</code>: for each hippo y, x is the same as y</li>
<li><code>SOMETHING(x)</code>: `∀ y (Hi(y) → (x == y))</li>
</ul>
<p>Now we can put everything together to get a complete translation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Hi(x) ∧ (∀ y (Hi(y) → (x == y)))
</span></span></code></pre></div><p>Here are a few more translations from English to predicate logic. Think about what the following statements mean, and click to reveal each answer:</p>
<ul>
<li>
<p><em>Every elephant is heavier than some hippo.</em></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∀ x (El(x) -&gt; (∃ y (Hi(y) ^ W(x, y))))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><em>There is an elephant that is heavier than all hippos.</em></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>∃ x (El(x) ^ (∀ y (Hi(y) -&gt; W(x, y))))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
<li>
<p><em>No hippo is heavier than every elephant.</em></p>
<ul>
<li>
<details>
  <summary> <b> Click here for solution </b></summary>
<p><code>¬(∃ x (Hi(x) ^ (∀ y (El(y) -&gt; W(x, y)))))</code></p>
  </details>
  <br>
</li>
</ul>
</li>
</ul>
<h3 id="order-matters">Order matters!</h3>
<p>We have learned that when dealing with mixed quantifiers, it is safest to embed them within the translation. If we put the mixed quantifiers out front of a translation, then we can accidentally include them in the wrong order and end up with an incorrect translation.</p>
<p>Suppose we have this predicate, over the domain of people:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>likes(x, y): whether person x likes person y
</span></span></code></pre></div><p>Further suppose that liking a person is not necessarily symmetric: that just because person x likes person y does not mean that person y necessarily likes person x.</p>
<p>Consider these pairs of propositions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y likes(x, y)     vs.     ∀ y ∀ x likes(x, y)  
</span></span><span style="display:flex;"><span>∃ x ∃ y likes(x, y)     vs.     ∃ y ∃ x likes(x, y)
</span></span></code></pre></div><p>Is there any difference between each one? No! The two versions of the first proposition both say that every person likes every other person, and the two versions of the second proposition both say that there is a person who likes another person.</p>
<p>But what about:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∃ y likes(x, y)     vs.     ∃ y ∀ x likes(x, y)
</span></span></code></pre></div><p>Suppose our domain is made up of the following people:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Bob: likes Alice and James
</span></span><span style="display:flex;"><span>Alice: likes Bob
</span></span><span style="display:flex;"><span>James: likes Alice
</span></span></code></pre></div><p>The first proposition, <code>∀ x ∃ y likes(x, y)</code>, says that all people have some person (not necessarily the same person) that they like. This would certainly be true for our domain, as every person has at least one person that they like. The second proposition, <code>∃ y ∀ x likes(x, y)</code> is saying that there is a person (the SAME person) that everyone likes. This proposition would be false for our domain, as there is no one person that is liked by everyone.</p>
<h2 id="precedence-with-quantifiers">Precedence with quantifiers</h2>
<p>In section 2.2, we discussed operator precedence for propositional logic statements. The same operator precedence holds for predicate logic statements, except that our two quantifiers (<code>∀</code> and <code>∃</code>) have the same precedence as the NOT operator. If we have a proposition with multiple quantifiers, then the quantifiers are resolved from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</p>
<p>Here is an updated list of operator precedence, from most important (do first) to least important (do last):</p>
<ol>
<li>Parentheses</li>
<li>Not operator (<code>¬</code>), universal quantifier (<code>∀</code>), existential quantifier (<code>∃</code>)</li>
<li>And operator, <code>∧</code></li>
<li>Or operator, <code>∨</code></li>
<li>Implies operator, <code>→</code></li>
</ol>
<p>And here is our updated list of how to resolve multiple operators with the same precedence:</p>
<ol>
<li>Multiple parentheses - the innermost parentheses are resolved first, working from inside out.</li>
<li>Multiple not ( <code>¬</code> ) operators &ndash; the rightmost <code>¬</code> is resolved first, working from right to left. For example, <code>¬¬p</code> is equivalent to <code>¬(¬p)</code>.</li>
<li>Multiple and ( <code>∧</code> ) operators &ndash; the leftmost <code>∧</code> is resolved first, working from left to right. For example, <code>p ∧ q ∧ r</code> is equivalent to <code>(p ∧ q) ∧ r</code>.</li>
<li>Multiple or ( <code>∨</code> ) operators &ndash; the leftmost <code>∨</code> is resolved first, working from left to right. For example, <code>p ∨ q ∨ r</code> is equivalent to <code>(p ∨ q) ∨ r</code>.</li>
<li>Multiple implies ( <code>→</code> ) operators &ndash; the rightmost <code>→</code> is resolved first, working from right to left. For example, <code>p → q → r</code> is equivalent to <code>p → (q → r)</code>.</li>
<li>Multiple quantifiers &ndash; the rightmost quantifier is resolved first, working from right to left. For example, <code>∃ y ∀ x likes(x, y)</code> should be interpreted as <code>∃ y (∀ x likes(x, y))</code>.</li>
</ol>
<p>When we get to predicate logic proofs in Chapter 6, we will see that Logika uses a different precedence for quantifiers &ndash; there, quantifiers have the LOWEST precedence (done last) of any operator. This ends up being more forgiving than confusing, as it will accept propositions as correct that are really missing parentheses. For example, Logika will accept: <code>∃ x isMouse(x) ∧ inHouse(x)</code>. Technically, this proposition <em>should</em> be incorrect &ndash; if we correctly treat quantifiers as having a higher precedence than <code>∧</code>, then <code>inHouse(x)</code> would no longer know about the variable <code>x</code> or its quantifier.</p>
<p>We <em>should</em> use parentheses with quantifiers to express our intended meaning, and so we should write <code>∃ x (isMouse(x) ∧ inHouse(x))</code> instead. But if we forget the parentheses, then Logika will forgive us.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-6">Chapter 6</h3>
<h1 id="predicate-logic-proofs">Predicate Logic Proofs</h1>
<p>Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Rules with ∀</h1>
    
    
<p>Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers &ndash; an &ldquo;introduction rule and an &ldquo;elimination&rdquo; rule.</p>
<p>In this section, we will see the two inference rules for the universal (∀) quantifier.</p>
<h2 id="for-all-elimination">For all elimination</h2>
<p>For all elimination allows us to take a claim that uses a universal quantifier &ndash; a statement about ALL individuals in a domain &ndash; and make the same statement about a specific individual in the domain. After all, if the statement is true for ALL individuals, then it follows that it should be true for a particular individual. We can formalize the rule as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     ∀ x P(x)
</span></span><span style="display:flex;"><span>∀e: ----------- 
</span></span><span style="display:flex;"><span>       P(v)     where v is a particular individual in the domain
</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∀e</code> rule in Logika. It shows that given the premises: <em>All humans are mortal</em> and <em>Socrates is a human</em>, that we can prove that <em>Socrates is mortal</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isHuman(x) → isMortal(x)),  isHuman(Socrates) ⊢ isMortal(Socrates)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isHuman(x) → isMortal(x))               premise
</span></span><span style="display:flex;"><span>    2. isHuman(Socrates)                            premise
</span></span><span style="display:flex;"><span>    3. isHuman(Socrates) → isMortal(Socrates)       ∀e 1 Socrates
</span></span><span style="display:flex;"><span>    4. isMortal(Socrates)                           →e 3 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can read the justification <code>∀e 1 Socrates</code> as: &ldquo;for all elimination of the for-all statement on line 1, plugging in the individual Socrates&rdquo;.</p>
<h2 id="for-all-introduction">For all introduction</h2>
<p>If we can show that a property of the form <code>P(a)</code> holds for an arbitrary member <code>a</code> of a domain, then we can use for all introduction to conclude that the property must hold for ALL individuals in the domain &ndash; i.e., that <code>∀ x P(x)</code>. We can formalize the fule as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     { a              (a is fresh)
</span></span><span style="display:flex;"><span>       ... P(a) }
</span></span><span style="display:flex;"><span>∀i: ---------------
</span></span><span style="display:flex;"><span>      ∀ x P(x) 
</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∀i</code> rule in Logika: &ldquo;Everyone is healthy; everyone is happ. Therefore, everyone is both healthy and happy.&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x isHealthy(x), ∀ y isHappy(y)  |-  ∀ z(isHealthy(z) ∧ isHappy(z))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  1. ∀ x isHealthy(x)                   premise
</span></span><span style="display:flex;"><span>  2. ∀ y isHappy(y)                     premise
</span></span><span style="display:flex;"><span>  3. {
</span></span><span style="display:flex;"><span>       4. a
</span></span><span style="display:flex;"><span>       5. isHealthy(a)                  ∀e 1 a
</span></span><span style="display:flex;"><span>       6. isHappy(a)                    ∀e 2 a
</span></span><span style="display:flex;"><span>       7. isHealthy(a) ∧ isHappy(a)     ∧i 5 6
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  8. ∀ z (isHealthy(z) ∧ isHappy(z))    ∀i 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we wish to introduce a for-all statement, the pattern is:</p>
<ul>
<li>
<p>Open a subproof and introduce an arbitrary/fresh individual in the domain (in the example above, we used <code>a</code>). It MUST be a name that we have not used elsewhere in the proof. The idea is that your individual could have been anyone/anything in the domain.</p>
</li>
<li>
<p>When you introduce your individual, you do NOT include a justification on that line</p>
</li>
<li>
<p>If you have other for-all statements available within the scope of the subproof, then it is often useful to use <code>∀e</code> to plug your fresh individual into them. After all, if those statements are true for ALL individuals, then they are also true for your fresh individual.</p>
</li>
<li>
<p>If you are trying to prove something of the form <code>∀ x P(x)</code>, then you need to reach <code>P(a)</code> by the end of the subproof. You need to show that your goal for-all statement holds for your fresh individual. In our case, we wished to prove <code>∀ z (isHealthy(z) ∧ isHappy(z))</code>, so we reached <code>isHealthy(a) ∧ isHappy(a)</code> by the end of the subproof.</p>
</li>
<li>
<p>After the subproof, you can use <code>∀i</code> to introduce a for-all statement for your last claim in the subproof &ndash; that since the individual could have been anyone, then the proposition holds for ALL individuals. The <code>∀i</code> justification needs the line number of the subproof.</p>
</li>
<li>
<p>When you use <code>∀i</code>, it does not matter what variable you introduce into the for-all statement. In the example above, we introduced <code>∀ z</code> &ndash; but that was only to match the goal conclusion in the proof. We could have instead introduced <code>∀ x</code>, <code>∀ y</code>, <code>∀ people</code>, etc. We would use whatever variable we chose in the rest of that proposition &ndash; i.e., <code>∀ z (isHealthy(z) ∧ isHappy(z))</code>, or <code>∀ people (isHealthy(people) ∧ isHappy(people))</code>, etc.</p>
</li>
</ul>
<h2 id="examples">Examples</h2>
<p>In this section, we will look at several proofs involving the universal quantifier.</p>
<h3 id="example-1">Example 1</h3>
<p>Suppose we wish to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span></code></pre></div><p>This will let us show that it doesn&rsquo;t matter what variable we use with a universal quantifier &ndash; both <code>∀ x P(x)</code> and <code>∀ y P(y)</code> are saying the same thing: <em>for all individuals, P holds for that individual</em>.</p>
<p>Since the top-level operator of our conclusion is a for-all statement, we see that we will need to use for all introduction. Following the pattern above, we open a subproof and introduce a fresh individual, <code>a</code>. Since we wish to introduce the for-all statement <code>∀ y P(y)</code>, then we know we need to reach <code>P(a)</code> by the end of our subproof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x P(x)         premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a            //our fresh individual
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: P(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y P(y)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since we have an available for-all statement in our subproof (<code>∀ x P(x)</code>, from line 1), then we use <code>∀e</code> to plug <code>a</code> into it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x P(x)         premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a            //our fresh individual
</span></span><span style="display:flex;"><span>        4. P(a)         ∀e 1 a
</span></span><span style="display:flex;"><span>        //need: P(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y P(y)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>At that point, we see that we have exactly the proposition we wanted to end our subproof &ndash; <code>P(a)</code>. All that remains is to use <code>∀i</code> to state that since <code>a</code> could have been anyone, that the proposition we reached at the end of subproof 2 must hold for all individuals. Here is the completed proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x P(x)         premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a            //our fresh individual
</span></span><span style="display:flex;"><span>        4. P(a)         ∀e 1 a
</span></span><span style="display:flex;"><span>        //need: P(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y P(y)
</span></span><span style="display:flex;"><span>    5. ∀ y P(y)         ∀i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="example-2">Example 2</h3>
<p>Suppose we wish to prove that, given the following premises in the domain of people:</p>
<ul>
<li>All students have a phone and/or a laptop</li>
<li>Everyone is a student</li>
</ul>
<p>Then we can conclude:</p>
<ul>
<li>Everyone has a phone and/or a laptop</li>
</ul>
<p>First, we identify the following predicates:</p>
<ul>
<li><code>isStudent(x)</code> - whether person x is a student</li>
<li><code>hasPhone(x)</code> - whether person x has a phone</li>
<li><code>hasLaptop(x)</code> = whether person x has a laptop</li>
</ul>
<p>Then, we can translate our premises and goal conclusion to predicate logic:</p>
<ul>
<li><em>All students have a phone and/or a laptop</em> translates to: <code>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))</code></li>
<li><em>Everyone is a student</em> translates to: <code>∀ x isStudent(x)</code></li>
<li><em>Everyone has a phone and/or a laptop</em> translates to: <code>∀ x (hasPhone(x) ∨ hasLaptop(x))</code></li>
</ul>
<p>We need to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span></code></pre></div><p>As with our previous example, we see that we are trying to prove a for-all statement (<code>∀ x (hasPhone(x) ∨ hasLaptop(x))</code>). This means we will need to open a subproof and introduce a fresh individual &ndash; perhaps <code>bob</code>. By the end of the subproof, we must show that our goal for-all statement holds for that individual &ndash; that <code>hasPhone(bob) ∨ hasLaptop(bob)</code>. We start the proof as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))          premise
</span></span><span style="display:flex;"><span>    2. ∀ x isStudent(x)                                         premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. bob
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        //goal: hasPhone(bob) ∨ hasLaptop(bob)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We have two available for-all statements within the subproof &ndash; <code>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))</code> and <code>∀ x isStudent(x)</code>. Since those propositions hold for all individuals, they also hold for <code>bob</code>. We use <code>Ae</code> to plug in <code>bob</code> to those two propositions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))          premise
</span></span><span style="display:flex;"><span>    2. ∀ x isStudent(x)                                         premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. bob
</span></span><span style="display:flex;"><span>        5. isStudent(bob) → hasPhone(bob) ∨ hasLaptop(bob)      ∀e 1 a
</span></span><span style="display:flex;"><span>        6. isStudent(bob)                                       ∀e 2 a   
</span></span><span style="display:flex;"><span>        //goal: hasPhone(bob) ∨ hasLaptop(bob)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Line 5 is an implies statement the form <code>p → q</code>, and line 6 is a statement of the form <code>p</code>. Thus we can use <code>→e</code> to conclude <code>hasPhone(bob) ∨ hasLaptop(bob)</code> (the &ldquo;q&rdquo; in that statement) &ndash; which is exactly what we needed to end the subproof. All that remains is to apply our <code>∀i</code> rule after the subproof. Here is the completed proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))          premise
</span></span><span style="display:flex;"><span>    2. ∀ x isStudent(x)                                         premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. bob
</span></span><span style="display:flex;"><span>        5. isStudent(bob) → hasPhone(bob) ∨ hasLaptop(bob)      ∀e 1 a
</span></span><span style="display:flex;"><span>        6. isStudent(bob)                                       ∀e 2 a   
</span></span><span style="display:flex;"><span>        7. hasPhone(bob) ∨ hasLaptop(bob)                       →e 5 6
</span></span><span style="display:flex;"><span>        //goal: hasPhone(bob) ∨ hasLaptop(bob)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>    8. ∀ x (hasPhone(x) ∨ hasLaptop(x))                         ∀i 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="example-3">Example 3</h3>
<p>Next, suppose we wish to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span></code></pre></div><p>We again see that the top-level operator of what we are trying to prove is a universal quantifier. We use our strategy to open a subproof, introduce a fresh individual (maybe <code>a</code>), and plug that individual into any available for-all statements. Since we wish to prove <code>∀ x ¬S(x)</code>, then we will want to reach <code>¬S(a)</code> by the end of the subproof. Here is a sketch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (S(x) → Pz(x))               premise
</span></span><span style="display:flex;"><span>    2. ∀ x (Pz(x) → D(x))               premise
</span></span><span style="display:flex;"><span>    3. ∀ x ¬D(x)                        premise
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. a
</span></span><span style="display:flex;"><span>        6. S(a) → Pz(a)                 ∀e 1 a
</span></span><span style="display:flex;"><span>        7. Pz(a) → D(a)                 ∀e 2 a
</span></span><span style="display:flex;"><span>        8. ¬D(a)                        ∀e 3 a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ¬S(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, we see that our goal is to reach <code>¬S(a)</code> by the end of the subproof &ndash; so we need to prove something whose top-level operator is a NOT. We recall that we have a strategy to prove NOT(something) from propositional logic &ndash; we open a subproof, assuming <em>something</em> (<code>S(a)</code>, in our case), try to get a contradiction, and use NOT introduction after the subproof to conclude NOT (something) (<code>¬S(a)</code> for us). Here is the strategy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (S(x) → Pz(x))               premise
</span></span><span style="display:flex;"><span>    2. ∀ x (Pz(x) → D(x))               premise
</span></span><span style="display:flex;"><span>    3. ∀ x ¬D(x)                        premise
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. a
</span></span><span style="display:flex;"><span>        6. S(a) → Pz(a)                 ∀e 1 a
</span></span><span style="display:flex;"><span>        7. Pz(a) → D(a)                 ∀e 2 a
</span></span><span style="display:flex;"><span>        8. ¬D(a)                        ∀e 3 a
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. S(a)                    assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: contradiction
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //use ¬i to conclude ¬S(a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ¬S(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can complete the proof as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (S(x) → Pz(x))               premise
</span></span><span style="display:flex;"><span>    2. ∀ x (Pz(x) → D(x))               premise
</span></span><span style="display:flex;"><span>    3. ∀ x ¬D(x)                        premise
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. a
</span></span><span style="display:flex;"><span>        6. S(a) → Pz(a)                 ∀e 1 a
</span></span><span style="display:flex;"><span>        7. Pz(a) → D(a)                 ∀e 2 a
</span></span><span style="display:flex;"><span>        8. ¬D(a)                        ∀e 3 a
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. S(a)                    assume
</span></span><span style="display:flex;"><span>            11. Pz(a)                   →e 6 10
</span></span><span style="display:flex;"><span>            12. D(a)                    →e 7 11
</span></span><span style="display:flex;"><span>            13. ⊥                       ¬e 12 8
</span></span><span style="display:flex;"><span>            //goal: contradiction
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //use ¬i to conclude ¬S(a)
</span></span><span style="display:flex;"><span>        14. ¬S(a)                       ¬i 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ¬S(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>    15. ∀ x ¬S(x)                       ∀i 4
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Rules with ∃</h1>
    
    
<p>In this section, we will see the two inference rules for the existential (∃) quantifier.</p>
<h2 id="exists-introduction">Exists introduction</h2>
<p>We can use the exists introduction rule, <code>∃i</code>, when we have a proposition of the form <code>P(a)</code> for an arbitrary member <code>a</code> of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       P(d)         where  d  is an individual
</span></span><span style="display:flex;"><span>∃i: -----------
</span></span><span style="display:flex;"><span>      ∃ x P(x)
</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∃i</code> rule in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>isHuman(Socrates) ⊢  ∃ x isHuman(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. isHuman(Socrates)            premise
</span></span><span style="display:flex;"><span>    2. ∃ x isHuman(x)               ∃i 1 Socrates
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When we use the <code>∃i</code> rule to justify a claim like <code>∃ x P(x)</code>, we include the line number of where the proposition held for a particular individual, as well as the name of the individual. In the proof above, we claim <code>∃ x isHuman(x)</code> with justification <code>∃i 1 Socrates</code> &ndash; line 1 corresponds to <code>isHuman(Socrates)</code>, where our <code>∃ x isHuman(x)</code> proposition held for a particular individual. The <code>Socrates</code> part of the justification is the name of the individual.</p>
<p>Note that we can use the <code>∃i</code> rule to introduce any variable, not just <code>x</code>. You can choose which variable to introduce based on the variables used in the conclusion. For example, the following proof is also valid:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>isHuman(Socrates) ⊢  ∃ z isHuman(z)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. isHuman(Socrates)            premise
</span></span><span style="display:flex;"><span>    2. ∃ z isHuman(z)               ∃i 1 Socrates
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="exists-elimination">Exists elimination</h2>
<p>Since the <code>∃i</code>-rule constructs propositions that begin with <code>∃</code>, the <code>∃e</code>-rule (exists elimination) disassembles propositions that begin with <code>∃</code>.</p>
<p>Here is a quick example (where our domain is living things):</p>
<ul>
<li>All humans are mortal</li>
<li>Someone is human</li>
<li>Therefore, someone is mortal</li>
</ul>
<p>We don&rsquo;t know the name of the human, but it does not matter. Since ALL humans are mortal and SOMEONE is human, then our anonymous human must be mortal. The steps will go like this:</p>
<ul>
<li>
<p>Since &ldquo;someone is human&rdquo; and since we do not know his/her name, we will just make up our own name for them – &ldquo;Jane&rdquo;. So, we assume that &ldquo;Jane is human&rdquo;.</p>
</li>
<li>
<p>We use the logic rules we already know to prove that &ldquo;Jane is mortal&rdquo;.</p>
</li>
<li>
<p>Therefore, SOMEONE is mortal and their name does not matter.</p>
</li>
</ul>
<p>This approach is coded into the last logic law, <code>∃e</code> (exists elimination).</p>
<p>Suppose we have a premise of the form <code>∃ x P(x)</code>. Since we do not know the name of the individual &ldquo;hidden&rdquo; behind the <code>∃ x</code>, we make up a name for it, say <code>a</code>, and discuss what must follow from the assumption that <code>P(a)</code> holds true. Here is the formalization of the <code>∃e</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                  {a  P(a)   assume       // where  a  is a new, fresh name
</span></span><span style="display:flex;"><span>      ∃ x P(x)      ...  Q         }      // a  MUST NOT appear in  Q
</span></span><span style="display:flex;"><span>∃e: -----------------------------------
</span></span><span style="display:flex;"><span>                     Q
</span></span></code></pre></div><p>That is, if we can deduce <code>Q</code> from <code>P(a)</code>, and we do not mention <code>a</code> within <code>Q</code>, then it means <code>Q</code> can be deduced no matter what name the hidden individual has. So, <code>Q</code> follows from <code>∃  P(x)</code>.</p>
<p>We can work the previous example, with <code>∃e</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>All humans are mortal
</span></span><span style="display:flex;"><span>Someone is human
</span></span><span style="display:flex;"><span>Therefore, someone is mortal
</span></span></code></pre></div><p>We make up the name, <code>jane</code>, for the human whose name we do not know:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ h(isHuman(h) → isMortal(h)), ∃ x isHuman(x) |- ∃ y isMortal(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ h(isHuman(h) → isMortal(h))        premise
</span></span><span style="display:flex;"><span>    2. ∃ x isHuman(x)                       premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. jane isHuman(jane)               assume
</span></span><span style="display:flex;"><span>        5. isHuman(jane) → isMortal(jane)   ∀e 1 jane
</span></span><span style="display:flex;"><span>        6. isMortal(jane)                   →e 5 4
</span></span><span style="display:flex;"><span>        7. ∃y isMortal(jane)                ∃i 6 ajane
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. ∃y isMortal(y)                       ∃e 2 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Line 4 proposes the name <code>jane</code> and the assumption that <code>isHuman(jane)</code>. The subproof leads to Line 7, which says that someone is mortal. (We never learned the individual&rsquo;s name!) Since Line 7 does not explicitly mention the made-up name, <code>jane</code>, we use Line 8 to repeat Line 7 – without knowing the name of the individual &ldquo;hiding&rdquo; inside Line 2, we made a subproof that proves the result, anyway. This is how <code>∃e</code> works.</p>
<p>Note that when we us the <code>∃e</code> rule as a justification we include first the line number of the there-exists statement that we processed (by naming the hidden individual) in the prrevious subproof, and then the line number of that subproof. In the example above, we say <code>∃e 2 3</code> because line 2 includes the there-exists statement we processed (<code>∃ x isHuman(x)</code>) in the previous subproof and line 3 is the subproof.</p>
<p>When using <code>∃e</code>, the previous subproof must begin with introducting a name for a hidden individual in a there-exists statement and then immediately substituting that name into the there-exists statement. The justification on the first line is always <code>assume</code>. The last line in the subproof should contain NO mention of the chosen name. Whatever we claim on the last line in the subproof, we must claim EXACTLY the same thing immediately afterwards when we use the <code>∃e</code> rule.</p>
<p>You are welcome to use any name for the hidden individual &ndash; not just <code>jane</code> or <code>a</code>. The only restriction is that you cannot have used the name anywhere else in the proof.</p>
<h2 id="examples">Examples</h2>
<p>In this section, we will look at several proofs involving the existential quantifier.</p>
<h3 id="example-1">Example 1</h3>
<p>Suppose we wish to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span></code></pre></div><p>Following the same approach in the <code>∃e</code> example above, we know that there is SOME human. Let&rsquo;s introduce the alias <code>bob</code> for that human:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Human(x))               premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. bob Human(bob)           assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, ∃ y (Human(y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such human exists
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since we have <code>Human(bob)</code> in our subproof, we can use <code>∃i</code> in our subproof to instead say that there exists some human. We will introduce the <code>y</code> variable, since that&rsquo;s what we want in our conclusion:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Human(x))               premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. bob Human(bob)           assume
</span></span><span style="display:flex;"><span>        4. ∃ y (Human(y))           ∃i 3 bob
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, ∃ y (Human(y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such human exists
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All that remains is to use <code>∃e</code> to restate our conclusion after the subproof. Since we knew someone was a human, and since we reached a claim that didn&rsquo;t use our alias, then we can restate the result outside the scope of the subproof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Human(x))               premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. bob Human(bob)           assume
</span></span><span style="display:flex;"><span>        4. ∃ y (Human(y))           ∃i 3 bob
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, ∃ y (Human(y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such human exists
</span></span><span style="display:flex;"><span>    5. ∃ y (Human(y))               ∃e 1 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="example-2">Example 2</h3>
<p>Suppose we wish to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Adult(x) ∨ Kid(x)) ⊢ (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span></code></pre></div><p>We will begin as we did previously: by introducing an alias for our person that is eitehr an adult or a kid (say, <code>alice</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Adult(x) ∨ Kid(x)) ⊢ (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Adult(x) ∨ Kid(x))              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. alice Adult(alice) ∨ Kid(alice)  assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To finish our proof, we can use OR elimination on <code>Adult(alice) ∨ Kid(alice)</code>, and then <code>∃e</code> afterwards to restate our conclusion. Here is the completed proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Adult(x) ∨ Kid(x)) ⊢ (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Adult(x) ∨ Kid(x))                  premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. alice Adult(alice) ∨ Kid(alice)      assume
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. Adult(alice)                     assume
</span></span><span style="display:flex;"><span>            6. ∃ x Adult(x)                     ∃i 5 alice
</span></span><span style="display:flex;"><span>            7. (∃ x Adult(x)) ∨ (∃ x Kid(x))    ∨i1 6
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. {
</span></span><span style="display:flex;"><span>            9. Kid(alice)                       assume
</span></span><span style="display:flex;"><span>            10. ∃ x Kid(x)                      ∃i  9 alice
</span></span><span style="display:flex;"><span>            11. (∃ x Adult(x)) ∨ (∃ x Kid(x))   ∨i2 10
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        12. (∃ x Adult(x)) ∨ (∃ x Kid(x))       ∨e 3 4 8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    13. (∃ x Adult(x)) ∨ (∃ x Kid(x))           ∃e 1 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="example-3">Example 3</h3>
<p>Suppose we wish to prove the following (in the domain of living things):</p>
<ul>
<li>All bunnies are fluffy</li>
<li>There is a fast bunny</li>
<li>Therefore, there is a creature that is fast and fluffy</li>
</ul>
<p>We can translate our premises and desired conclusion to predicate logic, and write the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (Bunny(x) → Fluffy(x)), ∃ x (Fast(x) ∧ Bunny(x)) ⊢ ∃ x (Fast(x) ∧ Fluffy(x))
</span></span></code></pre></div><p>Since we are trying to prove a claim about some individual, it makes sense that we would start the process of an <code>∃e</code> subproof where we introduce an alias (<code>thumper</code>) for the fast bunny. We will try to reach the conclusion by the end of that subproof. Here is the setup:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (Bunny(x) → Fluffy(x)), ∃ x (Fast(x) ∧ Bunny(x)) ⊢ ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (Bunny(x) → Fluffy(x))                   premise
</span></span><span style="display:flex;"><span>    2. ∃ x (Fast(x) ∧ Bunny(x))                     premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. thumper Fast(thumper) ∧ Bunny(thumper)   assume
</span></span><span style="display:flex;"><span>        5. Fast(thumper)                            ∧e1 4
</span></span><span style="display:flex;"><span>        6. Bunny(thumper)                           ∧e2 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //use ∃e to restate ∃ x (Fast(x) ∧ Fluffy(x)), since we know there is SOME fast bunny
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To finish our subproof, we see that we have a proposition about all creatures (<code>∀ x (Bunny(x) → Fluffy(x))</code>) and that we are working with an individual creature (<code>thumper</code>). We can use <code>∀e</code> to prove <code>Bunny(thumper) → Fluffy(thumper)</code>. After that, we have a few more manipulations using propositional logic rules, our <code>∃i</code> rule to transition our claim from being about our alias <code>thumper</code> to being about an unnamed individual, and then our <code>∃e</code> rule to pull our final claim out of the subproof. Here is the completed proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (Bunny(x) → Fluffy(x)), ∃ x (Fast(x) ∧ Bunny(x)) ⊢ ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (Bunny(x) → Fluffy(x))                   premise
</span></span><span style="display:flex;"><span>    2. ∃ x (Fast(x) ∧ Bunny(x))                     premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. thumper Fast(thumper) ∧ Bunny(thumper)   assume
</span></span><span style="display:flex;"><span>        5. Fast(thumper)                            ∧e1 4
</span></span><span style="display:flex;"><span>        6. Bunny(thumper)                           ∧e2 4
</span></span><span style="display:flex;"><span>        7. Bunny(thumper) → Fluffy(thumper)         ∀e 1 thumper
</span></span><span style="display:flex;"><span>        8. Fluffy(thumper)                          →e 7 6
</span></span><span style="display:flex;"><span>        9. Fast(thumper) ∧ Fluffy(thumper)          ∧i 5 8
</span></span><span style="display:flex;"><span>        10. ∃ x (Fast(x) ∧ Fluffy(x))               ∃i 9 thumper
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate ∃ x (Fast(x) ∧ Fluffy(x)), since we know there is SOME fast bunny
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    11. ∃ x (Fast(x) ∧ Fluffy(x))                   ∃e 2 3
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Nested Quantifiers</h1>
    
    
<p>Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that <code>∀ x ∀ y P(x, y)</code> is equivalent to <code>∀ x (∀ y P(x, y))</code>.</p>
<h2 id="example-1">Example 1</h2>
<p>Suppose we wish to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span></code></pre></div><p>Since we wish to prove a for-all statement of the form <code>∀ y (SOMETHING)</code>, then we know we must start with our for all introduction template:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But now we see that we want to prove ANOTHER for-all statement, <code>∀ x P(a, x)</code>. So we again use our for all introduction strategy in a nested subproof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //need: P(a, b)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //want to use ∀i to conclude ∀ x P(a, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, in subproof 4, we see that we must use <code>∀e</code> on our premise (<code>∀ x ∀ y P(x, y)</code>) to work towards our goal of <code>P(a, b)</code>. We have two available individuals &ndash; <code>a</code> and <code>b</code>. When we use <code>∀e</code>, we must eliminate the OUTER (top-level) quantifier and its variable. In the case of <code>∀ x ∀ y P(x, y)</code>, we see that we must eliminate the <code>∀ x</code>. Since the <code>x</code> is the first parameter in <code>P(x, y)</code>, and since we are hoping to reach <code>P(a, b)</code> by the end of subproof 4, we can see that we need to plug in the <code>a</code> for the <code>x</code> so that it will be in the desired position:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>            6. ∀ y P(a, y)          ∀e 1 a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //need: P(a, b)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //want to use ∀i to conclude ∀ x P(a, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that on line 6, we could NOT have used <code>∀e</code> to eliminate the <code>∀ y</code> in <code>∀ x ∀ y P(x, y)</code>, as it was not the top-level operator.</p>
<p>Next, we apply <code>∀e</code> again to <code>∀ y P(a, y)</code> to leave us with <code>P(a, b)</code>. All that remains at that point is to use <code>∀i</code> twice as planned to wrap up the two subproofs. Here is the completed proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>            6. ∀ y P(a, y)          ∀e 1 a
</span></span><span style="display:flex;"><span>            7. P(a, b)              ∀e 6 b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //need: P(a, b)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //want to use ∀i to conclude ∀ x P(a, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        8. ∀ x P(a, x)              ∀i 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    9. ∀ y ∀ x P(y, x)              ∀i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="example-2">Example 2</h2>
<p>Suppose we have the predicate <code>IsBossof(x, y)</code> in the domain of people, which describes whether person <code>x</code> is the boss of person <code>y</code>. We wish to prove the following sequent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∀ y IsBossOf(x, y) ⊢ ∀ y ∃ x IsBossOf(x, y)
</span></span></code></pre></div><p>You can read the premise as &ldquo;There is a person that is everyone&rsquo;s boss&rdquo;. From this statement, we are trying to prove the conclusion: &ldquo;All people have a boss&rdquo;. Here is the completed proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∀ y IsBossOf(x, y) ⊢ ∀ y ∃ x IsBossOf(x, y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  1. ∃ x ∀ y IsBossOf(x, y)             premise
</span></span><span style="display:flex;"><span>  2. {
</span></span><span style="display:flex;"><span>       3. a ∀ y IsBossOf(a, y)          assume
</span></span><span style="display:flex;"><span>       4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>            6. IsBossOf(a, b)           ∀e 3 b
</span></span><span style="display:flex;"><span>            7. ∃ x IsBossOf(x, b)       ∃i 6 a
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>       8. ∀ y ∃ x IsBossOf(x, y))       ∀i 4
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  9. ∀ y ∃ x IsBossOf(x, y)             ∃e 1 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the above proof, we let <code>a</code> be our made-up name for the boss-of-everyone. So, we have the assumption that <code>∀ y IsBossOf(a, y)</code>. Next, we let <code>b</code> be &ldquo;anybody at all&rdquo; who we might examine in the domain of people. The proof exposes that the boss of &ldquo;anybody at all&rdquo; in the domain must always be <code>a</code>. <code>∀i</code> and then <code>∃e</code> finish the proof.</p>
<p>Here is the proof worked again, with the subproofs swapped:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∀ y IsBossOf(x, y) ⊢ ∀ y ∃ x IsBossOf(x, y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  1. ∃ x ∀ y IsBossOf(x, y)             premise
</span></span><span style="display:flex;"><span>  2. {
</span></span><span style="display:flex;"><span>       3. b
</span></span><span style="display:flex;"><span>       4. {
</span></span><span style="display:flex;"><span>            5. a ∀ y IsBossOf(a, y)     assume
</span></span><span style="display:flex;"><span>            6. IsBossOf(a, b)           ∀e 5 b
</span></span><span style="display:flex;"><span>            7. ∃ x IsBossOf(x, b)       ∃i 6 a
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>       8. ∃ x IsBossOf(x, y))           ∃e 1 4
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  9. ∀ y ∃ x IsBossOf(x, y)             ∀i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Can we prove the converse? That is, if everyone has a boss, then there is one boss who is the boss of everyone?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ y ∃ x IsBossOf(x, y) ⊢ ∃ x ∀ y IsBossOf(x, y)
</span></span></code></pre></div><p>NO. We can try, but we get stuck:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ y ∃ x IsBossOf(x, y) ⊢ ∃ x ∀ y IsBossOf(x, y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ y ∃ x IsBossOf(x, y)           premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a
</span></span><span style="display:flex;"><span>        4. ∃ x IsBossOf(x, a)           ∀e 1 a
</span></span><span style="display:flex;"><span>        5. {
</span></span><span style="display:flex;"><span>            6. b IsBossOf(b, a)         assume
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        6. ∀ y isBoss(b, y)             ∀i 2  NO--THIS PROOF IS TRYING TO FINISH
</span></span><span style="display:flex;"><span>                                          THE OUTER SUBPROOF WITHOUT FINISHING
</span></span><span style="display:flex;"><span>                                          THE INNER ONE FIRST.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...can&#39;t finish
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We see that the &ldquo;block structure&rdquo; of the proofs warns us when we are making invalid deductions.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Equivalence</h1>
    
    
<p>In Chapter 5, we saw DeMorgan&rsquo;s laws for quantifiers &ndash; that if we have some domain, and if <code>P(x)</code> is a predicate for individuals in that domain, then the following statements are equivalent:</p>
<ul>
<li><code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code></li>
<li><code>¬(∀ x P(x))</code> is equivalent to <code>∃ x ¬P(x)</code></li>
</ul>
<p>The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic &ndash; we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.</p>
<h2 id="example---how-to-prove-equivalence">Example - how to prove equivalence</h2>
<p>For example, to prove that <code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code>, we must prove the sequents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(∃ x P(x)) ⊢ ∀ x ¬P(x)
</span></span></code></pre></div><p>and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ¬P(x) ⊢ ¬(∃ x P(x))
</span></span></code></pre></div><p>We prove both directions below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(∃ x P(x)) ⊢ ∀ x ¬P(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬(∃ x P(x))              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. P(a)             assume
</span></span><span style="display:flex;"><span>            6. ∃ x P(x)         ∃i 5 a
</span></span><span style="display:flex;"><span>            7. ⊥                ¬e 6 1
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. ¬P(a)                ¬i 4
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. ∀ x ¬P(x)                ∀i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ¬P(x) ⊢ ¬(∃ x P(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ¬P(x)                premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ∃ x P(x)             assume
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. a P(a)           assume
</span></span><span style="display:flex;"><span>            6. ¬P(a)            ∀i 1 a
</span></span><span style="display:flex;"><span>            7. ⊥                ¬e 5 6
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. ⊥                    ∃e 3 4
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. ¬(∃ x P(x))              ¬i 2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="more-extensive-list-of-equivalences">More extensive list of equivalences</h2>
<p>Here is a more extensive list of equivalences in predicate logic. The remaining proofs are left as exercises for the reader:</p>
<ul>
<li><code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code></li>
<li><code>¬(∀ x P(x))</code> is equivalent to <code>∃ x ¬P(x)</code></li>
<li><code>A x (P(x) → ¬Q(x))</code> is equivalent to <code>¬(E x P(x) ∧ Q(x))</code></li>
<li><code>∀ x ∀ y P(x, y)</code> is equivalent to <code>∀ y ∀ x P(x, y)</code></li>
<li><code>∃ x ∃ y P(x, y)</code> is equivalent to <code>∃ y ∃ x P(x, y)</code></li>
<li><code>Q ∧ (∀ x P(x))</code> is equivalent to <code>∀ x (Q ∧ P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
<li><code>Q v (∀ x P(x))</code> is equivalent to <code>∀ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
<li><code>Q ∧ (∃ x P(x))</code> is equivalent to <code>∃ x (Q ∧ P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
<li><code>Q V (∃ x P(x))</code> is equivalent to <code>∃ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Summary and Strategies</h1>
    
    
<p>In this section, we summarize all available rules in propositional logic, and discuss stratgies for approaching proofs.</p>
<h2 id="rules-with-universal-quantifier-">Rules with universal quantifier (<code>∀</code>)</h2>
<p>Rule summaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     ∀ x P(x)
</span></span><span style="display:flex;"><span>∀e: ----------- 
</span></span><span style="display:flex;"><span>       P(v)     where v is a particular individual in the domain
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     { a              (a is fresh)
</span></span><span style="display:flex;"><span>       ... P(a) }
</span></span><span style="display:flex;"><span>∀i: ---------------
</span></span><span style="display:flex;"><span>      ∀ x P(x) 
</span></span></code></pre></div><p>Logika syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    r. ∀ x P(x) 	        (...)
</span></span><span style="display:flex;"><span>    s. P(v)                 ∀e r v
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    r. {
</span></span><span style="display:flex;"><span>        s. a
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        t. P(a)             (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    u. ∀ x P(x)             ∀i r
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="rules-with-existential-quantifier-">Rules with existential quantifier (<code>∃</code>)</h2>
<p>Rule summaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       P(d)         where  d  is an individual
</span></span><span style="display:flex;"><span>∃i: -----------
</span></span><span style="display:flex;"><span>      ∃ x P(x)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                  {a  P(a)   assume       // where  a  is a new, fresh name
</span></span><span style="display:flex;"><span>      ∃ x P(x)      ...  Q         }      // a  MUST NOT appear in  Q
</span></span><span style="display:flex;"><span>∃e: -----------------------------------
</span></span><span style="display:flex;"><span>                     Q
</span></span></code></pre></div><p>Logika syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    r. P(d)                 (...)
</span></span><span style="display:flex;"><span>    s. ∃ x P(x)             ∃i r d
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    b. ∃ x P(x)             (...)
</span></span><span style="display:flex;"><span>    c. {
</span></span><span style="display:flex;"><span>        d. a P(a)           assume
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        e. Q                (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    f. Q                    ∃e b c
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="reminder-propositional-logic-rules-are-still-available">Reminder: propositional logic rules are still available</h2>
<p>When doing proofs in predicate logic, remember that all the deduction rules from propositional logic are still available. You will often want to use the same strategies we saw there &ndash; not introduction to prove a NOT, implies introduction to create an implies statement, OR elimination to process an OR statement, etc.</p>
<p>However, keep in mind that propositional logic rules can only be used on claims without quantifiers as their top-level operator. For example, if we have the statement <code>∀ x (S(x) ∧ Pz(x))</code>, then we cannot use <code>∧e</code> &ndash; the top-level operator is a universal quantifier, and the <code>∧</code> statement is &ldquo;bound up&rdquo; in that quantifier. We would only be able to use <code>∧e</code> after we had used <code>∀ e</code> to eliminate the quantifier.</p>
<h2 id="strategies">Strategies</h2>
<ol>
<li>
<p>Write down all premises first. Can you extract anything from the premises?</p>
<ul>
<li>If you have a for-all statement and an available individual, use <code>∀e</code> to plug that individual into the for-all statement.</li>
<li>If you have <code>p∧q</code>, use <code>∧e1</code> to extract <code>p</code> by itself and then <code>∧e2</code> to extract <code>q</code> by itself.</li>
<li>If you have <code>p→q</code> and <code>p</code>, use <code>→e</code> to get <code>q</code>.</li>
<li>If you have <code>p</code> and <code>¬p</code>, use <code>¬e</code> to claim a contradiction, <code>⊥</code>.</li>
</ul>
</li>
<li>
<p>Look at the top-level operator of what you are trying to prove.</p>
<ul>
<li>
<p>Are you trying to prove something of the form <code>∀ x P(x)</code>?</p>
<ul>
<li>Use <code>∀i</code>. Open a subproof, introduce a fresh <code>a</code>, and get to <code>P(a)</code> by the end of the subproof. After the subproof, use <code>∀i</code> to conclude <code>∀ x P(x)</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>∃ x P(x)</code>?</p>
<ul>
<li>You will usually have another there-exists (<code>∃</code>) statement available as a premise or previous claim. Open a subproof, and assume an alias for the individual in your there-exists statement. Get to <code>∃ x P(x)</code> by the last line of the subproof. After the subproof, use <code>∃e</code> to restate <code>∃ x P(x)</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p→q</code>?</p>
<ul>
<li>Use <code>→i</code>. Open a subproof, assume <code>p</code>, and get to <code>q</code> by the end of the subproof. After the subproof, use <code>→i</code> to conclude <code>p→q</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>¬p</code>?</p>
<ul>
<li>Use <code>¬i</code>. Open a subproof, assume <code>p</code>, and get a contradiction, <code>⊥</code>, by the end of the subproof. After the subproof, use <code>¬i</code> to conclude <code>¬p</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p ∧ q</code>?</p>
<ul>
<li>Try to prove <code>p</code> by itself and then <code>q</code> by itself. Afterward, use <code>∧i</code> to conclude <code>p ∧ q</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p ∨ q</code>?</p>
<ul>
<li>See if you have either <code>p</code> or <code>q</code> by itself &ndash; if you do, use either <code>∨i1</code> or <code>∨i2</code> to conclude <code>p ∨ q</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>You&rsquo;ll need to nest the approaches from step 2. Once you are in a subproof, think about what you are <em>trying to prove by the end of that subproof</em>. Follow the strategy in step 2 to prove your current goal, nesting subproofs as needed. As you work, stop and scan the claims that you have available. See if you can extract anything from them as you did for the premises in step 1.</p>
</li>
<li>
<p>No match, or still stuck?</p>
<ul>
<li>Do you have a there-exists statement available? Try using <code>∃e</code> to reach your goal.</li>
<li>Do you have an OR statement available? Try using OR elimination to prove your goal conclusion.</li>
<li>Do your statements have NOT operators, but don&rsquo;t fit the form for using <code>¬i</code>? Try using <code>pbc</code>. If you are trying to prove something of the form <code>p</code>, open a subproof, assume <code>¬p</code>, and try to reach a contradiction by the end of the subproof. Afterward, use <code>pbc</code> to conclude <code>p</code>.</li>
<li>As a last resort, try pasting in the proof for the law of the excluded middle (see section 4.5). Then use OR elimination on <code>p ∨ ¬p</code>.</li>
</ul>
</li>
</ol>
<p>Think of doing a proof as solving a maze, and of all our deduction rules as possible directions you can turn. If you have claims that match a deduction rule, then you can try applying the rule (i.e, &ldquo;turning that direction&rdquo;). As you work, you may apply more and more rules until the proof falls into place (you exit the maze)&hellip;or, you might get stuck. If this happens, it doesn&rsquo;t mean that you have done anything <em>wrong</em> &ndash; it just means that you have reached a dead end and need to try something else. You backtrack, and try a different approach instead (try turning in a different direction).</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Soundness and Completeness</h1>
    
    
<h2 id="soundness-and-completeness-definitions">Soundness and completeness definitions</h2>
<p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p>
<h2 id="interpretations">Interpretations</h2>
<p>When we write statements in logic, we use predicates and function symbols (e.g., <code>∀ i (i * 2) &gt; i</code>). An interpretation gives the meaning of:</p>
<ul>
<li>
<p>The underlying domain – what set of elements it names</p>
</li>
<li>
<p>Each function symbol – what answers it computes from its parameters from the domain</p>
</li>
<li>
<p>Each predicate – which combinations of arguments from the domain lead to true answers and false answers</p>
</li>
</ul>
<h3 id="interpretation-example---integers">Interpretation example - integers</h3>
<p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>&gt;</code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p>
<p>The standard interpretation of arithmetic is that:</p>
<ul>
<li>
<p><code>int</code> names the set of all integers</p>
</li>
<li>
<p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p>
</li>
<li>
<p><code>=</code> and <code>&gt;</code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p>
</li>
</ul>
<p>With this interpretation of arithmetic, we can interpret statements. For example,<code>∀ i (i * 2) &gt; i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>∃ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p>
<p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>&gt;</code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>&gt;</code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n &gt; m</code>.</p>
<p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 &gt; 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p>
<p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p>
<h3 id="interpretation-example---predicates">Interpretation example - predicates</h3>
<p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p>
<p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p>
<h2 id="valid-sequents-in-predicate-logic">Valid sequents in predicate logic</h2>
<blockquote>
<p>A sequent, <code>P_1, P_2, ..., P_n ⊢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &hellip;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p>
</blockquote>
<h2 id="soundness-and-completeness-in-predicate-logic">Soundness and completeness in predicate logic</h2>
<p>We can then define soundness and completeness for predicate logic:</p>
<blockquote>
<p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n ⊢ Q</code>, then the sequent is valid (in all possible interpretations)</p>
</blockquote>
<blockquote>
<p><em>completeness:</em> When <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p>
</blockquote>
<p>Note that, if <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;</code>, and <code>=</code>. No appropriate rule set was devised.</p>
<p>In the early 20th century, Kurt Gödel showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. Gödel showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p>
<p>Gödel’s construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p>
<p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-7">Chapter 7</h3>
<h1 id="mathematical-induction">Mathematical Induction</h1>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Induction Process</h1>
    
    
<p><em>Mathematical induction</em> allows us to prove that every nonnegative integer satisfies a certain property. In this chapter, we will use mathematical inductive to prove several mathematical claims. When we reach the next several chapters on programming logic, we will see that mathematical induction is very similar to the process of proving correctness for programs with loops.</p>
<h2 id="domino-effect">Domino effect</h2>
<p>To prove that a property is true for an arbitrary nonnegative integer 
<span class="math align-center">$n$</span> using mathematical induction, we must show two things:</p>
<ol>
<li>
<p><strong>Base case</strong>. We must prove that the property is true for the smallest possible value of 
<span class="math align-center">$n$</span>. Usually this is 
<span class="math align-center">$n = 0$</span> or 
<span class="math align-center">$n = 1$</span>, but occasionally we will define a property for all values greater than or equal to 2, or some bigger number.</p>
</li>
<li>
<p><strong>Inductive step</strong>. We assume the property holds for some arbitrary nonnegative integer 
<span class="math align-center">$n$</span>. This assumption is called the <em>inductive hypothesis</em>. Then, we must show that the property still holds for 
<span class="math align-center">$n + 1$</span>.</p>
</li>
</ol>
<p>How do these two steps prove anything at all? Suppose we are proving that a property holds for all positive integers 
<span class="math align-center">$n$</span>. In the base case, we prove that the property holds when 
<span class="math align-center">$n = 1$</span>. Proving the inductive step allows us to say that whenever the property holds for some number, then it also holds for the number right after that. Since we already know the the property holds when 
<span class="math align-center">$n = 1$</span>, then the inductive step allows us to infer that the property still holds when 
<span class="math align-center">$n = 2$</span>. And at that point we know the property holds for 
<span class="math align-center">$n = 2$</span>, so the inductive step again allows us to infer that the property holds for 
<span class="math align-center">$n = 3$</span>, etc.</p>
<p>Think of mathematical inductive like a line of dominoes. The &ldquo;base case&rdquo; tells us that the first domino will fall, and the &ldquo;inductive step&rdquo; tells us that if one domino falls, then the one right after it will fall as well. From these two pieces, we can conclude that the entire line of dominoes will fall (i.e., that the property will hold for the entire set of numbers).</p>
<h2 id="summation-property">Summation property</h2>
<p>There is a well-known formula for adding all positive integers up to some bound, 
<span class="math align-center">$n$</span>:</p>

<span class="math align-center">$$
\begin{aligned}
1 + 2 + ... + n = \dfrac{n(n+1)}{2}
\end{aligned}
$$</span><br>
<br>
<p>To see how this works, suppose 
<span class="math align-center">$n = 3$</span>. We have that 
<span class="math align-center">$1 + 2 + 3 = 6$</span>, and also that 
<span class="math align-center">$\dfrac{3(3+1)}{2} = 6$</span>.</p>
<p>Suppose instead that 
<span class="math align-center">$n = 7$</span>. We have that 
<span class="math align-center">$1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$</span>, and also that 
<span class="math align-center">$\dfrac{7(7+1)}{2} = 28$</span>.</p>
<h2 id="first-induction-proof">First induction proof</h2>
<p>We wish to use mathematical induction to prove that, for all positive integers 
<span class="math align-center">$n$</span>, the sum of all integers from 1 to 
<span class="math align-center">$n$</span> is 
<span class="math align-center">$\dfrac{n(n+1)}{2}$</span>. That is, that:</p>

<span class="math align-center">$$
\begin{aligned}
1 + 2 + ... + n = \dfrac{n(n+1)}{2}
\end{aligned}
$$</span><br>
<br>
<p>We will refer to 
<span class="math align-center">$1 + 2 + ... + n$</span> as 
<span class="math align-center">$LHS_n$</span> and we will refer to 
<span class="math align-center">$\dfrac{n(n+1)}{2}$</span> as 
<span class="math align-center">$RHS_n$</span>. We must prove that 
<span class="math align-center">$LHS_n = RHS_n$</span> for all positive integers 
<span class="math align-center">$n$</span>.</p>
<h3 id="base-case">Base case</h3>
<p>We must prove that the property holds for the smallest positive integer, 
<span class="math align-center">$n = 1$</span>, that is, that 
<span class="math align-center">$LHS_1 = RHS_1$</span>. The sum of all integers from 1 to 1 is just 1, so we have that 
<span class="math align-center">$LHS_1 = 1$</span>. We have that:</p>

<span class="math align-center">$$
\begin{aligned}
RHS_1 = \dfrac{1(1+1)}{2} = 1
\end{aligned}
$$</span><br>
<p>Thus 
<span class="math align-center">$LHS_1 = RHS_1$</span>, so the base case holds.</p>
<h3 id="inductive-step">Inductive step</h3>
<p>We assume the inductive hypothesis - that 
<span class="math align-center">$LHS_n = RHS_n$</span> for some positive integer 
<span class="math align-center">$n$</span>. We must prove that 
<span class="math align-center">$LHS_{n+1} = RHS_{n+1}$</span>. We have that:</p>

<span class="math align-center">$$
LHS_{n+1} = 1 + 2 + ... + n + (n + 1) \tag{1}
$$
$$
= LHS_n + (n + 1) \tag{2} 
$$
$$
= RHS_n + (n + 1) \tag{3}
$$
$$
= \dfrac{n(n+1)}{2} + (n + 1) \tag{4}
$$
$$
= \dfrac{n(n+1)}{2} + \dfrac{2(n+1)}{2} \tag{5}
$$
$$
= \dfrac{(n+1)(n + 2)}{2} \tag{6}
$$
$$
= \dfrac{(n+1)((n + 1) + 1)}{2} \tag{7}
$$
$$
= RHS_{n+1} \tag{8}
$$</span><p>Thus 
<span class="math align-center">$LHS_{n+1} = RHS_{n+1}$</span>, so the inductive step holds.</p>
<h2 id="inductive-step-explanation">Inductive step explanation</h2>
<p>In line 2 of the proof above we saw that 
<span class="math align-center">$1 + 2 + ... + n$</span> was really 
<span class="math align-center">$LHS_n$</span>, so we made that substitution. Then in line 3, we used our inductive hypothesis - that 
<span class="math align-center">$LHS_n = RHS_n$</span>, and substituted 
<span class="math align-center">$RHS_n$</span>for 
<span class="math align-center">$LHS_n$</span>. Since we had that 
<span class="math align-center">$RHS_n = \dfrac{n(n+1)}{2}$</span>, we made that substitution on line 4.</p>
<p>From lines 5 to 7, we did algebraic manipulations to combine our terms and work towards the form of 
<span class="math align-center">$RHS_{n+1}$</span>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Algebra example</h1>
    
    
<p>Claim: The sum of the first 
<span class="math align-center">$n$</span> odd numbers is 
<span class="math align-center">$n^2$</span>.</p>
<h3 id="try-it-out">Try it out</h3>
<p>Before proving this claim with mathematical induction, let&rsquo;s see if the property holds for some sample values. The sum of the first 3 odd numbers is 
<span class="math align-center">$1 + 3 + 5 = 9$</span>. We also have that 
<span class="math align-center">$3^2 = 9$</span>.</p>
<p>The sum of the first 7 odd numbers is 
<span class="math align-center">$1 + 3 + 5 + 7 + 9 + 11 + 13 = 49$</span>. We also have that 
<span class="math align-center">$7^2 = 49$</span>.</p>
<p>Another way to express the sum of the first 
<span class="math align-center">$n$</span> odd numbers is: 
<span class="math align-center">$1 + 3 + ... + (2n - 1)$</span>. For example, when 
<span class="math align-center">$n$</span> is 4, we have that 
<span class="math align-center">$2n - 1 = 7$</span>. The sum of the first 
<span class="math align-center">$4$</span> odd numbers is 
<span class="math align-center">$1 + 3 + 5 + 7$</span>.</p>
<h3 id="induction-proof">Induction proof</h3>
<p>We wish to use mathematical induction to prove that, for all positive integers 
<span class="math align-center">$n$</span>, the sum of the first 
<span class="math align-center">$n$</span> odd numbers is 
<span class="math align-center">$n^2$</span>. That is, that:</p>

<span class="math align-center">$$
\begin{aligned}
1 + 3 + ... + (2n - 1) = n^2
\end{aligned}
$$</span><br>
<br>
<p>We will refer to 
<span class="math align-center">$1 + 3 + ... + (2n - 1)$</span> as 
<span class="math align-center">$LHS_n$</span> and we will refer to 
<span class="math align-center">$n^2$</span> as 
<span class="math align-center">$RHS_n$</span>. We must prove that 
<span class="math align-center">LHS_n = RHS_n$</span> for all positive integers <em>n</em>.</p>
<h4 id="base-case">Base case</h4>
<p>We must prove that the property holds for the smallest positive integer, 
<span class="math align-center">$n = 1$</span>, that is, that 
<span class="math align-center">$LHS_1 = RHS_1$</span>  The sum the first 1 odd integer is just 1, so we have that 
<span class="math align-center">$LHS_1 = 1$</span>. We also have that 
<span class="math align-center">$RHS_1 = 1^2 = 1$</span>. Thus 
<span class="math align-center">$LHS_1 = RHS_1$</span>, so the base case holds.</p>
<h4 id="inductive-step">Inductive step</h4>
<p>We assume the inductive hypothesis - that 
<span class="math align-center">$LHS_n = RHS_n$</span> for some positive integer 
<span class="math align-center">$n$</span>. We must prove that 
<span class="math align-center">$LHS_{n+1} = RHS_{n+1}$</span>. We have that:</p>

<span class="math align-center">$$
LHS_{n+1} = 1 + 3 + ... + (2n - 1) + (2(n + 1) - 1) \tag{1}
$$
$$
= LHS_n + (2(n + 1) - 1) \tag{2}
$$
$$
= RHS_n + (2(n + 1) - 1) \tag{3}
$$
$$
= n^2 + (2(n + 1) - 1) \tag{4}
$$
$$
= n^2 + 2n + 2 - 1 \tag{5}
$$
$$
= n^2 + 2n + 1 \tag{6}
$$
$$
= (n+1)^2 \tag{7}
$$
$$
= RHS_{n+1} \tag{8}
$$</span><p>Thus 
<span class="math align-center">$LHS_{n+1} = RHS_{n+1}$</span>, so the inductive step holds.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Divisibility example</h1>
    
    
<p>Claim: If 
<span class="math align-center">$n$</span> is a positive integer, then 
<span class="math align-center">$6^{n} - 1$</span> is divisible by 5.</p>
<h3 id="try-it-out">Try it out</h3>
<p>Let&rsquo;s see if the property holds for several sample numbers. When 
<span class="math align-center">$n = 3$</span>  we have that 
<span class="math align-center">$6^{3} - 1 = 216 - 1 = 215$</span>. Since 
<span class="math align-center">$215$</span> ends with a 5, it is clearly divisible by 5.</p>
<p>As another test, suppose 
<span class="math align-center">$n = 5$</span>. We have that 
<span class="math align-center">$6^{5} - 1 = 7776 - 1 = 7775$</span>, which is also divisible by 5.</p>
<h3 id="induction-proof">Induction proof</h3>
<p>We will use mathematical induction to prove that if 
<span class="math align-center">$n$</span> is a positive integer, then 
<span class="math align-center">$6^{n} - 1$</span> is divisible by 5.</p>
<h4 id="base-case">Base case</h4>
<p>We must prove that the property holds for the smallest positive integer, 
<span class="math align-center">$n = 1$</span>  that is, that 
<span class="math align-center">$6^{1} - 1$</span> is divisible by 5. We have that 
<span class="math align-center">$6^{1} - 1 = 6 - 1 = 5$</span> is divisible by 5, so the base case holds.</p>
<h4 id="inductive-step">Inductive step</h4>
<p>We assume the inductive hypothesis - that 
<span class="math align-center">$6^{n} - 1$</span> is divisible by 5 for some positive integer 
<span class="math align-center">$n$</span>. We must prove that 
<span class="math align-center">$6^{n+1} - 1$</span> is also divisible by 5. We have that:</p>

<span class="math align-center">$$
6^{n+1} - 1 = 6(6^{n}) - 1 \tag{1}
$$
$$
= 6(6^{n}) - 6 + 5 \tag{2}
$$
$$
= 6(6^{n} - 1) + 5 \tag{3}
$$</span><p>Since 
<span class="math align-center">$6^{n} - 1$</span> is divisible by 5 from our inductive hypothesis, any multiple of it is also divisible by 5. Thus, 
<span class="math align-center">$6(6^{n} - 1)$</span> is divisible by 5. Adding 5 to a number that is a multiple of 5 yields another multiple of 5. Thus 
<span class="math align-center">$6(6^{n} - 1) + 5$</span> is divisible by 5, so our inductive step holds.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Set example</h1>
    
    
<p>Claim: If 
<span class="math align-center">$n$</span> is a positive integer greater than or equal to 2, then a set with 
<span class="math align-center">$n$</span> elements has 
<span class="math align-center">$\dfrac{n(n-1)}{2}$</span>possible subsets of size 2.</p>
<h3 id="try-it-out">Try it out</h3>
<p>Suppose 
<span class="math align-center">$n = 3$</span>, and our set contains the elements 
<span class="math align-center">$(a, b, c)$</span>. There are 3 possible subsets of size 2: 
<span class="math align-center">$(a, b)$</span>, 
<span class="math align-center">$(a, c)$</span>, and 
<span class="math align-center">$(b, c)$</span>. We also have that 
<span class="math align-center">$\dfrac{3(3-1)}{2} = 3$</span>.</p>
<h3 id="induction-proof">Induction proof</h3>
<p>We will use mathematical induction to prove our claim for all positive integers 
<span class="math align-center">$n$</span> greater than or equal to 2.</p>
<h4 id="base-case">Base case</h4>
<p>We must prove that the property holds for the smallest such integer, 
<span class="math align-center">$n = 2$</span>. We must show that a set with two elements contains 
<span class="math align-center">$\dfrac{2(2-1)}{2} = 1$</span> possible subsets of size 2. If a set has just two elements, then there is only one possible subset of size 2 &ndash; the subset that contains both elements. Thus the base case holds.</p>
<h4 id="inductive-step">Inductive step</h4>
<p>We assume the inductive hypothesis - that a set with 
<span class="math align-center">$n$</span> elements has 
<span class="math align-center">$\dfrac{n(n-1)}{2}$</span> possible subsets of size 2. We must prove that a set with 
<span class="math align-center">$n + 1$</span> elements has 
<span class="math align-center">$\dfrac{(n+1)((n+1)-1)}{2} = \dfrac{n(n+1)}{2}$</span>possible subsets of size 2.</p>
<p>Introducing a new element to a set with $n$ elements yields 
<span class="math align-center">$n$</span>more 2-element subsets, as the new element could pair with each of the original elements.</p>
<p>A set with 
<span class="math align-center">$n+1$</span> elements contains all the original 
<span class="math align-center">$\dfrac{n(n-1)}{2}$</span> size-2 elements from the size-
<span class="math align-center">$n$</span> set, plus the 
<span class="math align-center">$n$</span> new subsets described above.</p>
<p>We have that:</p>

<span class="math align-center">$$
\dfrac{n(n-1)}{2} + n = \dfrac{n(n-1)+2n}{2}
$$
$$
= \dfrac{n(n-1+2)}{2}
$$
$$
= \dfrac{n(n+1)}{2}
$$</span><p>Thus the inductive hypothesis holds.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-8">Chapter 8</h3>
<h1 id="intro-to-programming-logic-assignments-and-conditionals">Intro to Programming Logic: Assignments and Conditionals</h1>
<p>For the rest of the course, we will switch gears back to something more familiar for most &ndash; computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Programming Logic Goal</h1>
    
    
<p>In the next three chapters, we will learn how to reason about different kinds of program structures &ndash; assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs in a toy language within Logika.</p>
<p>We will see that the process for formally proving correctness is rather tedious, even for relatively simple programs. And in practice, proving correctness of computer programs is rarely done. So why bother studying it?</p>
<h2 id="safety-critical-code">Safety critical code</h2>
<p>One case where reasoning about correctness is certainly relevant is the arena of <em>safety critical code</em> &ndash; where lives depend on a program working correctly. Certain medical devices, such as pacemakers and continuous glucose monitors, have a software component. If that software fails, then a person could die. We can&rsquo;t test the correctness of medical devices by installing them in a human body and trying them out &ndash; instead, we need to be absolutely sure they work correctly before they are used.</p>
<p>Similarly, there is software in things like shuttle launches. While that might not cost lives, it&rsquo;s also a process that can&rsquo;t be fully tested beforehand. After all, no one is going to spend over a billion dollar on a &ldquo;practice&rdquo; launch. Instead, we need a way to more formally demonstrate that the software will work correctly.</p>
<h2 id="specifications">Specifications</h2>
<p>In chapter 9, we will learn to write function <em>specifications</em>. These specifications list any requirements the function has in order to work correctly (<em>preconditions</em>) and descibe the impact of calling the function (<em>postconditions</em>) - most notably, what the function returns in terms of its inputs. Even in cases where we do not formally prove correctness of a program, it very useful to write a specification for all functions. This can make it clear to any calling code what kinds of parameters should be passed, as well as what to expect about the returned value. By providing this structure, there will be fewer surprises and unintended errors.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Logika Programs</h1>
    
    
<p>As we study program logic, we will use a toy language within Logika. These Logika programs use a subset of the Scala language, and include the following features:</p>
<ul>
<li>Variables (booleans, ints, and sequences [which are like arrays/lists])</li>
<li>Printing and user input</li>
<li>Math operations</li>
<li>Conditional operations</li>
<li>If and if/else statements</li>
<li>While loops</li>
<li>Functions</li>
</ul>
<h2 id="running-logika-programs">Running Logika programs</h2>
<p>Logika programs should be saved with a .logika extension. To run a Logika program, right-click in the text area that contains the code and select &ldquo;Run Logika Program&rdquo;.</p>
<h2 id="verifying-logika-programs">Verifying Logika programs</h2>
<p>There are two modes in Logika &ndash; manual and SymExe. In chapters 8 and 9, we will use manual mode. In chapter 10, we will use SymExe mode. You can change the mode in Logika by going to File-&gt;Settings-&gt;Tools-&gt;Sireum-&gt;Logika.</p>
<p>For manual mode, uncheck &ldquo;Auto mode&rdquo; and mark the Checker kind as &ldquo;Forward.&rdquo;</p>
<p>For SymExe mode, check &ldquo;Auto mode&rdquo; and mark the Checker kind as &ldquo;Summarizing SymExe&rdquo;.</p>
<p>Logika verification <em>should</em> run automatically as you edit Logika programs and their proofs. If a program is verified, you will see a purple checkmark in the lower right corner just as you did in propositional and predicate logic proofs. If there are syntax or logic errors, you will see them highlighted in red.</p>
<p>Sometimes, the Logika verification needs to be run manually. If you don&rsquo;t see either red errors or a purple checkmark, right-click in the text area that contains the code and select &ldquo;Logika Check&rdquo;.</p>
<h2 id="example-programs">Example programs</h2>
<p>This section contains four sample Logika programs that highlight the different language features.</p>
<h3 id="example-1-user-input-printing-operations">Example 1: User input, printing, operations</h3>
<p>This first example gets a number as input from the user, adds one to it, and prints the result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt(&#34;Enter a number: &#34;)
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>println(&#34;One more is &#34;, x)
</span></span></code></pre></div><p>A few things to note:</p>
<ul>
<li>Each Logika program begins with an import statement: <code>import org.sireum.logika._</code></li>
<li>The <code>var</code> keyword stands for variable, which is something that can be changed. Logika also has a <code>val</code> keyword, which creates a constant value that cannot be changed.</li>
<li>Lines do not end in semi-colons</li>
<li>The parameter to the <code>readInt(...)</code> function call is a prompt telling the user what to type. This parameter is optional.</li>
<li>The code <code>var x: Z</code> creates a variable called <code>x</code> of type <code>Z</code> &ndash; the <code>Z</code> means <em>integer</em></li>
</ul>
<h3 id="example-2-ifelse-statements">Example 2: If/else statements</h3>
<p>Here is a Logika program that gets a number from the user, and uses an if/else statement to print whether the number is positive or negative/zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = readInt(&#34;Enter a number: &#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &gt; 0) {
</span></span><span style="display:flex;"><span>    println(num, &#34; is positive&#34;)
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    println(num, &#34; is negative (or zero)&#34;)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A couple of things to note here:</p>
<ul>
<li>The <code>else</code> statement MUST appear on the same line as the closing <code>}</code> of the previous if-statement</li>
<li>As mentioned above, the <code>val</code> keyword in this program means that <code>x</code> cannot be changed after being initialized</li>
</ul>
<h3 id="example-3-while-loops">Example 3: While loops</h3>
<p>Our next Logika program uses a while loop to print the numbers from 10 down to 1. This program can&rsquo;t be run the way it appears below, as Logika wants you to do some verification work first. However, this program demonstrates what a while loop will look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var cur: Z = 10
</span></span><span style="display:flex;"><span>while (cur &gt;= 1) {
</span></span><span style="display:flex;"><span>    println(&#34;Next number: &#34;, cur)
</span></span><span style="display:flex;"><span>    cur = cur - 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="example-4-sequences-and-functions">Example 4: Sequences and functions</h3>
<p>Our final sample Logika program demonstrates <em>sequences</em> (Logika&rsquo;s version of an array or list) and functions. It contains a function, <code>sumSequence</code>, which takes a sequence of integers as a parameter and returns the sum of the numbers in the sequence. At the bottom, we can see our test code that creates a sample sequence and tries calling <code>sumSequence</code>. As in our third example, this code cannot be run without some verification work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def sumSequence(seq: ZS) : Z = {
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var i: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i &lt; seq.size) {
</span></span><span style="display:flex;"><span>        sum = sum + seq(i)
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////// Calling code ////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val list: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>val total: Z = sumSequence(list)
</span></span><span style="display:flex;"><span>println(&#34;Sum of elements:&#34;, total)
</span></span></code></pre></div><p>A few things of note here:</p>
<ul>
<li>
<p>The definition <code>def sumSequence(seq: ZS) : Z</code> means that a function named <code>sumSequence</code> takes a parameter of type <code>ZS</code> (sequence of integers, <code>Z</code> = int and <code>S</code> = sequence) and returns something of type <code>Z</code> (int)</p>
</li>
<li>
<p>There is an <code>=</code> after the function header but before the opening <code>{</code> of the function</p>
</li>
<li>
<p>Functions in Logika are not part of a class - they are more similar to the structure in Python. We can include as many functions as we want in a file. At the bottom of the file (marked below the optional <code>////// Calling code ////////////</code>) is the <em>calling code</em>. When a Logika program runs, those calling code lines (which may call different functions) are executed. When the calling code lines are done, the program is done.</p>
</li>
</ul>
<h2 id="logika-program-proof-syntax">Logika program proof syntax</h2>
<p>In order to prove correctness of Logika programs, we will add <em>Logika proof blocks</em> to process what we have learned at different points in the program. In general, every time there is an assignment statement, there will be a following Logika proof block updating all relevant facts.</p>
<h3 id="proof-block">Proof block</h3>
<p>Here is the syntax for a proof block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    lineNumber. claim               justification
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Just as with our propositional and predicate logic proofs, we will number the lines in our proof blocks. Each line will contain a <em>claim</em> and a corresponding <em>justification</em> for that claim. We will still be able to use all of our propositional and predicate logic deduction rules, but we will learn new justifications for processing program statements. Each program may have multiple of these proof blocks to process each assignment statement.</p>
<h3 id="premise-justification">Premise justification</h3>
<p>Our first justification in programming logic is <em>premise</em>. In a Logika proof block, we use premise as a justification in the following cases:</p>
<ul>
<li>
<p>To express an assignment statement (or other program statement)</p>
</li>
<li>
<p>To pull a claim established in a previous proof block into a later proof block</p>
</li>
</ul>
<p>In both cases, the claim must capture the current value of the involved variables.</p>
<p>For example, consider the following program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>x = x + 1
</span></span></code></pre></div><p>We could insert a proof block between the two lines to express that <code>x</code> currently has the value 6:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span></code></pre></div><p>But we could NOT have the same proof block after incrementing <code>x</code>, since <code>x</code>&rsquo;s value has changed since that claim was established:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this proof block is correct -- it captures the current value of x
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//NO! This statement no longer captures the current value of x
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><h3 id="using-previous-deduction-rules">Using previous deduction rules</h3>
<p>We can use any of our previous deduction rules in a Logika proof block. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>val y: Z = 7
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>    2. y == 7               premise
</span></span><span style="display:flex;"><span>    3. (x == 6) ∧ (y == 7)  ∧i 1 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Assert and Assume</h1>
    
    
<h2 id="assert-statements">Assert statements</h2>
<p>An <em>assert</em> statement in Logika uses the syntax <code>assert(expression)</code>, where <code>expression</code> is of type <code>bool</code>. The assert passes if the expression is true, and throws an error if the expression is false.</p>
<p>Logika assert statements are different than assert statements in languages like Java and C# &ndash; in those languages, the code in the assert statement (which often includes test method calls) is actually run, and the assert statement checks whether those methods are returning the expected values. In Logika, assert statements only pass if we have previously PROVED what we are claiming &ndash; the code is never executed.</p>
<h3 id="example">Example</h3>
<p>Consider the following program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>val y: Z = 6
</span></span><span style="display:flex;"><span>val z: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert (x == y &amp; y &gt; z)
</span></span></code></pre></div><p>While we can tell that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>, this code would fail in Logika (at least in its manual mode, which is what we are using now). In order for an assert to pass, we must have already proved EXACTLY the statement in the assert.</p>
<p>Why do WE know that <code>x</code> equals <code>y</code> and that <code>y</code> is greater than <code>z</code>? From looking at the code! We can tell that <code>x</code> and <code>y</code> are given the same value (6), and that <code>y</code>&rsquo;s value of 6 is bigger than <code>z</code>&rsquo;s value of 4.</p>
<p>So far, we know we can pull in the values of each variable as premises, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 6
</span></span><span style="display:flex;"><span>val y: Z = 6
</span></span><span style="display:flex;"><span>val z: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6           premise
</span></span><span style="display:flex;"><span>    2. y == 6           premise
</span></span><span style="display:flex;"><span>    3. z == 4           premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //how to say that x and y are equal, and that y is bigger than z?
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert (x == y &amp; y &gt; z)
</span></span></code></pre></div><p>But we don&rsquo;t yet know how to justify claims that describe how variables compare to one another. We will learn how to do that with the <code>algebra</code> and <code>subst</code> rules in section 8.4.</p>
<h3 id="using-conditional-operators">Using conditional operators</h3>
<p>Notice that the program above used an <code>&amp;</code> symbol for an AND operator in an assert statement. Because asserts are part of the program and not part of a proof block, they will use the same conditional operators as in Logika programs. Here is a summary:</p>
<table>
<thead>
<tr>
<th>Meaning</th>
<th>Operator in proofs</th>
<th>Operator in Logika programs/assumes/asserts</th>
</tr>
</thead>
<tbody>
<tr>
<td>p AND q</td>
<td><code>p ∧ q</code></td>
<td><code>p &amp; q</code></td>
</tr>
<tr>
<td>p OR q</td>
<td><code>p ∨ q</code></td>
<td><code>p | q</code></td>
</tr>
<tr>
<td>NOT p</td>
<td><code>¬p</code></td>
<td><code>!p</code></td>
</tr>
<tr>
<td>p IMPLIES q</td>
<td><code>p → q</code></td>
<td>not available</td>
</tr>
</tbody>
</table>
<p>If we wanted to write an assert statement that would be true when some variable <code>p</code> was even and/or was a positive two-digit number, we could say:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(p % 2 == 0 | (p &gt; 9 &amp; p &lt; 100))
</span></span></code></pre></div><p>The implies operator is not available in assert statements. However, we can make use of one of the equivalences we learned about in section 3.4: that <code>p → q</code> is equivalent to <code>¬ p ∨ q</code>. So if we wanted to assert that if <code>p</code> was positive, then <code>q</code> was equal to <code>p</code>, then we could write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//expressing the implicaton ((p &gt; 0) → (q == p))
</span></span><span style="display:flex;"><span>assert(!(p &gt; 0) | (q == p))
</span></span></code></pre></div><p>Or, equivalently, we could write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert((p &lt;= 0) | (q == p))
</span></span></code></pre></div><h2 id="assume-statement">Assume statement</h2>
<p>An <em>assume</em> statement in Logika uses the syntax <code>assume(expression)</code>. If the expression is satisfiable, then we can use <code>expression</code> as a premise in the following Logika proof block.</p>
<h3 id="assume-example">Assume example</h3>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var a: Z = readInt()
</span></span><span style="display:flex;"><span>assume (a &gt; 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. a &gt; 0            premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Assume statements are almost always used to make assumptions about user input. Perhaps our program only works correctly for certain values of input. If we can assume that the user really did enter acceptable values, then we can use that information (by pulling it in as a premise in the next logic block) to prove the correctness of the program based on that assumption.</p>
<h3 id="assumes-vs-wrapping-if-statements">Assumes vs. wrapping if-statements</h3>
<p>Toy programs often use assume in lieu of wrapping code in an if statement. The following two examples are equivalent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var a : Z = readInt()
</span></span><span style="display:flex;"><span>assume (a != 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. a != 0  premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var b: Z = 20 / a
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//...is equivalent to:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var a : Z = readInt()
</span></span><span style="display:flex;"><span>var b : Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (a != 0) {
</span></span><span style="display:flex;"><span>    b = 20 / a
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>These examples also demonstrate a requirement when we use the division operator in Logika programs, we must first demonstrate that we are not dividing by zero.</p>
<h3 id="unsatisfiable-assume">Unsatisfiable assume</h3>
<p>You will see an error in Logika if your assume statement is not satisfiable. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var a: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assume(a &gt; 0)
</span></span><span style="display:flex;"><span>assume (a == 0)
</span></span></code></pre></div><p>If you try verifying this program, you will get a Logika error on the second <code>assume</code> statement. This is because we already assumed that <code>a</code> was greater than 0, and it is not possible for <code>a</code> to also be equal to 0.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Algebra and subst Rules</h1>
    
    
<p>In this section, we will learn our first two proof rules for programming logic &ndash; <code>algebra</code> and <code>subst</code>.</p>
<h2 id="verifying-simple-programs">Verifying simple programs</h2>
<p>Before we delve into our new proof rules, let&rsquo;s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the <code>// --&gt;</code> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>get user input / set initial variable values
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add assume statements to specify what must be true about the input
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program statement
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add logic block to evaluate what has happened in the program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program statement
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add logic block to evaluate what has happened in the program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program statement
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add logic block to evaluate what has happened in the program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(...more program statements)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // --&gt; add assert statements to express what our program did
</span></span></code></pre></div><p>We see that if our program involves user input, then we must consider whether our program will only work correctly for certain input values. In that situation, we express our assumptions using <code>assume</code> statements.</p>
<p>After each program statement, we must add a logic block to evaluate what changed on that line of code. We will see more details on these logic blocks throughout the rest of this chapter. Recall that the syntax for those logic blocks looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    lineNumber. claim               justification
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // ... (more claims/justifications)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Finally, we add one or more <code>assert</code> statements to express what our program did. These are usually placed at the end of a program, but sometimes we have assert statements throughout the program to describe the progress up to that point.</p>
<h2 id="algebra-justification">Algebra justification</h2>
<p>The <code>algebra</code> justification can be used for ANY algebraic manipulation on previous claims. When using this justification, include all relevant proof line numbers in whatever order (you might use as few as zero line numbers or as many as 3+ line numbers).</p>
<h3 id="example">Example</h3>
<p>Consider this example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 6
</span></span><span style="display:flex;"><span>var y: Z = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert (y == 6)
</span></span></code></pre></div><p>Following our process from above, we add logic blocks after each program statement. In these logic blocks, we start by listing the previous program statement as a premise:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var y: Z = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == x               premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //need claim &#34;y == 6&#34; for our assert to hold
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert (y == 6)
</span></span></code></pre></div><p>For our assert to hold, we must have EXACTLY that claim in a previous logic block &ndash; so we know we want our second logic block to include the claim <code>y == 6</code>.</p>
<p>Here is the program with the second logic block completed &ndash; the assert statement will now hold.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 6               premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var y: Z = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == x               premise
</span></span><span style="display:flex;"><span>    2. x == 6               premise     //established in a previous logic block, and x is unchanged since then
</span></span><span style="display:flex;"><span>    3. y == 6               algebra 1 2 //we know y is 6 using the claims from lines 1 and 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will hold
</span></span><span style="display:flex;"><span>assert (y == 6)
</span></span></code></pre></div><p>We could have also deleted the first logic block in this example. We would still be able to claim <code>x == 6</code> as a premise in the last logic block, as <code>x</code> had not changed since being given that value.</p>
<h2 id="subst">subst</h2>
<p>We have two deduction rules that involve substitution &ndash; <code>subst1</code> and <code>subst2</code>. Both of these rules are similar to the find/replace feature in text editors. They preserve truth by replacing one proposition with an equivalent one.</p>
<p>The <code>algebra</code> justification will work for most mathematical manipulation. However, it will not work for any claim involving <code>∧</code>, <code>∨</code>, <code>→</code>, <code>⊥</code>, <code>∀</code>, <code>∃</code> &ndash; in those cases, we will be required to use substitution instead.</p>
<h3 id="subst1-justification">subst1 justification</h3>
<p>Here is the syntax for the <code>subst1</code> rule. In the example below, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    m. LHS_M == RHS_M       (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    n. LINE_N               (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    p. (claim)              subst1 m n
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p><code>(claim1)</code> rewrites <code>LINE_N</code> by substituting all ocurrences of <code>LHS_M</code> (the FIRST side of line <code>m</code>) with <code>RHS_M</code>. Here is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x + 1 == y - 4                       (some justification)
</span></span><span style="display:flex;"><span>    2. x*(x + 1) == (x + 1) + y             (some justification)
</span></span><span style="display:flex;"><span>    3. x*(y - 4) == (y - 4) + y             subst1 1 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>We wrote line 2 by replacing each occurence of <code>x + 1</code> with <code>y - 4</code>.</p>
<h3 id="subst2-justification">subst2 justification</h3>
<p>Here is the syntax for the <code>subst2</code> rule. Just as with <code>subst1</code>, line <code>m</code> must be an equivalence (something equals something else). Line <code>n</code> can be anything.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    m. LHS_M == RHS_M       (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    n. LINE_N               (some justification)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    p. (claim)              subst2 m n
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p><code>(claim1)</code> rewrites <code>LINE_N</code> by substituting all ocurrences of <code>RHS_M</code> (the SECOND side of line <code>m</code>) with <code>LHS_M</code>. Here is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x + 1 == y                               (some justification)
</span></span><span style="display:flex;"><span>    2. y*(x + 1) == (x + 1) + y                 (some justification)
</span></span><span style="display:flex;"><span>    3. (x + 1)*(x + 1) == (x + 1) + (x + 1)     subst2 1 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>We wrote line 2 by replacing each occurence of <code>y</code> with <code>x + 1</code>. Note that we put parentheses around our first replacement to ensure a product equivalent to the original statement.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Assignment Statements</h1>
    
    
<p>Assignment statements in a program come in two forms &ndash; with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.</p>
<p>For example, an increment statement like <code>x = x + 1</code> MUTATES the value of <code>x</code> by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of <code>x</code>.</p>
<p>In contrast, a statemnet like <code>y = x + 1</code> assigns to <code>y</code> one more than the value in <code>x</code>. We do not need to know the previous value of <code>y</code>, as we are not using it in the assignment statement. (We do need to know the value of <code>x</code>).</p>
<h2 id="assignments-without-mutation">Assignments without mutation</h2>
<p>We have already seen the steps necessary to process assignment statements that do not involve variable mutation. Recall that we can declare as a <code>premise</code> any assignment statement or claim from a previous logic block involving variables that have not since changed.</p>
<p>For example, suppose we want to verify the following program so the assert statement at the end will hold:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val y: Z = x + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val z: Z = 10 - x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the assert will not hold yet
</span></span><span style="display:flex;"><span>assert(y == z &amp; y == 6)
</span></span></code></pre></div><p>Since none of the statements involve variable mutation, we can do the verification in a single logic block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = 4    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val y: Z = x + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val z: Z = 10 - x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    2. y == x + 2           premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    3. z == 10 - x          premise     //assignment of unchanged variable
</span></span><span style="display:flex;"><span>    4. y == 4 + 2           subst1 1 2
</span></span><span style="display:flex;"><span>    5. z == 10 - 4          subst1 1 3
</span></span><span style="display:flex;"><span>    6. y == 6               algebra 4
</span></span><span style="display:flex;"><span>    7. z == 6               algebra 5
</span></span><span style="display:flex;"><span>    8. y == z               subst2 7 6
</span></span><span style="display:flex;"><span>    9. y == z ∧ y == 6      ∧i 8 6
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now the assert will hold
</span></span><span style="display:flex;"><span>assert(y == z &amp; y == 6)
</span></span></code></pre></div><p>Note that we did need to do <code>∧i</code> so that the last claim was <code>y == z ∧ y == 6 </code>, even though we had previously established the claims <code>y == z</code> and <code>y == 6</code>. In order for an assert to hold (at least until we switch Logika modes in chapter 10), we need to have established EXACTLY the claim in the assert in a previous logic block.</p>
<h2 id="assignments-with-mutation">Assignments with mutation</h2>
<p>Assignments with mutation are trickier &ndash; we need to know the old value of a variable in order to reason about its new value. For example, if we have the following program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert(x == 5)
</span></span></code></pre></div><p>Then we might try to add the following logic blocks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //from previous variable assignment
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == x + 1           premise     //NO! Need to distinguish between old x (right side) and new x (left side)
</span></span><span style="display:flex;"><span>    2. x == 4               premise     //NO! x has changed since this claim
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//this assert will not hold yet
</span></span><span style="display:flex;"><span>assert(x == 5)
</span></span></code></pre></div><p>&hellip;but then we get stuck in the second logic block. There, <code>x</code> is supposed to refer to the CURRENT value of <code>x</code> (after being incremented), but both our attempted claims are untrue. The current value of <code>x</code> is not one more than itself (this makes no sense!), and we can tell from reading the code that <code>x</code> is now 5, not 4.</p>
<p>To help reason about changing variables, Logika has a special <code>name_old</code> value that refers to the OLD value of a variable called <code>name</code>, just before the latest update. In the example above, we can use <code>x_old</code> in the second logic block to refer to <code>x</code>&rsquo;s value just before it was incremented. We can now change our premises and finish the verification as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 4               premise     //from previous variable assignment
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = x + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == x_old + 1       premise     //Yes! x equals its old value plus 1
</span></span><span style="display:flex;"><span>    2. x_old == 4           premise     //Yes! The old value of x was 4
</span></span><span style="display:flex;"><span>    3. x == 4 + 1           subst1 2 1  
</span></span><span style="display:flex;"><span>    4. x == 5               algebra 3   //Could have skipped line 3 and used &#34;algebra 1 2&#34; instead
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now the assert will hold
</span></span><span style="display:flex;"><span>assert(x == 5)
</span></span></code></pre></div><p>By the end of the logic block following a variable mutation, we need to express everything we know about the variable&rsquo;s current value WITHOUT using the <code>_old</code> terminology, as its scope will end when the logic block ends. Moreover, we only ever have one <code>_old</code> value available in a logic block &ndash; the variable that was most recently changed. This means we will need logic blocks after each variable mutation to process the changes to any related facts.</p>
<h2 id="variable-swap-example">Variable swap example</h2>
<p>Suppose we have the following Logika program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//what do we want to assert we did?
</span></span></code></pre></div><p>We can see that this program gets two user input values, <code>x</code> and <code>y</code>, and then swaps their values. So if <code>x</code> was originally 4 and <code>y</code> was originally 6, then at the end of the program <code>x</code> would be 6 and <code>y</code> would be 4.</p>
<p>We would like to be able to assert what we did &ndash; that <code>x</code> now has the original value from <code>y</code>, and that <code>y</code> now has the original value from <code>x</code>. To do this, we might invent dummy constants called <code>xOrig</code> and <code>yOrig</code> that represent the original values of those variables. Then we can add our assert:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the original values of both inputs
</span></span><span style="display:flex;"><span>val xOrig: Z = x
</span></span><span style="display:flex;"><span>val yOrig: Z = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//x and y have swapped
</span></span><span style="display:flex;"><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style="display:flex;"><span>assert(x == yOrig &amp; y == xOrig)     //this assert will not yet hold
</span></span></code></pre></div><p>We can complete the verification by adding logic blocks after assignment statements, being careful to update all we know (without using the <code>_old</code> value) by the end of each block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the original values of both inputs
</span></span><span style="display:flex;"><span>val xOrig: Z = x
</span></span><span style="display:flex;"><span>val yOrig: Z = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. xOrig == x           premise
</span></span><span style="display:flex;"><span>    2. yOrig == y           premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//swap x and y
</span></span><span style="display:flex;"><span>val temp: Z = x
</span></span><span style="display:flex;"><span>x = y
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == y                   premise     //from the assignment statement
</span></span><span style="display:flex;"><span>    2. temp == x_old            premise     //temp equaled the OLD value of x
</span></span><span style="display:flex;"><span>    3. xOrig == x_old           premise     //xOrig equaled the OLD value of x
</span></span><span style="display:flex;"><span>    4. yOrig == y               premise     //yOrig still equals y
</span></span><span style="display:flex;"><span>    5. temp == xOrig            algebra 2 3
</span></span><span style="display:flex;"><span>    6. x == yOrig               algebra 1 4
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>y = temp
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. y == temp                premise     //from the assignment statemnet
</span></span><span style="display:flex;"><span>    2. temp == xOrig            premise     //from the previous logic block (temp and xOrig are unchanged since then)
</span></span><span style="display:flex;"><span>    3. yOrig == y_old           premise     //yOrig equaled the OLD value of y
</span></span><span style="display:flex;"><span>    4. y == xOrig               algebra 1 2
</span></span><span style="display:flex;"><span>    5. x == yOrig               premise     //from the previous logic block (x and yOrig are unchanged since then)
</span></span><span style="display:flex;"><span>    6. x == yOrig ^ y == xOrig  ^i 5 4
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//x and y have swapped
</span></span><span style="display:flex;"><span>//x has y&#39;s original value, and y has x&#39;s original value
</span></span><span style="display:flex;"><span>assert(x == yOrig &amp; y == xOrig)     //this assert will hold now
</span></span></code></pre></div><p>Notice that in each logic block, we express as much as we can about all variables/values in the program. In the first logic block, even though <code>xOrig</code> and <code>yOrig</code> were not used in the previous assignment statement, we still expressed how the current values our other variables compared to <code>xOrig</code> and <code>yOrig</code>. It helps to think about what you are trying to claim in the final assert &ndash; since our assert involved <code>xOrig</code> and <code>yOrig</code>, we needed to relate the current values of our variables to those values as we progressed through the program.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Integer Division and Modulo</h1>
    
    
<p>Working with division and modulo requires extra care, as Logika is finicky about both.</p>
<h2 id="division">Division</h2>
<p>Recall that <code>Z</code> (int) is the only numeric type in Logika, so any division is integer division. This means something like <code>9/2</code> evaluates to 4, just as it would in Java or C#.</p>
<h3 id="check-for-division-by-zero">Check for division by zero</h3>
<p>Before doing division of the form <code>numerator/denominator</code>, either in a line of code or in a logic block, you must have a line in a previous logic block that states: <code>denominator != 0</code>. Other forms, such as <code>denominator &gt; 0</code> or <code>0 != denominator</code>, will not work. You are even required to do this when dividing by a constant value that is obviously not zero.</p>
<p>For example, if we do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 10 / 2
</span></span></code></pre></div><p>Then Logika will give us an error complaining we have not proved that the denominator is not zero. We must add the claim <code>2 != 0</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 != 0           algebra
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 10 / 2
</span></span></code></pre></div><p>Note that our justification is just, <code>algebra</code>, as we don&rsquo;t need any extra information to claim that 2 is not equal to 0.</p>
<h3 id="pitfalls">Pitfalls</h3>
<p>Be careful when making claims that involve division. For example, the following claim will not validate in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == (x/3)*3         algebra     //NO!
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>While the claim <code>x == (x/3)*3</code> is certainly true in math, it is not true with integer division. For example, if <code>x</code> is 7, then <code>(x/3)*3</code> is 6 &ndash; so the two sides are not equal. In general, I recommend avoiding claims involving division if you can at all help it. Instead, try to find a way to express the same idea in a different way using multiplication.</p>
<h2 id="modulo">Modulo</h2>
<p>Modulo (%) works the same way in Logika as it does in other programming languages. For example, <code>20 % 6</code> evaluates to 2.</p>
<h3 id="modulo-checks-on-numerator-and-denominator">Modulo checks on numerator and denominator</h3>
<p>Before using the modulo operator in the form <code>numerator % denominator</code>, either in a line of code or as a claim in a logic block, you must have EXACTLY these claims in the previous logic block:</p>
<ul>
<li><code>numerator &gt;= 0</code></li>
<li><code>denominator &gt; 0</code></li>
</ul>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 &gt; 0           algebra
</span></span><span style="display:flex;"><span>    2. a &gt;= 0          (some justification)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = a % 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h3 id="example">Example</h3>
<p>Consider the following Logika program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt(&#34;Enter positive number: &#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assume(num &gt; 0)
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num * 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num + 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num/2 - 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == orig)
</span></span></code></pre></div><p>It can often be handy to walk through a program with sample numbers before trying to prove its correctness:</p>
<ul>
<li>Suppose our input value, <code>num</code>, is 11</li>
<li><code>orig</code> is initialized to be 11 also</li>
<li><code>num</code> is multiplied by 2, and is 22</li>
<li>It makes sense that <code>num</code> would be even, since any number times two is always even (and indeed, 22 is even)</li>
<li>We add 2 to <code>num</code>, so it is now 24</li>
<li>It makes sense that <code>num</code> would still be even, as it was even before and we added 2 (another even number) to it. Indeed, 24 is still even.</li>
<li>We update <code>num</code> by dividing it by 2 and subtracting 1, so <code>num</code> is now back to its original value of 11 (the same as <code>orig</code>). This step &ldquo;undoes&rdquo; the changes we have made to <code>num</code> &ndash; looking at the code, we can see that the final value of <code>num</code> is <code>orig*2 + 2</code>, so if we do <code>(orig*2 + 2) / 2 - 1</code>, we are left with <code>orig</code>.</li>
</ul>
<p>Here is the completed verification, with comments at each step:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt(&#34;Enter positive number: &#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assume(num &gt; 0)
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>num = num * 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == num_old * 2           premise     //we updated num to be its old value times 2
</span></span><span style="display:flex;"><span>    2. orig == num_old              premise     //orig equaled the old value of num (before our change)
</span></span><span style="display:flex;"><span>    3. num == orig * 2              algebra 1 2 //express the new value of num without referring to &#34;_old&#34;
</span></span><span style="display:flex;"><span>    4. 2 &gt; 0                        algebra     //needed to use modulo in step 7
</span></span><span style="display:flex;"><span>    5. num_old &gt; 0                  premise     //we assumed the old value of num (before its change) was &gt; 0
</span></span><span style="display:flex;"><span>    6. num &gt;= 0                     algebra 1 5 //needed to use modulo in step 7
</span></span><span style="display:flex;"><span>    7. num % 2 == 0                 algebra 1   //we have showed num is now even (needed for next assert)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num + 2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == num_old + 2               premise     //we updated num to be its old value plus 2
</span></span><span style="display:flex;"><span>    2. num_old &gt;= 0                     premise     //from line 6 in previous block, but num has since changed
</span></span><span style="display:flex;"><span>    3. num_old % 2 == 0                 premise     //from line 7 in previous block, but num has since changed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we know 2 &gt; 0 from previous block - don&#39;t need to restate here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    4. num &gt;= 0                         algebra 1 2 //needed to use modulo in step 5 (need to redo since num has changed)
</span></span><span style="display:flex;"><span>    5. num % 2 == 0                     algebra 1 3 //we have showed num is still even (needed for next assert)
</span></span><span style="display:flex;"><span>    6. num_old == orig * 2              premise     //from line 3 in block above, but num has since changed
</span></span><span style="display:flex;"><span>    7. num - 2 == orig * 2              algebra 1 6 //express new value of num without using &#34;_old&#34;
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num % 2 == 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 != 0                       algebra     //needed for dividing by 2
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num = num/2 - 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == num_old/2 - 1             premise     //we updated num to be its old value divided by 2 minus 1
</span></span><span style="display:flex;"><span>    2. num_old - 2 == orig * 2          premise     //from line 7 in previous block, but num has since changed
</span></span><span style="display:flex;"><span>    3. num_old == orig * 2 + 2          algebra 2
</span></span><span style="display:flex;"><span>    4. num == (orig * 2 + 2)/2 - 1      algebra 1 3 //express new value of num without using &#34;_old&#34;
</span></span><span style="display:flex;"><span>    5. num == orig + 1 - 1              algebra 4
</span></span><span style="display:flex;"><span>    6. num == orig                      algebra 5   //we have showed num is back to being orig (needed for last assert)
</span></span><span style="display:flex;"><span>                                                    //could have skipped straight here with &#34;algebra 1 2&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == orig)
</span></span></code></pre></div><p>Sometimes it can be tricky to figure out what to do at each step in order to get assert statements to pass. If you are unsure what to do, I recommend:</p>
<ul>
<li>
<p>Walk through the program several times with sample numbers, keeping track of changes to variables. Why do the assert statements make sense to you? Convince yourself that they are valid claims before you worry about the formal verification.</p>
</li>
<li>
<p>Add a logic block after each variable mutation. Work from the top down:</p>
<ul>
<li>Write a premise for every variable assignment and assume statement since the previous logic block.</li>
<li>Find all claims in the logic block just before you that do not use an &ldquo;_old&rdquo; reference &ndash; pull each claim into your current block, using an &ldquo;_old&rdquo; reference as needed for the most recently changed variable.</li>
<li>Manipulate your claims that use an &ldquo;_old&rdquo; reference until you have statements that capture the current value of the recently changed variable that do not reference &ldquo;_old&rdquo;</li>
<li>If your next statement is an assert, manipulate your claims until you have exactly the claim in the assert.</li>
<li>If any claims</li>
</ul>
</li>
<li>
<p>Add a logic block before each use of division (<code>numerator / denominator</code>) and modulus (<code>numerator % denominator</code>). Pull in claims from previous blocks as described above to help you show what is needed about <code>numerator</code> and <code>denominator</code>:</p>
<ul>
<li>For division, build to the claim <code>denominator != 0</code></li>
<li>For modulo, build to the claims <code>numerator &gt;= 0</code> and <code>denominator &gt; 0</code></li>
<li>If you can, avoid using division in logic block claims</li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Conditional Statements</h1>
    
    
<p>To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. Recall that Logika does not have an if/else if statement. However, you can simulate more than two branches by nesting another if/else inside the outer else.</p>
<h2 id="motivation">Motivation</h2>
<p>Before we formalize the details of verifying a program with a conditional statement, let&rsquo;s motivate the topic with an example.</p>
<h3 id="max-program">Max program</h3>
<p>Suppose we have a Logika program that finds finds the maximum (<code>max</code>) between two user input numbers (<code>x</code> and <code>y</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var max: Z = 0  //give max a dummy starting value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (x &gt; y) {
</span></span><span style="display:flex;"><span>    max = x
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    max = y
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="max-assert">Max assert</h3>
<p>Before worrying about how to do the verification, let&rsquo;s consider what we should assert at the end in order to be sure that <code>max</code> really does hold the biggest of the two inputs. Clearly, <code>max</code> should be greater than or equal to both inputs. So should our assert be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//Not quite all we want to say
</span></span><span style="display:flex;"><span>assert(max &gt;= x &amp; max &gt;= y)
</span></span></code></pre></div><p>Suppose <code>x</code> was 10, <code>y</code> was 15&hellip;and that <code>max</code> was 20. (Clearly this isn&rsquo;t what our code would do, but you can imagine writing something else for the max code that came up with such a calculation). In this case, <code>max</code> is indeed greater than or equal to both inputs&hellip;but it is just as clearly not the max. We know see that we also need to claim that <code>max</code> equals one of the two inputs. This makes our assert:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//Now we are sure we are describing the max between x and y
</span></span><span style="display:flex;"><span>assert(max &gt;= x &amp; max &gt;= y &amp; (max == x | max == y))
</span></span></code></pre></div><h3 id="analyzing-max">Analyzing max</h3>
<p>Now, we need to prove that our assert holds no matter which branch we follow in the conditional statement. First, when we analyze the code in the if-branch, we have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>max = x
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. max == x         premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>and when we analyze the code in the else-branch, we have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>max = y
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. max == y         premise
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>These two deductions imply that, when the if/else statements finishes, one or the other property holds true:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (x &gt; y) {
</span></span><span style="display:flex;"><span>    max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == x         premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    max = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == y         premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style="display:flex;"><span>    1 . max == x  v  max == y premise 
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>This illustrates the first principle of conditional commands: the knowledge produced by the command is the disjunction (or) of the knowledge produced by each branch. In the section on propositional logic, we covered how to apply cases analyses on disjunctive assertions to extract useful knowledge.</p>
<p>Recall that the intent of the if/else statement was to set <code>max</code> so that it holds the larger of <code>x</code> and <code>y</code>, so that our assert would hold:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(max &gt;= x &amp; max &gt;= y &amp; (max == x | max == y))
</span></span></code></pre></div><p>The claim we proved so far satisifies the second part of our assert statement, but not the first part. This is because we ignored a critical feature of an if/else statement: By asking a question — the condition — the if/else statement generates new knowledge.</p>
<p>For the if-branch, we have the new knowledge that <code>x &gt; y</code>; for the else-branch, we have that <code>¬(x &gt; y)</code>, that is, <code>y &gt;= x</code>. We can embed these assertions into the analysis of the conditional command, like this, and conclude that, in both cases, <code>max</code> is greater than or equal to both inputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = readInt()
</span></span><span style="display:flex;"><span>var y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var max: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (x &gt; y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        2. x &gt; y            premise     //the condition is true
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == x         premise     //from the &#34;max = x&#34; assignment
</span></span><span style="display:flex;"><span>        2. max &gt;= x         algebra 1
</span></span><span style="display:flex;"><span>        3. x &gt; y            premise     //condition is still true (x and y are unchanged)
</span></span><span style="display:flex;"><span>        4. max &gt;= y         algebra 1 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        2. ¬(x &gt; y)         premise     //the condition is NOT true
</span></span><span style="display:flex;"><span>        3. x &lt;= y           algebra 2
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    max = y
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == y         premise     //from the &#34;max = y&#34; assignment
</span></span><span style="display:flex;"><span>        2. x &lt;= y           premise     //pulled down from previous logic block (x and y are unchanged)
</span></span><span style="display:flex;"><span>        3. max &gt;= x         algebra 1 2
</span></span><span style="display:flex;"><span>        4. max &gt;= y         algebra 1
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//summary of what just happened
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //max == x in the IF, max == y in the ELSE
</span></span><span style="display:flex;"><span>    1. max == x ∨ max == y      premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    2. max &gt;= x                 premise     //true in BOTH branches
</span></span><span style="display:flex;"><span>    3. max &gt;= y                 premise     //true in BOTH branches
</span></span><span style="display:flex;"><span>    4. max &gt;= x ∧ max &gt;= y      ^i 2 3
</span></span><span style="display:flex;"><span>    5. (max &gt;= x ∧ max &gt;= y) ∧ (max == x ∨ max == y)    ^i 4 1
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert((max &gt;= x &amp; max &gt;= y) &amp; (max == x | max == y))
</span></span></code></pre></div><h2 id="rules-for-analyzing-programs-with-conditionals">Rules for analyzing programs with conditionals</h2>
<p>In this section, we will summarize how to analyze programs with conditional statements.</p>
<h3 id="declaring-condition-and-condition-as-premises">Declaring condition and ¬(condition) as premises</h3>
<p>If we have a program such as this with an if/else statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then we can claim <code>C</code> as a premise immediately inside the if-branch and <code>¬(C)</code> as a premise immediately inside the else branch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. C            premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ¬(C)         premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Be careful with the <code>else</code> case &ndash; you must claim exactly <code>¬(C)</code>, and not some claim you know to be equivalent. In our max example, <code>C</code> was <code>x &lt; y</code>, and we needed to claim exactly <code>¬(x &lt; y)</code> in the else &ndash; NOT <code>x &gt;= y</code>. After you have pulled in the initial claim using the form <code>¬(C)</code>, you can use <code>algebra</code> to manipulate it into a different form.</p>
<h3 id="each-branch-reaches-a-different-conclusion">Each branch reaches a different conclusion</h3>
<p>If the if-branch reaches conclusion <code>Q1</code> and the else branch reaches conclusion <code>Q2</code>, then afterwards we can list as a premise that one of those conclusions is true (since we know that one of the branches in an if/else will ALWAYS execute):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q1           (some justification)    //conclusion in if-branch
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q2           (some justification)    //conclusion in else-branch
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. Q1 ∨ Q2          premise     //Q1 from if, Q2 from else
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Note that order matters, and that we must claim <code>(if conclusion) ∨ (else conclusion)</code> &ndash; in the example above, we could not claim <code>Q2 ∨ Q1</code> afterwards.</p>
<h3 id="each-branch-reaches-the-same-conclusion">Each branch reaches the same conclusion</h3>
<p>If the if-branch and the else-branch both reach the SAME conclusion <code>Q</code>, then afterwards we can list <code>Q</code> as a premise. Here, we know that one of the branches in an if/else will ALWAYS execute &ndash; so if we get to the same conclusion in both cases, then we must always reach that conclusion:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q            (some justification)    //common conclusion reached in IF
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q            (some justification)    //common conclusion reached in ELSE
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. Q                premise     //Q was true in both the IF and the ELSE
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><h2 id="example-programs-with-no-else">Example: programs with no &ldquo;else&rdquo;</h2>
<p>Suppose we have an if-statement with no &ldquo;else&rdquo;. Afterwards, we know that either the if-branch was executed (which happens when the condition is true), or that the condition was false. If we reach some conclusion <code>Q</code> in the if-branch, then afterwards we know that either <code>Q</code> is true or that the if-statemention condition is not true. Similarly, if some claim <code>old</code> was true before an if-statement without an else, then afterwards we know that we either reached <code>Q</code> in the if-branch or that our <code>old</code> statement is still true.</p>
<p>We can pull in these claims as premises after an if-statement as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. old              (some justification)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (C) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        1. Q            (some justification)    //conclusion in if-branch
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. Q ∨ ¬(C)          premise    //either we reached Q in the if, or the condition was false
</span></span><span style="display:flex;"><span>    2. Q ∨ old           premise    //either we reached Q in the if, or &#34;old&#34; is still true
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>For example, suppose we have a program that finds the absolute value of an input number:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt()
</span></span><span style="display:flex;"><span>var orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &lt; 0) {
</span></span><span style="display:flex;"><span>    num = num * -1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//num is now the absolute value of the original input
</span></span></code></pre></div><p>Afterwards, we want to assert that <code>num</code> is the absolute value of the original input &ndash; that <code>num</code> is nonnegative and either equals <code>orig</code> (the original input) or <code>-1*orig</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(num &gt;= 0 &amp; (num == -1*orig | num == orig))
</span></span></code></pre></div><p>We start our verification as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt()
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. orig == num                  premise         //from &#34;orig = num&#34; assignment
</span></span><span style="display:flex;"><span>    2. num == orig                  algebra 1       //switch order to match assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &lt; 0) {
</span></span><span style="display:flex;"><span>    num = num * -1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. num_old &lt; 0              premise         //if condition (num just changed)
</span></span><span style="display:flex;"><span>        2. num == num_old * -1      premise         //from &#34;num = num * -1&#34; assignment
</span></span><span style="display:flex;"><span>        3. orig == num_old          premise         //orig did equal num (num just changed)
</span></span><span style="display:flex;"><span>        4. num &gt;= 0                 algebra 1 2     //a negative number times -1 is nonnegative
</span></span><span style="display:flex;"><span>        5. num == -1*orig           algebra 2 3     //needed for last part of assert
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num &gt;= 0 ∨ ¬(num &lt; 0)            premise         //conclusion from if OR !(condition)
</span></span><span style="display:flex;"><span>    2. num == -1*orig ∨ num == orig     premise         //conclusion from if OR num still equals orig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //incomplete    
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//num is now nonnegative
</span></span><span style="display:flex;"><span>assert(num &gt;= 0 &amp; (num == orig | num == -1*orig))
</span></span></code></pre></div><p>In our final logic block, we need to reach the claim <code>num &gt;= 0</code> so we can combine it with <code>num == -1*orig ∨ num == orig</code> to match our assert. We can do this with OR elimination on <code>num &gt;= 0 ∨ ¬(num &lt; 0)</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = readInt()
</span></span><span style="display:flex;"><span>val orig: Z = num
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. orig == num                  premise         //from &#34;orig = num&#34; assignment
</span></span><span style="display:flex;"><span>    2. num == orig                  algebra 1       //switch order to match assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>if (num &lt; 0) {
</span></span><span style="display:flex;"><span>    num = num * -1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. num_old &lt; 0              premise         //if condition (num just changed)
</span></span><span style="display:flex;"><span>        2. num == num_old * -1      premise         //from &#34;num = num * -1&#34; assignment
</span></span><span style="display:flex;"><span>        3. orig == num_old          premise         //orig did equal num (num just changed)
</span></span><span style="display:flex;"><span>        4. num &gt;= 0                 algebra 1 2     //a negative number times -1 is nonnegative
</span></span><span style="display:flex;"><span>        5. num == -1*orig           algebra 2 3     //needed for last part of assert
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num &gt;= 0 ∨ ¬(num &lt; 0)            premise     //conclusion from if OR !(condition)
</span></span><span style="display:flex;"><span>    2. num == -1*orig ∨ num == orig     premise     //conclusion from if OR num still equals orig
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. num &gt;= 0                     assume
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    5. {
</span></span><span style="display:flex;"><span>        6. ¬(num &lt; 0)                   assume
</span></span><span style="display:flex;"><span>        7. num &gt;= 0                     algebra 6
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. num &gt;= 0                         ∨e 1 3 5
</span></span><span style="display:flex;"><span>    9. num &gt;= 0 ∧ (num == -1*orig ∨ num == orig)    ∧i 8 2  //match assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//num is now nonnegative
</span></span><span style="display:flex;"><span>assert(num &gt;= 0 &amp; (num == -1*orig | num == orig))
</span></span></code></pre></div><h2 id="nested-conditionals">Nested conditionals</h2>
<p>We employ the same rules when analyzing programs with nested conditional statements. If we reach a common conclusion in both the if and else branches of an inner if/else statement, for example, then we can claim the common conclusion as a premise after that inner if/else statement (but still inside the outer if/else). The outline below summarizes what we can claim at various places in nested if/else statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>if (C1) {
</span></span><span style="display:flex;"><span>    if (C2) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. C1       premise     //outer if condition is true
</span></span><span style="display:flex;"><span>            2. C2       premise     //inner if condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q1       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. C1       premise     //outer if condition is true
</span></span><span style="display:flex;"><span>            2. ¬(C2)    premise     //inner if condition is false
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q2       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. common       premise     //common conclusion in inner if/else
</span></span><span style="display:flex;"><span>        2. Q1 ∨ Q2      premise     //Q1 from inner if, Q2 from inner else
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>} else {
</span></span><span style="display:flex;"><span>    if (C3) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. ¬(C1)    premise     //outer if condition is false
</span></span><span style="display:flex;"><span>            2. C3       premise     //inner if condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q3       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. ¬(C1)    premise     //outer if condition is false
</span></span><span style="display:flex;"><span>            2. ¬(C3)    premise     //inner if condition is false
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. common   (some justification)
</span></span><span style="display:flex;"><span>            2. Q4       (some justification)
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. common       premise     //common conclusion in inner if/else
</span></span><span style="display:flex;"><span>        2. Q3 ∨ Q4      premise     //Q1 from inner if, Q2 from inner else
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. common                   premise     //&#34;common&#34; was true in both the outer IF and the outer ELSE 
</span></span><span style="display:flex;"><span>    2. (Q1 ∨ Q2) ∨ (Q3 ∨ Q4)    premise     //(Q1 ∨ Q2) from outer if, (Q3 ∨ Q4) from else
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-9">Chapter 9</h3>
<h1 id="programming-logic-functions-and-loops">Programming Logic: Functions and Loops</h1>
<p>In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Functions</h1>
    
    
<p>A <em>function</em> in Logika is analogous to a method in Java or C# &ndash; it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def functionName(paramList): returnType = {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We will use the keyword <code>Unit</code> (like <code>void</code> in other languages) for a function that does not return a value. If a function has a non-<code>Unit</code> return type, then all paths through the function must end in a return statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>return expression
</span></span></code></pre></div><p>Where <code>expression</code> is a variable, literal, or expression matching <code>returnType</code>.</p>
<h2 id="function-contracts">Function contracts</h2>
<p>In order to prove the correctness of a function, it must include a <em>function contract</em> just inside the function header. This function contract specifies what we need to know to use the function correctly. While we will use these specifications to help us prove correctness, they are good to include in ANY library function that will be used by someone else (even more informally in other languages). <em>The person/program who calls the function is not supposed to read the function&rsquo;s code to know how to use the function</em>. A function contract shows them what parameters to pass (including what range of values are acceptable), what the function will return in terms of the parameter, and whether/how the function will modify things like sequences (arrays/lists in other languages) or global variables.</p>
<p>Here is the syntax for a function contract in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    requires (preconditions)
</span></span><span style="display:flex;"><span>    modifies (variable list)
</span></span><span style="display:flex;"><span>    ensures (postconditions)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Here is a summary of the different function contract clauses:</p>
<ul>
<li><code>requires</code>: lists the <em>preconditions</em> for the function. We can also use the keyword <code>pre</code> instead of <code>requires</code>. If there are no preconditions, we can skip this clause. If we have multiple preconditions, we can list them on separate lines (where subsequent lines are tabbed over under <code>requires</code>).</li>
<li><code>modifies</code>: lists the name of any sequence parameters and/or global variables that are modified by the function. We can skip this clause until chapter 10, when we will see sequences and global variables.</li>
<li><code>ensures</code>: lists the <em>postconditions</em> for the function. We can also use the keyword <code>post</code> instead of <code>ensures</code>. If we have multiple postconditions, we can list them on separate lines (where subsequent lines are tabbed over under <code>ensures</code>).</li>
</ul>
<h3 id="preconditions">Preconditions</h3>
<p>The <em>preconditions</em> for a function are requirements the function has in order to operate correctly. Generally, preconditions constrain the values of the parameters and/or global variables. For example, this function returns the integer division between two parameters. The function can only operate correctly when the denominator (the second parameter, <code>b</code>) is non-zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Logika will throw an error if any preconditions are not proven before calling a function. Because we are required to prove the preconditions before any function call, the function itself can list the preconditions as premises in a logic block just after the function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def example(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires precondition1
</span></span><span style="display:flex;"><span>            precondition2
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we can list the preconditions as premises
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. precondition1            premise
</span></span><span style="display:flex;"><span>        2. precondition2            premise
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="postconditions">Postconditions</h3>
<p>The <em>postconditions</em> of a function state what the function has accomplished when it terminates. In particular, postconditions should include:</p>
<ul>
<li>
<p>A formalization of what the function promises to return in terms of the parameters/global variables. We can use the keyword <code>result</code> to refer to the object returned by the function (we will only use this keyword in the function contract).</p>
</li>
<li>
<p>A description of how any global variables and/or sequence parameters will be modified by the function (we will not use global variables or sequences until chapter 10).</p>
</li>
</ul>
<p>For example, the <code>div</code> function above should promise to return the integer division of its two parameters, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to prove a postcondition involving the return value, we must have logic blocks just before returning that demonstrate each postcondition claim, using the variable name being returned instead of the <code>result</code> keyword. In the example above, since we are returning a variable named <code>ans</code>, then we must prove the claim <code>ans == a/b</code> in order to satisfy the postcondition. We can complete the verification of the <code>div</code> function as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. b != 0               premise     //precondition (needed for division)
</span></span><span style="display:flex;"><span>        2. ans == a/b           premise     //satisifies the postcondition
</span></span><span style="display:flex;"><span>                                            //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Logika will throw an error if postconditions are not proven before leaving a function. Because we are required to prove the postconditions before the function ends, any calling code can list those postconditions as premises after calling the function. We will see this in more detail in the next section.</p>
<h2 id="work-of-the-calling-code">Work of the calling code</h2>
<p>We saw above that when writing code that calls a function, we must PROVE the preconditions before the function call (since the function requires that we meet those preconditions in order to work correctly). After the function terminates, the calling code can list the function&rsquo;s postconditions as PREMISES (since the function ensured that certain things would happen).</p>
<p>Below, we will see the syntax for the verification of code that calls a function. We will refer to our finished <code>div</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. b != 0               premise     //precondition (needed for division)
</span></span><span style="display:flex;"><span>        2. ans == a/b           premise     //satisifies the postcondition
</span></span><span style="display:flex;"><span>                                            //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The &ldquo;calling code&rdquo; in Logika goes outside of any function definition. Typically, I place the calling code at the bottom of the Logika file, after all functions. Recall that this is the code executed first by Logika, just like in Python programs.</p>
<h3 id="proving-preconditions">Proving preconditions</h3>
<p>Suppose we wish to call the <code>div</code> function to divide two numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x, y)
</span></span></code></pre></div><p>If we included that calling code in a Logika file with our <code>div</code> function, we would see an error that we had not yet proved the precondition. To prove each precondition, we must have a logic block just before the function call that demonstrate each precondition claim, using value being passed instead of the parameter name. Since we are passing the value <code>y</code> as our second parameter, and since the <code>div</code> function requires that <code>b != 0</code> (where <code>b</code> is the second parameter), then we must demonstrate that <code>y != 0</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y != 0               algebra 2   //satisifies the precondition for div
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x, y)
</span></span></code></pre></div><p>Note that Logika is picky about proving the precondition using EXACTLY the value being passed for the corresponding parameter. For example, suppose instead that we wanted to divide <code>x-1</code> and <code>y+1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y != 0               algebra 2   //NO! precondition is not satisifed!
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span></code></pre></div><p>If we made no changes to our logic block, Logika would complain that we had not satisfied the precondition. And indeed we haven&rsquo;t &ndash; while we&rsquo;ve shown that <code>y</code> isn&rsquo;t 0, we haven&rsquo;t shown that our second parameter <code>y+1</code> isn&rsquo;t 0. Here is the correction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span></code></pre></div><h3 id="using-postconditions">Using postconditions</h3>
<p>Recall that since the function is ensuring that it will do/return specific things (its postconditions), then the calling code can list those postconditions as premises after the function call. If a postcondition uses the keyword <code>result</code>, then the calling code can list exactly that postcondition using whatever variable it used to store the return value in place of <code>result</code> and using whatever values were passed in place of the parameter names. In the <code>div</code> example above where we divde <code>x-1</code> by <code>y+1</code>, the calling code stores the value returned by <code>div</code> in a variable called <code>num</code>. Since the <code>div</code> postcondition is <code>result == a/b</code>, then we can claim the premise <code>num == (x-1)/(y+1)</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == (x-1)/(y+1)   premise     //postcondition of div
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>We know from looking at this example that <code>(x-1)/(y+1)</code> is really <code>9/3</code>, which is 3. We would like to be able to assert that <code>num</code>, the value returned from <code>div</code>, equals 3. We can do this by adding a few more steps to our final logic block, plugging in the values for <code>x</code> and <code>y</code> and doing some algebra:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == (x-1)/(y+1)   premise     //postcondition of div
</span></span><span style="display:flex;"><span>    2. x == 10              premise     //x is unchanged from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    3. y == 2               premise     //y is unchanged from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    4. num == 9/3           algebra 1 2 3
</span></span><span style="display:flex;"><span>    5. num == 3             algebra 4   //needed for assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == 3)
</span></span></code></pre></div><p>Using a function contract and our deduction rules, we have PROVED that the <code>div</code> function will return 3 in our example (without needing to test the code at all).</p>
<h2 id="examples">Examples</h2>
<p>In this section, we will see two completed examples of Logika programs with a function and calling code.</p>
<h3 id="example-1">Example 1</h3>
<p>In this example, we write a <code>plusOne</code> function that takes a non-negative parameter and returns one more than that parameter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def plusOne(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //precondition: parameter should be non-negative
</span></span><span style="display:flex;"><span>        ensures result == n+1   //postcondition 1: we promise returned value is one more than parameter
</span></span><span style="display:flex;"><span>            result &gt; 0          //postcondition 2: we promise returned value is greater than 0
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val answer: Z = n+1
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. n &gt;= 0               premise     //from the precondition
</span></span><span style="display:flex;"><span>        2. answer == n+1        premise     //from the &#34;answer = n+1&#34; assignment
</span></span><span style="display:flex;"><span>                                            //proves the first postcondition
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. answer &gt; 0           algebra 1 2 //proves the second postcondition
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return answer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////// Test code ///////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 5                   premise     //from the &#34;x=5&#34; assignment
</span></span><span style="display:flex;"><span>    2. x &gt;= 0                   algebra 1   //proves the plusOne precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var added: Z = plusOne(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //I can list the postcondition (what is returned) as a premise
</span></span><span style="display:flex;"><span>    1. x == 5                   premise     //x is unchanged 
</span></span><span style="display:flex;"><span>    2. added == x+1             premise     //plusOne postcondition 1
</span></span><span style="display:flex;"><span>    3. added &gt; 0                premise     //plusOne postcondition 2
</span></span><span style="display:flex;"><span>    4. added == 6               algebra 1 2
</span></span><span style="display:flex;"><span>    5. added == 6 
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(added == 6 ∧ added &gt; 0)
</span></span></code></pre></div><p>Note that when we have more than one postcondition, we must prove all postconditions inside the function, and we can list all postconditions as premises in the calling code after the function call.</p>
<h3 id="example-2">Example 2</h3>
<p>In this example, we write a <code>findMax</code> function that returns the biggest between two integer parameters. This is very similar to an example from section 8.7, which used an if/else statement to find the max. In that example, our assert that we had indeed found the max was: <code>assert((max &gt;= x &amp; max &gt;= y) &amp; (max == x | max == y))</code>. We will see that our postconditions for <code>findMax</code> come directly from the different claims in that assert. In our calling code, we call <code>findMax</code> with <code>num1</code> (which has the value 3) and <code>num2</code> (which has the value 2). We are able to prove that <code>findMax</code> returns 2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//find the max between x and y
</span></span><span style="display:flex;"><span>def findMax(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //no precondition needed
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            result &gt;= x                 //postcondition 1
</span></span><span style="display:flex;"><span>            result &gt;= y                 //postcondition 2
</span></span><span style="display:flex;"><span>            result == x v result == y   //postcondition 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var max: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == 0             premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (x &gt; y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == 0         premise
</span></span><span style="display:flex;"><span>            2. x &gt; y            premise     //IF condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == x         premise
</span></span><span style="display:flex;"><span>            2. max &gt;= x         algebra 1
</span></span><span style="display:flex;"><span>            3. x &gt; y            premise
</span></span><span style="display:flex;"><span>            4. max &gt;= y         algebra 1 3
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == 0         premise
</span></span><span style="display:flex;"><span>            2. ¬(x &gt; y)         premise     //IF condition is not true
</span></span><span style="display:flex;"><span>            3. x &lt;= y           algebra 2
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        max = y
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == y         premise
</span></span><span style="display:flex;"><span>            2. x &lt;= y           premise
</span></span><span style="display:flex;"><span>            3. max &gt;= x         algebra 1 2
</span></span><span style="display:flex;"><span>            4. max &gt;= y         algebra 1
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the postconditions
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //true in both the if and the else
</span></span><span style="display:flex;"><span>        1. max &gt;= x                 premise     //proves postcondition 1 
</span></span><span style="display:flex;"><span>        2. max &gt;= y                 premise     //proves postcondition 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //first was true in if, second true in else
</span></span><span style="display:flex;"><span>        3. max == x v max == y      premise     //proves postcondition 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return max
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Test code /////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num1: Z = 3
</span></span><span style="display:flex;"><span>val num2: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//findMax has no preconditions, so nothing to prove here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val biggest: Z = findMax(num1, num2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. biggest &gt;= num1                      premise     //findMax postcondition 1
</span></span><span style="display:flex;"><span>    2. biggest &gt;= num2                      premise     //findMax postcondition 2
</span></span><span style="display:flex;"><span>    3. biggest == num1 v biggest == num2    premise     //findMax postcondition 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in the initial values
</span></span><span style="display:flex;"><span>    4. num1 == 3                            premise
</span></span><span style="display:flex;"><span>    5. num2 == 2                            premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    6. biggest &gt;= 3                         algebra 1 4
</span></span><span style="display:flex;"><span>    7. biggest &gt;= 2                         algebra 2 5
</span></span><span style="display:flex;"><span>    8. biggest == 3 v biggest == num2       subst1 4 3
</span></span><span style="display:flex;"><span>    9. biggest == 3 v biggest == 2          subst1 5 8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //OR-elimination
</span></span><span style="display:flex;"><span>    10. {
</span></span><span style="display:flex;"><span>        11. biggest == 3                    assume
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    12. {
</span></span><span style="display:flex;"><span>        13. biggest == 2                    assume
</span></span><span style="display:flex;"><span>        14. ¬(biggest &gt;= 3)                 algebra 6 13
</span></span><span style="display:flex;"><span>        15. ⊥                               ¬e 6 14
</span></span><span style="display:flex;"><span>        16. biggest == 3                    ⊥e 15
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    17. biggest == 3                        ve 9 10 12  //needed for assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(biggest == 3)
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Recursion</h1>
    
    
<p>In this section, we will see how to prove the correctness of programs that use recursive functions. We will see that verifying a recursive function is exactly the same as verifying a non-recursive function:</p>
<ul>
<li>We must prove a function&rsquo;s preconditions before calling it (including before making a recursive call)</li>
<li>After calling a function, we can list the function&rsquo;s postconditions as premises (including after making a recursive call)</li>
<li>The function can list its preconditions as premises</li>
<li>The function must prove its postconditions just before it ends</li>
</ul>
<h2 id="writing-a-recursive-mult-function">Writing a recursive mult function</h2>
<p>We know we can multiply two numbers, <code>x</code> and <code>y</code>, using the <code>*</code> operator &ndash; <code>x * y</code>. But what if we wanted to find the same result using only addition, not multiplication? Multiplication can be thought of as repeated addition &ndash; <code>x * y</code> is really <code>x + x + ... + x</code>, where we add together <code>y</code> total <code>x</code>&rsquo;s.</p>
<p>We <em>could</em> do this repeated addition with a loop (and we will when we introduce loops in section 9.3), but we will use recursion instead. When we write a recursive function, we try to think of two things:</p>
<ul>
<li>The <em>base case</em>: the simplest version of the problem that we could immediately solve with no more work.</li>
<li>The <em>recursive case</em>: bigger versions of the problem, where we solve a piece of the problem and then recursively solve a smaller piece</li>
</ul>
<p>In the case of the multiplication <code>x * y</code>, we have:</p>
<ul>
<li>Base case: if <code>y</code> is 0, we have no work to do. Adding togther 0 <code>x</code>&rsquo;s is just 0.</li>
<li>Recursive case: if <code>y</code> is bigger than 0, we do ONE addition (<code>x + ...</code>) and recursively add the remaining <code>y - 1</code> numbers. (This will become our recursive call.)</li>
</ul>
<p>With those cases in mind, we can write a recursive <code>mult</code> functio:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that we separated the recursive call (<code>def addRest: Z = mult(x, y-1)</code>) from adding on the next piece (<code>ans = x + addRest</code>). In Logika, all function calls must go on a separate line by themselves &ndash; we can&rsquo;t combine them with other operations. Also, we included a dummy &ldquo;else&rdquo; branch to make the verification simpler.</p>
<h2 id="walking-through-mult">Walking through mult</h2>
<p>Suppose we call <code>mult</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var times: Z = mult(4, 2)
</span></span></code></pre></div><p>We can trace the recursive calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>times = mult(4, 2) 
</span></span><span style="display:flex;"><span>            (x = 4, y = 2)
</span></span><span style="display:flex;"><span>            addRest = mult(4, 1)    =&gt; mult(4, 1)
</span></span><span style="display:flex;"><span>            ans = 4 + addRest               (x = 4, y = 1)
</span></span><span style="display:flex;"><span>            returns ans                     addRest = mult(4, 0)    =&gt;  mult(4, 0)
</span></span><span style="display:flex;"><span>                                            ans = 4 + addRest               (x = 4, y = 0)
</span></span><span style="display:flex;"><span>                                            returns ans                     ans = 0
</span></span><span style="display:flex;"><span>                                                                            returns 0
</span></span></code></pre></div><p>We start with <code>mult(4, 2)</code>, and then immediately make the recursive call <code>mult(4, 1)</code>, which immediately makes the recursive call <code>mult(4, 0)</code>. That function instance hits the base case and returns 0. We now return back up the chain of function calls &ndash; the 0 gets returned back to the <code>mult(4, 1)</code> instance, which adds 4 and then returns 4:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>=&gt; mult(4, 1)
</span></span><span style="display:flex;"><span>    (x = 4, y = 1)
</span></span><span style="display:flex;"><span>    addRest = mult(4, 0) = 0
</span></span><span style="display:flex;"><span>    ans = 4 + addRest = 4 
</span></span><span style="display:flex;"><span>    returns ans (4)
</span></span></code></pre></div><p>This 4 returns back to the <code>mult(4, 2)</code> instance, which adds another 4 and returns 8:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>mult(4, 2) 
</span></span><span style="display:flex;"><span>    (x = 4, y = 2)
</span></span><span style="display:flex;"><span>    addRest = mult(4, 1) = 4
</span></span><span style="display:flex;"><span>    ans = 4 + addRest = 8
</span></span><span style="display:flex;"><span>    returns ans (8)
</span></span></code></pre></div><p>We have now backed our way up the chain &ndash; the 8 is returned back from the original function call, and <code>times</code> is set to 8.</p>
<h2 id="mult-function-contract">mult function contract</h2>
<p>Looking at our <code>mult</code> function, we see that the base case is when <code>y</code> is 0 and the recursive case is when <code>y &gt; 0</code>. Clearly, the function is not intended to work for negative values of <code>y</code>. This will be our precondition &ndash; that <code>y</code> must be greater than or equal to 0.</p>
<p>Our postcondition should describe what <code>mult</code> is returning in terms of its parameters. In this case, we know that <code>mult</code> is performing a multiplication of <code>x</code> and <code>y</code> using repeated addition. So, our function should ensure that it returns <code>x*y</code> (that <code>result == x*y</code>). Here is the function with the function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    //we still need to add the verification logic blocks
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == x*y
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="verification-in-mult">Verification in mult</h2>
<p>Now that we have our function contract for <code>mult</code>, we must add logic blocks with two things in mind:</p>
<ul>
<li>Proving the precondition before a recursive call</li>
<li>Proving the postcondition before we return from the function</li>
</ul>
<p>Our recursive call looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var addRest: Z = mult(x, y-1)
</span></span></code></pre></div><p>Since our precondition is <code>y &gt;= 0</code>, we see that we must prove that what we are passing as the second parameter (<code>y-1</code>, in the case of the recursive call) is greater than or equal to 0. This tells us that before our recursive call, we must have shown exactly: <code>y-1 &gt;= 0</code>. We can finish proving the precondition as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    //we still need to prove the postcondition
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == x*y
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. y &gt; 0                premise     //IF condition is true
</span></span><span style="display:flex;"><span>            2. y-1 &gt;= 0             algebra 1   //Proves the precondition for the recursive call
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All that remains is to prove the <code>mult</code> postcondition &ndash; that we are returning <code>x*y</code>. Since we are returning the variable <code>ans</code>, then we must prove the claim <code>ans == x*y</code> just before our return statement. In order to help with this process, we will need to take advantage of the postcondition after our recursive call. The function promises to return the first parameter times the second parameter, so when we do <code>addRest: Z = mult(x, y-1)</code>, we know that <code>addRest == x*(y-1)</code> (the first parameter, <code>x</code>, times the second parameter, <code>y-1</code>). Here is the completed verification</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    //verification complete!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == x*y
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. y &gt; 0                premise     //IF condition is true
</span></span><span style="display:flex;"><span>            2. y-1 &gt;= 0             algebra 1   //Proves the precondition for the recursive call
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. addRest == x*(y-1)   premise     //Postcondition from the recursive call
</span></span><span style="display:flex;"><span>            2. addRest == x*y - x   algebra 2
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. addRest == x*y - x   premise     //Pulled from previous block
</span></span><span style="display:flex;"><span>            2. ans == x + addRest   premise     //From the &#34;ans = x + addRest&#34; assignment statement
</span></span><span style="display:flex;"><span>            3. ans == x + x*y - x   algebra 1 2
</span></span><span style="display:flex;"><span>            4. ans == x*y           algebra 3   //Showed the postcondition for the IF branch
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing in code - but we still do verification
</span></span><span style="display:flex;"><span>        //need to show that postcondition will be correct even if we take this branch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. ¬(y &gt; 0)             premise     //if condition is false
</span></span><span style="display:flex;"><span>            2. y &gt;= 0               premise     //precondition
</span></span><span style="display:flex;"><span>            3. y == 0               algebra 1 2
</span></span><span style="display:flex;"><span>            4. ans == 0             premise     //ans is unchanged
</span></span><span style="display:flex;"><span>            5. ans == x*y           algebra 3 4 //Showed the postcondition for the ELSE branch
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Tie together what we learned in both branches
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ans == x*y               premise     //shows the postcondition      
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="verification-of-calling-code">Verification of calling code</h2>
<p>Verifying the test code that calls a recursive function works exactly the same way as it does for any other function:</p>
<ul>
<li>We must prove the precondition before calling the function</li>
<li>We can list the postcondition as a premise after calling the function</li>
</ul>
<p>Suppose we want to test <code>mult</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val times: Z = mult(4, 2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(times == 8)
</span></span></code></pre></div><p>We could complete the verification by proving the precondition and then using the postcondition to help us prove the claim in the assert:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 &gt;= 0               algebra     //proves the precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val times: Z = mult(4, 2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. times == 4*2         premise     //mult postcondition
</span></span><span style="display:flex;"><span>    2. times == 8           algebra 1   //needed for the assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(times == 8)
</span></span></code></pre></div><p>Note that since our second parameter is <code>2</code>, that we must demonstrate exactly <code>2 &gt;= 0</code> to satisfy <code>mult</code>&rsquo;s precondition. Furthermore, since <code>mult</code> promises to return the first parameter times the second parameter, and since we are storing the result of the function call in the <code>times</code> variable, then we can claim <code>times == 4*2</code> as a premise.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Loops</h1>
    
    
<p>A <em>loop</em> is a command that restarts itself over and over while its <em>loop condition</em> remains true. Loops are trickier to analyze than if/else statements, because we don&rsquo;t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations&hellip;we don&rsquo;t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.</p>
<p>The only loop available in Logika is a <em>while</em> loop, which behaves in the same way as while loops in other languages. If the loop condition is initially false, then the body of the while loop is skipped entirely. If the loop condition is initially true, then we execute the loop body and then recheck the condition. This continues until the loop condition becomes false.</p>
<p>Here is the syntax of a Logika while loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (condition) {
</span></span><span style="display:flex;"><span>   //body of loop
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="loop-invariants">Loop invariants</h2>
<p>Our solution to analyzing loops despite not knowing the number of iterations is a tool called a <em>loop invariant</em>. The job of the loop invariant is to summarize what is always true about the loop. Often, the loop invariant describes the relationship between variables and demonstrates how much progress the loop has made. Sometimes the loop invariant also contains claims that certain variables will always stay in a particular range.</p>
<p>Whatever we choose as the loop invariant, we must be able to do the following:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li>
</ul>
<h2 id="loop-invariants-and-mathematical-induction">Loop invariants and mathematical induction</h2>
<p>The process of proving the correctness of loop invariants is very similar to a mathematical induction proof. We must prove the loop invariant is true before the loop begins, which is analogous to the <em>base case</em> in mathematical induction. The process of assuming the invariant is true at the beginning of an iteration and proving that it is still true at the end of an iteration is just like mathematical induction&rsquo;s <em>inductive step</em>.</p>
<p>If we prove those two things about our invariant, we can be certain the invariant will still hold after the loop terminates. Why? For the same reason mathematical induction proves a property for a general 
<span class="math align-center">$n$</span>:</p>
<ul>
<li>We know the invariant holds before the loop begins</li>
<li>Because the invariant holds before the loop begins, we are sure it holds at the beginning of the first iteration</li>
<li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the first iteration</li>
<li>Because we&rsquo;re sure it still holds at the end of the first iteration, we know it holds at the beginning of the second iteration</li>
<li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the second iteration
&hellip;</li>
<li>We&rsquo;re sure the invariant still holds at the end of each iteration, including the end of the LAST iteration. Thus we&rsquo;re certain the invariant holds just after the loop ends.</li>
</ul>
<h2 id="loop-invariant-block-syntax">Loop invariant block syntax</h2>
<p>In Logika, we will use a logic block to indiciate our loop invariant. This <em>loop invariant block</em> will go just inside the loop, before the loop body:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (condition) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant (expression(s))
</span></span><span style="display:flex;"><span>        modifies (variable list)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //loop body
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here is a summary of the different loop invariant clauses:</p>
<ul>
<li><code>invariant</code>: lists the invariant for the function. If we have multiple invariants, we can list them on separate lines (where subsequent lines are tabbed over under <code>invariant</code>).</li>
<li><code>modifies</code>: lists the name of any variables that are modified in the loop body.</li>
</ul>
<h2 id="example-loop-invariant-block-for-a-multiplication-loop">Example: loop invariant block for a multiplication loop</h2>
<p>Suppose we have the following loop to multiply two numbers, <code>x</code> and <code>y</code>, using repeated addition. (This is very similar to our <code>mult</code> function from section 9.2, except it does the additions using a loop instead of using recursion):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><p>Before writing the loop invariant block, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>After iteration 3</th>
<th>&hellip;</th>
<th>After iteration y</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>y</td>
</tr>
<tr>
<td><code>sum</code></td>
<td>
<span class="math align-center">$0 (= 0*x)$</span></td>
<td>
<span class="math align-center">$x (= 1*x)$</span></td>
<td>
<span class="math align-center">$x + x (= 2*x)$</span></td>
<td>
<span class="math align-center">$x + x + x (= 3*x)$</span></td>
<td>&hellip;</td>
<td>
<span class="math align-center">$x + x + ... + x (= y*x)$</span></td>
</tr>
</tbody>
</table>
<p>Before the loop begins, we&rsquo;ve added 0 
<span class="math align-center">$x$</span>&rsquo;s together, so the sum is 0. After the first iteration, we&rsquo;ve added 1 
<span class="math align-center">$x$</span> together, so the sum is 
<span class="math align-center">$x$</span>. After the second iteration, we&rsquo;ve added 2 
<span class="math align-center">$x$</span>&rsquo;s together, so the sum is 
<span class="math align-center">$x + x$</span> which is really 
<span class="math align-center">$2 * x$</span>. This continues until after the y-th iteration, when we&rsquo;ve added y 
<span class="math align-center">$x$</span>&rsquo;s together (and the sum is 
<span class="math align-center">$y*x$</span>).</p>
<p>Using this table, it is easy to see that at any point, <code>sum == count*x</code> (since <code>count</code> tracks the number of iterations). This is true both before the loop begins and at the end of each iteration, so it will be our loop invariant.</p>
<p>We now add a loop invariant block to our loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    //loop invariant block (still needs to be proved)
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><p>We list <code>sum</code> and <code>count</code> in the <code>modifies</code> clause because those are the two variables that change value inside the loop.</p>
<h2 id="proving-the-loop-invariant">Proving the loop invariant</h2>
<p>In order to prove the correctness of a loop, we must do two things:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li>
</ul>
<h3 id="proving-loop-invariant-before-loop-begins">Proving loop invariant before loop begins</h3>
<p>In our multiplication loop above, let&rsquo;s start by proving the loop invariant before the loop begins. This means that just before the loop, we must prove exactly the claim <code>sum == count*x</code>. We can do this with algebra on the current variable values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>    2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>    3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we still need to prove the invariant after each iteration
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><h3 id="proving-loop-invariant-at-the-end-of-each-iteration">Proving loop invariant at the end of each iteration</h3>
<p>To prove the loop invariant still holds at the end of an iteration, we must have a logic block at the end of the loop body with exactly the claim in the loop invariant (which will now be referring to the updated values of each variable). Since this step has us assuming the loop invariant is true at the beginning of each iteration, we can list the loop invariant as a <em>premise</em> in a logic block just inside the loop body. Here is the structure we wish to follow for our multiplication loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == count*x           premise     //the loop invariant holds
</span></span><span style="display:flex;"><span>                                                //at the beginning of an iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //need to prove exactly &#34;sum == count*x&#34;
</span></span><span style="display:flex;"><span>    //to prove our invariant still holds at the end of an iteration
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can complete the loop invariant proof by using our tools for processing assignment statements with mutations. Here is the completed verification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>    2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>    3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                //at the beginning of an iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>        2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>        3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>        2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                    //but count has changed
</span></span><span style="display:flex;"><span>        3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>        4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>        5. sum == count*x               algebra 4   //loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><h3 id="knowledge-after-loop-ends">Knowledge after loop ends</h3>
<p>In the example above, suppose we add the following assert after the loop ends:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(sum == x*y)
</span></span></code></pre></div><p>This seems like a reasonable claim &ndash; after all, we said that our loop was supposed to calculated <code>x * y</code> using repeated addition. We have proved the loop invariant, so we can be sure that <code>sum == count*x</code> after the loop&hellip;but that&rsquo;s not quite the same thing. Does <code>count</code> equal <code>y</code>? How do we know?</p>
<p>We can prove our assert statement by considering one more piece of information &ndash; if we have exited the loop, we know that the loop condition must be false. In fact, you always know two things (which you can claim as premises) after the loop ends:</p>
<ol>
<li>The loop condition is false (so we can claim <code>¬(condition)</code>)</li>
<li>The loop invariant is true, since we proved is true at the end of each iteration</li>
</ol>
<p>We can use those pieces of information to prove our assert statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//the multiplication loop example goes here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == count*x           premise     //the loop invariant holds
</span></span><span style="display:flex;"><span>    2. ¬(count != y)            premise     //the loop condition is not true
</span></span><span style="display:flex;"><span>    3. count == y               algebra 2
</span></span><span style="display:flex;"><span>    4. sum == x*y               algebra 1 3 //proves our assert statement
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(sum == x*y)
</span></span></code></pre></div><h2 id="functions-with-loops">Functions with loops</h2>
<p>If we have a function that includes a loop, we must do the following:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Given that the loop invariant is true at the beginning of an iteration, prove that it is still true at the end of the iteration</li>
<li>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition</li>
</ul>
<p>For example, suppose our loop multiplication is inside a function which is tested by some calling code. We would like to add a function contract, our loop invariant proof, and necessary logic blocks to show that our assert holds at the end of the calling code. Here is just the code for the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>We start by adding a function contract to <code>mult</code>, which will be the same as our function contract for the recursive version of this function in section 9.2 &ndash; <code>y</code> needs to be nonnegative, and we promise to return <code>x*y</code>. Here is the code after adding the function contract and our previous loop verificaton:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>        2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>        3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                    //at the beginning of an iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>            3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                        //but count has changed
</span></span><span style="display:flex;"><span>            3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>            4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>            5. sum == count*x               algebra 4   //loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //STILL NEED TO PROVE POSTCONDITION
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//STILL NEED TO ADD VERIFICATION FOR ASSERT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>We can use the negation of the loop condition (<code>¬(count != y)</code>) together with the loop invariant to prove the postcondition will hold before the function returns. We can also apply the same process as in sections 9.1 and 9.2 to prove the precondition in the calling code before calling the <code>mult</code> function, and to use the function&rsquo;s postcondition after the call to <code>mult</code> to prove our goal assert. Here is the completed example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>        2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>        3. sum == count*x       algebra 1 2 //proves EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                    //at the beginning of an iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>            3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                        //but count has changed
</span></span><span style="display:flex;"><span>            3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>            4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>            5. sum == count*x               algebra 4   //proves loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ¬(count != y)                    premise     //loop condition is now false
</span></span><span style="display:flex;"><span>        2. sum == count*x                   premise     //loop invariant holds after loop
</span></span><span style="display:flex;"><span>        3. count == y                       algebra 1
</span></span><span style="display:flex;"><span>        4. sum == x*y                       algebra 2 3 //proves the postcondition
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. two == 4             premise     //from the &#34;two = 4&#34; assignment
</span></span><span style="display:flex;"><span>    2. two &gt;= 0             algebra 1   //proves the mult precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. one == 3             premise
</span></span><span style="display:flex;"><span>    2. two == 4             premise
</span></span><span style="display:flex;"><span>    3. answer == one*two    premise         //from the mult postcondition
</span></span><span style="display:flex;"><span>    4. answer == 12         algebra 1 2 3   //proves the assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><h2 id="how-to-construct-a-loop-invariant">How to construct a loop invariant</h2>
<p>The most difficult part of the entire process of proving the correctness of a function with a loop is coming up with an appropriate loop invariant. In this section, we will look study two additional loops and learn techniques for deriving loop invariants. In general, we need to think about what the loop is doing as it iterates, and what progress it has made so far towards its goal. A good first approach is to trace through the values of variables for several iterations of the loop, as we did with <code>mult</code> above &ndash; this helps us identify patterns that can then become the loop invariant.</p>
<h3 id="example-1-sum-of-odds">Example 1: Sum of odds</h3>
<p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It might be difficult to tell what this code is doing before walking through a few iterations. Let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>After iteration 3</th>
<th>&hellip;</th>
<th>After iteration n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>n</td>
</tr>
<tr>
<td><code>total</code></td>
<td>
<span class="math align-center">$0 $</span></td>
<td>
<span class="math align-center">$1 $</span></td>
<td>
<span class="math align-center">$1 + 3 (= 4)$</span></td>
<td>
<span class="math align-center">$1 + 3 + 5 (= 9)$</span></td>
<td>&hellip;</td>
<td>
<span class="math align-center">$1 + 3 + 5 + ... + (2*n-1) (=n^2)$</span></td>
</tr>
</tbody>
</table>
<p>Now we can see the pattern &ndash; we are adding up the first 
<span class="math align-center">$n$</span> odd numbers. We can see that at the end of the i-th iteration we have added the first 
<span class="math align-center">$i$</span> odd numbers, where 
<span class="math align-center">$(2*i-1)$</span> is our most recent odd number. We also see that the sum of the first 1 odd number is 1, the sum of the first 2 odd numbers is 
<span class="math align-center">$2^2 = 4$</span>, &hellip;, and the sum of the first 
<span class="math align-center">$n$</span> odd numbers is 
<span class="math align-center">$n^2$</span>.</p>
<p>Since our loop invariant should describe what progress it has made towards its goal of adding the first 
<span class="math align-center">$n$</span> odd numbers, we can see that the loop invariant should be that at any point (before the loop begins and at the end each iteration), 
<span class="math align-center">$total$</span> holds the sum of the first 
<span class="math align-center">$i$</span> numbers (whose value is 
<span class="math align-center">$i^2$</span>). We first try this as our loop invariant:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant total == i*i
</span></span><span style="display:flex;"><span>        modifies i, n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Another consideration of writing a loop invariant is that we should be able to deduce our overall goal once the loop ends. After our loop, we want to be sure that <code>total</code> holds the sum of the first <code>n</code> odd numbers &ndash; i.e., that <code>total == n*n</code>. Our loop invariant tells us that <code>total == i*i</code> after the loop ends &ndash; but does <code>n</code> necessarily equal <code>i</code>?</p>
<p>The way it is written, we can&rsquo;t be certain. We do know that the loop condition must be false after the loop, or that <code>¬(i &lt; n)</code>. But this is equivalent to <code>i &gt;= n</code> and not <code>i == n</code>. We need to tighten our invariant to add a restriction that <code>i</code> always be less than or equal to n:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant total == i*i
</span></span><span style="display:flex;"><span>            i &lt;= n
</span></span><span style="display:flex;"><span>        modifies i, n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After the loop ends, we can now combine the negation of the loop condition, <code>¬(i &lt; n)</code> together with the <code>i &lt;= n</code> portion of the invariant to deduce that <code>i == n</code>. Together with the other half of the invariant &ndash; <code>total == i*i</code> &ndash; we can be sure that <code>total == n*n</code> when the loop ends.</p>
<h3 id="example-2-factorial">Example 2: factorial</h3>
<p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var prod: Z = 1
</span></span><span style="display:flex;"><span>var i: Z = 1
</span></span><span style="display:flex;"><span>while (i != n) {
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    prod = prod * i
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>&hellip;</th>
<th>After iteration n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>n</td>
</tr>
<tr>
<td><code>prod</code></td>
<td>
<span class="math align-center">$1 $</span></td>
<td>
<span class="math align-center">$1 * 2$</span></td>
<td>
<span class="math align-center">$1 * 2 * 3$</span></td>
<td>&hellip;</td>
<td>
<span class="math align-center">$1 * 2 * 3 * ... * n$</span></td>
</tr>
</tbody>
</table>
<p>From this table, we can clearly see that after 
<span class="math align-center">$i$</span> iterations, 
<span class="math align-center">$prod == i!$</span> (i factorial). This <em>should</em> be our loop invariant&hellip;but as with many other languages, Logika does not recognize <code>!</code> as a factorial operator (instead, it is a negation operator). In the next section, we will see how to create a <em>Logika fact</em> to help define the factorial operation. We will then be able to use that Logika fact in place of <code>!</code> to let our invariant be a formalization of: <em>prod equals i factorial</em>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Logika Facts</h1>
    
    
<p>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that 
<span class="math align-center">$n! = n * (n-1) * (n-2) * ... * 2 * 1$</span>, but we don&rsquo;t have a way to describe the &ldquo;&hellip;&rdquo; portion using our current tools.</p>
<p>In this section, we introduce <em>Logika facts</em>, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a &ldquo;&hellip;&rdquo; to demonstrate a pattern.</p>
<h2 id="logika-fact-syntax">Logika fact syntax</h2>
<p>Logika allows these proof functions to be written in multiple ways, but we will start with the most straightforward of these options:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def proofFunctionName(paramList) : returnType
</span></span><span style="display:flex;"><span>            factName1. //describe when proofFunctionName has its first possible value
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>            factNameN. //describe when proofFunctionName has its last possible value
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>In the proof function definition, <em>proofFunctionName</em> is the name we give our proof function, <em>paramList</em> is the list of parameter names and types needed for this proof function (which are formatted exactly like a parameter list in a regular Logika function), and <em>returnType</em> is the return type of the proof function (usually either <code>Z</code> for integer or <code>B</code> for boolean).</p>
<p>Below the proof function definition, we include a line for each possible way to calculate its value. Usually, at least one of the lines includes a recursive defintion &ndash; relating the value of something like <code>proofFunctionName(n)</code> to the proof function&rsquo;s definition for a smaller value, like <code>proofFunctionName(n-1)</code>. The label, such as <code>factNameN</code>, names the proof rule. We will be able to pull in a particular line of the definition into a logic block by using the justification <code>fact factNameN</code>.</p>
<p>Logika facts are defined at the top of the Logika file, below the <code>import</code> but before any of the code.</p>
<h2 id="example-logika-fact-to-define-factorial">Example: Logika fact to define factorial</h2>
<p>It is much easier to see how Logika facts work by using an example. Suppose we want to define the factorial operation. The first step is to come up with a <em>recursive definition</em>, which has us defining the operation the same way we would in a recursive function &ndash; with one or more <em>base cases</em> where we can define the operation for the simplest case, and one or more <em>recursive cases</em> that express a general instance of the problem in terms of a smaller instance.</p>
<p>For factorial, the simplest version is 
<span class="math align-center">$1!$</span>, which is just 1. In the general case, we have that:</p>

<span class="math align-center">$$
n! = n * (n-1) * (n-2) * ... * 2 * 1 = n * (n-1)!
$$</span><br>
<p>So we can write the following recursive definition:</p>
<ul>
<li>Base case: 
<span class="math align-center">$1! = 1$</span></li>
<li>Recursive case: for values of 
<span class="math align-center">$n$</span> greater than 1, 
<span class="math align-center">$n! = n * (n-1)!$</span></li>
</ul>
<p>And we can then translate the recursive definition to a Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Let&rsquo;s consider each portion of this proof function. Here, <code>factDef</code> is the name given to the proof function. It takes one parameter, <code>n</code>, which is an integer, and it returns an integer. We have two possible ways of calculating the value for the proof function. First, we define <code>fOne</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fOne. factDef(1) == 1
</span></span></code></pre></div><p><code>fOne</code> defines <code>factDef(1)</code> as 1; i.e., <code>factDef(n)</code> is 1 if $n == 1$. This is the same as our base case in our recursive definition for factorial &ndash; 
<span class="math align-center">$1! = 1$</span>.</p>
<p>Next, consider the definition for <code>fBig</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span></code></pre></div><p><code>fBig</code> states that for all integers <code>x</code> that are bigger than 1, we define <code>factDef(x) == x * factDef(x - 1)</code>. This is the same as our recursive case in our recursive definition for factorial &ndash; for values of 
<span class="math align-center">$n$</span> greater than 1, 
<span class="math align-center">$n! = n * (n-1)!$</span>.</p>
<h2 id="evaluating-a-logika-fact">Evaluating a Logika fact</h2>
<p>Suppose we used our <code>factDef</code> proof function to calculate <code>factDef(3)</code>. We would have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(3) == 3 * factDef(2)        //we use fBig, since 3 &gt; 1
</span></span><span style="display:flex;"><span>factDef(2) == 2 * factDef(1)        //we use fBig, since 2 &gt; 1
</span></span><span style="display:flex;"><span>factDef(1) == 1                     //we use fOne       
</span></span></code></pre></div><p>Once we work down to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(1) == 1
</span></span></code></pre></div><p>We can plug <code>1</code> in for <code>factDef(1)</code> in <code>factDef(2) == 2 * factDef(1)</code>, which gives us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(2) == 2
</span></span></code></pre></div><p>Similarly, we can plug <code>2</code> in for <code>factDef(2)</code> in <code>factDef(3) == 3 * factDef(2)</code>, and see that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(3) == 6
</span></span></code></pre></div><h2 id="using-logika-facts-as-justifications">Using Logika facts as justifications</h2>
<p>If we had our Logika fact, <code>factDef</code>, then we could pull its two definitions into a logic block like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. factDef(1) == 1                                  fact fOne
</span></span><span style="display:flex;"><span>    2. ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)  fact fBig
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Note that we must pull in the definitions EXACTLY as they are written in the proof function. The justification is always <code>fact</code> followed by the name of the corresponding definition.</p>
<h2 id="using-logika-facts-in-postconditions-and-invariants">Using Logika facts in postconditions and invariants</h2>
<p>Consider the following full Logika program that includes a function to find and return a factorial, as well as test code that calls our factorial function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// n! = n * (n-1) * (n-2) * .. * 1
</span></span><span style="display:flex;"><span>// 1! = 1
</span></span><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style="display:flex;"><span>    var product: Z = 1  //our current calculation
</span></span><span style="display:flex;"><span>    while (i != n) {
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>        product = product * i
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return product
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = factorial(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 2)
</span></span></code></pre></div><p>We want to add a function contract, loop invariant block, and supporting logic blocks to demonstrate that <code>factorial</code> is returning <code>n!</code> and to prove the assert in our text code.</p>
<h3 id="writing-a-function-contract-using-a-logika-fact">Writing a function contract using a Logika fact</h3>
<p>We our <code>factorial</code> function contract to say that it is returning <code>n!</code>, and that it is only defined for values of <code>n</code> that are greater than or equal to 0. We recall that our Logika fact, <code>factDef</code>, defines the factorial operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>And we will use <code>factDef</code> to define what we mean by &ldquo;factorial&rdquo; in our <code>factorial</code> function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 1                 //factorial(n) is only defined when n &gt;= 1
</span></span><span style="display:flex;"><span>        ensures result == factDef(n)    //we promise to return factDef(n),
</span></span><span style="display:flex;"><span>                                    //where factDef(n) defines n!
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //code for factorial function
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="writing-a-loop-invariant-block-using-a-logika-fact">Writing a loop invariant block using a Logika fact</h3>
<p>We can similarly use <code>factDef</code> in our loop invariant block. We noted at the end of section 9.3 that the invariant in our loop should be: <em>prod equals i factorial</em>. Now we have a way to express what we mean by &ldquo;factorial&rdquo;, so our invariant will be: <code>prod == factDef(i)</code>. Since the <code>factDef</code> proof function is only defined for parameters greater than or equal to 1, we need to add a second piece to the invariant to guarantee that <code>i</code> will always be greater than or equal to 1. We now have the following loop invariant block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (i != n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant product == factDef(i)
</span></span><span style="display:flex;"><span>            i &gt;= 1
</span></span><span style="display:flex;"><span>        modifies i, product
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //loop body
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="finishing-the-verification">Finishing the verification</h3>
<p>All that remains is to:</p>
<ul>
<li>Prove our loop invariant holds before the loop begins</li>
<li>When we assume the loop invariant holds at the beginning of an iteration, prove that it still holds at the end of the iteration</li>
<li>Use the loop invariant together with the negation of the loop condition to prove the <code>factorial</code> postcondition</li>
<li>Prove the precondition holds in the calling code just before calling <code>factorial</code></li>
<li>Use the postcondition after calling <code>factorial</code> to prove the final assert</li>
</ul>
<p>Here is the completed verification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 1
</span></span><span style="display:flex;"><span>        ensures result == factDef(n)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var i: Z = 1 //how many multiplications we have done
</span></span><span style="display:flex;"><span>    var product: Z = 1  //my current calculation
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Prove invariant before loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. i == 1                       premise
</span></span><span style="display:flex;"><span>        2. product == 1                 premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //pull in first Logika fact rule
</span></span><span style="display:flex;"><span>        3. factDef(1) == 1              fact fOne     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //proves first loop invariant holds  
</span></span><span style="display:flex;"><span>        4. product == factDef(i)        algebra 1 2 3   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //proves second loop invariant hols
</span></span><span style="display:flex;"><span>        5. i &gt;= 1                       algebra 1       
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant product == factDef(i)
</span></span><span style="display:flex;"><span>                i &gt;= 1
</span></span><span style="display:flex;"><span>            modifies i, product
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            //from &#34;i = i + 1&#34;
</span></span><span style="display:flex;"><span>            1. i == i_old + 1               premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //loop invariant held before changing i
</span></span><span style="display:flex;"><span>            2. product == factDef(i_old)    premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //rewrite invariant with no &#34;_old&#34;
</span></span><span style="display:flex;"><span>            3. product == factDef(i-1)      algebra 1 2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //second loop invariant held before changing i
</span></span><span style="display:flex;"><span>            4. i_old &gt;= 1                   premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //needed for the Logika fact
</span></span><span style="display:flex;"><span>            5. i &gt; 1                        algebra 1 4 
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        product = product * i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //Prove invariant still holds at end of iteration
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            //from &#34;product = product * i&#34;
</span></span><span style="display:flex;"><span>            1. product == product_old*i                         premise 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //from previous logic block
</span></span><span style="display:flex;"><span>            2. product_old == factDef(i-1)                      premise 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //pull in Logika fact
</span></span><span style="display:flex;"><span>            3. ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x  fact fBig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //plug in &#34;i&#34; for &#34;x&#34;
</span></span><span style="display:flex;"><span>            4. i &gt; 1 → factDef(i) == factDef(i - 1) * i         Ae 3 i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //from previous logic block
</span></span><span style="display:flex;"><span>            5. i &gt; 1                                            premise   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //i &gt; 1, so get right side of →
</span></span><span style="display:flex;"><span>            6. factDef(i) == factDef(i - 1) * i                 →e 4 5     
</span></span><span style="display:flex;"><span>            7. product == factDef(i-1)*i                        algebra 1 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //proves first invariant still holds
</span></span><span style="display:flex;"><span>            8. product == factDef(i)                            algebra 6 7 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //proves first invariant still holds
</span></span><span style="display:flex;"><span>            9. i &gt;= 1                                           algebra 5
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Prove postcondition
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. product == factDef(i)        premise //loop invariant
</span></span><span style="display:flex;"><span>        2. !(i != n)                    premise //loop condition false
</span></span><span style="display:flex;"><span>        3. i == n                       algebra 2
</span></span><span style="display:flex;"><span>        4. product == factDef(n)        algebra 1 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return product
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//Prove precondition
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == 2             premise
</span></span><span style="display:flex;"><span>    2. num &gt;= 1             algebra 1   //proves factorial precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = factorial(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. answer == factDef(num)           premise     //factorial postcondition
</span></span><span style="display:flex;"><span>    2. num == 2                         premise
</span></span><span style="display:flex;"><span>    3. answer == factDef(2)             algebra 1 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in Logika fact
</span></span><span style="display:flex;"><span>    4. ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x  fact fBig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //plug in &#34;2&#34; for &#34;x&#34;
</span></span><span style="display:flex;"><span>    5. 2 &gt; 1 → factDef(2) == factDef(2 - 1) * 2         Ae 4 2 
</span></span><span style="display:flex;"><span>    6. 2 &gt; 1                            algebra
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //2 &gt; 1, so use →
</span></span><span style="display:flex;"><span>    7. factDef(2) == factDef(2 - 1) * 2  →e 5 6  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in Logika fact
</span></span><span style="display:flex;"><span>    8. factDef(1) == 1                  fact fOne       
</span></span><span style="display:flex;"><span>    9. factDef(2) == factDef(1) * 2     algebra 7
</span></span><span style="display:flex;"><span>    10. factDef(2) == 2                 algebra 8 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //proves claim in assert
</span></span><span style="display:flex;"><span>    11. answer == 2                     algebra 1 2 10
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 2)
</span></span></code></pre></div><h2 id="logika-fact-for-multiplication">Logika fact for multiplication</h2>
<p>Suppose we wanted to create a Logika fact that recursively defined multiplication. We first recursively define how we would multiply 
<span class="math align-center">$x * y$</span>. We know that our base case will be when 
<span class="math align-center">$y == 0$</span>, because anything times 0 is 0. We also saw that multiplication can be defined as repeated addition, so that 
<span class="math align-center">$x * y == x + x + ... x$</span> for a total of 
<span class="math align-center">$y$</span> additions. We also see that 
<span class="math align-center">$x * y == x + x * (y-1)$</span>, since we can pull out one of the additions and then have 
<span class="math align-center">$y-1$</span> additions left to do.</p>
<p>Here is our recursive definition of the problem:</p>
<ul>
<li>Base case: for all numbers x, x * 0 is 0</li>
<li>Recursive case: for all numbers x and all positive numbers y, x * y = x + x * (y-1)</li>
</ul>
<p>We can translate this directly to a Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines m * n = m + m + ... + m (n times)
</span></span><span style="display:flex;"><span>        def multDef(m: Z, n: Z): Z
</span></span><span style="display:flex;"><span>            //anything multiplied by 0 is just 0
</span></span><span style="display:flex;"><span>            mult0. ∀ x: Z multDef(x, 0) == 0
</span></span><span style="display:flex;"><span>            multPos. ∀ x: Z (∀ y: Z y &gt; 0 → multDef(x, y) == x + multDef(x, y-1))
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>We could use this Logika fact in the postcondition and loop invariant block for a multiplication function as follows:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>```text
</span></span><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines m * n = m + m + ... + m (n times)
</span></span><span style="display:flex;"><span>        def multDef(m: Z, n: Z): Z
</span></span><span style="display:flex;"><span>            //anything multiplied by 0 is just 0
</span></span><span style="display:flex;"><span>            mult0. A x: Z multDef(x, 0) == 0
</span></span><span style="display:flex;"><span>            multPos. A x: Z (A y: Z y &gt; 0 -&gt; multDef(x, y) == multDef(x, y-1) + x)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//want to find: num1 + num1 + ... + num1 (a total of num2 times)
</span></span><span style="display:flex;"><span>def mult(num1: Z, num2: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires num2 &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == multDef(num1, num2)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var answer: Z = 0
</span></span><span style="display:flex;"><span>    var cur: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (cur != num2) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant
</span></span><span style="display:flex;"><span>                answer == multDef(num1, cur)
</span></span><span style="display:flex;"><span>                cur &gt;= 0
</span></span><span style="display:flex;"><span>            modifies cur, answer
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>        cur = cur + 1
</span></span><span style="display:flex;"><span>        answer = answer + num1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return answer
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The example above does not include the verification steps to prove the loop invariant and postcondition, but those things could be accomplished in the same way as for the <code>factorial</code> function.</p>
<h2 id="logika-fact-for-fibonacci-numbers">Logika fact for Fibonacci numbers</h2>
<p>The Fibonacci sequence is:</p>

<span class="math align-center">$$
1, 1, 2, 3, 5, 8, 13, ...
$$</span><p><br><br></p>
<p>The first two Fibonacci numbers are both 1, and subsequent Fibonacci numbers are found by adding the two previous values. In the sequence above, we see that the two latest numbers were 8 and 13, so the next number in the sequence will be 
<span class="math align-center">$8 + 13 = 21$</span>.</p>
<p>We can recursively define the Fibonnaci sequence as follows:</p>
<ul>
<li>Base case 1: the first Fibonacci number is 1</li>
<li>Base case 2: the second Fibonacci number is 1</li>
<li>Recursive case: for all numbers x greater than 2, the x-th Fibonacci number is the (x-1)-th Fibonacci number + the (x-2)-th Fibonacci number</li>
</ul>
<p>We can translate this directly to a Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines the nth number in the Fibonacci sequence
</span></span><span style="display:flex;"><span>        //1, 1, 2, 3, 5, 8, 13, ...
</span></span><span style="display:flex;"><span>        def fibDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fib1. fibDef(1) == 1
</span></span><span style="display:flex;"><span>            fib2. fibDef(2) == 1
</span></span><span style="display:flex;"><span>            fibN. ∀ x: Z x &gt; 2 → fibDef(x) == fibDef(x-1) + fibDef(x-2)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Which we could use in a postcondition and loop invariant if we wrote a function to compute the Fibonacci numbers.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Summary</h1>
    
    
<p>Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:</p>
<h2 id="step-1-write-function-contracts">Step 1: Write function contracts</h2>
<p>Write a function contract for any function that doesn&rsquo;t already have one. Function contracts go just inside the function defintion, and look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    requires (preconditions)
</span></span><span style="display:flex;"><span>    ensures (postconditions)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>(The <em>modifies</em> clause is omitted, as we did not use it in this chapter. We will use the <em>modifies</em> clause in chapter 10.) The <em>preconditions</em> list any requirements your function has about the range of its parameters, and the <em>postconditions</em> describe the impact of calling the function (in this chapter, the postcondition always describes how the return value relates to the parameters.) If you&rsquo;re not sure what to write as the postcondition, try walking through your function with different parameters to get a sense for the pattern of what the function is doing in relation to the parameters. If you were given a Logika proof function, you will likely need to use it in the postcondition (and loop invariant) to describe the behavior.</p>
<h2 id="step-2-write-loop-invariant-blocks">Step 2: Write loop invariant blocks</h2>
<p>Write a loop invariant block for any loop that doesn&rsquo;t already have one. Loop invariant blocks go just inside the loop (before any code) and look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    invariant (loop invariants)
</span></span><span style="display:flex;"><span>    modifies (variable list)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>The <em>invariant</em> clause lists all loop invariants, which should describe the progress the loop has made toward its goal (the loop invariant will often greatly reasonable the postcondition for the enclosing function). Loop invariants occasionally need to specify the range of different variables, especially if the invariant uses Logika facts (which may only be defined for particular values) or if you need more information about the final value of a variable when a loop terminates. I recommend making a table of variable values for several iterations of your loop to get a sense of the relationship between variables &ndash; this relationship is what will become the loop invariant.</p>
<p>The <em>modifies</em> clause lists all variables that are modified in the loop body.</p>
<h2 id="step-3-prove-invariant-holds-before-loop-begins">Step 3: Prove invariant holds before loop begins</h2>
<p>In each loop, prove your invariant holds before the loop begins. You may need to pull in the function&rsquo;s precondition as a premise in this step. You must prove EXACTLY the claim in all pieces of the loop invariant. If your loop invariant involves a Logika fact, you may need to pull in a piece of the fact definition to help prove the invariant.</p>
<h2 id="step-4-prove-invariant-still-holds-at-end-of-iteration">Step 4: Prove invariant still holds at end of iteration</h2>
<p>In each loop, prove your invariant still holds at the end of each iteration. Start by pulling in each part of the loop invariant as a premise before the loop body begins. Use logic blocks to process each statement in the body of the loop. By the end of the loop, you must prove EXACTLY the claim in all pieces of the loop invariant. (Again, if your loop invariant involves a Logika fact, you&rsquo;ll want to pull in a piece of the fact definition to help with this step.)</p>
<h2 id="step-5-prove-the-postcondition">Step 5: Prove the postcondition</h2>
<p>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition just before your function ends.</p>
<h2 id="step-6-prove-the-precondition-before-each-function-call">Step 6: Prove the precondition before each function call</h2>
<p>Before any function call, prove exactly the precondition(s) for the function (using whatever values you are passing as parameters).</p>
<h2 id="step-7-use-postcondition-after-each-function-call">Step 7: Use postcondition after each function call</h2>
<p>After returning from each function call, pull the function&rsquo;s postcondition into a logic block as a premise (using whatever values you passed as parameters). Use this information to help prove any asserts.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-10">Chapter 10</h3>
<h1 id="programming-logic-sequences-global-variables-and-termination">Programming Logic: Sequences, Global Variables, and Termination</h1>
<p>In our conclusion of programming logic, we&rsquo;ll examines programs with sequences and global variables. We&rsquo;ll also learn the idea of <em>termination</em> in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Logika Modes</h1>
    
    
<p>Logika has different modes for programming logic verification. We can switch between modes by going to File-&gt;Settings-&gt;Tools-&gt;Sireum-&gt;Logika.</p>
<h2 id="logikas-manual-mode">Logika&rsquo;s &ldquo;manual&rdquo; mode</h2>
<p>Up to now, we have been running Logika in &ldquo;manual mode&rdquo;, which uses these Logika settings:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/sireumManual.png" alt="manual mode"></p>
<p>We are now reaching the point where additional practice in manual mode may no longer be a learning activity, and where the proof-blocks after claim transformations can become dozens of lines long.</p>
<h2 id="logikas-symexe-mode">Logika&rsquo;s SymExe mode</h2>
<p>In Chapter 10, we will be switching to Logika&rsquo;s &ldquo;symexe mode&rdquo;, which uses these Logika settings:</p>
<p><img src="https://ksu-cs-textbooks.github.io/cis301/images/sireumSymexe.png" alt="symexe mode"></p>
<p>Symexe mode allows us to reason about our program by using ONLY invariants and function contracts. While the same work has to be done for a program to be verified (the precondition must be true before a function call, the loop invariant must be true before the loop begins, etc.), symexe mode does the work of analyzing your program statements to ensure that all parts of your loop invariant and function contract are satisified. When you use symexe mode, you will only need to include a function contract for each function and a loop invariant block for each loop, and it will do the grunt work.</p>
<h3 id="multiplication-example">Multiplication example</h3>
<p>In section 9.3, we did a verification of a multiplication a program using Logika&rsquo;s manual mode. Here is how we would write the verification of the same program using Logika&rsquo;s symexe mode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>Note that the only logic blocks we needed to provide were the function contract and the loop invariant block.</p>
<h3 id="pitfalls">Pitfalls</h3>
<p>When using this more advanced mode, it is not always obvious why Logika will not verify. Sometimes semantic errors in the program keep it from verifying; i.e. Logika has found a corner or edge case for which the program does not account. Other times the invariants and conditions do not actually help prove the goal in an assert or postcondition. Inevitably, sometimes it will be both.</p>
<p>In either case an option is to uncheck &ldquo;auto&rdquo; and begin typing each proof-block as if in manual mode (this can be done with Symexe enabled) until you find the logical or programming error.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Intro to Sequences</h1>
    
    
<p><em>Sequences</em> in Logika are fairly similar to lists in Python and arrays in Java and C#. As with lists and arrays, Logika sequences are ordered. Each element is stored at a particular (zero-based) position, and there are no gaps in the sequence.</p>
<p>Logika sequences can either store integers (type <code>ZS</code>) or booleans (type <code>BS</code>).</p>
<h2 id="sequence-syntax">Sequence syntax</h2>
<p>We can create new sequence variables like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//creates the sequence (5, 10, 15)
</span></span><span style="display:flex;"><span>var seq: ZS = ZS(5,10,15)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//creates the sequence (false, true)
</span></span><span style="display:flex;"><span>var bools: BS = BS(false, true)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//creates an empty sequence of integers
</span></span><span style="display:flex;"><span>var empty: ZS = ZS()
</span></span></code></pre></div><p>Given the following sequence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var a: ZS = ZS(1, 2, 3)
</span></span></code></pre></div><p>Here is a table of the different sequence operations we will use in this course:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Indexing: <code>a(pos)</code></td>
<td>Accesses the value in the sequence at position <code>pos</code>. <br> Sequences are zero-based, and Logika will show an error if you have not proven (or if it cannot infer, in symexe mode) that the position lies within the sequence range. <br><br> For example, <code>a(0)</code> is 1. <br> <code>a(0) = 11</code> would change the first value to be 11, so the sequence would be <code>[11,2,3]</code>. <br> <code>a(3)</code> would give an error, as position 3 is past the end of the sequence.</td>
</tr>
<tr>
<td>Size: <code>a.size</code></td>
<td>Evaluates to the number of elements in the sequence: <code>a.size == 3</code></td>
</tr>
<tr>
<td>Reassignment</td>
<td>Sequences instantiated as <code>var</code> can be reassigned. <br><br> For example, after <code>a = ZS(5,6)</code>, <code>a</code> is now <code>[5,6]</code>.</td>
</tr>
</tbody>
</table>
<h2 id="sample-program-with-a-sequence">Sample program with a sequence</h2>
<p>Here is a sample Logika program that uses a sequence. The <code>makeFirstZero</code> function sets the first element in a sequence to 0::</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//&#34;Unit&#34; is like a void return type
</span></span><span style="display:flex;"><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style="display:flex;"><span>    seq(0) = 0
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>///// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var nums: ZS = ZS(1,2,3)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>makeFirstZero(nums)
</span></span><span style="display:flex;"><span>assert(nums == ZS(0,2,3))
</span></span></code></pre></div><p>This program will not run (or be verified) as we have not yet provided a function contract for <code>makeZeroFirst</code>. We will complete the verification for the program later in the section.</p>
<h2 id="predicate-logic-statements-with-sequences">Predicate logic statements with sequences</h2>
<p>When we write function contracts and loop invariants with sequences, we will need to make statements about <em>all</em> or <em>some</em> elements in a sequence. We can do this with predicate logic statements.</p>
<h3 id="statements-about-all-sequence-elements">Statements about all sequence elements</h3>
<p>As we did in chapters 4 and 5, we will use the universal (<code>∀</code>) quantifier for statements involving all elements in a sequence. The basic forms of specifying some claim <code>P(a(x))</code> holds for every element in a sequence <code>a</code> are:</p>
<table>
<thead>
<tr>
<th>Statement</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>∀ x: (lower..upper)  P(a(x))</code></td>
<td><code>P(a(x))</code> holds for every element in <code>a</code> from position <code>lower</code> to position <code>upper</code> (including both <code>lower</code> and <code>upper</code>)</td>
</tr>
<tr>
<td><code>∀ x: (lower..&lt;upper)  P(a(x))</code></td>
<td><code>P(a(x))</code> holds for every element in <code>a</code> from position <code>lower</code> up to but not including position <code>upper</code> (<code>lower</code> but not <code>upper</code>)</td>
</tr>
</tbody>
</table>
<p>Here are several sample claims and explanations about integer sequence <code>a</code>:</p>
<table>
<thead>
<tr>
<th>Claim</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>∀ x: (0..&lt;a.size) a(x) &gt; 0</code></td>
<td>Every element in <code>a</code> is greater than 0</td>
</tr>
<tr>
<td><code>∀ x: (1..3) a(x) == 0</code></td>
<td>All elements in <code>a</code> between positions 1 and 3 (inclusive of 1 and 3) have value 0</td>
</tr>
<tr>
<td><code>∀ x: (0..&lt;a.size) a(x) &lt; 0 → a(x) == -10</code></td>
<td>All negative elements in <code>a</code> have value -10</td>
</tr>
</tbody>
</table>
<h3 id="statements-about-some-sequence-elements">Statements about some sequence elements</h3>
<p>We will use the existential (<code>∃</code>) quantifier for statements involving one or more elements in a sequence. The basic forms of specifying claims is the same as for the universal quantifier, but using the existential quantifier instead of the universal quantifier.</p>
<p>Here are several sample claims and explanations about integer sequences <code>a</code> and <code>b</code>:</p>
<table>
<thead>
<tr>
<th>Claim</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>∃ x: (0..&lt;a.size) a(x) &gt; 0</code></td>
<td>There is an element in <code>a</code> that is greater than 0</td>
</tr>
<tr>
<td><code>∃ x: (2..4) a(x) == a(x-1) * 2</code></td>
<td>There is an element in <code>a</code> between positions 2 and 4 (inclusive) that is twice as big as the previous element</td>
</tr>
<tr>
<td><code>∀ x: (0..&lt;a.size) (∃ y: (0..&lt;b.size) a(x) == b(y))</code></td>
<td>Every value in <code>a</code> appears somewhere in <code>b</code></td>
</tr>
</tbody>
</table>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Sequences in Functions</h1>
    
    
<p>Sequences in Logika are passed to functions by reference. This means that if a function makes changes to a sequence parameter, then it will also change whatever sequence object was passed to the function. For example, the test code above passes <code>nums</code>, which has the value <code>ZS(1,2,3)</code>, to the <code>makeFirstZero</code> function. The <code>makeFirstZero</code> function changes the first position in its parameter (<code>seq</code>) to be 0, which means that the <code>nums</code> sequence in the test code will also have its first position set to 0 (making it have the value <code>ZS(0,2,3)</code>).</p>
<h2 id="preconditions-with-sequences">Preconditions with sequences</h2>
<p>When writing the precondition for a function that takes a sequence parameter, we must consider whether our function will only work correctly for particular sequence values or sizes. For example, our <code>makeFirstZero</code> function will not work if the size of the <code>seq</code> parameter is zero. We would need to add this requirement to the function&rsquo;s precondition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>requires seq.size &gt; 0
</span></span></code></pre></div><p>If we wanted to require that all values in a sequence parameter (say, <code>nums</code>) be between 10 and 20, we would write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>requires ∀ x: (0..&lt;nums.size) (nums(x) &gt;= 10 ∧ nums(x) &lt;= 20)
</span></span></code></pre></div><p>Sometimes, functions with sequence parameters will work for any size/values &ndash; in those cases, we don&rsquo;t need to list anything about the sequence in the precondition.</p>
<h2 id="function-modifies-clause">Function <code>modifies</code> clause</h2>
<p>We learned in chapter 9 that the format of a function contract is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    requires (preconditions)
</span></span><span style="display:flex;"><span>    modifies (sequences/globals changed in this function)
</span></span><span style="display:flex;"><span>    ensures (postconditions)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Until this point, we have been leaving off the <code>modifies</code> clause because our functions have not used sequences or global variables. We now need to include that clause whenever a function CHANGES the values in a sequence parameter. For example, the <code>makeFirstZero</code> function DOES change its sequence parameter, <code>seq</code>, as it sets its first position to 0. <code>makeFirstZero</code> should therefore include this <code>modifies</code> clause:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>modifies seq
</span></span></code></pre></div><p>If the function modifies more than one sequence or global variable, they are listed together in a comma-separated list.</p>
<h2 id="postconditions-with-sequences">Postconditions with sequences</h2>
<p>When writing the postcondition for a function that uses a sequence parameter, we must consider two things:</p>
<ul>
<li>How the return value relates to the sequence</li>
<li>How the function will change the sequence</li>
</ul>
<h3 id="relating-return-values-to-sequence-elements">Relating return values to sequence elements</h3>
<p>We will still use the <code>result</code> keyword for describing the function&rsquo;s return value in the postcondition. For example, if a function was returning the smallest value in the sequence <code>nums</code>, we would say:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ensures ∀ x: (0..&lt;nums.size) result &lt;= nums(x)
</span></span><span style="display:flex;"><span>    ∃ x: (0..&lt;a.size) result == nums(x)
</span></span></code></pre></div><p>Here, the first postcondition states that our return value will be less than or equal to every value in the sequence, and the second postcondition statees that our return value is one of the sequence elements. (The second postcondition prevents us from sneakily returning some large negative number and claiming that it was the smallest element in the sequence, when in fact it wasn&rsquo;t one of the sequence elements.)</p>
<p>Sometimes, our postconditions will promise to return a particular value if some claim about the sequence is true. Suppose we have a function that returns whether or not (i.e., a bool) all elements in the sequence <code>a</code> are negative. Our postcondition would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ensures (∀ x: (0..&lt;nums.size) nums(x) &lt; 0) → (result == true)
</span></span><span style="display:flex;"><span>    (∃ x: (0..&lt;nums.size) nums(x) &gt;= 0) → (result == false)
</span></span></code></pre></div><p>Here, the first postcondition promises that if all sequence elements are negative, then the function will return true. The second postcondition promises the opposite &ndash; that if there is a nonnegative sequence element, then the function will return false.</p>
<h3 id="describing-how-the-function-changes-the-sequence">Describing how the function changes the sequence</h3>
<p>Consider again the <code>makeFirstZero</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style="display:flex;"><span>    seq(0) = 0
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function doesn&rsquo;t return anything (hence the <code>Unit</code> return type), but we do need to describe what impact calling this function will have on the sequence. We can partially accomplish our goal with this postcondition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ensures seq(0) == 0
</span></span></code></pre></div><p>Which promises that after the function ends, the first value in the sequence will be 0. However, suppose we wrote this instead for the <code>makeFirstZero</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style="display:flex;"><span>    seq(0) = 0
</span></span><span style="display:flex;"><span>    seq(1) = 100
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This version of the function DOES satisfy the postcondition &ndash; the first element is indeed set to 0 &ndash; but it changes other elements, too. The postcondition should be descriptive enough that anyone calling it can be certain EXACTLY what every single value in the sequence will be afterwards. Our postcondition needs to describe exactly what values in the sequence WILL change and exactly what values WON&rsquo;T change.</p>
<p>This means that our <code>makeFirstZero</code> function needs to state that the first element in <code>seq</code> gets set to 0, and that every other value in the sequence <em>stays the same as its original value</em>. To help us describe the <em>original value</em> of a sequence, we can use the special <code>sequenceName_in</code> syntax, which holds the value of a sequence parameter <code>sequenceName</code> at the time the function was called. (This <code>_in</code> syntax can only be used in logic blocks, not in the code.)</p>
<p>We can specify exactly what happens to each sequence element in our first version of <code>makeFirstZero</code> like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ensures seq(0) == 0
</span></span><span style="display:flex;"><span>    ∀ x: (1..&lt;seq.size) seq(x) == seq_in(x)
</span></span></code></pre></div><p>The second postcondition says: &ldquo;All elements from position 1 on keep their original values&rdquo;.</p>
<h3 id="postcondition-size-doesnt-change">Postcondition: size doesn&rsquo;t change</h3>
<p>Logika has an oddity with programs that modify sequence parameters &ndash; in those cases, you must also include as a postcondition that the size of the sequence will not change (i.e., that the resulting sequence size will equal the original sequence size. For example, if a function modified the sequence <code>seq</code>, we would need to add the postcondition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>seq.size == seq_in.size
</span></span></code></pre></div><p>Logika is concerned that any function that modifies a sequence might also change the size of that sequence. While it is possible to append and prepend to Logika sequences (much like with Python lists), we cannot do so to sequence parameters. As a rule, Logika functions cannot assign to ANY parameter value (they are read-only). However, we still must state that the size doesn&rsquo;t change or the program will not be verified. Whenever you list a sequence in the <code>modifies</code> clause to a function, you must also include a postcondition to say that its size doesn&rsquo;t change.</p>
<p>If you are writing a function that uses a sequence parameter but doesn&rsquo;t change that parameter, you should not list that sequence in a <code>modifies</code> clause, and you should not state that the sequence size doesn&rsquo;t change (or anything else about the <code>..._in</code> value of the sequence).</p>
<h2 id="example-finished-makefirstzero-verification">Example: finished <code>makeFirstZero</code> verification</h2>
<p>Now that we have seen all the pieces of writing function contracts for functions that work with sequences, we can put together the full function contract for our <code>makeFirstZero</code> function. The assert statement in the test code will be verified in Logika&rsquo;s symexe mode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//&#34;Unit&#34; is like a void return type
</span></span><span style="display:flex;"><span>def makeFirstZero(seq: ZS): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires seq.size &gt;= 1  //we need at least 1 element
</span></span><span style="display:flex;"><span>        modifies seq            //we are changing the sequence
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            //we promise the first element will be a 0
</span></span><span style="display:flex;"><span>            seq(0) == 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //we promise every other element is the same as its original value
</span></span><span style="display:flex;"><span>            A x: (1..&lt;seq.size) seq(x) == seq_in(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //we promise the sequence size won&#39;t change
</span></span><span style="display:flex;"><span>            seq.size == seq_in.size
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    seq(0) = 0
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>///// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var nums: ZS = ZS(1,2,3)
</span></span><span style="display:flex;"><span>makeFirstZero(nums)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//we want to claim that nums is what it was, but with the first
</span></span><span style="display:flex;"><span>//element as a 0
</span></span><span style="display:flex;"><span>assert(nums == ZS(0,2,3))
</span></span></code></pre></div><h2 id="example-swap-program">Example: swap program</h2>
<p>Suppose we have the following swap program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def swap(list: ZS, pos1: Z, pos2: Z): Unit = {
</span></span><span style="display:flex;"><span>    var temp: Z = list(pos1)
</span></span><span style="display:flex;"><span>    list(pos1) = list(pos2)
</span></span><span style="display:flex;"><span>    list(pos2) = temp
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>///////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var testList: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>swap(testList,0,3)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the values in positions 0 and 3 should be swapped
</span></span><span style="display:flex;"><span>//all other elements should be the same
</span></span><span style="display:flex;"><span>assert(testList == ZS(4,2,3,1))
</span></span></code></pre></div><p>Here, <code>swap</code> takes an integer sequence (<code>list</code>) and two positions (<code>pos1</code> and <code>pos2</code>). It uses a temp variable to swap the values in <code>list</code> at <code>pos1</code> and <code>pos2</code>. We would like to write an appropriate function contract so the assert statement in the test code holds.</p>
<p>We must first consider the precondition &ndash; does <code>swap</code> have any requirements about its parameters? Since <code>swap</code> uses <code>pos1</code> and <code>pos2</code> as positions within <code>list</code>, we can see that <code>swap</code> will crash if either position is out of bounds &ndash; either negative or past the end of the sequence.</p>
<p>The function is changing the sequence, so we will need a <code>modifies</code> clause. Finally, we must consider the postcondition. This function isn&rsquo;t returning a value, but it is changing the sequence &ndash; so we should describe exactly what values HAVE changed (and their new values) and what values have NOT changed. We want to say that:</p>
<ul>
<li><code>list(pos1)</code> has the value that was originally at <code>list(pos2)</code> (i.e, the value at <code>list_in(pos2)</code>)</li>
<li><code>list(pos2)</code> has the value that was originally at <code>list(pos1)</code> (i.e, the value at <code>list_in(pos1)</code>)</li>
<li>All other positions are unchanged (i.e., they are the same as they were in <code>list_in</code>)</li>
<li>The size doesn&rsquo;t change (which we must always list if a sequence is modified)</li>
</ul>
<p>We can now complete the function contract for <code>swap</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def swap(list: ZS, pos1: Z, pos2: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //pos1 and pos2 need to be valid positions
</span></span><span style="display:flex;"><span>        requires pos1 &gt;= 0
</span></span><span style="display:flex;"><span>            pos2 &gt;= 0
</span></span><span style="display:flex;"><span>            pos1 &lt; list.size
</span></span><span style="display:flex;"><span>            pos2 &lt; list.size
</span></span><span style="display:flex;"><span>        modifies list
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            list(pos1) == list_in(pos2)
</span></span><span style="display:flex;"><span>            list(pos2) == list_in(pos1)
</span></span><span style="display:flex;"><span>            list.size == list_in.size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //all the other spots stay the same
</span></span><span style="display:flex;"><span>            A x:(0..&lt;list.size) (x != pos1 ^ x != pos2) -&gt; list(x) == list_in(x)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var temp: Z = list(pos1)
</span></span><span style="display:flex;"><span>    list(pos1) = list(pos2)
</span></span><span style="display:flex;"><span>    list(pos2) = temp
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>///////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var testList: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>swap(testList,0,3)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//the values in positions 0 and 3 should be swapped
</span></span><span style="display:flex;"><span>//all other elements should be the same
</span></span><span style="display:flex;"><span>assert(testList == ZS(4,2,3,1))
</span></span></code></pre></div><p>If we test this program in Logika&rsquo;s symexe mode, the final assert will hold &ndash; we have enough information to make a claim about EXACTLY what the sequence will look like after calling <code>swap</code>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Sequences in Loops</h1>
    
    
<p>We also must consider sequences when writing loop invariants. Typically, we must include the following in our invariant:</p>
<ul>
<li>If the sequence changes in the loop
<ul>
<li>Describe what sequence elements have already changed in the loop (and what their new values are)</li>
<li>Describe what sequence elements still have their original value</li>
<li>State that the sequence size does not change</li>
<li>Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence)</li>
<li>List the sequence along with other changing variables in the loop invariant block&rsquo;s <code>modifies</code> clause</li>
</ul>
</li>
<li>If the sequence does not change in the loop
<ul>
<li>Consider what we are doing with each sequence element as we look at them. Usually we have another variable that is storing our progress (and often, this variable is returned from the function after the loop). Express how the variable&rsquo;s value relates to the part of the sequence we&rsquo;ve looked at so far &ndash; this statement should look very similar to your postcondition, but should only describe part of the sequence.</li>
<li>Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence)</li>
</ul>
</li>
</ul>
<h2 id="example-add-one-to-all-program">Example: add one to all program</h2>
<p>Suppose we have the following program, which adds one to every element in a sequence parameter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def addOne(list: ZS): Unit = {
</span></span><span style="display:flex;"><span>    var i: Z = 0
</span></span><span style="display:flex;"><span>    while (i &lt; list.size) {
</span></span><span style="display:flex;"><span>        list(i) = list(i) + 1
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var test: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>addOne(test)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(test == ZS(2,3,4,5))
</span></span></code></pre></div><p>We would like to write an appropriate function contract and loop invariant block so the assert statement in the test code holds (which asserts that the sequence <code>ZS(1,2,3,4)</code> becomes the sequence <code>ZS(2,3,4,5)</code> after calling the function).</p>
<p>For the function contract, we must consider:</p>
<ul>
<li><em>Precondition</em>: this function will work correctly on all sequences &ndash; even empty ones. We can leave the <code>requires</code> clause off.</li>
<li><code>modifies</code> clause: this function is changing the <code>list</code> sequence parameter, so we must list it in a <code>modifies</code> clause`</li>
<li><em>Postcondition</em>: the function is not returning anything, but we must describe that all sequence parameters will be one bigger than their original values. Since the function modifies the sequence, the postcondition must also state that the sequence size does not change.</li>
</ul>
<p>For the loop invariant block, we notice that the loop is changing the sequence. We must include:</p>
<ul>
<li><em>Which elements have already changed</em>. Since <code>i</code> is tracking our position in the sequence, we know that at the end of each iteration, all elements from position 0 up to but not including position <code>i</code> have been changed to be one bigger than their original values.</li>
<li><em>Which elements have not changed</em>. All other elements in the sequence &ndash; from position <code>i</code> to the end of the sequence &ndash; still have their original values</li>
<li><em>State that the sequence size does not change</em>.</li>
<li><em>Upper and lower bounds for position variables</em>. Since <code>i</code> is tracking our position, we must state that i is always a valid sequence index. Here, we need to claim that <code>i</code> will always be greater than or equal to 0 and less than or equal to the sequence size. (While the sequence size itself is not a valid sequence index, we see from looking at the loop that <code>i</code> is incrementing as the very last step in the loop. On the last iteration, <code>i</code> will start off at <code>list.size-1</code>, and we will correctly access and modify the last element in <code>list</code>. Then we will increment <code>i</code>, making it EQUAL <code>list.size</code> &ndash; at that point, the loop ends. If we made part of our invariant be <code>i &lt; list.size</code>, it would be incorrect because of that last iteration.)</li>
</ul>
<p>We can now complete the function contract and loop invariant for <code>addOne</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def addOne(list: ZS): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //function contract
</span></span><span style="display:flex;"><span>        modifies list
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            list.size == list_in.size
</span></span><span style="display:flex;"><span>            A x: (0..&lt;list.size) list(x) == list_in(x) + 1
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var i: Z = 0
</span></span><span style="display:flex;"><span>    while (i &lt; list.size) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant
</span></span><span style="display:flex;"><span>                i &gt;= 0
</span></span><span style="display:flex;"><span>                i &lt;= list.size
</span></span><span style="display:flex;"><span>                list.size == list_in.size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                //what I HAVE changed
</span></span><span style="display:flex;"><span>                A x:(0..&lt;i) list(x) == list_in(x) + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                //what I haven&#39;t changed
</span></span><span style="display:flex;"><span>                A x: (i..&lt;list.size) list(x) == list_in(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            modifies list, i
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        list(i) = list(i) + 1
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var test: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>addOne(test)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(test == ZS(2,3,4,5))
</span></span></code></pre></div><p>If we test this program in Logika&rsquo;s symexe mode, the final assert will hold &ndash; we have enough information to know what the sequence will look like after calling <code>addOne</code>.</p>
<h2 id="example-min-program">Example: min program</h2>
<p>In our next example, we examine a function that does <em>not</em> modify its sequence parameter, and that <em>does</em> return a value. Consider the following <code>min</code> function and test code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//return the smallest element in list
</span></span><span style="display:flex;"><span>def min(list: ZS): Z = {
</span></span><span style="display:flex;"><span>    var small: Z = list(0)
</span></span><span style="display:flex;"><span>    var i: Z = 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i &lt; list.size) {
</span></span><span style="display:flex;"><span>        if (list(i) &lt; small) {
</span></span><span style="display:flex;"><span>            small = list(i)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return small
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var test: ZS = ZS(8,1,0,10,9,2,0)
</span></span><span style="display:flex;"><span>var testMin: Z = min(test)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(testMin == 0)
</span></span></code></pre></div><p>Here, our <code>min</code> function is supposed to find and return the smallest value in an integer sequence. We can see that our test code passes <code>min</code> the sequence (<code>ZS(8,1,0,10,9,2,0)</code>), and that we are trying to assert that <code>min</code> correctly returns <code>0</code> as the smallest value in the sequence. We need to add an appropriate function contract and loop invariant block to make this assert hold.</p>
<p>For the function contract, we must consider:</p>
<ul>
<li><em>Precondition</em>: this function starts by saving out the element at position 0. If the sequence was empty, the function would crash. We need to require that the sequence size be at least 1.</li>
<li><code>modifies</code> clause: this function is NOT modifying its sequence parameter, so we can omit this clause</li>
<li><em>Postcondition</em>: the function is not changing the sequence, so we do not need to describe the final values of each sequence element. We <em>do</em> need to describe what value we are returning, and how it relates to the sequence. We want to describe that <code>result</code> (our return value) is the smallest element in <code>list</code>, so that:
<ul>
<li><code>result</code> is less than or equal to every element in <code>list</code></li>
<li>There is an element in <code>list</code> that equals <code>result</code> (i.e., we really are returning one of our sequence values)</li>
</ul>
</li>
</ul>
<p>For the loop invariant block, we notice that the loop is NOT changing the sequence. We must include:</p>
<ul>
<li><em>What we are doing with each sequence element, and how that relates to another variable</em>. We can see that <code>small</code> tracks the smallest element we&rsquo;ve seen in the sequence so far &ndash; up to but not including position <code>i</code>. Similar to the postcondition, we want to claim that:
<ul>
<li><code>small</code> is less than or equal to every element in <code>list</code> <em>that we have seen so far</em></li>
<li>There is an element <em>we have already seen</em> in <code>list</code> that equals small</li>
</ul>
</li>
<li><em>Upper and lower bounds for position variables</em>. Here, <code>i</code> is our position variable. We see that it is initialized to 1, so we will claim that it is always greater than or equal to 1 and less than or equal to the list size.</li>
</ul>
<p>We can now complete the function contract and loop invariant for <code>min</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//return the smallest element in list
</span></span><span style="display:flex;"><span>def min(list: ZS): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires list.size &gt; 0
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            //result is &lt;= every element in list
</span></span><span style="display:flex;"><span>            A x: (0..&lt;list.size) result &lt;= list(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //there exists a list element that matches my result
</span></span><span style="display:flex;"><span>            E x: (0..&lt;list.size) result == list(x)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var small: Z = list(0)
</span></span><span style="display:flex;"><span>    var i: Z = 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i &lt; list.size) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant
</span></span><span style="display:flex;"><span>                i &lt;= list.size
</span></span><span style="display:flex;"><span>                i &gt;= 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                //small is the smallest up to position i
</span></span><span style="display:flex;"><span>                A x: (0..&lt;i) small &lt;= list(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                //small is one of the elements up to position i
</span></span><span style="display:flex;"><span>                E x: (0..&lt;i) small == list(x)
</span></span><span style="display:flex;"><span>            modifies small, i
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (list(i) &lt; small) {
</span></span><span style="display:flex;"><span>            small = list(i)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return small
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var test: ZS = ZS(8,1,0,10,9,2,0)
</span></span><span style="display:flex;"><span>var testMin: Z = min(test)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(testMin == 0)
</span></span></code></pre></div><p>If we test this program in Logika&rsquo;s symexe mode, the final assert will hold &ndash; we have enough information to know what the sequence will look like after calling <code>addOne</code>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Logika Facts, revisited</h1>
    
    
<p>As in other programs with loops, programs with sequences sometimes necessitate the use of a <em>Logika fact</em> to describe how a particular value is calculated. For example, consider the following program that finds and returns the sum of all elements in an integer sequence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def seqSum(list: ZS): Z = {
</span></span><span style="display:flex;"><span>    var i: Z = 0
</span></span><span style="display:flex;"><span>    var total: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i &lt; list.size) {
</span></span><span style="display:flex;"><span>        total = total + list(i)
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return total
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var test: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>var added: Z = seqSum(test)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(added == 10)
</span></span></code></pre></div><p>In the <code>seqSum</code> function contract, we need to describe that the return value equals the sum of all sequence elements &ndash; that is, that <code>result == list(0) + list(1) + ... + list(list.size - 1)</code>. This is the same situation that we encountered when trying to specify something like a factorial. We know the pattern that we want to describe, but aren&rsquo;t able to do so without using the &ldquo;&hellip;&rdquo; notation. When you need to describe a pattern in this way, you will almost always want to use a Logika fact.</p>
<h2 id="blueprint-for-logika-facts-with-sequences">Blueprint for Logika facts with sequences</h2>
<p>When writing a Logika fact that works with a sequence, we will have this general recursive definition:</p>
<ul>
<li>Base case: we have already processed all elements in the sequence</li>
<li>Recursive case: process one sequence element, and recursively process the rest</li>
</ul>
<p>We need some way to track what element we are ready to process, so in addition to having the Logika proof function take a sequence parameter, we will also have it take a parameter that stores how many elements we have left to process. We will use this template for our Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factName(seqName: seqType, count: Z): returnType
</span></span><span style="display:flex;"><span>            = (baseCaseValue), if count == 0                    (factName0)
</span></span><span style="display:flex;"><span>            = (recursiveCaseValue), if count &gt; 0                (factNameN)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Where we have that:</p>
<ul>
<li><code>factName</code> is the name we give our Logika proof function</li>
<li><code>seqName</code> is the name of our sequence parameter, and <code>seqType</code> is its type (either <code>ZS</code> or <code>ZB</code>)</li>
<li><code>returnType</code> is the type of what we are calculating (most likely <code>Z</code> or <code>B</code>)</li>
<li><code>count</code> is the number of items left to process in the sequence. We will see that we will initially pass our sequence size as this parameter, so that all elements in the sequence will be processed.</li>
<li><code>(baseCaseValue)</code> is the value we want for our base case &ndash; if we have already processed all sequence elements</li>
<li><code>(recursiveCaseValue)</code> is the value we want for our recursive case. In this step, we want to process the current sequence element, <code>seqName(count-1)</code>, and then use the proof function to recursively evaluate the rest of the sequence (passing <code>count-1</code> as the number of items left to process).</li>
<li><code>(factName0)</code> is the name we are giving out base case definition, and <code>(factNameN)</code> is the name we are giving our recursive case definition. We will not need to refer to these name in our verification when we use symexe mode.</li>
</ul>
<p>You may notice that this format is slightly different than the format we used for Logika facts in section 9.4. We could also write our sequence Logika facts in that format, using quantifiers to describe ranges, but you will find that the above format is much more straightforward.</p>
<h2 id="logika-fact-for-sequence-sum">Logika fact for sequence sum</h2>
<p>We are now ready to write a Logika fact to describe the calculation of adding all elements in a sequence &ndash; the sum <code>list(0) + list(1) + ... + list(list.size - 1)</code> for some sequence <code>list</code>. We use the template above to write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def sumFact(seq: ZS, pos: Z): Z
</span></span><span style="display:flex;"><span>            = 0, if pos == 0                                    (sum0)
</span></span><span style="display:flex;"><span>            = seq(pos-1) + sumFact(seq, pos-1), if pos &gt; 0          (sumN)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><h2 id="how-does-the-sequence-sum-fact-work">How does the sequence sum fact work?</h2>
<p>To see how this Logika proof function works for a particular sequence, seq is <code>ZS(5,4,2)</code>. If we were to calculate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>sumFact(seq, seq.size)
</span></span></code></pre></div><p>Then <code>sumFact</code> would initially go into the recursive case, since <code>pos</code> is 3 (and is greater than 0). Thus we would have that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>sumFact(seq, seq.size) = 2 + sumFact(seq, 2)
</span></span></code></pre></div><p><code>sumFact(seq, 2)</code> would also go into the recursive case. Since <code>pos</code> is 2 in this case, it would evaluate to be: <code>4 + sumFact(seq, 1)</code>. Next, <code>sumFact(seq, 1)</code> would evaluate to be: <code>5 + sumFact(seq, 0)</code>, and then <code>sumFact(seq, 0)</code> would reach our base case and would evaluate to 0.</p>
<p>Since <code>sumFact(seq, 0)</code> is 0, we now have that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>sumFact(seq, 1) = 5 + sumFact(seq, 0) = 5 + 0 = 5
</span></span></code></pre></div><p>And then we can plug in 5 for <code>sumFact(seq, 1)</code> to get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>sumFact(seq, 2) = 4 + sumFact(seq, 1) = 4 + 5 = 9
</span></span></code></pre></div><p>Lastly, we can use <code>sumFact(seq, 2) == 9</code> in our top-level calculation to get that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>sumFact(seq, seq.size) = 2 + sumFact(seq, 2) = 2 + 9 = 11
</span></span></code></pre></div><p>And we see that <code>sumFact</code> has correctly described that the sum of all elements in our <code>ZS(5,4,2)</code> sequence is 11.</p>
<h2 id="finishing-the-sumseq-example">Finishing the <code>sumSeq</code> example</h2>
<p>Now that we have a Logika fact to describe the sum of all the elements in a sequence, we have enough information to write the postcondition and loop invariant for our <code>sumSeq</code> function.</p>
<p>For the function contract, we must consider:</p>
<ul>
<li><em>Precondition</em>: this function will work for all sizes of sequences. For an empty sequence, it will correctly return a sum of 0. We can omit the <code>requires</code> clause from the function contract.</li>
<li><code>modifies</code> clause: this function is NOT modifying its sequence parameter, so we can omit this clause</li>
<li><em>Postcondition</em>: the function is not changing the sequence, so we do not need to describe the final values of each sequence element. We <em>do</em> need to describe what value we are returning, and how it relates to the sequence. We want to use our <code>sumFact</code> proof function to describe that <code>result</code> (our return value) is the sum of all elements in <code>list</code> &ndash; that is, that <code>result == sumFact(list, list.size)</code>.</li>
</ul>
<p>For the loop invariant block, we notice that the loop is NOT changing the sequence. We must include:</p>
<ul>
<li><em>What we are doing with each sequence element, and how that relates to another variable</em>. We can see that <code>total</code> tracks the sum of all elements in the sequence so far &ndash; up to but not including position <code>i</code>. Similar to the postcondition, we want to use our <code>sumFact</code> proof function to claim that <code>small</code> is the sum of the first <code>i</code> elements in <code>list</code> &ndash; that is, that <code>small == sumFact(list, i)</code>.</li>
<li><em>Upper and lower bounds for position variables</em>. Here, <code>i</code> is our position variable. We see that it is initialized to 0, so we will claim that it is always greater than or equal to 0 and less than or equal to the list size.</li>
</ul>
<p>We can now complete the function contract and loop invariant for <code>seqSum</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//What is this Logika fact saying?
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//add all elements from position 0 up to but not including pos
</span></span><span style="display:flex;"><span>//sum(seq, seq.size) - defines adding ALL elements in seq
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>   fact
</span></span><span style="display:flex;"><span>       def sum(seq: ZS, pos: Z): Z
</span></span><span style="display:flex;"><span>           = 0, if pos == 0                                    (sum0)
</span></span><span style="display:flex;"><span>           = seq(pos-1) + sum(seq, pos-1), if pos &gt; 0          (sumN)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def seqSum(list: ZS): Z = {
</span></span><span style="display:flex;"><span>   l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>       ensures
</span></span><span style="display:flex;"><span>           result == sum(list, list.size)
</span></span><span style="display:flex;"><span>   }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   var i: Z = 0
</span></span><span style="display:flex;"><span>   var total: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   while (i &lt; list.size) {
</span></span><span style="display:flex;"><span>       l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>           invariant
</span></span><span style="display:flex;"><span>               //total is the sum of the first i elements
</span></span><span style="display:flex;"><span>               //total = list(0) + list(1) + ... + list(i-1)
</span></span><span style="display:flex;"><span>               total == sum(list, i)
</span></span><span style="display:flex;"><span>               i &gt;= 0
</span></span><span style="display:flex;"><span>               i &lt;= list.size
</span></span><span style="display:flex;"><span>           modifies total, i
</span></span><span style="display:flex;"><span>       }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       total = total + list(i)
</span></span><span style="display:flex;"><span>       i = i + 1
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   return total
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Calling code ///////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var test: ZS = ZS(1,2,3,4)
</span></span><span style="display:flex;"><span>var added: Z = seqSum(test)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(added == 10)
</span></span></code></pre></div><p>If we test this program in Logika&rsquo;s symexe mode, the final assert will hold &ndash; we have enough information to know exactly the sum of a specific sequence.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Global Variables</h1>
    
    
<h2 id="motivation">Motivation</h2>
<p>We will now consider programs with multiple functions that modify a shared pool of <em>global variables</em>. (This is very similar to the concerns in general classes in Java or C#, where multiple methods might edit fields/property values for an object). We want to be sure that global variables will maintain desired ranges and and relationships between one another, even as multiple functions modify their values.</p>
<h2 id="global-variables-in-logika">Global variables in Logika</h2>
<p>A global variable in Logika exists before any function call, and still exists after any function ends.</p>
<h3 id="functions-that-access-global-variables">Functions that access global variables</h3>
<p>Consider the following Logika program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//global variable
</span></span><span style="display:flex;"><span>var feetPerMile: Z = 5280  // feet in a mile mile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def convertToFeet(m : Z): Z = {
</span></span><span style="display:flex;"><span>    val feet: Z = m * feetPerMile
</span></span><span style="display:flex;"><span>    return feet
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/////////// Calling code ////////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var miles: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var totalFeet: Z = 0
</span></span><span style="display:flex;"><span>if (miles &gt;= 0){
</span></span><span style="display:flex;"><span>    totalFeet = convertToFeet(miles)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, <code>feetPerMile</code> is a global variable &ndash; it exists before the <code>convertToFeet</code> function is called, and still exists after <code>convertToFeet</code> ends. In contrast, the <code>feet</code> variable inside <code>convertToFeet</code> is NOT global &ndash; its scope ends when the <code>convertToFeet</code> function returns.</p>
<p>(The <code>miles</code> and <code>totalFeet</code> variables in the calling code do not behave as global variables, as they were declared after any function definition. However, if we did add additional functions after our calling code, then <code>miles</code> and <code>totalFeet</code> would be global to those later functions. In Logika, the scope for any variable declared outside of a function begins at the point in the code where it is declared.)</p>
<p>In the example above, <code>convertToFeet</code> only accesses the <code>feetPerMile</code> global variable. A global variable that is read (but not updated) by a function body can be safely used in the functions precondition and postcondition &ndash; it acts just like an extra parameter to the function. We might edit <code>convertToFeet</code> to have this function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//global variable
</span></span><span style="display:flex;"><span>var feetPerMile: Z = 5280  // feet in a mile mile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def convertToFeet(m : Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //only do conversions on nonnegative distances
</span></span><span style="display:flex;"><span>        requires m &gt;= 0    
</span></span><span style="display:flex;"><span>            //not needed, but demonstrates using global variables in preconditions     
</span></span><span style="display:flex;"><span>            feetPerMile &gt; 5200  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //can use global variable in postcondition    
</span></span><span style="display:flex;"><span>        ensures result == m * feetPerMile
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val feet: Z = m * feetPerMile
</span></span><span style="display:flex;"><span>    return feet
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/////////// Calling code ////////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var miles: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var totalFeet: Z = 0
</span></span><span style="display:flex;"><span>if (miles &gt;= 0){
</span></span><span style="display:flex;"><span>    totalFeet = convertToFeet(miles)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, we cannot assign to a global variable the result of calling a function. That is, <code>totalFeet = convertToFeet(5)</code> is ok, and so is <code>totalFeet = convertToFeet(feetPerMile)</code>, but <code>feetPerMile = convertToFeet(5)</code> is not.</p>
<h3 id="functions-that-modify-global-variables">Functions that modify global variables</h3>
<p>In the Logika language, every global variable that is modified by a function must be listed in that function&rsquo;s <code>modifies</code> clause. Such functions must also describe in their postconditions how these global variables will be changed by the function from their original (pre-function call) values. We will use the notation <code>globalVariableName_in</code> for the value of global variable <code>globalVariableName</code> at the start of the function, just as we did for sequences.</p>
<p>Here is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//global variable
</span></span><span style="display:flex;"><span>var time: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def tick(): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires time &gt; 0
</span></span><span style="display:flex;"><span>        modifies time
</span></span><span style="display:flex;"><span>        ensures time == time_in + 1
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    time = time + 1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, we have a global <code>time</code> variable and a <code>tick</code> function that increases the time by 1 with each function call. Since the <code>tick</code> function changes the <code>time</code> global variable, we must include two things in its function contract:</p>
<ul>
<li>A <code>modifies</code> clause that lists <code>time</code> as one of the global variables modified by this function</li>
<li>A postcondition that describes how the value of <code>time</code> after the function call compares to the value of <code>time</code> just before the function call. The statement <code>time == time_in + 1</code> means: &ldquo;the value of time after the function call equals the value of time just before the function call, plus one&rdquo;.</li>
</ul>
<h2 id="global-invariants">Global invariants</h2>
<p>When we have a program with global variables that are modified by multiple functions, we often want some way to ensure that the global variables always stay within a desired range, or always maintain a particular relationship among each other. We can accomplish these goals with <em>global invariants</em>, which specify what must always be true about global variables.</p>
<h3 id="bank-example">Bank example</h3>
<p>For example, consider the following partial program that represents a bank account:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//global variables
</span></span><span style="display:flex;"><span>var balance: Z = 0
</span></span><span style="display:flex;"><span>var elite: B = false
</span></span><span style="display:flex;"><span>val eliteMin: Z = 1000000 //$1M is the minimum balance for elite status
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//global invariants
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    invariant
</span></span><span style="display:flex;"><span>        //balance should be non-negative
</span></span><span style="display:flex;"><span>        balance &gt;= 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //elite status should reflect if balance is at least a million
</span></span><span style="display:flex;"><span>        elite == (balance &gt;= eliteMin)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def deposit(amount: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //We still need to complete the function contract
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    balance = balance + amount
</span></span><span style="display:flex;"><span>    if (balance &gt;= eliteMin) {
</span></span><span style="display:flex;"><span>        elite = true
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        elite = false
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def withdraw(amount: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //We still need to complete the function contract
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    balance = balance - amount
</span></span><span style="display:flex;"><span>    if (balance &gt;= eliteMin) {
</span></span><span style="display:flex;"><span>        elite = true
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        elite = false
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, we have three global variables: <code>balance</code> (the bank account balance), <code>elite</code> (whether or not the customer has &ldquo;elite status&rdquo; with the bank, which is given to customers maintaining above a certain balance threshold), and <code>eliteMin</code> (a value representing the minimum account balance to achieve elite status). We have two global invariants describing what must always be true about these global variables:</p>
<ul>
<li><code>balance &gt;= 0</code>, which states that the account balance must never be negative</li>
<li><code>elite == (balance &gt;= eliteMin)</code>, which states that the <code>elite</code> boolean flag should always accurately represent whether the customer&rsquo;s current account balance is over the minimum threshold for elite status</li>
</ul>
<h3 id="global-invariants-must-hold-before-each-function-call">Global invariants must hold before each function call</h3>
<p>In any program with global invariants, we either must prove (in manual mode) or their must be sufficient evidence (in symexe mode) that each global invariant holds immediately before any function call (including when the program first begins, before any function call). In our bank example, we see that the global variables are initialized as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var balance: Z = 0
</span></span><span style="display:flex;"><span>var elite: B = false
</span></span><span style="display:flex;"><span>val eliteMin: Z = 1000000
</span></span></code></pre></div><p>In symexe mode, there is clearly enough evidence that the global invariants all hold with those initial values &ndash; the balance is nonnegative, and the customer correctly does not have elite status (because they do not have about the $1,000,000 threshold).</p>
<h3 id="global-invariants-must-still-hold-at-the-end-of-each-function-call">Global invariants must still hold at the end of each function call</h3>
<p>Since we must demonstrate that global invariants hold before each function call, functions themselves can assume the global invariants are true at the beginning of the function. If we were using manual mode, we could list each global invariant as a <code>premise</code> at the beginning of the function &ndash; much like we do with preconditions. Then, it is the job of each function to ensure that the global invariants STILL hold when the function ends. In manual mode, we would need to demonstrate that each global invariant claim <code>globalInvariant</code> still held in a logic block just before the end of the function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //each global invariant must still hold at the end of the function
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    1. globalInvariant              (some justification)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>In symexe mode, we do not need to include such logic blocks, but there must be sufficient detail in the function contract to infer that each global invariant will hold no matter what at the end of the function.</p>
<h3 id="bank-function-contracts">Bank function contracts</h3>
<p>Consider the <code>deposit</code> function in our bank example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def deposit(amount: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //We still need to complete the function contract
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    balance = balance + amount
</span></span><span style="display:flex;"><span>    if (balance &gt;= eliteMin) {
</span></span><span style="display:flex;"><span>        elite = true
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        elite = false
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since <code>deposit</code> is modifying the global variables <code>balance</code> and <code>elite</code>, we know we must include two things in its function contract:</p>
<ul>
<li>A <code>modifies</code> clause that lists <code>balance</code> and <code>elite</code> as global variables modified by this function</li>
<li>A postcondition that describes how the value of <code>balance</code> after the function call compares to the value of <code>balance</code> just before the function call. We want to say, <code>balance == balance_in + amount</code>, because the value of <code>balance</code> at the end of the function equals the value of <code>balance</code> at the beginning of the function, plus <code>amount</code>.</li>
</ul>
<p>We also must consider how the <code>elite</code> variable changes as a result of the function call. In the code, we use an if/else statement to ensure that <code>elite</code> gets correctly updated if the customer&rsquo;s new balance is above or below the threshold for elite status. If we were to write a postcondition that summarized how <code>elite</code> was updated by the function, we would write: <code>elite == (balance &gt;= eliteMin)</code> to say that the value of elite after the function equaled whether the new balance was above the threshold. However, this claim is already a global invariant, which already must hold at the end of the function. We do not need to list it again as a postcondition.</p>
<p>Consider this potential function contract for <code>deposit</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def deposit(amount: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //this function contract is not quite correct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        modifies balance, elite
</span></span><span style="display:flex;"><span>        ensures balance == balance_in + amount
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    balance = balance + amount
</span></span><span style="display:flex;"><span>    if (balance &gt;= eliteMin) {
</span></span><span style="display:flex;"><span>        elite = true
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        elite = false
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function contract is close to correct, but contains a major flaw. In symexe mode, the function contract must be tight enough to guarantee that the global invariants will still hold after the function ends. Suppose <code>balance</code> still has its starting value of 0, and that we called <code>deposit(-100)</code>. With no other changes, the function code would dutifully update the <code>balance</code> global variable to be -100&hellip;which would violate the global invariant that <code>balance &gt;= 0</code>. In order to guarantee that the balance will never be negative after the <code>deposit</code> function ends, we must restrict the deposit amounts to be greater than or equal to 0. Since functions are can assume that the global invariants hold when they are called, we know that <code>balance</code> will be 0 at minimum at the beginning of <code>deposit</code>. If <code>amount</code> is also nonnegative, we can guarantee that the value of <code>balance</code> at the end of the <code>deposit</code> function will be greater than or equal to 0 &ndash; thus satisfying our global invariant.</p>
<p>Here is the corrected <code>deposit</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def deposit(amount: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires amount &gt;= 0
</span></span><span style="display:flex;"><span>        modifies balance, elite
</span></span><span style="display:flex;"><span>        ensures balance == balance_in + amount
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    balance = balance + amount
</span></span><span style="display:flex;"><span>    if (balance &gt;= eliteMin) {
</span></span><span style="display:flex;"><span>        elite = true
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        elite = false
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can similarly write the function contract for the <code>withdraw</code> function. Since withdraw is subtracting an amount from the balance, we must require that the withdraw amount be less than or equal to the account balance &ndash; otherwise, the account balance might become negative, and we would violate the global invariant. We will also require that our withdrawal amount be nonnegative, as it doesn&rsquo;t make any sense to withdraw a negative amount from a bank account:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def withdraw(amount: Z): Unit = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires amount &gt;= 0
</span></span><span style="display:flex;"><span>            amount &lt;= balance
</span></span><span style="display:flex;"><span>        modifies balance, elite
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            balance == balance_in - amount
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    balance = balance - amount
</span></span><span style="display:flex;"><span>    if (balance &gt;= eliteMin) {
</span></span><span style="display:flex;"><span>        elite = true
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        elite = false
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="bank-calling-code">Bank calling code</h3>
<p>When we call a function in a program with global invariants (whether in the calling code or from another function), we must consider four things:</p>
<ul>
<li>We must demonstrate that all global variables hold before the function call</li>
<li>We must demonstrate that the preconditions for the function holds</li>
<li>We can assume that all global variables hold after the function call (as the function itself if responsible for showing that the global invariants still hold just before the function ends)</li>
<li>We can assume the postcondition for the function holds after the function call</li>
</ul>
<p>Suppose we had this test code at the end of our bank program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>deposit(500000)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//Assert will hold
</span></span><span style="display:flex;"><span>assert(balance == 500000 &amp; elite == false)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>deposit(500000)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//Assert will hold
</span></span><span style="display:flex;"><span>assert(balance == 1000000 &amp; elite == true)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//Precondition will not hold
</span></span><span style="display:flex;"><span>withdraw(2000000)
</span></span></code></pre></div><p>We already showed how our global invariants initially held for the starting values of the global variables (<code>balance = 0</code> and <code>elite = false</code>). When we consider the first function call, <code>deposit(500000)</code>, we can also see that the precondition holds (we are depositing a non-negative amount). The <code>deposit</code> postcondition tells us that the new value of <code>balance</code> is 500000 more than it was before the function call, so we know balance is now 500000. We can also assume that all global invariants hold after the <code>deposit</code> call, so we can infer that <code>elite</code> is still false (since the balance is not more than the threshold). Thus the next assert statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(balance == 500000 &amp; elite == false)
</span></span></code></pre></div><p>will hold in Logika&rsquo;s symexe mode.</p>
<p>The very next statement in the calling code is another call to <code>deposit</code>. Since we could assuem the global invariants held immediately after the last call to deposit, we can infer that they still hold before the next <code>deposit</code> call. We also see that the function&rsquo;s precondition is satisified, as we are depositing another nonnegative value. Just as before, we can use the <code>deposit</code> postcondition to see that <code>balance</code> will be 1000000 after the next function call (the postcondition tells us that <code>balance</code> is 500000 more than it was just before the function call). We also know that the global invariants hold, so we are sure <code>elite</code> has been updated to true. Thus our next assert holds as well:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(balance == 1000000 &amp; elite == true)
</span></span></code></pre></div><p>Our final function call, <code>withdraw(2000000)</code>, will not be allowed. We are trying to withdraw $2,000,000, but our account balance at this point is $1,000,000. We will get an error saying that the <code>withdraw</code> precondition has not been satisified, as that function requires that our withdrawal amount be less than or equal to the account balance.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Termination</h1>
    
    
<h2 id="what-is-termination">What is termination?</h2>
<p>In this section, we will consider the notion of <em>termination</em> &ndash; whether a function will ever finish running.</p>
<h2 id="partial-correctness-vs-total-correctness">Partial correctness vs total correctness</h2>
<p>Up to this point, we have proved <em>partial correctness</em> for functions &ndash; IF the function&rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.</p>
<h3 id="example-of-partial-correctness">Example of partial correctness</h3>
<p>Consider the following version of our <code>mult</code> function, which uses repeated addition to multiply two numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def mult(m: Z, n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ensures result == m*n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == m*count
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + m
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function will be verified in Logika&rsquo;s symexe mode, but in fact it has a subtle flaw. If we were to pass in <code>-1</code> for our second parameter (<code>n</code>), then we would get stuck in an infinite loop. <code>count</code> would be initially 0, and we would increment <code>count</code> each time in the loop, but of course it NEVER equal -1.</p>
<p>This is an example of partial correctness &ndash; if our function DOES finish (which it would for nonnegative values of <code>n</code>), then we have shown it will return the correct value. We can see that we will need to require that the <code>n</code> parameter be nonnegative .</p>
<h3 id="total-correctness-definition">Total correctness definition</h3>
<p><em>Total correctness</em> goes a step further than partial correctness &ndash; it says that IF the function&rsquo;s precondition holds, THEN we promise that it will terminate and that its postcondition will hold.</p>
<p>In order to show total correctness for our <code>mult</code> function, we must show that it always terminates.</p>
<h2 id="process-of-proving-termination">Process of proving termination</h2>
<p>We will see later in this section that the idea of termination is a much more challenging topic than it might seem. There is no button in Logika that will check for termination, but we can often insert manual assertions which, if they are verified, will guarantee termination. We will show how to create such manual assertions for simple loops that execute a set number of times.</p>
<p>First, we need to come up with a way to measure (as an integer) how much work the loop has left to do. Using this measure of work, we want to show two things:</p>
<ul>
<li>Each loop iteration decreases the integer measure (i.e., the amount of work left to do is strictly decreasing)</li>
<li>When our integer measure is 0 or less, then we are certain that we are done (i.e., the loop exits)</li>
</ul>
<h2 id="termination-in-mult">Termination in mult</h2>
<p>In our <code>mult</code> example, let&rsquo;s first try to establish an integer measure of work for the loop. We know that the loop is computing <code>m + m + ... + m</code>, for a total of <code>n</code> additions. When <code>count</code> is 0, we know we have <code>n</code> more additions to do (<code>n</code> more iterations of the loop). When <code>count</code> is 1, we know we have <code>n-1</code> more additions&hellip;and when <code>count</code> is <code>n</code>, we know that we have no more additions to do (and the loop ends). Our measure of work should be the number of additions left to do, which is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Measure of work: n - count
</span></span></code></pre></div><p>We can calculate this measure at the beginning of each iteration and again at the end of each iteration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (count != n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == m*count
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //get measure value at beginning of iteration
</span></span><span style="display:flex;"><span>    val measureBegin: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + m
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //get measure value at end of iteration
</span></span><span style="display:flex;"><span>    val measureEnd: Z = n-count
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, we want to assert that <code>measureEnd &lt; measureBegin</code> &ndash; that the amount of work decreases with each iteration. We can also assert that <code>measureEnd &gt; 0 | count == n</code> &ndash; that either we have more work to do, or our loop condition is false (meaning that if we have no more work to do, then our loop condition must be false and thus terminate):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def mult(m: Z, n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //needed for termination
</span></span><span style="display:flex;"><span>        ensures result == m*n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == m*count
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at beginning of iteration
</span></span><span style="display:flex;"><span>        val measureBegin: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + m
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at end of iteration
</span></span><span style="display:flex;"><span>        val measureEnd: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we are making progress
</span></span><span style="display:flex;"><span>        //the amount of work decreases with each iteration
</span></span><span style="display:flex;"><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we either have more work, or the loop will terminate
</span></span><span style="display:flex;"><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style="display:flex;"><span>        assert(measureEnd &gt; 0 | count == n)     //NOTE: will not hold!
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we try verifying this program in Logika, the second assert, <code>assert(measureEnd &gt; 0 | count == n)</code> will not hold. To see why, let&rsquo;s suppose that <code>measureEnd &lt;= 0</code>. For the assert to be true, we would need to be certain that <code>count == n</code> (since the left side of the OR would be false). Because <code>measureEnd = n-count</code>, we can infer that <code>count &gt;= n</code> when <code>measureEnd &lt;= 0</code>. However, Logika is unable to infer that <code>count == n</code> from the knowledge that <code>count &gt;= n</code> unless it also knows that <code>count &lt;= n</code> always holds. We can add this knowledge by strengthening our loop invariant to provide a range for the loop counter &ndash; <code>count &gt;= 0</code> and <code>count &lt;= n</code>. Even if not required, it is a good habit anyway to include the loop counter range as part of the loop invariant.</p>
<p>We strengthen our loop invariant, and both asserts will hold &ndash; thus demonstrating termination:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def mult(m: Z, n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //needed for termination
</span></span><span style="display:flex;"><span>        ensures result == m*n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == m*count
</span></span><span style="display:flex;"><span>                count &gt;= 0
</span></span><span style="display:flex;"><span>                count &lt;= n      //bound loop counter
</span></span><span style="display:flex;"><span>                                //needed for assert to hold
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at beginning of iteration
</span></span><span style="display:flex;"><span>        val measureBegin: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + m
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at end of iteration
</span></span><span style="display:flex;"><span>        val measureEnd: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we are making progress
</span></span><span style="display:flex;"><span>        //the amount of work decreases with each iteration
</span></span><span style="display:flex;"><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we either have more work, or the loop will terminate
</span></span><span style="display:flex;"><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style="display:flex;"><span>        assert(measureEnd &gt; 0 | count == n) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We could similarly use measures of work and manual assert statements to prove termination in some recursive functions. Here, we would demonstrate that a parameter value decreased with each recursive call, and that we either had more work to do or had reached the base case of our recursion (with no more recursive calls needed).</p>
<h2 id="collatz-function">Collatz function</h2>
<p>While it is possible to prove termination for certain kinds of programs &ndash; those that loop or make recursive calls a set number of times &ndash; it is not possible to prove termination for all programs.</p>
<p>Consider the <code>collatz</code> function below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>def collatz(m: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires m &gt; 0
</span></span><span style="display:flex;"><span>        ensures result == 1
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var n: Z = m
</span></span><span style="display:flex;"><span>    while (n &gt; 1) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant n &gt;= 1
</span></span><span style="display:flex;"><span>            modifies n
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (n % 2 == 0) {
</span></span><span style="display:flex;"><span>            n = n / 2
</span></span><span style="display:flex;"><span>        } else {
</span></span><span style="display:flex;"><span>            n = 3 * n + 1
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return n
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We see that we must pass <code>collatz</code> a positve parameter, and that it promises to return 1 (no matter what the parameter is). It contains a loop that repeatedly modifies a current value (which is initially the parameter value):</p>
<ul>
<li>If the current number is even, we divide the number by 2</li>
<li>If the current number is odd, we triple the number and add 1</li>
</ul>
<p>Suppose we compute <code>collatz(17)</code>. We can track the value of <code>n</code> as follows: 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. We can see that <code>n</code> does eventually reach 1, and that the program terminates in that case. We can similarly try other parameters, and will again see that we always end up with 1 (sometimes after a surprising number of iterations). But in fact:</p>
<ul>
<li>No one has proved that the Collatz function terminates for all postiive numbers; and</li>
<li>No one has found a positive number on which the Collatz function does not terminate</li>
</ul>
<h2 id="decidability-and-the-halting-problem">Decidability and the Halting problem</h2>
<p>It is an obvious question whether we could write a program to check whether another program always terminates. Unfortunately, this (the <em>Halting problem</em>) turns out to be impossible, as was demonstrated by Alan Turing. The Halting problem is an example of an <em>undecidable</em> problem in computer science &ndash; a decision problem (a problem with a yes/no answer) that we can&rsquo;t correctly answer one way or another on all inputs, even if we have unlimited resources.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
            </section>
        </div>
      </main>
    
<div class="git-footer">
<p>Last modified by: 
            <i class='fas fa-user'></i> Julie Thornton
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/d9ba63f4d574d493a0ed46a6b0e578c76d37dd8b">Aug 3, 2022</a>
</p>
</div>

    
    </div>
    
    
    
    
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">

<a id="logo" href="https://ksu-cs-textbooks.github.io/cis301/">
  CIS 301: Logical Foundations of Programming
</a>

        </div>
        <div class="searchbox default-animation">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/auto-complete.js?1662576092" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.min.js?1662576092" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.stemmer.support.min.js?1662576092" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.multi.min.js?1662576092" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.en.min.js?1662576092" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/search.js?1662576092" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics collapsible-menu">
          <li data-nav-id="/0-chapter/" title="Getting Started" class="dd-item"><input type="checkbox" id="section-c55c9f751a28ecc9415234375cddd395" class="toggle"/><label for="section-c55c9f751a28ecc9415234375cddd395" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/"><b>0. </b>Getting Started</a><ul>
          <li data-nav-id="/0-chapter/0_1-toolsguide/" title="Tools Guide" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/0_1-toolsguide/">0.1. Tools Guide</a></li></ul></li>
          <li data-nav-id="/1-chapter/" title="Basics and Logic Puzzles" class="dd-item"><input type="checkbox" id="section-7a71fe25dd66b523fca4004b7c4d01d0" class="toggle"/><label for="section-7a71fe25dd66b523fca4004b7c4d01d0" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/"><b>1. </b>Basics and Logic Puzzles</a><ul>
          <li data-nav-id="/1-chapter/1_1-logicbasics/" title="Basic Logical Reasoning" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_1-logicbasics/">1.1. Basic Logical Reasoning</a></li>
          <li data-nav-id="/1-chapter/1_2-knightsknaves/" title="Knights and Knaves" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_2-knightsknaves/">1.2. Knights and Knaves</a></li>
          <li data-nav-id="/1-chapter/1_3-otherpuzzles/" title="Other Puzzles" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_3-otherpuzzles/">1.3. Other Puzzles</a></li></ul></li>
          <li data-nav-id="/2-chapter/" title="Truth Tables" class="dd-item"><input type="checkbox" id="section-c23f766dd7728aa0e1cff094001eac05" class="toggle"/><label for="section-c23f766dd7728aa0e1cff094001eac05" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/"><b>2. </b>Truth Tables</a><ul>
          <li data-nav-id="/2-chapter/2_1-opscircuits/" title="Operators and Circuits" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_1-opscircuits/">2.1. Operators and Circuits</a></li>
          <li data-nav-id="/2-chapter/2_2-logikatruth/" title="Truth Tables in Logika" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_2-logikatruth/">2.2. Truth Tables in Logika</a></li>
          <li data-nav-id="/2-chapter/2_3-satis/" title="Satisfiability" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_3-satis/">2.3. Satisfiability</a></li>
          <li data-nav-id="/2-chapter/2_4-logicalequiv/" title="Logical Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/">2.4. Logical Equivalence</a></li>
          <li data-nav-id="/2-chapter/2_5-sementail/" title="Semantic Entailment" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_5-sementail/">2.5. Semantic Entailment</a></li></ul></li>
          <li data-nav-id="/3-chapter/" title="Propositional Logic Translations" class="dd-item"><input type="checkbox" id="section-ccb531d159d5247057d21618514721b6" class="toggle"/><label for="section-ccb531d159d5247057d21618514721b6" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/"><b>3. </b>Propositional Logic Translations</a><ul>
          <li data-nav-id="/3-chapter/3_1-propatom/" title="Propositional Atoms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_1-propatom/">3.1. Propositional Atoms</a></li>
          <li data-nav-id="/3-chapter/3_2-notandor/" title="NOT, AND, OR Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_2-notandor/">3.2. NOT, AND, OR Translations</a></li>
          <li data-nav-id="/3-chapter/3_3-implies/" title="Implies Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_3-implies/">3.3. Implies Translations</a></li>
          <li data-nav-id="/3-chapter/3_4-equiv/" title="Equivalent Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_4-equiv/">3.4. Equivalent Translations</a></li>
          <li data-nav-id="/3-chapter/3_5-knightsknavestt/" title="Knights and Knaves, revisited" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_5-knightsknavestt/">3.5. Knights and Knaves, revisited</a></li></ul></li>
          <li data-nav-id="/4-chapter/" title="Propositional Logic Proofs" class="dd-item"><input type="checkbox" id="section-8ebf970484325d93d52075c7c72ba517" class="toggle"/><label for="section-8ebf970484325d93d52075c7c72ba517" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/"><b>4. </b>Propositional Logic Proofs</a><ul>
          <li data-nav-id="/4-chapter/4_1-intro/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_1-intro/">4.1. Introduction</a></li>
          <li data-nav-id="/4-chapter/4_2-andrules/" title="AND Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_2-andrules/">4.2. AND Rules</a></li>
          <li data-nav-id="/4-chapter/4_3-orrules/" title="OR Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_3-orrules/">4.3. OR Rules</a></li>
          <li data-nav-id="/4-chapter/4_4-impliesrules/" title="Implies Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_4-impliesrules/">4.4. Implies Rules</a></li>
          <li data-nav-id="/4-chapter/4_5-notrules/" title="Negation Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_5-notrules/">4.5. Negation Rules</a></li>
          <li data-nav-id="/4-chapter/4_6-strategies/" title="Summary and Strategies" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_6-strategies/">4.6. Summary and Strategies</a></li>
          <li data-nav-id="/4-chapter/4_7-theorems/" title="Theorems" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/">4.7. Theorems</a></li>
          <li data-nav-id="/4-chapter/4_8-equivalence/" title="Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_8-equivalence/">4.8. Equivalence</a></li>
          <li data-nav-id="/4-chapter/4_9-soundcomplete/" title="Soundness and Completeness" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_9-soundcomplete/">4.9. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/5-chapter/" title="Predicate Logic Translations" class="dd-item"><input type="checkbox" id="section-b69c30f957b0ff55c1e9673979ceb29d" class="toggle"/><label for="section-b69c30f957b0ff55c1e9673979ceb29d" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/"><b>5. </b>Predicate Logic Translations</a><ul>
          <li data-nav-id="/5-chapter/5_1-motivation/" title="Motivation" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_1-motivation/">5.1. Motivation</a></li>
          <li data-nav-id="/5-chapter/5_2-predsyntax/" title="Syntax" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_2-predsyntax/">5.2. Syntax</a></li>
          <li data-nav-id="/5-chapter/5_3-singlequantifier/" title="Single Quantifier" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_3-singlequantifier/">5.3. Single Quantifier</a></li>
          <li data-nav-id="/5-chapter/5_4-multquant/" title="Multiple Quantifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_4-multquant/">5.4. Multiple Quantifiers</a></li></ul></li>
          <li data-nav-id="/6-chapter/" title="Predicate Logic Proofs" class="dd-item"><input type="checkbox" id="section-482218cb3a05b9572157ed70ed9a5c02" class="toggle"/><label for="section-482218cb3a05b9572157ed70ed9a5c02" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/"><b>6. </b>Predicate Logic Proofs</a><ul>
          <li data-nav-id="/6-chapter/6_1-univrules/" title="Rules with ∀" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_1-univrules/">6.1. Rules with ∀</a></li>
          <li data-nav-id="/6-chapter/6_2-existrules/" title="Rules with ∃" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_2-existrules/">6.2. Rules with ∃</a></li>
          <li data-nav-id="/6-chapter/6_3-nested/" title="Nested Quantifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_3-nested/">6.3. Nested Quantifiers</a></li>
          <li data-nav-id="/6-chapter/6_4-equiv/" title="Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_4-equiv/">6.4. Equivalence</a></li>
          <li data-nav-id="/6-chapter/6_5-strategies/" title="Summary and Strategies" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_5-strategies/">6.5. Summary and Strategies</a></li>
          <li data-nav-id="/6-chapter/6_6-soundcomplete/" title="Soundness and Completeness" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/">6.6. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/7-chapter/" title="Mathematical Induction" class="dd-item"><input type="checkbox" id="section-fc25ecfcb3d8e929949e8db759e88bab" class="toggle"/><label for="section-fc25ecfcb3d8e929949e8db759e88bab" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/"><b>7. </b>Mathematical Induction</a><ul>
          <li data-nav-id="/7-chapter/7_1-process/" title="Induction Process" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_1-process/">7.1. Induction Process</a></li>
          <li data-nav-id="/7-chapter/7_2-algebraex/" title="Algebra example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_2-algebraex/">7.2. Algebra example</a></li>
          <li data-nav-id="/7-chapter/7_3-divex/" title="Divisibility example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_3-divex/">7.3. Divisibility example</a></li>
          <li data-nav-id="/7-chapter/7_4-setex/" title="Set example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_4-setex/">7.4. Set example</a></li></ul></li>
          <li data-nav-id="/8-chapter/" title="Intro to Programming Logic" class="dd-item"><input type="checkbox" id="section-bd411d4b09a07aa69f5152043fa837ed" class="toggle"/><label for="section-bd411d4b09a07aa69f5152043fa837ed" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/"><b>8. </b>Intro to Programming Logic</a><ul>
          <li data-nav-id="/8-chapter/8_1-goal/" title="Programming Logic Goal" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_1-goal/">8.1. Programming Logic Goal</a></li>
          <li data-nav-id="/8-chapter/8_2-logikaprograms/" title="Logika Programs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_2-logikaprograms/">8.2. Logika Programs</a></li>
          <li data-nav-id="/8-chapter/8_3-assertassume/" title="Assert and Assume" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_3-assertassume/">8.3. Assert and Assume</a></li>
          <li data-nav-id="/8-chapter/8_4-algebrasubst/" title="Algebra and subst Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_4-algebrasubst/">8.4. Algebra and subst Rules</a></li>
          <li data-nav-id="/8-chapter/8_5-assignment/" title="Assignment Statements" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/">8.5. Assignment Statements</a></li>
          <li data-nav-id="/8-chapter/8_6-divmod/" title="Integer Division and Modulo" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_6-divmod/">8.6. Integer Division and Modulo</a></li>
          <li data-nav-id="/8-chapter/8_7-conditionals/" title="Conditional Statements" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_7-conditionals/">8.7. Conditional Statements</a></li></ul></li>
          <li data-nav-id="/9-chapter/" title="Functions and Loops" class="dd-item"><input type="checkbox" id="section-708a4026c5b157dd8da0a277e359073f" class="toggle"/><label for="section-708a4026c5b157dd8da0a277e359073f" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/"><b>9. </b>Functions and Loops</a><ul>
          <li data-nav-id="/9-chapter/9_1-functions/" title="Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/">9.1. Functions</a></li>
          <li data-nav-id="/9-chapter/9_2-recursion/" title="Recursion" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_2-recursion/">9.2. Recursion</a></li>
          <li data-nav-id="/9-chapter/9_3-loops/" title="Loops" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/">9.3. Loops</a></li>
          <li data-nav-id="/9-chapter/9_4-logikafacts/" title="Logika Facts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/">9.4. Logika Facts</a></li>
          <li data-nav-id="/9-chapter/9_5-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_5-summary/">9.5. Summary</a></li></ul></li>
          <li data-nav-id="/10-chapter/" title="Sequences, Globals, and Termination" class="dd-item"><input type="checkbox" id="section-83e8e84779c32ba319a378089810947b" class="toggle"/><label for="section-83e8e84779c32ba319a378089810947b" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/"><b>10. </b>Sequences, Globals, and Termination</a><ul>
          <li data-nav-id="/10-chapter/10_1-modes/" title="Logika Modes" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_1-modes/">10.1 Logika Modes</a></li>
          <li data-nav-id="/10-chapter/10_2-intosequences/" title="Intro to Sequences" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_2-intosequences/">10.2 Intro to Sequences</a></li>
          <li data-nav-id="/10-chapter/10_3-seqfn/" title="Sequences in Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_3-seqfn/">10.3 Sequences in Functions</a></li>
          <li data-nav-id="/10-chapter/10_4-seqloop/" title="Sequences in Loops" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_4-seqloop/">10.4 Sequences in Loops</a></li>
          <li data-nav-id="/10-chapter/10_5_seqlogfact/" title="Logika Facts, revisited" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_5_seqlogfact/">10.5 Logika Facts, revisited</a></li>
          <li data-nav-id="/10-chapter/10_6-globals/" title="Global Variables" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_6-globals/">10.6 Global Variables</a></li>
          <li data-nav-id="/10-chapter/10_7-termination/" title="Termination" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/">10.7 Termination</a></li></ul></li>
        </ul>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch showVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="variants.changeVariant( this.value );">
                    <option id="light-theme" value="light-theme" selected>Light Theme</option>
                    <option id="dark-theme" value="dark-theme">Dark Theme</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter"><style>
  #footer {
      font-size: 13px;
      margin-left: auto;
      margin-right: auto;
      padding: 2rem 1rem;
      min-width: 230px;
      max-width: 300px;
  }
  #footer p {
      margin: 0;
  }
</style>
  
<p>Built using <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/K-State-Computational-Core/hugo-theme-relearn/tree/main">Hugo Relearn Theme</a>.</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; margin: .5rem auto" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p>

        </div>
      </div>
    </aside>
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1662576092" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1662576092" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/featherlight.min.js?1662576092" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign({
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://ksu-cs-textbooks.github.io/cis301/js/mathjax/tex-mml-chtml.js?1662576092"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1662576092" defer></script>
    
    
    
    
  </body>
</html>
