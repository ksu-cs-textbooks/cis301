<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.0.3+tip">




	
	
			

	
	
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Functions and Loops :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/" rel="canonical" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/index.xml" rel="alternate" type="application/rss+xml" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/tele.html" rel="alternate" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/embed.html" rel="alternate" type="text/html" title="CIS 301 Textbook">
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1662241024" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1662241024" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1662241024" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <noscript>
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1662241024" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1662241024" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1662241024" rel="stylesheet">
    </noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1662241024" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1662241024" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1662241024" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1662241024" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-light-theme.css?1662241024" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1662241024" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1662241024" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1662241024" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1662241024"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis301/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1662241024" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/jquery.min.js?1662241024" defer></script>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/9-chapter/">
    
    
    <div id="body" class="default-animation">
      
      
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/" title="Functions (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <a class="nav nav-prev" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_7-conditionals/" title="Conditional Statements (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-print-link">
            <a class="print-link" title='Print whole chapter (CTRL+ALT+p)' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/_print/">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="top-github-link">
            <a class="github-link" title='Edit (CTRL+ALT+e)' href="https://gitlab.cs.ksu.edu/-/ide/project/cs-textbooks/cis301-textbook/edit/master/-/content/9-chapter/_index.md" target="blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span id="toc-menu" title='Table of Contents (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="2" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/"><span itemprop="name">Homepage</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/" aria-disabled="true"><span itemprop="name">Functions and Loops</span></a></li>
            </ol>
          </div>
          <div class="default-animation progress">
            <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#chapter-9">Chapter 9</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </div>
          </div>
        </div>
      </nav>
      
      
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
          <article class="chapter deprecated">

<h3 id="chapter-9">Chapter 9</h3>
<h1 id="programming-logic-functions-and-loops">Programming Logic: Functions and Loops</h1>
<p>In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
    
          <article class="default">
    
    
<h1>Functions</h1>
    
    
<p>A <em>function</em> in Logika is analogous to a method in Java or C# &ndash; it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def functionName(paramList): returnType = {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We will use the keyword <code>Unit</code> (like <code>void</code> in other languages) for a function that does not return a value. If a function has a non-<code>Unit</code> return type, then all paths through the function must end in a return statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>return expression
</span></span></code></pre></div><p>Where <code>expression</code> is a variable, literal, or expression matching <code>returnType</code>.</p>
<h2 id="function-contracts">Function contracts</h2>
<p>In order to prove the correctness of a function, it must include a <em>function contract</em> just inside the function header. This function contract specifies what we need to know to use the function correctly. While we will use these specifications to help us prove correctness, they are good to include in ANY library function that will be used by someone else (even more informally in other languages). <em>The person/program who calls the function is not supposed to read the function&rsquo;s code to know how to use the function</em>. A function contract shows them what parameters to pass (including what range of values are acceptable), what the function will return in terms of the parameter, and whether/how the function will modify things like sequences (arrays/lists in other languages) or global variables.</p>
<p>Here is the syntax for a function contract in Logika:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    requires (preconditions)
</span></span><span style="display:flex;"><span>    modifies (variable list)
</span></span><span style="display:flex;"><span>    ensures (postconditions)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Here is a summary of the different function contract clauses:</p>
<ul>
<li><code>requires</code>: lists the <em>preconditions</em> for the function. We can also use the keyword <code>pre</code> instead of <code>requires</code>. If there are no preconditions, we can skip this clause. If we have multiple preconditions, we can list them on separate lines (where subsequent lines are tabbed over under <code>requires</code>).</li>
<li><code>modifies</code>: lists the name of any sequence parameters and/or global variables that are modified by the function. We can skip this clause until chapter 10, when we will see sequences and global variables.</li>
<li><code>ensures</code>: lists the <em>postconditions</em> for the function. We can also use the keyword <code>post</code> instead of <code>ensures</code>. If we have multiple postconditions, we can list them on separate lines (where subsequent lines are tabbed over under <code>ensures</code>).</li>
</ul>
<h3 id="preconditions">Preconditions</h3>
<p>The <em>preconditions</em> for a function are requirements the function has in order to operate correctly. Generally, preconditions constrain the values of the parameters and/or global variables. For example, this function returns the integer division between two parameters. The function can only operate correctly when the denominator (the second parameter, <code>b</code>) is non-zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Logika will throw an error if any preconditions are not proven before calling a function. Because we are required to prove the preconditions before any function call, the function itself can list the preconditions as premises in a logic block just after the function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def example(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires precondition1
</span></span><span style="display:flex;"><span>            precondition2
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we can list the preconditions as premises
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. precondition1            premise
</span></span><span style="display:flex;"><span>        2. precondition2            premise
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="postconditions">Postconditions</h3>
<p>The <em>postconditions</em> of a function state what the function has accomplished when it terminates. In particular, postconditions should include:</p>
<ul>
<li>
<p>A formalization of what the function promises to return in terms of the parameters/global variables. We can use the keyword <code>result</code> to refer to the object returned by the function (we will only use this keyword in the function contract).</p>
</li>
<li>
<p>A description of how any global variables and/or sequence parameters will be modified by the function (we will not use global variables or sequences until chapter 10).</p>
</li>
</ul>
<p>For example, the <code>div</code> function above should promise to return the integer division of its two parameters, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to prove a postcondition involving the return value, we must have logic blocks just before returning that demonstrate each postcondition claim, using the variable name being returned instead of the <code>result</code> keyword. In the example above, since we are returning a variable named <code>ans</code>, then we must prove the claim <code>ans == a/b</code> in order to satisfy the postcondition. We can complete the verification of the <code>div</code> function as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. b != 0               premise     //precondition (needed for division)
</span></span><span style="display:flex;"><span>        2. ans == a/b           premise     //satisifies the postcondition
</span></span><span style="display:flex;"><span>                                            //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Logika will throw an error if postconditions are not proven before leaving a function. Because we are required to prove the postconditions before the function ends, any calling code can list those postconditions as premises after calling the function. We will see this in more detail in the next section.</p>
<h2 id="work-of-the-calling-code">Work of the calling code</h2>
<p>We saw above that when writing code that calls a function, we must PROVE the preconditions before the function call (since the function requires that we meet those preconditions in order to work correctly). After the function terminates, the calling code can list the function&rsquo;s postconditions as PREMISES (since the function ensured that certain things would happen).</p>
<p>Below, we will see the syntax for the verification of code that calls a function. We will refer to our finished <code>div</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. b != 0               premise     //precondition (needed for division)
</span></span><span style="display:flex;"><span>        2. ans == a/b           premise     //satisifies the postcondition
</span></span><span style="display:flex;"><span>                                            //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The &ldquo;calling code&rdquo; in Logika goes outside of any function definition. Typically, I place the calling code at the bottom of the Logika file, after all functions. Recall that this is the code executed first by Logika, just like in Python programs.</p>
<h3 id="proving-preconditions">Proving preconditions</h3>
<p>Suppose we wish to call the <code>div</code> function to divide two numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x, y)
</span></span></code></pre></div><p>If we included that calling code in a Logika file with our <code>div</code> function, we would see an error that we had not yet proved the precondition. To prove each precondition, we must have a logic block just before the function call that demonstrate each precondition claim, using value being passed instead of the parameter name. Since we are passing the value <code>y</code> as our second parameter, and since the <code>div</code> function requires that <code>b != 0</code> (where <code>b</code> is the second parameter), then we must demonstrate that <code>y != 0</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y != 0               algebra 2   //satisifies the precondition for div
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x, y)
</span></span></code></pre></div><p>Note that Logika is picky about proving the precondition using EXACTLY the value being passed for the corresponding parameter. For example, suppose instead that we wanted to divide <code>x-1</code> and <code>y+1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y != 0               algebra 2   //NO! precondition is not satisifed!
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span></code></pre></div><p>If we made no changes to our logic block, Logika would complain that we had not satisfied the precondition. And indeed we haven&rsquo;t &ndash; while we&rsquo;ve shown that <code>y</code> isn&rsquo;t 0, we haven&rsquo;t shown that our second parameter <code>y+1</code> isn&rsquo;t 0. Here is the correction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span></code></pre></div><h3 id="using-postconditions">Using postconditions</h3>
<p>Recall that since the function is ensuring that it will do/return specific things (its postconditions), then the calling code can list those postconditions as premises after the function call. If a postcondition uses the keyword <code>result</code>, then the calling code can list exactly that postcondition using whatever variable it used to store the return value in place of <code>result</code> and using whatever values were passed in place of the parameter names. In the <code>div</code> example above where we divde <code>x-1</code> by <code>y+1</code>, the calling code stores the value returned by <code>div</code> in a variable called <code>num</code>. Since the <code>div</code> postcondition is <code>result == a/b</code>, then we can claim the premise <code>num == (x-1)/(y+1)</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == (x-1)/(y+1)   premise     //postcondition of div
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>We know from looking at this example that <code>(x-1)/(y+1)</code> is really <code>9/3</code>, which is 3. We would like to be able to assert that <code>num</code>, the value returned from <code>div</code>, equals 3. We can do this by adding a few more steps to our final logic block, plugging in the values for <code>x</code> and <code>y</code> and doing some algebra:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == (x-1)/(y+1)   premise     //postcondition of div
</span></span><span style="display:flex;"><span>    2. x == 10              premise     //x is unchanged from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    3. y == 2               premise     //y is unchanged from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    4. num == 9/3           algebra 1 2 3
</span></span><span style="display:flex;"><span>    5. num == 3             algebra 4   //needed for assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == 3)
</span></span></code></pre></div><p>Using a function contract and our deduction rules, we have PROVED that the <code>div</code> function will return 3 in our example (without needing to test the code at all).</p>
<h2 id="examples">Examples</h2>
<p>In this section, we will see two completed examples of Logika programs with a function and calling code.</p>
<h3 id="example-1">Example 1</h3>
<p>In this example, we write a <code>plusOne</code> function that takes a non-negative parameter and returns one more than that parameter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def plusOne(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //precondition: parameter should be non-negative
</span></span><span style="display:flex;"><span>        ensures result == n+1   //postcondition 1: we promise returned value is one more than parameter
</span></span><span style="display:flex;"><span>            result &gt; 0          //postcondition 2: we promise returned value is greater than 0
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val answer: Z = n+1
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. n &gt;= 0               premise     //from the precondition
</span></span><span style="display:flex;"><span>        2. answer == n+1        premise     //from the &#34;answer = n+1&#34; assignment
</span></span><span style="display:flex;"><span>                                            //proves the first postcondition
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. answer &gt; 0           algebra 1 2 //proves the second postcondition
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return answer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////// Test code ///////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 5                   premise     //from the &#34;x=5&#34; assignment
</span></span><span style="display:flex;"><span>    2. x &gt;= 0                   algebra 1   //proves the plusOne precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var added: Z = plusOne(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //I can list the postcondition (what is returned) as a premise
</span></span><span style="display:flex;"><span>    1. x == 5                   premise     //x is unchanged 
</span></span><span style="display:flex;"><span>    2. added == x+1             premise     //plusOne postcondition 1
</span></span><span style="display:flex;"><span>    3. added &gt; 0                premise     //plusOne postcondition 2
</span></span><span style="display:flex;"><span>    4. added == 6               algebra 1 2
</span></span><span style="display:flex;"><span>    5. added == 6 
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(added == 6 ∧ added &gt; 0)
</span></span></code></pre></div><p>Note that when we have more than one postcondition, we must prove all postconditions inside the function, and we can list all postconditions as premises in the calling code after the function call.</p>
<h3 id="example-2">Example 2</h3>
<p>In this example, we write a <code>findMax</code> function that returns the biggest between two integer parameters. This is very similar to an example from section 8.7, which used an if/else statement to find the max. In that example, our assert that we had indeed found the max was: <code>assert((max &gt;= x &amp; max &gt;= y) &amp; (max == x | max == y))</code>. We will see that our postconditions for <code>findMax</code> come directly from the different claims in that assert. In our calling code, we call <code>findMax</code> with <code>num1</code> (which has the value 3) and <code>num2</code> (which has the value 2). We are able to prove that <code>findMax</code> returns 2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//find the max between x and y
</span></span><span style="display:flex;"><span>def findMax(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //no precondition needed
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            result &gt;= x                 //postcondition 1
</span></span><span style="display:flex;"><span>            result &gt;= y                 //postcondition 2
</span></span><span style="display:flex;"><span>            result == x v result == y   //postcondition 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var max: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == 0             premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (x &gt; y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == 0         premise
</span></span><span style="display:flex;"><span>            2. x &gt; y            premise     //IF condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == x         premise
</span></span><span style="display:flex;"><span>            2. max &gt;= x         algebra 1
</span></span><span style="display:flex;"><span>            3. x &gt; y            premise
</span></span><span style="display:flex;"><span>            4. max &gt;= y         algebra 1 3
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == 0         premise
</span></span><span style="display:flex;"><span>            2. ¬(x &gt; y)         premise     //IF condition is not true
</span></span><span style="display:flex;"><span>            3. x &lt;= y           algebra 2
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        max = y
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == y         premise
</span></span><span style="display:flex;"><span>            2. x &lt;= y           premise
</span></span><span style="display:flex;"><span>            3. max &gt;= x         algebra 1 2
</span></span><span style="display:flex;"><span>            4. max &gt;= y         algebra 1
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the postconditions
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //true in both the if and the else
</span></span><span style="display:flex;"><span>        1. max &gt;= x                 premise     //proves postcondition 1 
</span></span><span style="display:flex;"><span>        2. max &gt;= y                 premise     //proves postcondition 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //first was true in if, second true in else
</span></span><span style="display:flex;"><span>        3. max == x v max == y      premise     //proves postcondition 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return max
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Test code /////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num1: Z = 3
</span></span><span style="display:flex;"><span>val num2: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//findMax has no preconditions, so nothing to prove here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val biggest: Z = findMax(num1, num2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. biggest &gt;= num1                      premise     //findMax postcondition 1
</span></span><span style="display:flex;"><span>    2. biggest &gt;= num2                      premise     //findMax postcondition 2
</span></span><span style="display:flex;"><span>    3. biggest == num1 v biggest == num2    premise     //findMax postcondition 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in the initial values
</span></span><span style="display:flex;"><span>    4. num1 == 3                            premise
</span></span><span style="display:flex;"><span>    5. num2 == 2                            premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    6. biggest &gt;= 3                         algebra 1 4
</span></span><span style="display:flex;"><span>    7. biggest &gt;= 2                         algebra 2 5
</span></span><span style="display:flex;"><span>    8. biggest == 3 v biggest == num2       subst1 4 3
</span></span><span style="display:flex;"><span>    9. biggest == 3 v biggest == 2          subst1 5 8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //OR-elimination
</span></span><span style="display:flex;"><span>    10. {
</span></span><span style="display:flex;"><span>        11. biggest == 3                    assume
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    12. {
</span></span><span style="display:flex;"><span>        13. biggest == 2                    assume
</span></span><span style="display:flex;"><span>        14. ¬(biggest &gt;= 3)                 algebra 6 13
</span></span><span style="display:flex;"><span>        15. ⊥                               ¬e 6 14
</span></span><span style="display:flex;"><span>        16. biggest == 3                    ⊥e 15
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    17. biggest == 3                        ve 9 10 12  //needed for assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(biggest == 3)
</span></span></code></pre></div>
            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Recursion</h1>
    
    
<p>In this section, we will see how to prove the correctness of programs that use recursive functions. We will see that verifying a recursive function is exactly the same as verifying a non-recursive function:</p>
<ul>
<li>We must prove a function&rsquo;s preconditions before calling it (including before making a recursive call)</li>
<li>After calling a function, we can list the function&rsquo;s postconditions as premises (including after making a recursive call)</li>
<li>The function can list its preconditions as premises</li>
<li>The function must prove its postconditions just before it ends</li>
</ul>
<h2 id="writing-a-recursive-mult-function">Writing a recursive mult function</h2>
<p>We know we can multiply two numbers, <code>x</code> and <code>y</code>, using the <code>*</code> operator &ndash; <code>x * y</code>. But what if we wanted to find the same result using only addition, not multiplication? Multiplication can be thought of as repeated addition &ndash; <code>x * y</code> is really <code>x + x + ... + x</code>, where we add together <code>y</code> total <code>x</code>&rsquo;s.</p>
<p>We <em>could</em> do this repeated addition with a loop (and we will when we introduce loops in section 9.3), but we will use recursion instead. When we write a recursive function, we try to think of two things:</p>
<ul>
<li>The <em>base case</em>: the simplest version of the problem that we could immediately solve with no more work.</li>
<li>The <em>recursive case</em>: bigger versions of the problem, where we solve a piece of the problem and then recursively solve a smaller piece</li>
</ul>
<p>In the case of the multiplication <code>x * y</code>, we have:</p>
<ul>
<li>Base case: if <code>y</code> is 0, we have no work to do. Adding togther 0 <code>x</code>&rsquo;s is just 0.</li>
<li>Recursive case: if <code>y</code> is bigger than 0, we do ONE addition (<code>x + ...</code>) and recursively add the remaining <code>y - 1</code> numbers. (This will become our recursive call.)</li>
</ul>
<p>With those cases in mind, we can write a recursive <code>mult</code> functio:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that we separated the recursive call (<code>def addRest: Z = mult(x, y-1)</code>) from adding on the next piece (<code>ans = x + addRest</code>). In Logika, all function calls must go on a separate line by themselves &ndash; we can&rsquo;t combine them with other operations. Also, we included a dummy &ldquo;else&rdquo; branch to make the verification simpler.</p>
<h2 id="walking-through-mult">Walking through mult</h2>
<p>Suppose we call <code>mult</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var times: Z = mult(4, 2)
</span></span></code></pre></div><p>We can trace the recursive calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>times = mult(4, 2) 
</span></span><span style="display:flex;"><span>            (x = 4, y = 2)
</span></span><span style="display:flex;"><span>            addRest = mult(4, 1)    =&gt; mult(4, 1)
</span></span><span style="display:flex;"><span>            ans = 4 + addRest               (x = 4, y = 1)
</span></span><span style="display:flex;"><span>            returns ans                     addRest = mult(4, 0)    =&gt;  mult(4, 0)
</span></span><span style="display:flex;"><span>                                            ans = 4 + addRest               (x = 4, y = 0)
</span></span><span style="display:flex;"><span>                                            returns ans                     ans = 0
</span></span><span style="display:flex;"><span>                                                                            returns 0
</span></span></code></pre></div><p>We start with <code>mult(4, 2)</code>, and then immediately make the recursive call <code>mult(4, 1)</code>, which immediately makes the recursive call <code>mult(4, 0)</code>. That function instance hits the base case and returns 0. We now return back up the chain of function calls &ndash; the 0 gets returned back to the <code>mult(4, 1)</code> instance, which adds 4 and then returns 4:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>=&gt; mult(4, 1)
</span></span><span style="display:flex;"><span>    (x = 4, y = 1)
</span></span><span style="display:flex;"><span>    addRest = mult(4, 0) = 0
</span></span><span style="display:flex;"><span>    ans = 4 + addRest = 4 
</span></span><span style="display:flex;"><span>    returns ans (4)
</span></span></code></pre></div><p>This 4 returns back to the <code>mult(4, 2)</code> instance, which adds another 4 and returns 8:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>mult(4, 2) 
</span></span><span style="display:flex;"><span>    (x = 4, y = 2)
</span></span><span style="display:flex;"><span>    addRest = mult(4, 1) = 4
</span></span><span style="display:flex;"><span>    ans = 4 + addRest = 8
</span></span><span style="display:flex;"><span>    returns ans (8)
</span></span></code></pre></div><p>We have now backed our way up the chain &ndash; the 8 is returned back from the original function call, and <code>times</code> is set to 8.</p>
<h2 id="mult-function-contract">mult function contract</h2>
<p>Looking at our <code>mult</code> function, we see that the base case is when <code>y</code> is 0 and the recursive case is when <code>y &gt; 0</code>. Clearly, the function is not intended to work for negative values of <code>y</code>. This will be our precondition &ndash; that <code>y</code> must be greater than or equal to 0.</p>
<p>Our postcondition should describe what <code>mult</code> is returning in terms of its parameters. In this case, we know that <code>mult</code> is performing a multiplication of <code>x</code> and <code>y</code> using repeated addition. So, our function should ensure that it returns <code>x*y</code> (that <code>result == x*y</code>). Here is the function with the function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    //we still need to add the verification logic blocks
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == x*y
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="verification-in-mult">Verification in mult</h2>
<p>Now that we have our function contract for <code>mult</code>, we must add logic blocks with two things in mind:</p>
<ul>
<li>Proving the precondition before a recursive call</li>
<li>Proving the postcondition before we return from the function</li>
</ul>
<p>Our recursive call looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var addRest: Z = mult(x, y-1)
</span></span></code></pre></div><p>Since our precondition is <code>y &gt;= 0</code>, we see that we must prove that what we are passing as the second parameter (<code>y-1</code>, in the case of the recursive call) is greater than or equal to 0. This tells us that before our recursive call, we must have shown exactly: <code>y-1 &gt;= 0</code>. We can finish proving the precondition as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    //we still need to prove the postcondition
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == x*y
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. y &gt; 0                premise     //IF condition is true
</span></span><span style="display:flex;"><span>            2. y-1 &gt;= 0             algebra 1   //Proves the precondition for the recursive call
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All that remains is to prove the <code>mult</code> postcondition &ndash; that we are returning <code>x*y</code>. Since we are returning the variable <code>ans</code>, then we must prove the claim <code>ans == x*y</code> just before our return statement. In order to help with this process, we will need to take advantage of the postcondition after our recursive call. The function promises to return the first parameter times the second parameter, so when we do <code>addRest: Z = mult(x, y-1)</code>, we know that <code>addRest == x*(y-1)</code> (the first parameter, <code>x</code>, times the second parameter, <code>y-1</code>). Here is the completed verification</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    //verification complete!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == x*y
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var ans: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (y &gt; 0) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. y &gt; 0                premise     //IF condition is true
</span></span><span style="display:flex;"><span>            2. y-1 &gt;= 0             algebra 1   //Proves the precondition for the recursive call
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        var addRest: Z = mult(x, y-1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. addRest == x*(y-1)   premise     //Postcondition from the recursive call
</span></span><span style="display:flex;"><span>            2. addRest == x*y - x   algebra 2
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ans = x + addRest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. addRest == x*y - x   premise     //Pulled from previous block
</span></span><span style="display:flex;"><span>            2. ans == x + addRest   premise     //From the &#34;ans = x + addRest&#34; assignment statement
</span></span><span style="display:flex;"><span>            3. ans == x + x*y - x   algebra 1 2
</span></span><span style="display:flex;"><span>            4. ans == x*y           algebra 3   //Showed the postcondition for the IF branch
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        //do nothing in code - but we still do verification
</span></span><span style="display:flex;"><span>        //need to show that postcondition will be correct even if we take this branch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. ¬(y &gt; 0)             premise     //if condition is false
</span></span><span style="display:flex;"><span>            2. y &gt;= 0               premise     //precondition
</span></span><span style="display:flex;"><span>            3. y == 0               algebra 1 2
</span></span><span style="display:flex;"><span>            4. ans == 0             premise     //ans is unchanged
</span></span><span style="display:flex;"><span>            5. ans == x*y           algebra 3 4 //Showed the postcondition for the ELSE branch
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Tie together what we learned in both branches
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ans == x*y               premise     //shows the postcondition      
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="verification-of-calling-code">Verification of calling code</h2>
<p>Verifying the test code that calls a recursive function works exactly the same way as it does for any other function:</p>
<ul>
<li>We must prove the precondition before calling the function</li>
<li>We can list the postcondition as a premise after calling the function</li>
</ul>
<p>Suppose we want to test <code>mult</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val times: Z = mult(4, 2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(times == 8)
</span></span></code></pre></div><p>We could complete the verification by proving the precondition and then using the postcondition to help us prove the claim in the assert:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. 2 &gt;= 0               algebra     //proves the precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val times: Z = mult(4, 2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. times == 4*2         premise     //mult postcondition
</span></span><span style="display:flex;"><span>    2. times == 8           algebra 1   //needed for the assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(times == 8)
</span></span></code></pre></div><p>Note that since our second parameter is <code>2</code>, that we must demonstrate exactly <code>2 &gt;= 0</code> to satisfy <code>mult</code>&rsquo;s precondition. Furthermore, since <code>mult</code> promises to return the first parameter times the second parameter, and since we are storing the result of the function call in the <code>times</code> variable, then we can claim <code>times == 4*2</code> as a premise.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Loops</h1>
    
    
<p>A <em>loop</em> is a command that restarts itself over and over while its <em>loop condition</em> remains true. Loops are trickier to analyze than if/else statements, because we don&rsquo;t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations&hellip;we don&rsquo;t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.</p>
<p>The only loop available in Logika is a <em>while</em> loop, which behaves in the same way as while loops in other languages. If the loop condition is initially false, then the body of the while loop is skipped entirely. If the loop condition is initially true, then we execute the loop body and then recheck the condition. This continues until the loop condition becomes false.</p>
<p>Here is the syntax of a Logika while loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (condition) {
</span></span><span style="display:flex;"><span>   //body of loop
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="loop-invariants">Loop invariants</h2>
<p>Our solution to analyzing loops despite not knowing the number of iterations is a tool called a <em>loop invariant</em>. The job of the loop invariant is to summarize what is always true about the loop. Often, the loop invariant describes the relationship between variables and demonstrates how much progress the loop has made. Sometimes the loop invariant also contains claims that certain variables will always stay in a particular range.</p>
<p>Whatever we choose as the loop invariant, we must be able to do the following:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li>
</ul>
<h2 id="loop-invariants-and-mathematical-induction">Loop invariants and mathematical induction</h2>
<p>The process of proving the correctness of loop invariants is very similar to a mathematical induction proof. We must prove the loop invariant is true before the loop begins, which is analogous to the <em>base case</em> in mathematical induction. The process of assuming the invariant is true at the beginning of an iteration and proving that it is still true at the end of an iteration is just like mathematical induction&rsquo;s <em>inductive step</em>.</p>
<p>If we prove those two things about our invariant, we can be certain the invariant will still hold after the loop terminates. Why? For the same reason mathematical induction proves a property for a general $n$:</p>
<ul>
<li>We know the invariant holds before the loop begins</li>
<li>Because the invariant holds before the loop begins, we are sure it holds at the beginning of the first iteration</li>
<li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the first iteration</li>
<li>Because we&rsquo;re sure it still holds at the end of the first iteration, we know it holds at the beginning of the second iteration</li>
<li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the second iteration
&hellip;</li>
<li>We&rsquo;re sure the invariant still holds at the end of each iteration, including the end of the LAST iteration. Thus we&rsquo;re certain the invariant holds just after the loop ends.</li>
</ul>
<h2 id="loop-invariant-block-syntax">Loop invariant block syntax</h2>
<p>In Logika, we will use a logic block to indiciate our loop invariant. This <em>loop invariant block</em> will go just inside the loop, before the loop body:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (condition) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant (expression(s))
</span></span><span style="display:flex;"><span>        modifies (variable list)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //loop body
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here is a summary of the different loop invariant clauses:</p>
<ul>
<li><code>invariant</code>: lists the invariant for the function. If we have multiple invariants, we can list them on separate lines (where subsequent lines are tabbed over under <code>invariant</code>).</li>
<li><code>modifies</code>: lists the name of any variables that are modified in the loop body.</li>
</ul>
<h2 id="example-loop-invariant-block-for-a-multiplication-loop">Example: loop invariant block for a multiplication loop</h2>
<p>Suppose we have the following loop to multiply two numbers, <code>x</code> and <code>y</code>, using repeated addition. (This is very similar to our <code>mult</code> function from section 9.2, except it does the additions using a loop instead of using recursion):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><p>Before writing the loop invariant block, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>After iteration 3</th>
<th>&hellip;</th>
<th>After iteration y</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>y</td>
</tr>
<tr>
<td><code>sum</code></td>
<td>$0 (= 0*x)$</td>
<td>$x (= 1*x)$</td>
<td>$x + x (= 2*x)$</td>
<td>$x + x + x (= 3*x)$</td>
<td>&hellip;</td>
<td>$x + x + &hellip; + x (= y*x)$</td>
</tr>
</tbody>
</table>
<p>Before the loop begins, we&rsquo;ve added 0 $x$&rsquo;s together, so the sum is 0. After the first iteration, we&rsquo;ve added 1 $x$ together, so the sum is $x$. After the second iteration, we&rsquo;ve added 2 $x$&rsquo;s together, so the sum is $x + x$ which is really $2 * x$. This continues until after the y-th iteration, when we&rsquo;ve added y $x$&rsquo;s together (and the sum is $y*x$).</p>
<p>Using this table, it is easy to see that at any point, <code>sum == count*x</code> (since <code>count</code> tracks the number of iterations). This is true both before the loop begins and at the end of each iteration, so it will be our loop invariant.</p>
<p>We now add a loop invariant block to our loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    //loop invariant block (still needs to be proved)
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><p>We list <code>sum</code> and <code>count</code> in the <code>modifies</code> clause because those are the two variables that change value inside the loop.</p>
<h2 id="proving-the-loop-invariant">Proving the loop invariant</h2>
<p>In order to prove the correctness of a loop, we must do two things:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li>
</ul>
<h3 id="proving-loop-invariant-before-loop-begins">Proving loop invariant before loop begins</h3>
<p>In our multiplication loop above, let&rsquo;s start by proving the loop invariant before the loop begins. This means that just before the loop, we must prove exactly the claim <code>sum == count*x</code>. We can do this with algebra on the current variable values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>    2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>    3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we still need to prove the invariant after each iteration
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><h3 id="proving-loop-invariant-at-the-end-of-each-iteration">Proving loop invariant at the end of each iteration</h3>
<p>To prove the loop invariant still holds at the end of an iteration, we must have a logic block at the end of the loop body with exactly the claim in the loop invariant (which will now be referring to the updated values of each variable). Since this step has us assuming the loop invariant is true at the beginning of each iteration, we can list the loop invariant as a <em>premise</em> in a logic block just inside the loop body. Here is the structure we wish to follow for our multiplication loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == count*x           premise     //the loop invariant holds
</span></span><span style="display:flex;"><span>                                                //at the beginning of an iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //need to prove exactly &#34;sum == count*x&#34;
</span></span><span style="display:flex;"><span>    //to prove our invariant still holds at the end of an iteration
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can complete the loop invariant proof by using our tools for processing assignment statements with mutations. Here is the completed verification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>    2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>    3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                //at the beginning of an iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>        2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>        3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>        2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                    //but count has changed
</span></span><span style="display:flex;"><span>        3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>        4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>        5. sum == count*x               algebra 4   //loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><h3 id="knowledge-after-loop-ends">Knowledge after loop ends</h3>
<p>In the example above, suppose we add the following assert after the loop ends:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(sum == x*y)
</span></span></code></pre></div><p>This seems like a reasonable claim &ndash; after all, we said that our loop was supposed to calculated <code>x * y</code> using repeated addition. We have proved the loop invariant, so we can be sure that <code>sum == count*x</code> after the loop&hellip;but that&rsquo;s not quite the same thing. Does <code>count</code> equal <code>y</code>? How do we know?</p>
<p>We can prove our assert statement by considering one more piece of information &ndash; if we have exited the loop, we know that the loop condition must be false. In fact, you always know two things (which you can claim as premises) after the loop ends:</p>
<ol>
<li>The loop condition is false (so we can claim <code>¬(condition)</code>)</li>
<li>The loop invariant is true, since we proved is true at the end of each iteration</li>
</ol>
<p>We can use those pieces of information to prove our assert statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//the multiplication loop example goes here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == count*x           premise     //the loop invariant holds
</span></span><span style="display:flex;"><span>    2. ¬(count != y)            premise     //the loop condition is not true
</span></span><span style="display:flex;"><span>    3. count == y               algebra 2
</span></span><span style="display:flex;"><span>    4. sum == x*y               algebra 1 3 //proves our assert statement
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(sum == x*y)
</span></span></code></pre></div><h2 id="functions-with-loops">Functions with loops</h2>
<p>If we have a function that includes a loop, we must do the following:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Given that the loop invariant is true at the beginning of an iteration, prove that it is still true at the end of the iteration</li>
<li>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition</li>
</ul>
<p>For example, suppose our loop multiplication is inside a function which is tested by some calling code. We would like to add a function contract, our loop invariant proof, and necessary logic blocks to show that our assert holds at the end of the calling code. Here is just the code for the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>We start by adding a function contract to <code>mult</code>, which will be the same as our function contract for the recursive version of this function in section 9.2 &ndash; <code>y</code> needs to be nonnegative, and we promise to return <code>x*y</code>. Here is the code after adding the function contract and our previous loop verificaton:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>        2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>        3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                    //at the beginning of an iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>            3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                        //but count has changed
</span></span><span style="display:flex;"><span>            3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>            4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>            5. sum == count*x               algebra 4   //loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //STILL NEED TO PROVE POSTCONDITION
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//STILL NEED TO ADD VERIFICATION FOR ASSERT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>We can use the negation of the loop condition (<code>¬(count != y)</code>) together with the loop invariant to prove the postcondition will hold before the function returns. We can also apply the same process as in sections 9.1 and 9.2 to prove the precondition in the calling code before calling the <code>mult</code> function, and to use the function&rsquo;s postcondition after the call to <code>mult</code> to prove our goal assert. Here is the completed example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>        2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>        3. sum == count*x       algebra 1 2 //proves EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                    //at the beginning of an iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>            3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                        //but count has changed
</span></span><span style="display:flex;"><span>            3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>            4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>            5. sum == count*x               algebra 4   //proves loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ¬(count != y)                    premise     //loop condition is now false
</span></span><span style="display:flex;"><span>        2. sum == count*x                   premise     //loop invariant holds after loop
</span></span><span style="display:flex;"><span>        3. count == y                       algebra 1
</span></span><span style="display:flex;"><span>        4. sum == x*y                       algebra 2 3 //proves the postcondition
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. two == 4             premise     //from the &#34;two = 4&#34; assignment
</span></span><span style="display:flex;"><span>    2. two &gt;= 0             algebra 1   //proves the mult precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. one == 3             premise
</span></span><span style="display:flex;"><span>    2. two == 4             premise
</span></span><span style="display:flex;"><span>    3. answer == one*two    premise         //from the mult postcondition
</span></span><span style="display:flex;"><span>    4. answer == 12         algebra 1 2 3   //proves the assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><h2 id="how-to-construct-a-loop-invariant">How to construct a loop invariant</h2>
<p>The most difficult part of the entire process of proving the correctness of a function with a loop is coming up with an appropriate loop invariant. In this section, we will look study two additional loops and learn techniques for deriving loop invariants. In general, we need to think about what the loop is doing as it iterates, and what progress it has made so far towards its goal. A good first approach is to trace through the values of variables for several iterations of the loop, as we did with <code>mult</code> above &ndash; this helps us identify patterns that can then become the loop invariant.</p>
<h3 id="example-1-sum-of-odds">Example 1: Sum of odds</h3>
<p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It might be difficult to tell what this code is doing before walking through a few iterations. Let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>After iteration 3</th>
<th>&hellip;</th>
<th>After iteration n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>n</td>
</tr>
<tr>
<td><code>total</code></td>
<td>$0 $</td>
<td>$1 $</td>
<td>$1 + 3 (= 4)$</td>
<td>$1 + 3 + 5 (= 9)$</td>
<td>&hellip;</td>
<td>$1 + 3 + 5 + &hellip; + (2*n-1) (=n^2)$</td>
</tr>
</tbody>
</table>
<p>Now we can see the pattern &ndash; we are adding up the first $n$ odd numbers. We can see that at the end of the i-th iteration we have added the first $i$ odd numbers, where $(2*i-1)$ is our most recent odd number. We also see that the sum of the first 1 odd number is 1, the sum of the first 2 odd numbers is $2^2 = 4$, &hellip;, and the sum of the first $n$ odd numbers is $n^2$.</p>
<p>Since our loop invariant should describe what progress it has made towards its goal of adding the first $n$ odd numbers, we can see that the loop invariant should be that at any point (before the loop begins and at the end each iteration), $total$ holds the sum of the first $i$ numbers (whose value is $i^2$). We first try this as our loop invariant:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant total == i*i
</span></span><span style="display:flex;"><span>        modifies i, n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Another consideration of writing a loop invariant is that we should be able to deduce our overall goal once the loop ends. After our loop, we want to be sure that <code>total</code> holds the sum of the first <code>n</code> odd numbers &ndash; i.e., that <code>total == n*n</code>. Our loop invariant tells us that <code>total == i*i</code> after the loop ends &ndash; but does <code>n</code> necessarily equal <code>i</code>?</p>
<p>The way it is written, we can&rsquo;t be certain. We do know that the loop condition must be false after the loop, or that <code>¬(i &lt; n)</code>. But this is equivalent to <code>i &gt;= n</code> and not <code>i == n</code>. We need to tighten our invariant to add a restriction that <code>i</code> always be less than or equal to n:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant total == i*i
</span></span><span style="display:flex;"><span>            i &lt;= n
</span></span><span style="display:flex;"><span>        modifies i, n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After the loop ends, we can now combine the negation of the loop condition, <code>¬(i &lt; n)</code> together with the <code>i &lt;= n</code> portion of the invariant to deduce that <code>i == n</code>. Together with the other half of the invariant &ndash; <code>total == i*i</code> &ndash; we can be sure that <code>total == n*n</code> when the loop ends.</p>
<h3 id="example-2-factorial">Example 2: factorial</h3>
<p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var prod: Z = 1
</span></span><span style="display:flex;"><span>var i: Z = 1
</span></span><span style="display:flex;"><span>while (i != n) {
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    prod = prod * i
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>&hellip;</th>
<th>After iteration n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>n</td>
</tr>
<tr>
<td><code>prod</code></td>
<td>$1 $</td>
<td>$1 * 2$</td>
<td>$1 * 2 * 3$</td>
<td>&hellip;</td>
<td>$1 * 2 * 3 * &hellip; * n$</td>
</tr>
</tbody>
</table>
<p>From this table, we can clearly see that after $i$ iterations, $prod == i!$ (i factorial). This <em>should</em> be our loop invariant&hellip;but as with many other languages, Logika does not recognize <code>!</code> as a factorial operator (instead, it is a negation operator). In the next section, we will see how to create a <em>Logika fact</em> to help define the factorial operation. We will then be able to use that Logika fact in place of <code>!</code> to let our invariant be a formalization of: <em>prod equals i factorial</em>.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Logika Facts</h1>
    
    
<p>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * &hellip; * 2 * 1$, but we don&rsquo;t have a way to describe the &ldquo;&hellip;&rdquo; portion using our current tools.</p>
<p>In this section, we introduce <em>Logika facts</em>, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a &ldquo;&hellip;&rdquo; to demonstrate a pattern.</p>
<h2 id="logika-fact-syntax">Logika fact syntax</h2>
<p>Logika allows these proof functions to be written in multiple ways, but we will start with the most straightforward of these options:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def proofFunctionName(paramList) : returnType
</span></span><span style="display:flex;"><span>            factName1. //describe when proofFunctionName has its first possible value
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>            factNameN. //describe when proofFunctionName has its last possible value
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>In the proof function definition, <em>proofFunctionName</em> is the name we give our proof function, <em>paramList</em> is the list of parameter names and types needed for this proof function (which are formatted exactly like a parameter list in a regular Logika function), and <em>returnType</em> is the return type of the proof function (usually either <code>Z</code> for integer or <code>B</code> for boolean).</p>
<p>Below the proof function definition, we include a line for each possible way to calculate its value. Usually, at least one of the lines includes a recursive defintion &ndash; relating the value of something like <code>proofFunctionName(n)</code> to the proof function&rsquo;s definition for a smaller value, like <code>proofFunctionName(n-1)</code>. The label, such as <code>factNameN</code>, names the proof rule. We will be able to pull in a particular line of the definition into a logic block by using the justification <code>fact factNameN</code>.</p>
<p>Logika facts are defined at the top of the Logika file, below the <code>import</code> but before any of the code.</p>
<h2 id="example-logika-fact-to-define-factorial">Example: Logika fact to define factorial</h2>
<p>It is much easier to see how Logika facts work by using an example. Suppose we want to define the factorial operation. The first step is to come up with a <em>recursive definition</em>, which has us defining the operation the same way we would in a recursive function &ndash; with one or more <em>base cases</em> where we can define the operation for the simplest case, and one or more <em>recursive cases</em> that express a general instance of the problem in terms of a smaller instance.</p>
<p>For factorial, the simplest version is $1!$, which is just 1. In the general case, we have that $n! = n * (n-1) * (n-2) * &hellip; * 2 * 1 = n * (n-1)!$. So we can write the following recursive definition:</p>
<ul>
<li>Base case: $1! = 1$</li>
<li>Recursive case: for values of $n$ greater than 1, $n! = n * (n-1)!$</li>
</ul>
<p>And we can then translate the recursive definition to a Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Let&rsquo;s consider each portion of this proof function. Here, <code>factDef</code> is the name given to the proof function. It takes one parameter, <code>n</code>, which is an integer, and it returns an integer. We have two possible ways of calculating the value for the proof function. First, we define <code>fOne</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fOne. factDef(1) == 1
</span></span></code></pre></div><p><code>fOne</code> defines <code>factDef(1)</code> as 1; i.e., <code>factDef(n)</code> is 1 if $n == 1$. This is the same as our base case in our recursive definition for factorial &ndash; $1! = 1$.</p>
<p>Next, consider the definition for <code>fBig</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span></code></pre></div><p><code>fBig</code> states that for all integers <code>x</code> that are bigger than 1, we define <code>factDef(x) == x * factDef(x - 1)</code>. This is the same as our recursive case in our recursive definition for factorial &ndash; for values of $n$ greater than 1, $n! = n * (n-1)!$.</p>
<h2 id="evaluating-a-logika-fact">Evaluating a Logika fact</h2>
<p>Suppose we used our <code>factDef</code> proof function to calculate <code>factDef(3)</code>. We would have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(3) == 3 * factDef(2)        //we use fBig, since 3 &gt; 1
</span></span><span style="display:flex;"><span>factDef(2) == 2 * factDef(1)        //we use fBig, since 2 &gt; 1
</span></span><span style="display:flex;"><span>factDef(1) == 1                     //we use fOne       
</span></span></code></pre></div><p>Once we work down to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(1) == 1
</span></span></code></pre></div><p>We can plug <code>1</code> in for <code>factDef(1)</code> in <code>factDef(2) == 2 * factDef(1)</code>, which gives us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(2) == 2
</span></span></code></pre></div><p>Similarly, we can plug <code>2</code> in for <code>factDef(2)</code> in <code>factDef(3) == 3 * factDef(2)</code>, and see that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(3) == 6
</span></span></code></pre></div><h2 id="using-logika-facts-as-justifications">Using Logika facts as justifications</h2>
<p>If we had our Logika fact, <code>factDef</code>, then we could pull its two definitions into a logic block like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. factDef(1) == 1                                  fact fOne
</span></span><span style="display:flex;"><span>    2. ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)  fact fBig
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Note that we must pull in the definitions EXACTLY as they are written in the proof function. The justification is always <code>fact</code> followed by the name of the corresponding definition.</p>
<h2 id="using-logika-facts-in-postconditions-and-invariants">Using Logika facts in postconditions and invariants</h2>
<p>Consider the following full Logika program that includes a function to find and return a factorial, as well as test code that calls our factorial function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// n! = n * (n-1) * (n-2) * .. * 1
</span></span><span style="display:flex;"><span>// 1! = 1
</span></span><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style="display:flex;"><span>    var product: Z = 1  //our current calculation
</span></span><span style="display:flex;"><span>    while (i != n) {
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>        product = product * i
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return product
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = factorial(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 2)
</span></span></code></pre></div><p>We want to add a function contract, loop invariant block, and supporting logic blocks to demonstrate that <code>factorial</code> is returning <code>n!</code> and to prove the assert in our text code.</p>
<h3 id="writing-a-function-contract-using-a-logika-fact">Writing a function contract using a Logika fact</h3>
<p>We our <code>factorial</code> function contract to say that it is returning <code>n!</code>, and that it is only defined for values of <code>n</code> that are greater than or equal to 0. We recall that our Logika fact, <code>factDef</code>, defines the factorial operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>And we will use <code>factDef</code> to define what we mean by &ldquo;factorial&rdquo; in our <code>factorial</code> function contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 1                 //factorial(n) is only defined when n &gt;= 1
</span></span><span style="display:flex;"><span>        ensures result == factDef(n)    //we promise to return factDef(n),
</span></span><span style="display:flex;"><span>                                    //where factDef(n) defines n!
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //code for factorial function
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="writing-a-loop-invariant-block-using-a-logika-fact">Writing a loop invariant block using a Logika fact</h3>
<p>We can similarly use <code>factDef</code> in our loop invariant block. We noted at the end of section 9.3 that the invariant in our loop should be: <em>prod equals i factorial</em>. Now we have a way to express what we mean by &ldquo;factorial&rdquo;, so our invariant will be: <code>prod == factDef(i)</code>. Since the <code>factDef</code> proof function is only defined for parameters greater than or equal to 1, we need to add a second piece to the invariant to guarantee that <code>i</code> will always be greater than or equal to 1. We now have the following loop invariant block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (i != n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant product == factDef(i)
</span></span><span style="display:flex;"><span>            i &gt;= 1
</span></span><span style="display:flex;"><span>        modifies i, product
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //loop body
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="finishing-the-verification">Finishing the verification</h3>
<p>All that remains is to:</p>
<ul>
<li>Prove our loop invariant holds before the loop begins</li>
<li>When we assume the loop invariant holds at the beginning of an iteration, prove that it still holds at the end of the iteration</li>
<li>Use the loop invariant together with the negation of the loop condition to prove the <code>factorial</code> postcondition</li>
<li>Prove the precondition holds in the calling code just before calling <code>factorial</code></li>
<li>Use the postcondition after calling <code>factorial</code> to prove the final assert</li>
</ul>
<p>Here is the completed verification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 1
</span></span><span style="display:flex;"><span>        ensures result == factDef(n)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var i: Z = 1 //how many multiplications we have done
</span></span><span style="display:flex;"><span>    var product: Z = 1  //my current calculation
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Prove invariant before loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. i == 1                       premise
</span></span><span style="display:flex;"><span>        2. product == 1                 premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //pull in first Logika fact rule
</span></span><span style="display:flex;"><span>        3. factDef(1) == 1              fact fOne     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //proves first loop invariant holds  
</span></span><span style="display:flex;"><span>        4. product == factDef(i)        algebra 1 2 3   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //proves second loop invariant hols
</span></span><span style="display:flex;"><span>        5. i &gt;= 1                       algebra 1       
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant product == factDef(i)
</span></span><span style="display:flex;"><span>                i &gt;= 1
</span></span><span style="display:flex;"><span>            modifies i, product
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            //from &#34;i = i + 1&#34;
</span></span><span style="display:flex;"><span>            1. i == i_old + 1               premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //loop invariant held before changing i
</span></span><span style="display:flex;"><span>            2. product == factDef(i_old)    premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //rewrite invariant with no &#34;_old&#34;
</span></span><span style="display:flex;"><span>            3. product == factDef(i-1)      algebra 1 2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //second loop invariant held before changing i
</span></span><span style="display:flex;"><span>            4. i_old &gt;= 1                   premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //needed for the Logika fact
</span></span><span style="display:flex;"><span>            5. i &gt; 1                        algebra 1 4 
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        product = product * i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //Prove invariant still holds at end of iteration
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            //from &#34;product = product * i&#34;
</span></span><span style="display:flex;"><span>            1. product == product_old*i                         premise 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //from previous logic block
</span></span><span style="display:flex;"><span>            2. product_old == factDef(i-1)                      premise 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //pull in Logika fact
</span></span><span style="display:flex;"><span>            3. ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x  fact fBig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //plug in &#34;i&#34; for &#34;x&#34;
</span></span><span style="display:flex;"><span>            4. i &gt; 1 → factDef(i) == factDef(i - 1) * i         Ae 3 i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //from previous logic block
</span></span><span style="display:flex;"><span>            5. i &gt; 1                                            premise   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //i &gt; 1, so get right side of →
</span></span><span style="display:flex;"><span>            6. factDef(i) == factDef(i - 1) * i                 →e 4 5     
</span></span><span style="display:flex;"><span>            7. product == factDef(i-1)*i                        algebra 1 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //proves first invariant still holds
</span></span><span style="display:flex;"><span>            8. product == factDef(i)                            algebra 6 7 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //proves first invariant still holds
</span></span><span style="display:flex;"><span>            9. i &gt;= 1                                           algebra 5
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Prove postcondition
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. product == factDef(i)        premise //loop invariant
</span></span><span style="display:flex;"><span>        2. !(i != n)                    premise //loop condition false
</span></span><span style="display:flex;"><span>        3. i == n                       algebra 2
</span></span><span style="display:flex;"><span>        4. product == factDef(n)        algebra 1 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return product
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//Prove precondition
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == 2             premise
</span></span><span style="display:flex;"><span>    2. num &gt;= 1             algebra 1   //proves factorial precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = factorial(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. answer == factDef(num)           premise     //factorial postcondition
</span></span><span style="display:flex;"><span>    2. num == 2                         premise
</span></span><span style="display:flex;"><span>    3. answer == factDef(2)             algebra 1 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in Logika fact
</span></span><span style="display:flex;"><span>    4. ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x  fact fBig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //plug in &#34;2&#34; for &#34;x&#34;
</span></span><span style="display:flex;"><span>    5. 2 &gt; 1 → factDef(2) == factDef(2 - 1) * 2         Ae 4 2 
</span></span><span style="display:flex;"><span>    6. 2 &gt; 1                            algebra
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //2 &gt; 1, so use →
</span></span><span style="display:flex;"><span>    7. factDef(2) == factDef(2 - 1) * 2  →e 5 6  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in Logika fact
</span></span><span style="display:flex;"><span>    8. factDef(1) == 1                  fact fOne       
</span></span><span style="display:flex;"><span>    9. factDef(2) == factDef(1) * 2     algebra 7
</span></span><span style="display:flex;"><span>    10. factDef(2) == 2                 algebra 8 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //proves claim in assert
</span></span><span style="display:flex;"><span>    11. answer == 2                     algebra 1 2 10
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 2)
</span></span></code></pre></div><h2 id="logika-fact-for-multiplication">Logika fact for multiplication</h2>
<p>Suppose we wanted to create a Logika fact that recursively defined multiplication. We first recursively define how we would multiply $x * y$. We know that our base case will be when $y == 0$, because anything times 0 is 0. We also saw that multiplication can be defined as repeated addition, so that $x * y == x + x + &hellip; x$ for a total of $y$ additions. We also see that $x * y == x + x * (y-1)$, since we can pull out one of the additions and then have $y-1$ additions left to do.</p>
<p>Here is our recursive definition of the problem:</p>
<ul>
<li>Base case: for all numbers x, x * 0 is 0</li>
<li>Recursive case: for all numbers x and all positive numbers y, x * y = x + x * (y-1)</li>
</ul>
<p>We can translate this directly to a Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines m * n = m + m + ... + m (n times)
</span></span><span style="display:flex;"><span>        def multDef(m: Z, n: Z): Z
</span></span><span style="display:flex;"><span>            //anything multiplied by 0 is just 0
</span></span><span style="display:flex;"><span>            mult0. ∀ x: Z multDef(x, 0) == 0
</span></span><span style="display:flex;"><span>            multPos. ∀ x: Z (∀ y: Z y &gt; 0 → multDef(x, y) == x + multDef(x, y-1))
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>We could use this Logika fact in the postcondition and loop invariant block for a multiplication function as follows:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>```text
</span></span><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines m * n = m + m + ... + m (n times)
</span></span><span style="display:flex;"><span>        def multDef(m: Z, n: Z): Z
</span></span><span style="display:flex;"><span>            //anything multiplied by 0 is just 0
</span></span><span style="display:flex;"><span>            mult0. A x: Z multDef(x, 0) == 0
</span></span><span style="display:flex;"><span>            multPos. A x: Z (A y: Z y &gt; 0 -&gt; multDef(x, y) == multDef(x, y-1) + x)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//want to find: num1 + num1 + ... + num1 (a total of num2 times)
</span></span><span style="display:flex;"><span>def mult(num1: Z, num2: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires num2 &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == multDef(num1, num2)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var answer: Z = 0
</span></span><span style="display:flex;"><span>    var cur: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (cur != num2) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant
</span></span><span style="display:flex;"><span>                answer == multDef(num1, cur)
</span></span><span style="display:flex;"><span>                cur &gt;= 0
</span></span><span style="display:flex;"><span>            modifies cur, answer
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>        cur = cur + 1
</span></span><span style="display:flex;"><span>        answer = answer + num1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return answer
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The example above does not include the verification steps to prove the loop invariant and postcondition, but those things could be accomplished in the same way as for the <code>factorial</code> function.</p>
<h2 id="logika-fact-for-fibonacci-numbers">Logika fact for Fibonacci numbers</h2>
<p>The Fibonacci sequence is:</p>
<p>$$
1, 1, 2, 3, 5, 8, 13, &hellip;
$$</p>
<p><br><br></p>
<p>The first two Fibonacci numbers are both 1, and subsequent Fibonacci numbers are found by adding the two previous values. In the sequence above, we see that the two latest numbers were 8 and 13, so the next number in the sequence will be $8 + 13 = 21$.</p>
<p>We can recursively define the Fibonnaci sequence as follows:</p>
<ul>
<li>Base case 1: the first Fibonacci number is 1</li>
<li>Base case 2: the second Fibonacci number is 1</li>
<li>Recursive case: for all numbers x greater than 2, the x-th Fibonacci number is the (x-1)-th Fibonacci number + the (x-2)-th Fibonacci number</li>
</ul>
<p>We can translate this directly to a Logika fact:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines the nth number in the Fibonacci sequence
</span></span><span style="display:flex;"><span>        //1, 1, 2, 3, 5, 8, 13, ...
</span></span><span style="display:flex;"><span>        def fibDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fib1. fibDef(1) == 1
</span></span><span style="display:flex;"><span>            fib2. fibDef(2) == 1
</span></span><span style="display:flex;"><span>            fibN. ∀ x: Z x &gt; 2 → fibDef(x) == fibDef(x-1) + fibDef(x-2)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>Which we could use in a postcondition and loop invariant if we wrote a function to compute the Fibonacci numbers.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
    
          <article class="default">
    
    
<h1>Summary</h1>
    
    
<p>Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:</p>
<h2 id="step-1-write-function-contracts">Step 1: Write function contracts</h2>
<p>Write a function contract for any function that doesn&rsquo;t already have one. Function contracts go just inside the function defintion, and look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    requires (preconditions)
</span></span><span style="display:flex;"><span>    ensures (postconditions)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>(The <em>modifies</em> clause is omitted, as we did not use it in this chapter. We will use the <em>modifies</em> clause in chapter 10.) The <em>preconditions</em> list any requirements your function has about the range of its parameters, and the <em>postconditions</em> describe the impact of calling the function (in this chapter, the postcondition always describes how the return value relates to the parameters.) If you&rsquo;re not sure what to write as the postcondition, try walking through your function with different parameters to get a sense for the pattern of what the function is doing in relation to the parameters. If you were given a Logika proof function, you will likely need to use it in the postcondition (and loop invariant) to describe the behavior.</p>
<h2 id="step-2-write-loop-invariant-blocks">Step 2: Write loop invariant blocks</h2>
<p>Write a loop invariant block for any loop that doesn&rsquo;t already have one. Loop invariant blocks go just inside the loop (before any code) and look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    invariant (loop invariants)
</span></span><span style="display:flex;"><span>    modifies (variable list)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span></code></pre></div><p>The <em>invariant</em> clause lists all loop invariants, which should describe the progress the loop has made toward its goal (the loop invariant will often greatly reasonable the postcondition for the enclosing function). Loop invariants occasionally need to specify the range of different variables, especially if the invariant uses Logika facts (which may only be defined for particular values) or if you need more information about the final value of a variable when a loop terminates. I recommend making a table of variable values for several iterations of your loop to get a sense of the relationship between variables &ndash; this relationship is what will become the loop invariant.</p>
<p>The <em>modifies</em> clause lists all variables that are modified in the loop body.</p>
<h2 id="step-3-prove-invariant-holds-before-loop-begins">Step 3: Prove invariant holds before loop begins</h2>
<p>In each loop, prove your invariant holds before the loop begins. You may need to pull in the function&rsquo;s precondition as a premise in this step. You must prove EXACTLY the claim in all pieces of the loop invariant. If your loop invariant involves a Logika fact, you may need to pull in a piece of the fact definition to help prove the invariant.</p>
<h2 id="step-4-prove-invariant-still-holds-at-end-of-iteration">Step 4: Prove invariant still holds at end of iteration</h2>
<p>In each loop, prove your invariant still holds at the end of each iteration. Start by pulling in each part of the loop invariant as a premise before the loop body begins. Use logic blocks to process each statement in the body of the loop. By the end of the loop, you must prove EXACTLY the claim in all pieces of the loop invariant. (Again, if your loop invariant involves a Logika fact, you&rsquo;ll want to pull in a piece of the fact definition to help with this step.)</p>
<h2 id="step-5-prove-the-postcondition">Step 5: Prove the postcondition</h2>
<p>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition just before your function ends.</p>
<h2 id="step-6-prove-the-precondition-before-each-function-call">Step 6: Prove the precondition before each function call</h2>
<p>Before any function call, prove exactly the precondition(s) for the function (using whatever values you are passing as parameters).</p>
<h2 id="step-7-use-postcondition-after-each-function-call">Step 7: Use postcondition after each function call</h2>
<p>After returning from each function call, pull the function&rsquo;s postcondition into a logic block as a premise (using whatever values you passed as parameters). Use this information to help prove any asserts.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        </div>
      </main>
    
<div class="git-footer">
<p>Last modified by: 
            <i class='fas fa-user'></i> Julie Thornton
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/5b0128cd165d1039d4edd8d34ef9d04eee836ae3">Jun 8, 2022</a>
</p>
</div>

    
    </div>
    
    
    
    
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">

<a id="logo" href="https://ksu-cs-textbooks.github.io/cis301/">
  CIS 301: Logical Foundations of Programming
</a>

        </div>
        <div class="searchbox default-animation">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/auto-complete.js?1662241024" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.min.js?1662241024" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.stemmer.support.min.js?1662241024" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.multi.min.js?1662241024" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.en.min.js?1662241024" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/search.js?1662241024" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics collapsible-menu">
          <li data-nav-id="/0-chapter/" title="Getting Started" class="dd-item"><input type="checkbox" id="section-c55c9f751a28ecc9415234375cddd395" class="toggle"/><label for="section-c55c9f751a28ecc9415234375cddd395" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/"><b>0. </b>Getting Started</a><ul>
          <li data-nav-id="/0-chapter/0_1-toolsguide/" title="Tools Guide" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/0_1-toolsguide/">0.1. Tools Guide</a></li></ul></li>
          <li data-nav-id="/1-chapter/" title="Basics and Logic Puzzles" class="dd-item"><input type="checkbox" id="section-7a71fe25dd66b523fca4004b7c4d01d0" class="toggle"/><label for="section-7a71fe25dd66b523fca4004b7c4d01d0" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/"><b>1. </b>Basics and Logic Puzzles</a><ul>
          <li data-nav-id="/1-chapter/1_1-logicbasics/" title="Basic Logical Reasoning" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_1-logicbasics/">1.1. Basic Logical Reasoning</a></li>
          <li data-nav-id="/1-chapter/1_2-knightsknaves/" title="Knights and Knaves" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_2-knightsknaves/">1.2. Knights and Knaves</a></li>
          <li data-nav-id="/1-chapter/1_3-otherpuzzles/" title="Other Puzzles" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_3-otherpuzzles/">1.3. Other Puzzles</a></li></ul></li>
          <li data-nav-id="/2-chapter/" title="Truth Tables" class="dd-item"><input type="checkbox" id="section-c23f766dd7728aa0e1cff094001eac05" class="toggle"/><label for="section-c23f766dd7728aa0e1cff094001eac05" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/"><b>2. </b>Truth Tables</a><ul>
          <li data-nav-id="/2-chapter/2_1-opscircuits/" title="Operators and Circuits" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_1-opscircuits/">2.1. Operators and Circuits</a></li>
          <li data-nav-id="/2-chapter/2_2-logikatruth/" title="Truth Tables in Logika" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_2-logikatruth/">2.2. Truth Tables in Logika</a></li>
          <li data-nav-id="/2-chapter/2_3-satis/" title="Satisfiability" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_3-satis/">2.3. Satisfiability</a></li>
          <li data-nav-id="/2-chapter/2_4-logicalequiv/" title="Logical Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/">2.4. Logical Equivalence</a></li>
          <li data-nav-id="/2-chapter/2_5-sementail/" title="Semantic Entailment" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_5-sementail/">2.5. Semantic Entailment</a></li></ul></li>
          <li data-nav-id="/3-chapter/" title="Propositional Logic Translations" class="dd-item"><input type="checkbox" id="section-ccb531d159d5247057d21618514721b6" class="toggle"/><label for="section-ccb531d159d5247057d21618514721b6" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/"><b>3. </b>Propositional Logic Translations</a><ul>
          <li data-nav-id="/3-chapter/3_1-propatom/" title="Propositional Atoms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_1-propatom/">3.1. Propositional Atoms</a></li>
          <li data-nav-id="/3-chapter/3_2-notandor/" title="NOT, AND, OR Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_2-notandor/">3.2. NOT, AND, OR Translations</a></li>
          <li data-nav-id="/3-chapter/3_3-implies/" title="Implies Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_3-implies/">3.3. Implies Translations</a></li>
          <li data-nav-id="/3-chapter/3_4-equiv/" title="Equivalent Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_4-equiv/">3.4. Equivalent Translations</a></li>
          <li data-nav-id="/3-chapter/3_5-knightsknavestt/" title="Knights and Knaves, revisited" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_5-knightsknavestt/">3.5. Knights and Knaves, revisited</a></li></ul></li>
          <li data-nav-id="/4-chapter/" title="Propositional Logic Proofs" class="dd-item"><input type="checkbox" id="section-8ebf970484325d93d52075c7c72ba517" class="toggle"/><label for="section-8ebf970484325d93d52075c7c72ba517" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/"><b>4. </b>Propositional Logic Proofs</a><ul>
          <li data-nav-id="/4-chapter/4_1-intro/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_1-intro/">4.1. Introduction</a></li>
          <li data-nav-id="/4-chapter/4_2-andrules/" title="AND Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_2-andrules/">4.2. AND Rules</a></li>
          <li data-nav-id="/4-chapter/4_3-orrules/" title="OR Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_3-orrules/">4.3. OR Rules</a></li>
          <li data-nav-id="/4-chapter/4_4-impliesrules/" title="Implies Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_4-impliesrules/">4.4. Implies Rules</a></li>
          <li data-nav-id="/4-chapter/4_5-notrules/" title="Negation Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_5-notrules/">4.5. Negation Rules</a></li>
          <li data-nav-id="/4-chapter/4_6-strategies/" title="Summary and Strategies" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_6-strategies/">4.6. Summary and Strategies</a></li>
          <li data-nav-id="/4-chapter/4_7-theorems/" title="Theorems" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/">4.7. Theorems</a></li>
          <li data-nav-id="/4-chapter/4_8-equivalence/" title="Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_8-equivalence/">4.8. Equivalence</a></li>
          <li data-nav-id="/4-chapter/4_9-soundcomplete/" title="Soundness and Completeness" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_9-soundcomplete/">4.9. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/5-chapter/" title="Predicate Logic Translations" class="dd-item"><input type="checkbox" id="section-b69c30f957b0ff55c1e9673979ceb29d" class="toggle"/><label for="section-b69c30f957b0ff55c1e9673979ceb29d" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/"><b>5. </b>Predicate Logic Translations</a><ul>
          <li data-nav-id="/5-chapter/5_1-motivation/" title="Motivation" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_1-motivation/">5.1. Motivation</a></li>
          <li data-nav-id="/5-chapter/5_2-predsyntax/" title="Syntax" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_2-predsyntax/">5.2. Syntax</a></li>
          <li data-nav-id="/5-chapter/5_3-singlequantifier/" title="Single Quantifier" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_3-singlequantifier/">5.3. Single Quantifier</a></li>
          <li data-nav-id="/5-chapter/5_4-multquant/" title="Multiple Quantifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_4-multquant/">5.4. Multiple Quantifiers</a></li></ul></li>
          <li data-nav-id="/6-chapter/" title="Predicate Logic Proofs" class="dd-item"><input type="checkbox" id="section-482218cb3a05b9572157ed70ed9a5c02" class="toggle"/><label for="section-482218cb3a05b9572157ed70ed9a5c02" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/"><b>6. </b>Predicate Logic Proofs</a><ul>
          <li data-nav-id="/6-chapter/6_1-univrules/" title="Rules with ∀" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_1-univrules/">6.1. Rules with ∀</a></li>
          <li data-nav-id="/6-chapter/6_2-existrules/" title="Rules with ∃" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_2-existrules/">6.2. Rules with ∃</a></li>
          <li data-nav-id="/6-chapter/6_3-nested/" title="Nested Quantifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_3-nested/">6.3. Nested Quantifiers</a></li>
          <li data-nav-id="/6-chapter/6_4-equiv/" title="Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_4-equiv/">6.4. Equivalence</a></li>
          <li data-nav-id="/6-chapter/6_5-strategies/" title="Summary and Strategies" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_5-strategies/">6.5. Summary and Strategies</a></li>
          <li data-nav-id="/6-chapter/6_6-soundcomplete/" title="Soundness and Completeness" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/">6.6. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/7-chapter/" title="Mathematical Induction" class="dd-item"><input type="checkbox" id="section-fc25ecfcb3d8e929949e8db759e88bab" class="toggle"/><label for="section-fc25ecfcb3d8e929949e8db759e88bab" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/"><b>7. </b>Mathematical Induction</a><ul>
          <li data-nav-id="/7-chapter/7_1-process/" title="Induction Process" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_1-process/">7.1. Induction Process</a></li>
          <li data-nav-id="/7-chapter/7_2-algebraex/" title="Algebra example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_2-algebraex/">7.2. Algebra example</a></li>
          <li data-nav-id="/7-chapter/7_3-divex/" title="Divisibility example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_3-divex/">7.3. Divisibility example</a></li>
          <li data-nav-id="/7-chapter/7_4-setex/" title="Set example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_4-setex/">7.4. Set example</a></li></ul></li>
          <li data-nav-id="/8-chapter/" title="Intro to Programming Logic" class="dd-item"><input type="checkbox" id="section-bd411d4b09a07aa69f5152043fa837ed" class="toggle"/><label for="section-bd411d4b09a07aa69f5152043fa837ed" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/"><b>8. </b>Intro to Programming Logic</a><ul>
          <li data-nav-id="/8-chapter/8_1-goal/" title="Programming Logic Goal" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_1-goal/">8.1. Programming Logic Goal</a></li>
          <li data-nav-id="/8-chapter/8_2-logikaprograms/" title="Logika Programs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_2-logikaprograms/">8.2. Logika Programs</a></li>
          <li data-nav-id="/8-chapter/8_3-assertassume/" title="Assert and Assume" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_3-assertassume/">8.3. Assert and Assume</a></li>
          <li data-nav-id="/8-chapter/8_4-algebrasubst/" title="Algebra and subst Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_4-algebrasubst/">8.4. Algebra and subst Rules</a></li>
          <li data-nav-id="/8-chapter/8_5-assignment/" title="Assignment Statements" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/">8.5. Assignment Statements</a></li>
          <li data-nav-id="/8-chapter/8_6-divmod/" title="Integer Division and Modulo" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_6-divmod/">8.6. Integer Division and Modulo</a></li>
          <li data-nav-id="/8-chapter/8_7-conditionals/" title="Conditional Statements" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_7-conditionals/">8.7. Conditional Statements</a></li></ul></li>
          <li data-nav-id="/9-chapter/" title="Functions and Loops" class="dd-item active parent"><input type="checkbox" id="section-708a4026c5b157dd8da0a277e359073f" class="toggle" checked/><label for="section-708a4026c5b157dd8da0a277e359073f" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/"><b>9. </b>Functions and Loops</a><ul>
          <li data-nav-id="/9-chapter/9_1-functions/" title="Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/">9.1. Functions</a></li>
          <li data-nav-id="/9-chapter/9_2-recursion/" title="Recursion" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_2-recursion/">9.2. Recursion</a></li>
          <li data-nav-id="/9-chapter/9_3-loops/" title="Loops" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/">9.3. Loops</a></li>
          <li data-nav-id="/9-chapter/9_4-logikafacts/" title="Logika Facts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/">9.4. Logika Facts</a></li>
          <li data-nav-id="/9-chapter/9_5-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_5-summary/">9.5. Summary</a></li></ul></li>
          <li data-nav-id="/10-chapter/" title="Sequences, Globals, and Termination" class="dd-item"><input type="checkbox" id="section-83e8e84779c32ba319a378089810947b" class="toggle"/><label for="section-83e8e84779c32ba319a378089810947b" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/"><b>10. </b>Sequences, Globals, and Termination</a><ul>
          <li data-nav-id="/10-chapter/10_1-modes/" title="Logika Modes" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_1-modes/">10.1 Logika Modes</a></li>
          <li data-nav-id="/10-chapter/10_2-intosequences/" title="Intro to Sequences" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_2-intosequences/">10.2 Intro to Sequences</a></li>
          <li data-nav-id="/10-chapter/10_3-seqfn/" title="Sequences in Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_3-seqfn/">10.3 Sequences in Functions</a></li>
          <li data-nav-id="/10-chapter/10_4-seqloop/" title="Sequences in Loops" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_4-seqloop/">10.4 Sequences in Loops</a></li>
          <li data-nav-id="/10-chapter/10_5_seqlogfact/" title="Logika Facts, revisited" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_5_seqlogfact/">10.5 Logika Facts, revisited</a></li>
          <li data-nav-id="/10-chapter/10_6-globals/" title="Global Variables" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_6-globals/">10.6 Global Variables</a></li>
          <li data-nav-id="/10-chapter/10_7-termination/" title="Termination" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/">10.7 Termination</a></li></ul></li>
        </ul>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch showVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="variants.changeVariant( this.value );">
                    <option id="light-theme" value="light-theme" selected>Light Theme</option>
                    <option id="dark-theme" value="dark-theme">Dark Theme</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter"><style>
  #footer {
      font-size: 13px;
      margin-left: auto;
      margin-right: auto;
      padding: 2rem 1rem;
      min-width: 230px;
      max-width: 300px;
  }
  #footer p {
      margin: 0;
  }
</style>
  
<p>Built using <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/K-State-Computational-Core/hugo-theme-relearn/tree/main">Hugo Relearn Theme</a>.</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; margin: .5rem auto" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p>

        </div>
      </div>
    </aside>
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1662241024" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1662241024" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/featherlight.min.js?1662241024" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1662241024" defer></script>
    
    
    
    
  </body>
</html>
