<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Programming Logic: Functions and Loops In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Functions and Loops :: CIS 301 Textbook"><meta name=twitter:description content="Programming Logic: Functions and Loops In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/9-chapter/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Functions and Loops :: CIS 301 Textbook"><meta property="og:description" content="Programming Logic: Functions and Loops In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Functions and Loops :: CIS 301 Textbook"><meta itemprop=description content="Programming Logic: Functions and Loops In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion."><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T14:52:41-05:00"><meta itemprop=wordCount content="31"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Functions and Loops :: CIS 301 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis301/9-chapter/index.html rel=canonical type=text/html title="Functions and Loops :: CIS 301 Textbook"><link href=/cis301/9-chapter/index.xml rel=alternate type=application/rss+xml title="Functions and Loops :: CIS 301 Textbook"><link href=/cis301/9-chapter/tele.html rel=alternate type=text/html title="Functions and Loops :: CIS 301 Textbook"><link href=/cis301/9-chapter/embed.html rel=alternate type=text/html title="Functions and Loops :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1755877650 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1755877650 defer></script><script src=/cis301/js/search-lunr.min.js?1755877650 defer></script><script src=/cis301/js/search.min.js?1755877650 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1755877650"</script><script src=/cis301/js/lunr/lunr.min.js?1755877650 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1755877650 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1755877650 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1755877650 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755877650 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755877650 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1755877650 rel=stylesheet><link href=/cis301/css/theme.min.css?1755877650 rel=stylesheet><link href=/cis301/css/format-print.min.css?1755877650 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/9-chapter/index.html",window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1755877650 rel=stylesheet></head><body class="mobile-support print" data-url=/cis301/9-chapter/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 9-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=functions-and-loops>Functions and Loops</h1><h6 id=programming-logic-functions-and-loops>Programming Logic: Functions and Loops</h6><p>In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Functions and Loops</h1><article class=default><header class=headline></header><h1 id=functions>Functions</h1><p>A <em>function</em> in Scala is analogous to a method in Java or C# &ndash; it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def functionName(paramList): returnType = {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We will use the keyword <code>Unit</code> (like <code>void</code> in other languages) for a function that does not return a value. If a function has a non-<code>Unit</code> return type, then all paths through the function must end in a return statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>return expression</span></span></code></pre></div><p>Where <code>expression</code> is a variable, literal, or expression matching <code>returnType</code>.</p><h2 id=function-contracts>Function contracts</h2><p>In order to prove the correctness of a function, it must include a <em>function contract</em> just inside the function header. This function contract specifies what we need to know to use the function correctly. While we will use these specifications to help us prove correctness, they are good to include in ANY library function that will be used by someone else (even more informally in other languages). <em>The person/program who calls the function is not supposed to read the function&rsquo;s code to know how to use the function</em>. A function contract shows them what parameters to pass (including what range of values are acceptable), what the function will return in terms of the parameter, and whether/how the function will modify things like sequences (arrays/lists in other languages) or global variables.</p><p>Here is the syntax for a function contract in Logika:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires (  preconditions   ),
</span></span><span style=display:flex><span>    Ensures (   postconditions  )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here is a summary of the different function contract clauses:</p><ul><li><code>Requires</code>: lists the <em>preconditions</em> for the function in a comma-separated list. If there are no preconditions, we can skip this clause.</li><li><code>Ensures</code>: lists the <em>postconditions</em> for the function in a comma-separated list.</li></ul><h3 id=preconditions>Preconditions</h3><p>The <em>preconditions</em> for a function are requirements the function has in order to operate correctly. Generally, preconditions constrain the values of the parameters and/or global variables. For example, this function returns the integer division between two parameters. The function can only operate correctly when the denominator (the second parameter, <code>b</code>) is non-zero:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (  b != 0  ),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val ans: Z = a/b
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Logika will display an error if any preconditions are not proven before calling a function. Because we are required to prove the preconditions before any function call, the function itself can list the preconditions as premises in a proof block just after the function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def example(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (  Precondition1, Precondition2, ...),
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //we can list the preconditions as premises
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( precondition1   )   by Premise,
</span></span><span style=display:flex><span>        2 ( precondition2   )   by Premise
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=postconditions>Postconditions</h3><p>The <em>postconditions</em> of a function state what the function has accomplished when it terminates. In particular, postconditions should include:</p><ul><li><p>A formalization of what the function promises to return in terms of the parameters/global variables. We use the keyword <code>Res[returnType]</code> to refer to the object returned by the function (we will only use this keyword in the function contract). For example, in a function that returns an integer (<code>Z</code>), we can use the keyword <code>Res[Z]</code> in a postcondition to refer to the return value.</p></li><li><p>A description of how any global variables and/or sequence parameters will be modified by the function (we will not use global variables or sequences until chapter 10).</p></li></ul><p>For example, the <code>div</code> function above should promise to return the integer division of its two parameters, like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   b != 0  ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == a/b   )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val ans: Z = a/b
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>In order to prove a postcondition involving the return value, we must have proof blocks just before returning that demonstrate each postcondition claim, using the variable name being returned instead of the <code>Res[returnType]</code> keyword. In the example above, since we are returning a variable named <code>ans</code>, then we must prove the claim <code>ans == a/b</code> in order to satisfy the postcondition. We can complete the verification of the <code>div</code> function as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   b != 0  ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == a/b   )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val ans: Z = a/b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 ( b != 0      )   by Premise, //precondition (needed for division)
</span></span><span style=display:flex><span>        2 ( ans == a/b  )   by Premise  //satisifes the postcondition
</span></span><span style=display:flex><span>                                        //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Logika will display an error if postconditions are not proven before leaving a function. Because we are required to prove the postconditions before the function ends, any calling code can list those postconditions as premises after calling the function. We will see this in more detail in the next section.</p><h2 id=work-of-the-calling-code>Work of the calling code</h2><p>We saw above that when writing code that calls a function, we must PROVE the preconditions before the function call (since the function requires that we meet those preconditions in order to work correctly). After the function terminates, the calling code can list the function&rsquo;s postconditions as PREMISES (since the function ensured that certain things would happen).</p><p>The &ldquo;calling code&rdquo; in Scala goes outside of any function definition. Typically, I place the calling code at the bottom of the Scala file, after all functions. This is the code executed first by Scala, just like in Python programs.</p><h3 id=proving-preconditions>Proving preconditions</h3><p>Suppose we wish to call the <code>div</code> function to divide two numbers:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x, y)</span></span></code></pre></div><p>If we included that calling code in a file with our <code>div</code> function, we would see an error that we had not yet proved the precondition. To prove each precondition, we must have a proof block just before the function call that demonstrate each precondition claim, using value being passed instead of the parameter name. Since we are passing the value <code>y</code> as our second parameter, and since the <code>div</code> function requires that <code>b != 0</code> (where <code>b</code> is the second parameter), then we must demonstrate that <code>y != 0</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y != 0      )   by Algebra*(2)  //satisfies the precondition for div
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x, y)</span></span></code></pre></div><p>Note that Logika is picky about proving the precondition using EXACTLY the value being passed for the corresponding parameter. For example, suppose instead that we wanted to divide <code>x-1</code> and <code>y+1</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y != 0      )   by Algebra*(2)  //NO! precondition is not satisfied!
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)</span></span></code></pre></div><p>If we made no changes to our logic block, Logika would complain that we had not satisfied the precondition. And indeed we haven&rsquo;t &ndash; while we&rsquo;ve shown that <code>y</code> isn&rsquo;t 0, we haven&rsquo;t shown that our second parameter <code>y+1</code> isn&rsquo;t 0. Here is the correction:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)</span></span></code></pre></div><h3 id=using-postconditions>Using postconditions</h3><p>Recall that since the function is ensuring that it will do/return specific things (its postconditions), then the calling code can list those postconditions as premises after the function call. If a postcondition uses the keyword <code>Res[returnType]</code>, then the calling code can list exactly that postcondition using whatever variable it used to store the return value in place of <code>Res[returnType]</code> and using whatever values were passed in place of the parameter names. In the <code>div</code> example above where we divide <code>x-1</code> by <code>y+1</code>, the calling code stores the value returned by <code>div</code> in a variable called <code>num</code>. Since the <code>div</code> postcondition is <code>result == a/b</code>, then we can claim the premise <code>num == (x-1)/(y+1)</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( num == (x-1)/(y+1)  )   by Premise  //postcondition of div
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We know from looking at this example that <code>(x-1)/(y+1)</code> is really <code>9/3</code>, which is 3. We would like to be able to assert that <code>num</code>, the value returned from <code>div</code>, equals 3. We can do this by adding a few more steps to our final proof block, plugging in the values for <code>x</code> and <code>y</code> and doing some algebra:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val x: Z = 10
</span></span><span style=display:flex><span>val y: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span style=display:flex><span>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span style=display:flex><span>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num: Z = div(x-1, y+1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 ( num == (x-1)/(y+1)  )   by Premise,     //postcondition of div
</span></span><span style=display:flex><span>    2 ( x == 10             )   by Premise,     //previous variable assignment
</span></span><span style=display:flex><span>    3 ( y == 2              )   by Premise,     //previous variable assignment
</span></span><span style=display:flex><span>    4 ( num == 9/3          )   by Algebra*(1,2,3),
</span></span><span style=display:flex><span>    5 ( num == 3            )   by Algebra*(4)  //needed for assert 
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(num == 3)</span></span></code></pre></div><p>Using a function contract and our deduction rules, we have PROVED that the <code>div</code> function will return 3 in our example (without needing to test the code at all).</p><h2 id=examples>Examples</h2><p>In this section, we will see two completed examples of Logika programs with a function and calling code.</p><h3 id=example-1>Example 1</h3><p>In this example, we write a <code>plusOne</code> function that takes a non-negative parameter and returns one more than that parameter:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def plusOne(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 0  ),
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            Res[Z] == n + 1,
</span></span><span style=display:flex><span>            Res[Z] &gt; 0
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    val answer: Z = n + 1
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1  (    n &gt;= 0          )   by Premise,
</span></span><span style=display:flex><span>        2  (    answer == n + 1 )   by Premise,
</span></span><span style=display:flex><span>        3  (    answer &gt; 0      )   by Algebra*(1, 2)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return answer
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////// Test code ///////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var x: Z = 5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     x == 5      )   by Premise,     //from the &#34;x=5&#34; assignment
</span></span><span style=display:flex><span>    2 (     x &gt;= 0      )   by Algebra*(1)  //proves the plusOne precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var added: Z = plusOne(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    //I can list the postcondition (what is returned) as a premise
</span></span><span style=display:flex><span>    1 (     x == 5                  )   by Premise, //x is unchanged 
</span></span><span style=display:flex><span>    2 (     added == x+1            )   by Premise, //plusOne postcondition 1
</span></span><span style=display:flex><span>    3 (     added &gt; 0               )   by Premise, //plusOne postcondition 2
</span></span><span style=display:flex><span>    4 (     added == 6              )   by Algebra*(1,2),
</span></span><span style=display:flex><span>    5 (     added == 6 ∧ added &gt; 0  )   by AndI(4,3)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(added == 6 ∧ added &gt; 0)</span></span></code></pre></div><p>Note that when we have more than one postcondition, we must prove all postconditions inside the function, and we can list all postconditions as premises in the calling code after the function call.</p><h3 id=example-2>Example 2</h3><p>In this example, we write a <code>findMax</code> function that returns the biggest between two integer parameters. This is very similar to an example from section 8.7, which used an if/else statement to find the max. In that example, our assert that we had indeed found the max was: <code>assert((max >= x & max >= y) & (max == x | max == y))</code>. We will see that our postconditions for <code>findMax</code> come directly from the different claims in that assert. In our calling code, we call <code>findMax</code> with <code>num1</code> (which has the value 3) and <code>num2</code> (which has the value 2). We are able to prove that <code>findMax</code> returns 2:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//find the max between x and y
</span></span><span style=display:flex><span>def findMax(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        //no precondition needed
</span></span><span style=display:flex><span>        Ensures(
</span></span><span style=display:flex><span>            Res[Z] &gt;= x,                //postcondition 1
</span></span><span style=display:flex><span>            Res[Z] &gt;= y,                //postcondition 2
</span></span><span style=display:flex><span>            Res[Z] == x v Res[Z] == y   //postcondition 3
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var max: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (x &gt; y) {
</span></span><span style=display:flex><span>        max = x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     max == x    )   by Premise,
</span></span><span style=display:flex><span>            2 (     max &gt;= x    )   by Algebra*(1),     //build to postcondition 1
</span></span><span style=display:flex><span>            3 (     x &gt; y       )   by Premise,         //IF condition is true
</span></span><span style=display:flex><span>            4 (     max &gt;= y    )   by Algebra*(1,3)    //build to postcondition 2
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        max = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     max == y    )   by Premise,
</span></span><span style=display:flex><span>            2 (     ¬(x &gt; y)    )   by Premise,         //IF condition is false
</span></span><span style=display:flex><span>            3 (     x &lt;= y      )   by Algebra*(2),
</span></span><span style=display:flex><span>            4 (     max &gt;= x    )   by Algebra*(1, 2),  //build to postcondition 1
</span></span><span style=display:flex><span>            5 (     max &gt;= y    )   by Algebra*(1)      //build to postcondition 2
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //prove the postconditions
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        //true in both the if and the else
</span></span><span style=display:flex><span>        1 (     max &gt;= x            )   by Premise,     //proves postcondition 1 
</span></span><span style=display:flex><span>        2 (     max &gt;= y            )   by Premise,     //proves postcondition 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //first was true in if, second true in else
</span></span><span style=display:flex><span>        3 (     max == x v max == y )   by Premise     //proves postcondition 3
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return max
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>////////////// Test code /////////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val num1: Z = 3
</span></span><span style=display:flex><span>val num2: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//findMax has no preconditions, so nothing to prove here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val biggest: Z = findMax(num1, num2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     biggest &gt;= num1                     )   by Premise,     //findMax postcondition 1
</span></span><span style=display:flex><span>    2 (     biggest &gt;= num2                     )   by Premise,     //findMax postcondition 2
</span></span><span style=display:flex><span>    3 (     biggest == num1 v biggest == num2   )   by Premise,     //findMax postcondition 3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in the initial values
</span></span><span style=display:flex><span>    4 (     num1 == 3                           )   by Premise,
</span></span><span style=display:flex><span>    5 (     num2 == 2                           )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    6 (     biggest &gt;= 3                        )   by Algebra*(1, 4),
</span></span><span style=display:flex><span>    7 (     biggest &gt;= 2                        )   by Algebra*(2, 5),
</span></span><span style=display:flex><span>    8 (     biggest == 3 v biggest == num2      )   by Subst_&lt;(4, 3),
</span></span><span style=display:flex><span>    9 (     biggest == 3 v biggest == 2         )   by Subst_&lt;(5, 8),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //OR-elimination
</span></span><span style=display:flex><span>    10 SubProof(
</span></span><span style=display:flex><span>        11  Assume( biggest == 3 ) 
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    12 SubProof(
</span></span><span style=display:flex><span>        13  Assume( biggest == 2 ) 
</span></span><span style=display:flex><span>        14 (    ¬(biggest &gt;= 3)                 )   by Algebra*(13),
</span></span><span style=display:flex><span>        15 (    F                               )   by NegE(6, 14),
</span></span><span style=display:flex><span>        16 (    biggest == 3                    )   by BottomE(15)
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    17 (        biggest == 3                    )   by OrE(9,10,12) //needed for assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(biggest == 3)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=recursion>Recursion</h1><p>In this section, we will see how to prove the correctness of programs that use recursive functions. We will see that verifying a recursive function is exactly the same as verifying a non-recursive function:</p><ul><li>We must prove a function&rsquo;s preconditions before calling it (including before making a recursive call)</li><li>After calling a function, we can list the function&rsquo;s postconditions as premises (including after making a recursive call)</li><li>The function can list its preconditions as premises</li><li>The function must prove its postconditions just before it ends</li></ul><h2 id=writing-a-recursive-mult-function>Writing a recursive mult function</h2><p>We know we can multiply two numbers, <code>x</code> and <code>y</code>, using the <code>*</code> operator &ndash; <code>x * y</code>. But what if we wanted to find the same result using only addition, not multiplication? Multiplication can be thought of as repeated addition &ndash; <code>x * y</code> is really <code>x + x + ... + x</code>, where we add together <code>y</code> total <code>x</code>&rsquo;s.</p><p>We <em>could</em> do this repeated addition with a loop (and we will when we introduce loops in section 9.3), but we will use recursion instead. When we write a recursive function, we try to think of two things:</p><ul><li>The <em>base case</em>: the simplest version of the problem that we could immediately solve with no more work.</li><li>The <em>recursive case</em>: bigger versions of the problem, where we solve a piece of the problem and then recursively solve a smaller piece</li></ul><p>In the case of the multiplication <code>x * y</code>, we have:</p><ul><li>Base case: if <code>y</code> is 0, we have no work to do. Adding together 0 <code>x</code>&rsquo;s is just 0.</li><li>Recursive case: if <code>y</code> is bigger than 0, we do ONE addition (<code>x + ...</code>) and recursively add the remaining <code>y - 1</code> numbers. (This will become our recursive call.)</li></ul><p>With those cases in mind, we can write a recursive <code>mult</code> function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        ans = mult(x, y-1)
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Note that we separated the recursive call (<code>ans = mult(x, y-1)</code>) from adding on the next piece (<code>ans = ans + x</code>). When using Logika, all function calls must go on a separate line by themselves &ndash; we can&rsquo;t combine them with other operations. Also, we included a dummy &ldquo;else&rdquo; branch to make the verification simpler.</p><h2 id=walking-through-mult>Walking through mult</h2><p>Suppose we call <code>mult</code> as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var times: Z = mult(4, 2)</span></span></code></pre></div><p>We can trace the recursive calls:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>times = mult(4, 2) 
</span></span><span style=display:flex><span>            (x = 4, y = 2)
</span></span><span style=display:flex><span>            ans = mult(4, 1)    =&gt; mult(4, 1)
</span></span><span style=display:flex><span>            ans = ans + 4               (x = 4, y = 1)
</span></span><span style=display:flex><span>            returns ans                     ans = mult(4, 0)    =&gt;  mult(4, 0)
</span></span><span style=display:flex><span>                                            ans = ans + 4               (x = 4, y = 0)
</span></span><span style=display:flex><span>                                            returns ans                     ans = 0
</span></span><span style=display:flex><span>                                                                            returns 0</span></span></code></pre></div><p>We start with <code>mult(4, 2)</code>, and then immediately make the recursive call <code>mult(4, 1)</code>, which immediately makes the recursive call <code>mult(4, 0)</code>. That function instance hits the base case and returns 0. We now return back up the chain of function calls &ndash; the 0 gets returned back to the <code>mult(4, 1)</code> instance, which adds 4 and then returns 4:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>=&gt; mult(4, 1)
</span></span><span style=display:flex><span>    (x = 4, y = 1)
</span></span><span style=display:flex><span>    ans = mult(4, 0) = 0
</span></span><span style=display:flex><span>    ans = ans + 4 = 4
</span></span><span style=display:flex><span>    returns ans (4)</span></span></code></pre></div><p>This 4 returns back to the <code>mult(4, 2)</code> instance, which adds another 4 and returns 8:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mult(4, 2) 
</span></span><span style=display:flex><span>    (x = 4, y = 2)
</span></span><span style=display:flex><span>    ans = mult(4, 1) = 4
</span></span><span style=display:flex><span>    ans = ans + 4 = 8
</span></span><span style=display:flex><span>    returns ans (8)</span></span></code></pre></div><p>We have now backed our way up the chain &ndash; the 8 is returned back from the original function call, and <code>times</code> is set to 8.</p><h2 id=mult-function-contract>mult function contract</h2><p>Looking at our <code>mult</code> function, we see that the base case is when <code>y</code> is 0 and the recursive case is when <code>y > 0</code>. Clearly, the function is not intended to work for negative values of <code>y</code>. This will be our precondition &ndash; that <code>y</code> must be greater than or equal to 0.</p><p>Our postcondition should describe what <code>mult</code> is returning in terms of its parameters. In this case, we know that <code>mult</code> is performing a multiplication of <code>x</code> and <code>y</code> using repeated addition. So, our function should ensure that it returns <code>x*y</code> (that <code>Res[Z] == x*y</code>). Here is the function with the function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    //we still need to add the verification logic blocks
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        ans = mult(x, y-1)
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=verification-in-mult>Verification in mult</h2><p>Now that we have our function contract for <code>mult</code>, we must add logic blocks with two things in mind:</p><ul><li>Proving the precondition before a recursive call</li><li>Proving the postcondition before we return from the function</li></ul><p>Our recursive call looks like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ans = mult(x, y-1)</span></span></code></pre></div><p>Since our precondition is <code>y >= 0</code>, we see that we must prove that what we are passing as the second parameter (<code>y-1</code>, in the case of the recursive call) is greater than or equal to 0. This tells us that before our recursive call, we must have shown exactly: <code>y-1 >= 0</code>. We can finish proving the precondition as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    //we still need to prove the postcondition
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     y &gt; 0       )   by Premise,     //IF condition is true
</span></span><span style=display:flex><span>            2 (     y-1 &gt;= 0    )   by Algebra*(1)  //Proves the precondition for the recursive call
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans = mult(x, y-1)
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>All that remains is to prove the <code>mult</code> postcondition &ndash; that we are returning <code>x*y</code>. Since we are returning the variable <code>ans</code>, then we must prove the claim <code>ans == x*y</code> just before our return statement. In order to help with this process, we will need to take advantage of the postcondition after our recursive call. The function promises to return the first parameter times the second parameter, so when we do <code>ans = mult(x, y-1)</code>, we know that <code>ans == x*(y-1)</code> (the first parameter, <code>x</code>, times the second parameter, <code>y-1</code>). Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z): Z = {
</span></span><span style=display:flex><span>    //verification complete!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var ans: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (y &gt; 0) {
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     y &gt; 0       )   by Premise,     //IF condition is true
</span></span><span style=display:flex><span>            2 (     y-1 &gt;= 0    )   by Algebra*(1)  //Proves the precondition for the recursive call
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       ans = mult(x, y-1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     ans == x * (y - 1)  )   by Premise, //Postcondition from the recursive call
</span></span><span style=display:flex><span>            2 (     ans == x * y - x    )   by Algebra*(1)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans = ans + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     Old(ans) == x * y - x   )   by Premise,         //Pulled from previous block
</span></span><span style=display:flex><span>            2 (     ans == Old(ans) + x     )   by Premise,         //From the &#34;ans = ans + x&#34; assignment statement
</span></span><span style=display:flex><span>            3 (     ans == x + x * y - x    )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>            4 (     ans == x * y            )   by Algebra*(3)      //Showed the postcondition for the IF branch
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        //do nothing in code - but we still do verification
</span></span><span style=display:flex><span>        //need to show that postcondition will be correct even if we take this branch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     ¬(y &gt; 0)        )   by Premise,         //if condition is false
</span></span><span style=display:flex><span>            2 (     y &gt;= 0          )   by Premise,         //precondition
</span></span><span style=display:flex><span>            3 (     y == 0          )   by Algebra*(1, 2),
</span></span><span style=display:flex><span>            4 (     ans == 0        )   by Premise,         //ans is unchanged
</span></span><span style=display:flex><span>            5 (     ans == x * y    )   by Algebra*(3, 4)   //Showed the postcondition for the ELSE branch
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Tie together what we learned in both branches
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     ans == x*y          )   by Premise          //shows the postcondition      
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return ans
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=verification-of-calling-code>Verification of calling code</h2><p>Verifying the test code that calls a recursive function works exactly the same way as it does for any other function:</p><ul><li>We must prove the precondition before calling the function</li><li>We can list the postcondition as a premise after calling the function</li></ul><p>Suppose we want to test <code>mult</code> as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>val times: Z = mult(4, 2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(times == 8)</span></span></code></pre></div><p>We could complete the verification by proving the precondition and then using the postcondition to help us prove the claim in the assert:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     2 &gt;= 0      )   by Algebra*()    //proves the precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val times: Z = mult(4, 2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     times == 4*2    )   by Premise,     //mult postcondition
</span></span><span style=display:flex><span>    2 (     times == 8      )   by Algebra*(1)  //needed for the assert
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(times == 8)</span></span></code></pre></div><p>Note that since our second parameter is <code>2</code>, that we must demonstrate exactly <code>2 >= 0</code> to satisfy <code>mult</code>&rsquo;s precondition. Furthermore, since <code>mult</code> promises to return the first parameter times the second parameter, and since we are storing the result of the function call in the <code>times</code> variable, then we can claim <code>times == 4*2</code> as a premise.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=loops>Loops</h1><p>A <em>loop</em> is a command that restarts itself over and over while its <em>loop condition</em> remains true. Loops are trickier to analyze than if/else statements, because we don&rsquo;t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations&mldr;we don&rsquo;t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.</p><p>The only loop available in Logika is a <em>while</em> loop, which behaves in the same way as while loops in other languages. If the loop condition is initially false, then the body of the while loop is skipped entirely. If the loop condition is initially true, then we execute the loop body and then recheck the condition. This continues until the loop condition becomes false.</p><p>Here is the syntax of a Scala while loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (condition) {
</span></span><span style=display:flex><span>   //body of loop
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=loop-invariants>Loop invariants</h2><p>Our solution to analyzing loops despite not knowing the number of iterations is a tool called a <em>loop invariant</em>. The job of the loop invariant is to summarize what is always true about the loop. Often, the loop invariant describes the relationship between variables and demonstrates how much progress the loop has made. Sometimes the loop invariant also contains claims that certain variables will always stay in a particular range.</p><p>Whatever we choose as the loop invariant, we must be able to do the following:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li></ul><h2 id=loop-invariants-and-mathematical-induction>Loop invariants and mathematical induction</h2><p>The process of proving the correctness of loop invariants is very similar to a mathematical induction proof. We must prove the loop invariant is true before the loop begins, which is analogous to the <em>base case</em> in mathematical induction. The process of assuming the invariant is true at the beginning of an iteration and proving that it is still true at the end of an iteration is just like mathematical induction&rsquo;s <em>inductive step</em>.</p><p>If we prove those two things about our invariant, we can be certain the invariant will still hold after the loop terminates. Why? For the same reason mathematical induction proves a property for a general <span class="math align-center">$n$</span>:</p><ul><li>We know the invariant holds before the loop begins</li><li>Because the invariant holds before the loop begins, we are sure it holds at the beginning of the first iteration</li><li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the first iteration</li><li>Because we&rsquo;re sure it still holds at the end of the first iteration, we know it holds at the beginning of the second iteration</li><li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the second iteration
&mldr;</li><li>We&rsquo;re sure the invariant still holds at the end of each iteration, including the end of the LAST iteration. Thus we&rsquo;re certain the invariant holds just after the loop ends.</li></ul><h2 id=loop-invariant-block-syntax>Loop invariant block syntax</h2><p>In Logika, we will write a <em>loop invariant block</em> to describe our loop invariants. This block will go just inside the loop, before the loop body:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (condition) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(comma-separated list of variables),
</span></span><span style=display:flex><span>        Invariant_1,
</span></span><span style=display:flex><span>        Invariant_2,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //loop body
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here is a summary of the different loop invariant clauses:</p><ul><li><code>Modifies</code>: uses a comma-separated list to name each variable whose value changes in the loop body</li><li><code>Invariant_i</code>: lists an invariant for the function. If we have multiple invariants, we can list them on separate lines (<code>Invariant_1</code>, <code>Invariant_2</code>, etc.)</li></ul><h2 id=example-loop-invariant-block-for-a-multiplication-loop>Example: loop invariant block for a multiplication loop</h2><p>Suppose we have the following loop to multiply two numbers, <code>x</code> and <code>y</code>, using repeated addition. (This is very similar to our <code>mult</code> function from section 9.2, except it does the additions using a loop instead of using recursion):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><p>Before writing the loop invariant block, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>After iteration 3</th><th>&mldr;</th><th>After iteration y</th></tr></thead><tbody><tr><td><code>count</code></td><td>0</td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>y</td></tr><tr><td><code>sum</code></td><td><span class="math align-center">$0 (= 0*x)$</span></td><td><span class="math align-center">$x (= 1*x)$</span></td><td><span class="math align-center">$x + x (= 2*x)$</span></td><td><span class="math align-center">$x + x + x (= 3*x)$</span></td><td>&mldr;</td><td><span class="math align-center">$x + x + ... + x (= y*x)$</span></td></tr></tbody></table><p>Before the loop begins, we&rsquo;ve added 0 <span class="math align-center">$x$</span>&rsquo;s together, so the sum is 0. After the first iteration, we&rsquo;ve added 1 <span class="math align-center">$x$</span> together, so the sum is <span class="math align-center">$x$</span>. After the second iteration, we&rsquo;ve added 2 <span class="math align-center">$x$</span>&rsquo;s together, so the sum is <span class="math align-center">$x + x$</span> which is really <span class="math align-center">$2 * x$</span>. This continues until after the y-th iteration, when we&rsquo;ve added y <span class="math align-center">$x$</span>&rsquo;s together (and the sum is <span class="math align-center">$y*x$</span>).</p><p>Using this table, it is easy to see that at any point, <code>sum == count*x</code> (since <code>count</code> tracks the number of iterations). This is true both before the loop begins and at the end of each iteration, so it will be our loop invariant.</p><p>We now add a loop invariant block to our loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    //loop invariant block (still needs to be proved)
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><p>We list <code>sum</code> and <code>count</code> in the <code>Modifies</code> clause because those are the two variables that change value inside the loop.</p><h2 id=proving-the-loop-invariant>Proving the loop invariant</h2><p>In order to prove the correctness of a loop, we must do two things:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li></ul><h3 id=proving-loop-invariant-before-loop-begins>Proving loop invariant before loop begins</h3><p>In our multiplication loop above, let&rsquo;s start by proving the loop invariant before the loop begins. This means that just before the loop, we must prove exactly the claim <code>sum == count*x</code>. We can do this with algebra on the current variable values:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//prove the invariant before the loop begins
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //we still need to prove the invariant after each iteration
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><h3 id=proving-loop-invariant-at-the-end-of-each-iteration>Proving loop invariant at the end of each iteration</h3><p>To prove the loop invariant still holds at the end of an iteration, we must have a logic block at the end of the loop body with exactly the claim in the loop invariant (which will now be referring to the updated values of each variable). Since this step has us assuming the loop invariant is true at the beginning of each iteration, we can list the loop invariant as a <em>premise</em> in a logic block just inside the loop body. Here is the structure we wish to follow for our multiplication loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                        //at the beginning of an iteration
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //need to prove exactly &#34;sum == count*x&#34;
</span></span><span style=display:flex><span>    //to prove our invariant still holds at the end of an iteration
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We can complete the loop invariant proof by using our tools for processing assignment statements with mutations. Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>val x: Z = Z.read()
</span></span><span style=display:flex><span>val y: Z = Z.read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var sum: Z = 0
</span></span><span style=display:flex><span>var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//prove the invariant before the loop begins
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>while (count != y) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == count * x
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                        //at the beginning of an iteration
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span style=display:flex><span>        2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span style=display:flex><span>        3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span style=display:flex><span>        2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style=display:flex><span>                                                                //but count has changed
</span></span><span style=display:flex><span>        3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span style=display:flex><span>        4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span style=display:flex><span>        5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//now sum is x*y</span></span></code></pre></div><h3 id=knowledge-after-loop-ends>Knowledge after loop ends</h3><p>In the example above, suppose we add the following assert after the loop ends:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>assert(sum == x*y)</span></span></code></pre></div><p>This seems like a reasonable claim &ndash; after all, we said that our loop was supposed to calculated <code>x * y</code> using repeated addition. We have proved the loop invariant, so we can be sure that <code>sum == count*x</code> after the loop&mldr;but that&rsquo;s not quite the same thing. Does <code>count</code> equal <code>y</code>? How do we know?</p><p>We can prove our assert statement by considering one more piece of information &ndash; if we have exited the loop, we know that the loop condition must be false. In fact, you always know two things (which you can claim as premises) after the loop ends:</p><ol><li>The loop condition is false (so we can claim <code>¬(condition)</code>)</li><li>The loop invariant is true, since we proved is true at the end of each iteration</li></ol><p>We can use those pieces of information to prove our assert statement:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//the multiplication loop example goes here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     sum == count*x  )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>    2 (     ¬(count != y)   )   by Premise,     //the loop condition is not true
</span></span><span style=display:flex><span>    3 (     count == y      )   by Algebra*(2),
</span></span><span style=display:flex><span>    4 (     sum == x*y      )   by Algebra*1,3  //proves our assert statement
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(sum == x*y)</span></span></code></pre></div><h2 id=functions-with-loops>Functions with loops</h2><p>If we have a function that includes a loop, we must do the following:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Given that the loop invariant is true at the beginning of an iteration, prove that it is still true at the end of the iteration</li><li>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition</li></ul><p>For example, suppose our loop multiplication is inside a function which is tested by some calling code. We would like to add a function contract, our loop invariant proof, and necessary logic blocks to show that our assert holds at the end of the calling code. Here is just the code for the example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != y) {
</span></span><span style=display:flex><span>        sum = sum + x
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><p>We start by adding a function contract to <code>mult</code>, which will be the same as our function contract for the recursive version of this function in section 9.2 &ndash; <code>y</code> needs to be nonnegative, and we promise to return <code>x*y</code>. Here is the code after adding the function contract and our previous loop verificaton:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style=display:flex><span>    //function contract
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),  //precondition: y should be nonnegative
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )   //postcondition (we promise to return x*y)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //prove the invariant before the loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != y) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == count * x
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                            //at the beginning of an iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span style=display:flex><span>            2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span style=display:flex><span>            3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span style=display:flex><span>            2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style=display:flex><span>                                                                    //but count has changed
</span></span><span style=display:flex><span>            3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span style=display:flex><span>            4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span style=display:flex><span>            5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //STILL NEED TO PROVE POSTCONDITION
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//STILL NEED TO ADD VERIFICATION FOR ASSERT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><p>We can use the negation of the loop condition (<code>¬(count != y)</code>) together with the loop invariant to prove the postcondition will hold before the function returns. We can also apply the same process as in sections 9.1 and 9.2 to prove the precondition in the calling code before calling the <code>mult</code> function, and to use the function&rsquo;s postcondition after the call to <code>mult</code> to prove our goal assert. Here is the completed example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style=display:flex><span>    //function contract
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   y &gt;= 0          ),  //precondition: y should be nonnegative
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == x * y )   //postcondition (we promise to return x*y)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //prove the invariant before the loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span style=display:flex><span>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span style=display:flex><span>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != y) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == count * x
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span style=display:flex><span>                                                            //at the beginning of an iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span style=display:flex><span>            2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span style=display:flex><span>            3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span style=display:flex><span>            2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style=display:flex><span>                                                                    //but count has changed
</span></span><span style=display:flex><span>            3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span style=display:flex><span>            4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span style=display:flex><span>            5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     ¬(count != y)       )   by Premise,         //loop condition is now false
</span></span><span style=display:flex><span>        2 (     sum == count*x      )   by Premise,         //loop invariant holds after loop
</span></span><span style=display:flex><span>        3 (     count == y          )   by Algebra*(1),
</span></span><span style=display:flex><span>        4 (     sum == x*y          )   by Algebra*(2,3)    //proves the postcondition
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////////// Test code //////////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var one: Z = 3
</span></span><span style=display:flex><span>var two: Z = 4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     two == 4        )   by Premise,     //from the &#34;two = 4&#34; assignment
</span></span><span style=display:flex><span>    2 (     two &gt;= 0        )   by Algebra*(1)  //proves the mult precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = mult(one, two)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     one == 3            )   by Premise,
</span></span><span style=display:flex><span>    2 (     two == 4            )   by Premise,
</span></span><span style=display:flex><span>    3 (     answer == one*two   )   by Premise          //from the mult postcondition
</span></span><span style=display:flex><span>    4 (     answer == 12        )   by Algebra*(1,2,3)  //proves the assert 
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 12)</span></span></code></pre></div><h2 id=how-to-construct-a-loop-invariant>How to construct a loop invariant</h2><p>The most difficult part of the entire process of proving the correctness of a function with a loop is coming up with an appropriate loop invariant. In this section, we will study two additional loops and learn techniques for deriving loop invariants. In general, we need to think about what the loop is doing as it iterates, and what progress it has made so far towards its goal. A good first approach is to trace through the values of variables for several iterations of the loop, as we did with <code>mult</code> above &ndash; this helps us identify patterns that can then become the loop invariant.</p><h3 id=example-1-sum-of-odds>Example 1: Sum of odds</h3><p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var total: Z = 0
</span></span><span style=display:flex><span>var i: Z = 0
</span></span><span style=display:flex><span>while (i &lt; n) {
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    total = total + (2*i - 1)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>It might be difficult to tell what this code is doing before walking through a few iterations. Let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>After iteration 3</th><th>&mldr;</th><th>After iteration n</th></tr></thead><tbody><tr><td><code>i</code></td><td>0</td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>n</td></tr><tr><td><code>total</code></td><td><span class="math align-center">$0 $</span></td><td><span class="math align-center">$1 $</span></td><td><span class="math align-center">$1 + 3 (= 4)$</span></td><td><span class="math align-center">$1 + 3 + 5 (= 9)$</span></td><td>&mldr;</td><td><span class="math align-center">$1 + 3 + 5 + ... + (2*n-1) (=n^2)$</span></td></tr></tbody></table><p>Now we can see the pattern &ndash; we are adding up the first <span class="math align-center">$n$</span> odd numbers. We can see that at the end of the i-th iteration we have added the first <span class="math align-center">$i$</span> odd numbers, where <span class="math align-center">$(2*i-1)$</span> is our most recent odd number. We also see that the sum of the first 1 odd number is 1, the sum of the first 2 odd numbers is <span class="math align-center">$2^2 = 4$</span>, &mldr;, and the sum of the first <span class="math align-center">$n$</span> odd numbers is <span class="math align-center">$n^2$</span>.</p><p>Since our loop invariant should describe what progress it has made towards its goal of adding the first <span class="math align-center">$n$</span> odd numbers, we can see that the loop invariant should be that at any point (before the loop begins and at the end each iteration), <span class="math align-center">$total$</span> holds the sum of the first <span class="math align-center">$i$</span> numbers (whose value is <span class="math align-center">$i^2$</span>). We first try this as our loop invariant:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var total: Z = 0
</span></span><span style=display:flex><span>var i: Z = 0
</span></span><span style=display:flex><span>while (i &lt; n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, n),
</span></span><span style=display:flex><span>        total == i*i
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    total = total + (2*i - 1)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Another consideration of writing a loop invariant is that we should be able to deduce our overall goal once the loop ends. After our loop, we want to be sure that <code>total</code> holds the sum of the first <code>n</code> odd numbers &ndash; i.e., that <code>total == n*n</code>. Our loop invariant tells us that <code>total == i*i</code> after the loop ends &ndash; but does <code>n</code> necessarily equal <code>i</code>?</p><p>The way it is written, we can&rsquo;t be certain. We do know that the loop condition must be false after the loop, or that <code>¬(i &lt; n)</code>. But this is equivalent to <code>i >= n</code> and not <code>i == n</code>. We need to tighten our invariant to add a restriction that <code>i</code> always be less than or equal to n:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var total: Z = 0
</span></span><span style=display:flex><span>var i: Z = 0
</span></span><span style=display:flex><span>while (i &lt; n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, n),
</span></span><span style=display:flex><span>        total == i*i,
</span></span><span style=display:flex><span>        i &lt;= n
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    total = total + (2*i - 1)
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>After the loop ends, we can now combine the negation of the loop condition, <code>¬(i &lt; n)</code> together with the <code>i &lt;= n</code> portion of the invariant to deduce that <code>i == n</code>. Together with the other half of the invariant &ndash; <code>total == i*i</code> &ndash; we can be sure that <code>total == n*n</code> when the loop ends.</p><h3 id=example-2-factorial>Example 2: factorial</h3><p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>var prod: Z = 1
</span></span><span style=display:flex><span>var i: Z = 1
</span></span><span style=display:flex><span>while (i != n) {
</span></span><span style=display:flex><span>    i = i + 1
</span></span><span style=display:flex><span>    prod = prod * i
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>As before, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>&mldr;</th><th>After iteration n</th></tr></thead><tbody><tr><td><code>i</code></td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>n</td></tr><tr><td><code>prod</code></td><td><span class="math align-center">$1 $</span></td><td><span class="math align-center">$1 * 2$</span></td><td><span class="math align-center">$1 * 2 * 3$</span></td><td>&mldr;</td><td><span class="math align-center">$1 * 2 * 3 * ... * n$</span></td></tr></tbody></table><p>From this table, we can clearly see that after <span class="math align-center">$i$</span> iterations, <span class="math align-center">$prod == i!$</span> (i factorial). This <em>should</em> be our loop invariant&mldr;but as with many other languages, Logika does not recognize <code>!</code> as a factorial operator (instead, it is a negation operator). In the next section, we will see how to create a <em>Logika fact</em> to help define the factorial operation. We will then be able to use that Logika fact in place of <code>!</code> to let our invariant be a formalization of: <em>prod equals i factorial</em>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=logika-facts>Logika Facts</h1><p>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that <span class="math align-center">$n! = n * (n-1) * (n-2) * ... * 2 * 1$</span>, but we don&rsquo;t have a way to describe the &ldquo;&mldr;&rdquo; portion using our current tools.</p><p>In this section, we introduce <em>Logika facts</em>, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a &ldquo;&mldr;&rdquo; to demonstrate a pattern.</p><h2 id=logika-fact-syntax>Logika fact syntax</h2><p>Logika allows these proof functions to be written in multiple ways, but we will start with the most straightforward of these options:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def proofFunction(paramList): returnType = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def proofFacts = Fact(
</span></span><span style=display:flex><span>    proofFunction(baseCase) == baseValue,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; (rangeOfX) → (proofFunction(x) == proofFunction(x - 1) * x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>In the above definition, <code>proofFunction</code> is the name we give our proof function, <code>paramList</code> is the list of parameter names and types needed for this proof function (which are formatted exactly like a parameter list in a regular Logika function), and <code>returnType</code> is the return type of the proof function (usually either <code>Z</code> for integer or <code>B</code> for boolean). The <code>= $</code> at the end of the proof function is indicating that its definition will be provided later.</p><p>Below the proof function, we include the <em>proof facts</em>, which is a recursive definition of the values for our proof function. We include one or more base cases, which list the value of our proof function for its smallest possible input (or for the smallest several inputs). Finally, we include our recursive case as a quantified statement &ndash; it lists the value of our proof function on all inputs bigger than our base cases. This recursive case uses the proof function&rsquo;s definition for a smaller value, like <code>proofFunction(x-1)</code>.</p><p>Logika facts are defined at the top of the Logika file, below the <code>import</code>s but before any of the code.</p><h2 id=example-logika-fact-to-define-factorial>Example: Logika fact to define factorial</h2><p>It is much easier to see how Logika facts work by using an example. Suppose we want to define the factorial operation. The first step is to come up with a <em>recursive definition</em>, which has us defining the operation the same way we would in a recursive function &ndash; with one or more <em>base cases</em> where we can define the operation for the simplest case, and one or more <em>recursive cases</em> that express a general instance of the problem in terms of a smaller instance.</p><p>For factorial, the simplest version is <span class="math align-center">$1!$</span>, which is just 1. In the general case, we have that:</p><span class="math align-center">$$
n! = n * (n-1) * (n-2) * ... * 2 * 1 = n * (n-1)!
$$</span><br><p>So we can write the following recursive definition:</p><ul><li>Base case: <span class="math align-center">$1! = 1$</span></li><li>Recursive case: for values of <span class="math align-center">$n$</span> greater than 1, <span class="math align-center">$n! = n * (n-1)!$</span></li></ul><p>And we can then translate the recursive definition to a Logika fact:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    ∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Let&rsquo;s consider each portion of this proof function. Here, <code>factFunction</code> is the name given to the proof function. It takes one parameter, <code>n</code>, which is an integer, and it returns an integer. We have two possible ways of calculating the value for the proof function, which we detail in <code>factorialFacts</code>. First, we define our base case:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(1) == 1</span></span></code></pre></div><p>Which says that <code>factFunction(n)</code> is 1 if <span class="math align-center">$n == 1$</span>. This is the same as our base case in our recursive definition for factorial &ndash; <span class="math align-center">$1! = 1$</span>.</p><p>Next, consider the recursive case of our proof function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )</span></span></code></pre></div><p>This case states that for all integers <code>x</code> that are bigger than 1, we define <code>factFunction(x) == x * factFunction(x - 1)</code>. This is the same as our recursive case in our recursive definition for factorial &ndash; for values of <span class="math align-center">$n$</span> greater than 1, <span class="math align-center">$n! = n * (n-1)!$</span>.</p><h2 id=evaluating-a-logika-fact>Evaluating a Logika fact</h2><p>Suppose we used our <code>factorialFacts</code> proof function to calculate <code>factFunction(3)</code>. We would have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(3) == 3 * factFunction(2)      //we use the recursive case, since 3 &gt; 1
</span></span><span style=display:flex><span>factFunction(2) == 2 * factFunction(1)      //we use the recursive case, since 2 &gt; 1
</span></span><span style=display:flex><span>factFunction(1) == 1                        //we use the base case       </span></span></code></pre></div><p>Once we work down to:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(1) == 1</span></span></code></pre></div><p>We can plug <code>1</code> in for <code>facfactFunctiontDef(1)</code> in <code>factFunction(2) == 2 * factFunction(1)</code>, which gives us:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(2) == 2</span></span></code></pre></div><p>Similarly, we can plug <code>2</code> in for <code>factFunction(2)</code> in <code>factFunction(3) == 3 * factFunction(2)</code>, and see that:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(3) == 6</span></span></code></pre></div><h2 id=using-logika-facts-as-justifications>Using Logika facts as justifications</h2><p>If we had our proof function, <code>factFunction</code>, then we could pull its two facts from its <code>factorialFacts</code> recursive definition into a proof block like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     factFunction(1) == 1                                                )   by ClaimOf(factorialFacts _),                                             
</span></span><span style=display:flex><span>    2 (     ∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )  )   by ClaimOf(factorialFacts _)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that we must pull in the definitions EXACTLY as they are written in the proof function. The justification is always <code>ClaimOf(proofFacts _)</code> where <code>proofFacts</code> is the name of the recursive definition.</p><h2 id=using-logika-facts-in-postconditions-and-invariants>Using Logika facts in postconditions and invariants</h2><p>Consider the following full Logika program that includes a function to find and return a factorial, as well as test code that calls our factorial function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// n! = n * (n-1) * (n-2) * .. * 1
</span></span><span style=display:flex><span>// 1! = 1
</span></span><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style=display:flex><span>    var product: Z = 1  //our current calculation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>        product = product * i
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return product
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = factorial(num)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 2)</span></span></code></pre></div><p>We want to add a function contract, loop invariant block, and supporting logic blocks to demonstrate that <code>factorial</code> is returning <code>n!</code> and to prove the assert in our text code.</p><h3 id=writing-a-function-contract-using-a-logika-fact>Writing a function contract using a Logika fact</h3><p>We want our <code>factorial</code> function contract to say that it is returning <code>n!</code>, and that it is only defined for values of <code>n</code> that are greater than or equal to 0. We recall that our Logika fact, <code>factFunction</code>, defines the factorial operation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    ∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>And we will use <code>factFunction</code> to define what we mean by &ldquo;factorial&rdquo; in our <code>factorial</code> function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 1                      ),  //factFunction(n) is only defined when n &gt;= 1
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == factFunction(n)   )   //we promise to return factFunction(n), where factFunction defines n!
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //code for factorial function
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=writing-a-loop-invariant-block-using-a-logika-fact>Writing a loop invariant block using a Logika fact</h3><p>We can similarly use <code>factFunction</code> in our loop invariant block. We noted at the end of section 9.3 that the invariant in our loop should be: <em>prod equals i factorial</em>. Now we have a way to express what we mean by &ldquo;factorial&rdquo;, so our invariant will be: <code>prod == factFunction(i)</code>. Since the <code>factFunction</code> proof function is only defined for parameters greater than or equal to 1, we need to add a second piece to the invariant to guarantee that <code>i</code> will always be greater than or equal to 1. We now have the following loop invariant block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (i != n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, product),
</span></span><span style=display:flex><span>        product == factFunction(i),
</span></span><span style=display:flex><span>        i &gt;= 1
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //loop body
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=finishing-the-verification>Finishing the verification</h3><p>All that remains is to:</p><ul><li>Prove our loop invariant holds before the loop begins</li><li>When we assume the loop invariant holds at the beginning of an iteration, prove that it still holds at the end of the iteration</li><li>Use the loop invariant together with the negation of the loop condition to prove the <code>factorial</code> postcondition</li><li>Prove the precondition holds in the calling code just before calling <code>factorial</code></li><li>Use the postcondition after calling <code>factorial</code> to prove the final assert</li></ul><p>Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    ∀((x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x))
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 1                      ),  //factFunction(n) is only defined when n &gt;= 1
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == factFunction(n)   )   //we promise to return factFunction(n), where factFunction defines n!
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style=display:flex><span>    var product: Z = 1  //my current calculation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Prove invariant before loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     i == 1                      ) by Premise,
</span></span><span style=display:flex><span>        2 (     product == 1                ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         //pull in proof function base case
</span></span><span style=display:flex><span>        3 (     factFunction(1) == 1        ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //proves first loop invariant holds 
</span></span><span style=display:flex><span>        4 (     product == factFunction(i)  ) by Algebra*(1, 2, 3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //proves second loop invariant holds 
</span></span><span style=display:flex><span>        5 (     i &gt;= 1                      ) by Algebra*(1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(i, product),
</span></span><span style=display:flex><span>            product == factFunction(i),
</span></span><span style=display:flex><span>            i &gt;= 1
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            //from &#34;i = i + 1&#34;
</span></span><span style=display:flex><span>            1 (     i == Old(i) + 1                  ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //loop invariant held before changing i
</span></span><span style=display:flex><span>            2 (     product == factFunction(Old(i))  ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //rewrite invariant with no &#34;Old&#34;
</span></span><span style=display:flex><span>            3 (     product == factFunction(i - 1)   ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //second loop invariant held before changing i
</span></span><span style=display:flex><span>            4 (     Old(i) &gt;= 1                      ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //needed for the Logika fact
</span></span><span style=display:flex><span>            5 (     i &gt; 1                            ) by Algebra*(1, 4)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        product = product * i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //Prove invariant still holds at end of iteration
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            //from &#34;product = product * i&#34;
</span></span><span style=display:flex><span>            1 (  product == Old(product) * i                                        ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //from previous logic block
</span></span><span style=display:flex><span>            2 (  Old(product) == factFunction(i - 1)                                ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             //pull in recursive case from proof function
</span></span><span style=display:flex><span>            3 (  ∀( (x: Z) =&gt; x &gt; 1 → factFunction(x) == factFunction(x - 1) * x )  ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //plug in &#34;i&#34; for &#34;x&#34; (where i is of type Z)
</span></span><span style=display:flex><span>            4 (  i &gt; 1 → factFunction(i) == factFunction(i - 1) * i                 ) by AllE[Z](3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //from previous logic block
</span></span><span style=display:flex><span>            5 (  i &gt; 1                                                              ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //i &gt; 1, so get right side of →
</span></span><span style=display:flex><span>            6 (  factFunction(i) == factFunction(i - 1) * i                         ) by ImplyE(4, 5),
</span></span><span style=display:flex><span>            7 (  product == factFunction(i - 1) * i                                 ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //proves first invariant still holds
</span></span><span style=display:flex><span>            8 (  product == factFunction(i)                                         ) by Algebra*(6, 7),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //proves second invariant still holds
</span></span><span style=display:flex><span>            9 (  i &gt;= 1                                                             ) by Algebra*(5)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Prove postcondition
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     product == factFunction(i)  ) by Premise,      //loop invariant
</span></span><span style=display:flex><span>        2 (     !(i != n)                   ) by Premise,      //loop condition false
</span></span><span style=display:flex><span>        3 (     i == n                      ) by Algebra*(2),
</span></span><span style=display:flex><span>        4 (     product == factFunction(n)  ) by Algebra*(1, 3)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return product
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//Prove precondition
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     num == 2  ) by Premise,
</span></span><span style=display:flex><span>    2 (     num &gt;= 1  ) by Algebra*(1)     //proves factorial precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = factorial(num)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (  answer == factFunction(num)                                        ) by Premise,       //factorial postcondition
</span></span><span style=display:flex><span>    2 (  num == 2                                                           ) by Premise,
</span></span><span style=display:flex><span>    3 (  answer == factFunction(2)                                          ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in recursive case from proof function
</span></span><span style=display:flex><span>    4 (  ∀( (x: Z) =&gt; x &gt; 1 → factFunction(x) == factFunction(x - 1) * x )  ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     //plug in &#34;2&#34; for &#34;x&#34; (where 2 is an integer of type Z)
</span></span><span style=display:flex><span>    5 (  2 &gt; 1 → factFunction(2) == factFunction(2 - 1) * 2                 ) by AllE[Z](4),
</span></span><span style=display:flex><span>    6 (  2 &gt; 1                                                              ) by Algebra*(),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //2 &gt; 1, so use →
</span></span><span style=display:flex><span>    7 (  factFunction(2) == factFunction(2 - 1) * 2                         ) by ImplyE(5, 6),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in base case from proof function
</span></span><span style=display:flex><span>    8 (  factFunction(1) == 1                                               ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>    9 (  factFunction(2) == factFunction(1) * 2                             ) by Algebra*(7),
</span></span><span style=display:flex><span>    10 (  factFunction(2) == 2                                              ) by Algebra*(8, 9),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //proves claim in assert
</span></span><span style=display:flex><span>    11 (  answer == 2                                                       ) by Algebra*(1, 2, 10)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 2)</span></span></code></pre></div><h2 id=logika-fact-for-multiplication>Logika fact for multiplication</h2><p>Suppose we wanted to create a Logika fact that recursively defined multiplication. We first recursively define how we would multiply <span class="math align-center">$x * y$</span>. We know that our base case will be when <span class="math align-center">$y == 0$</span>, because anything times 0 is 0. We also saw that multiplication can be defined as repeated addition, so that <span class="math align-center">$x * y == x + x + ... x$</span> for a total of <span class="math align-center">$y$</span> additions. We also see that <span class="math align-center">$x * y == x + x * (y-1)$</span>, since we can pull out one of the additions and then have <span class="math align-center">$y-1$</span> additions left to do.</p><p>Here is our recursive definition of the problem:</p><ul><li>Base case: for all numbers x, x * 0 is 0</li><li>Recursive case: for all numbers x and all positive numbers y, x * y = x + x * (y-1)</li></ul><p>We can translate this directly to a proof function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def multFunction(m: Z, n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFacts = Fact(
</span></span><span style=display:flex><span>    //anything multiplied by 0 is just 0
</span></span><span style=display:flex><span>    ∀((x: Z) =&gt; multFunction(x, 0) == 0 ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; ∀( (y: Z) =&gt; (y &gt; 1) → (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We could use this Logika fact in the postcondition and loop invariant block for a multiplication function as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFunction(m: Z, n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFacts = Fact(
</span></span><span style=display:flex><span>    //anything multiplied by 0 is just 0
</span></span><span style=display:flex><span>    ∀((x: Z) =&gt; multFunction(x, 0) == 0 ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; ∀( (y: Z) =&gt; (y &gt; 1) → (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//want to find: num1 + num1 + ... + num1 (a total of num2 times)
</span></span><span style=display:flex><span>def mult(num1: Z, num2: Z): Z = {
</span></span><span style=display:flex><span>    Contract( 
</span></span><span style=display:flex><span>        Requires( num2 &gt;= 1 ),
</span></span><span style=display:flex><span>        Ensures( Res[Z] == multFunction(num1, num2) )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    var answer: Z = 0
</span></span><span style=display:flex><span>    var cur: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (cur != num2) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(cur, answer),
</span></span><span style=display:flex><span>            answer == multFunction(num1, cur),
</span></span><span style=display:flex><span>            cur &gt;= 0
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cur = cur + 1
</span></span><span style=display:flex><span>        answer = answer + num1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return answer
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>The example above does not include the verification steps to prove the loop invariant and postcondition, but those things could be accomplished in the same way as for the <code>factorial</code> function.</p><h2 id=logika-fact-for-fibonacci-numbers>Logika fact for Fibonacci numbers</h2><p>The Fibonacci sequence is:</p><span class="math align-center">$$
1, 1, 2, 3, 5, 8, 13, ...
$$</span><p><br><br></p><p>The first two Fibonacci numbers are both 1, and subsequent Fibonacci numbers are found by adding the two previous values. In the sequence above, we see that the two latest numbers were 8 and 13, so the next number in the sequence will be <span class="math align-center">$8 + 13 = 21$</span>.</p><p>We can recursively define the Fibonacci sequence as follows:</p><ul><li>Base case 1: the first Fibonacci number is 1</li><li>Base case 2: the second Fibonacci number is 1</li><li>Recursive case: for all numbers x greater than 2, the x-th Fibonacci number is the (x-1)-th Fibonacci number + the (x-2)-th Fibonacci number</li></ul><p>We can translate this directly to a Logika fact:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//defines the nth number in the Fibonacci sequence
</span></span><span style=display:flex><span>//1, 1, 2, 3, 5, 8, 13, ...
</span></span><span style=display:flex><span>@spec def fibFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def fibFacts = Fact(
</span></span><span style=display:flex><span>    fibFunction(1) == 1,
</span></span><span style=display:flex><span>    fibFunction(2) == 2,
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; (x &gt; 2) → fibFunction(x-1) + fibFunction(x-2) )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; ∀( (y: Z) =&gt; (y &gt; 1) → (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Which we could use in a postcondition and loop invariant if we wrote a function to compute the Fibonacci numbers.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:</p><h2 id=step-1-write-function-contracts>Step 1: Write function contracts</h2><p>Write a function contract for any function that doesn&rsquo;t already have one. Function contracts go just inside the function defintion, and look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires( preconditions ),
</span></span><span style=display:flex><span>    Ensures( postconditions )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, <em>preconditions</em> is a comma-separated list of any requirements your function has about the range of its parameters, and <em>postconditions</em> is a comma-separated list describing the impact of calling the function (in this chapter, the postcondition always describes how the return value relates to the parameters.) If you&rsquo;re not sure what to write as the postcondition, try walking through your function with different parameters to get a sense for the pattern of what the function is doing in relation to the parameters. If you were given a Logika proof function, you will likely need to use it in the postcondition (and loop invariant) to describe the behavior.</p><h2 id=step-2-write-loop-invariant-blocks>Step 2: Write loop invariant blocks</h2><p>Write a loop invariant block for any loop that doesn&rsquo;t already have one. Loop invariant blocks go just inside the loop (before any code) and look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Invariant(
</span></span><span style=display:flex><span>    Modifies(comma-separated list of variables),
</span></span><span style=display:flex><span>    Invariant_1,
</span></span><span style=display:flex><span>    Invariant_2,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Each <em>Invariant_i</em> describes an invariant for the loop, which should describe the progress the loop has made toward its goal (the loop invariant will often greatly resemble the postcondition for the enclosing function). Loop invariants occasionally need to specify the range of different variables, especially if the invariant uses Logika facts (which may only be defined for particular values) or if you need more information about the final value of a variable when a loop terminates. I recommend making a table of variable values for several iterations of your loop to get a sense of the relationship between variables &ndash; this relationship is what will become the loop invariant.</p><p>The <em>Modifies</em> clause lists all variables that are modified in the loop body.</p><h2 id=step-3-prove-invariant-holds-before-loop-begins>Step 3: Prove invariant holds before loop begins</h2><p>In each loop, prove your invariant holds before the loop begins. You may need to pull in the function&rsquo;s precondition as a premise in this step. You must prove EXACTLY the claim in all pieces of the loop invariant. If your loop invariant involves a Logika fact, you may need to pull in a piece of the fact definition to help prove the invariant.</p><h2 id=step-4-prove-invariant-still-holds-at-end-of-iteration>Step 4: Prove invariant still holds at end of iteration</h2><p>In each loop, prove your invariant still holds at the end of each iteration. Start by pulling in each part of the loop invariant as a premise before the loop body begins. Use logic blocks to process each statement in the body of the loop. By the end of the loop, you must prove EXACTLY the claim in all pieces of the loop invariant. (Again, if your loop invariant involves a Logika fact, you&rsquo;ll want to pull in a piece of the fact definition to help with this step.)</p><h2 id=step-5-prove-the-postcondition>Step 5: Prove the postcondition</h2><p>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition just before your function ends.</p><h2 id=step-6-prove-the-precondition-before-each-function-call>Step 6: Prove the precondition before each function call</h2><p>Before any function call, prove exactly the precondition(s) for the function (using whatever values you are passing as parameters).</p><h2 id=step-7-use-postcondition-after-each-function-call>Step 7: Use postcondition after each function call</h2><p>After returning from each function call, pull the function&rsquo;s postcondition into a logic block as a premise (using whatever values you passed as parameters). Use this information to help prove any asserts.</p><footer class=footline></footer></article></section></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis301/js/mathjax/tex-mml-chtml.js?1755877650></script><script src=/cis301/js/clipboard/clipboard.min.js?1755877650 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1755877650 defer></script><script src=/cis301/js/theme.min.js?1755877650 defer></script></div><script src=/cis301/js/tele-scroll.min.js?1755877650 defer></script></body></html>