




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Logika Facts :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/index.xml" rel="alternate" type="application/rss+xml" title="Logika Facts :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/index.print.html" rel="alternate" type="text/html" title="Logika Facts :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/tele.html" rel="alternate" type="text/html" title="Logika Facts :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/embed.html" rel="alternate" type="text/html" title="Logika Facts :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1711307483" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1711307483" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1711307483" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1711307483" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1711307483" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1711307483" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1711307483" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1711307483" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1711307483" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1711307483" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1711307483" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1711307483" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1711307483" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1711307483"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1711307483"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1711307483" rel="stylesheet">

  </head>
  <body class="mobile-support html disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
            <a class="nav nav-next topbar-link" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_5-summary/index.html" title="Summary (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
            <a class="nav nav-prev topbar-link" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/index.html" title="Loops (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-print-link">
            <a class="print-link topbar-link" title='Print whole chapter (CTRL+ALT+p)' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/index.print.html">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="top-github-link">
            <a class="github-link topbar-link" title='Edit (CTRL+ALT+w)' href="https://gitlab.cs.ksu.edu/-/ide/project/cs-textbooks/cis301-textbook/edit/master/-/content/9-chapter/9_4-logikaFacts.md" target="_blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span id="toc-menu" title='Table of Contents (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/index.html"><span itemprop="name">CIS 301 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/index.html"><span itemprop="name">Functions and Loops</span></a><meta itemprop="position" content="2"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Logika Facts</span><meta itemprop="position" content="3"></li>
            </ol>
          </div>
          <div class="default-animation progress">
            <div class="toc-wrapper"><nav id="TableOfContents">
  <ul>
    <li><a href="#logika-fact-syntax">Logika fact syntax</a></li>
    <li><a href="#example-logika-fact-to-define-factorial">Example: Logika fact to define factorial</a></li>
    <li><a href="#evaluating-a-logika-fact">Evaluating a Logika fact</a></li>
    <li><a href="#using-logika-facts-as-justifications">Using Logika facts as justifications</a></li>
    <li><a href="#using-logika-facts-in-postconditions-and-invariants">Using Logika facts in postconditions and invariants</a>
      <ul>
        <li><a href="#writing-a-function-contract-using-a-logika-fact">Writing a function contract using a Logika fact</a></li>
        <li><a href="#writing-a-loop-invariant-block-using-a-logika-fact">Writing a loop invariant block using a Logika fact</a></li>
        <li><a href="#finishing-the-verification">Finishing the verification</a></li>
      </ul>
    </li>
    <li><a href="#logika-fact-for-multiplication">Logika fact for multiplication</a></li>
    <li><a href="#logika-fact-for-fibonacci-numbers">Logika fact for Fibonacci numbers</a></li>
  </ul>
</nav>
            </div>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="logika-facts">Logika Facts</h1>

<p>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that 
<span class="math align-center">$n! = n * (n-1) * (n-2) * ... * 2 * 1$</span>, but we don&rsquo;t have a way to describe the &ldquo;&hellip;&rdquo; portion using our current tools.</p>
<p>In this section, we introduce <em>Logika facts</em>, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a &ldquo;&hellip;&rdquo; to demonstrate a pattern.</p>
<h2 id="logika-fact-syntax">Logika fact syntax</h2>
<p>Logika allows these proof functions to be written in multiple ways, but we will start with the most straightforward of these options:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def proofFunctionName(paramList) : returnType
</span></span><span style="display:flex;"><span>            factName1. //describe when proofFunctionName has its first possible value
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>            factNameN. //describe when proofFunctionName has its last possible value
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>In the proof function definition, <em>proofFunctionName</em> is the name we give our proof function, <em>paramList</em> is the list of parameter names and types needed for this proof function (which are formatted exactly like a parameter list in a regular Logika function), and <em>returnType</em> is the return type of the proof function (usually either <code>Z</code> for integer or <code>B</code> for boolean).</p>
<p>Below the proof function definition, we include a line for each possible way to calculate its value. Usually, at least one of the lines includes a recursive defintion &ndash; relating the value of something like <code>proofFunctionName(n)</code> to the proof function&rsquo;s definition for a smaller value, like <code>proofFunctionName(n-1)</code>. The label, such as <code>factNameN</code>, names the proof rule. We will be able to pull in a particular line of the definition into a logic block by using the justification <code>fact factNameN</code>.</p>
<p>Logika facts are defined at the top of the Logika file, below the <code>import</code> but before any of the code.</p>
<h2 id="example-logika-fact-to-define-factorial">Example: Logika fact to define factorial</h2>
<p>It is much easier to see how Logika facts work by using an example. Suppose we want to define the factorial operation. The first step is to come up with a <em>recursive definition</em>, which has us defining the operation the same way we would in a recursive function &ndash; with one or more <em>base cases</em> where we can define the operation for the simplest case, and one or more <em>recursive cases</em> that express a general instance of the problem in terms of a smaller instance.</p>
<p>For factorial, the simplest version is 
<span class="math align-center">$1!$</span>, which is just 1. In the general case, we have that:</p>

<span class="math align-center">$$
n! = n * (n-1) * (n-2) * ... * 2 * 1 = n * (n-1)!
$$</span><br>
<p>So we can write the following recursive definition:</p>
<ul>
<li>Base case: 
<span class="math align-center">$1! = 1$</span></li>
<li>Recursive case: for values of 
<span class="math align-center">$n$</span> greater than 1, 
<span class="math align-center">$n! = n * (n-1)!$</span></li>
</ul>
<p>And we can then translate the recursive definition to a Logika fact:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Let&rsquo;s consider each portion of this proof function. Here, <code>factDef</code> is the name given to the proof function. It takes one parameter, <code>n</code>, which is an integer, and it returns an integer. We have two possible ways of calculating the value for the proof function. First, we define <code>fOne</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fOne. factDef(1) == 1</span></span></code></pre></div><p><code>fOne</code> defines <code>factDef(1)</code> as 1; i.e., <code>factDef(n)</code> is 1 if 
<span class="math align-center">$n == 1$</span>. This is the same as our base case in our recursive definition for factorial &ndash; 
<span class="math align-center">$1! = 1$</span>.</p>
<p>Next, consider the definition for <code>fBig</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)</span></span></code></pre></div><p><code>fBig</code> states that for all integers <code>x</code> that are bigger than 1, we define <code>factDef(x) == x * factDef(x - 1)</code>. This is the same as our recursive case in our recursive definition for factorial &ndash; for values of 
<span class="math align-center">$n$</span> greater than 1, 
<span class="math align-center">$n! = n * (n-1)!$</span>.</p>
<h2 id="evaluating-a-logika-fact">Evaluating a Logika fact</h2>
<p>Suppose we used our <code>factDef</code> proof function to calculate <code>factDef(3)</code>. We would have:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(3) == 3 * factDef(2)        //we use fBig, since 3 &gt; 1
</span></span><span style="display:flex;"><span>factDef(2) == 2 * factDef(1)        //we use fBig, since 2 &gt; 1
</span></span><span style="display:flex;"><span>factDef(1) == 1                     //we use fOne       </span></span></code></pre></div><p>Once we work down to:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(1) == 1</span></span></code></pre></div><p>We can plug <code>1</code> in for <code>factDef(1)</code> in <code>factDef(2) == 2 * factDef(1)</code>, which gives us:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(2) == 2</span></span></code></pre></div><p>Similarly, we can plug <code>2</code> in for <code>factDef(2)</code> in <code>factDef(3) == 3 * factDef(2)</code>, and see that:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>factDef(3) == 6</span></span></code></pre></div><h2 id="using-logika-facts-as-justifications">Using Logika facts as justifications</h2>
<p>If we had our Logika fact, <code>factDef</code>, then we could pull its two definitions into a logic block like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. factDef(1) == 1                                  fact fOne
</span></span><span style="display:flex;"><span>    2. ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)  fact fBig
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Note that we must pull in the definitions EXACTLY as they are written in the proof function. The justification is always <code>fact</code> followed by the name of the corresponding definition.</p>
<h2 id="using-logika-facts-in-postconditions-and-invariants">Using Logika facts in postconditions and invariants</h2>
<p>Consider the following full Logika program that includes a function to find and return a factorial, as well as test code that calls our factorial function:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// n! = n * (n-1) * (n-2) * .. * 1
</span></span><span style="display:flex;"><span>// 1! = 1
</span></span><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style="display:flex;"><span>    var product: Z = 1  //our current calculation
</span></span><span style="display:flex;"><span>    while (i != n) {
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>        product = product * i
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return product
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = factorial(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 2)</span></span></code></pre></div><p>We want to add a function contract, loop invariant block, and supporting logic blocks to demonstrate that <code>factorial</code> is returning <code>n!</code> and to prove the assert in our text code.</p>
<h3 id="writing-a-function-contract-using-a-logika-fact">Writing a function contract using a Logika fact</h3>
<p>We want our <code>factorial</code> function contract to say that it is returning <code>n!</code>, and that it is only defined for values of <code>n</code> that are greater than or equal to 0. We recall that our Logika fact, <code>factDef</code>, defines the factorial operation:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == x * factDef(x - 1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>And we will use <code>factDef</code> to define what we mean by &ldquo;factorial&rdquo; in our <code>factorial</code> function contract:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 1                 //factorial(n) is only defined when n &gt;= 1
</span></span><span style="display:flex;"><span>        ensures result == factDef(n)    //we promise to return factDef(n),
</span></span><span style="display:flex;"><span>                                        //where factDef(n) defines n!
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //code for factorial function
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="writing-a-loop-invariant-block-using-a-logika-fact">Writing a loop invariant block using a Logika fact</h3>
<p>We can similarly use <code>factDef</code> in our loop invariant block. We noted at the end of section 9.3 that the invariant in our loop should be: <em>prod equals i factorial</em>. Now we have a way to express what we mean by &ldquo;factorial&rdquo;, so our invariant will be: <code>prod == factDef(i)</code>. Since the <code>factDef</code> proof function is only defined for parameters greater than or equal to 1, we need to add a second piece to the invariant to guarantee that <code>i</code> will always be greater than or equal to 1. We now have the following loop invariant block:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (i != n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant product == factDef(i)
</span></span><span style="display:flex;"><span>            i &gt;= 1
</span></span><span style="display:flex;"><span>        modifies i, product
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //loop body
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="finishing-the-verification">Finishing the verification</h3>
<p>All that remains is to:</p>
<ul>
<li>Prove our loop invariant holds before the loop begins</li>
<li>When we assume the loop invariant holds at the beginning of an iteration, prove that it still holds at the end of the iteration</li>
<li>Use the loop invariant together with the negation of the loop condition to prove the <code>factorial</code> postcondition</li>
<li>Prove the precondition holds in the calling code just before calling <code>factorial</code></li>
<li>Use the postcondition after calling <code>factorial</code> to prove the final assert</li>
</ul>
<p>Here is the completed verification:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        def factDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fOne. factDef(1) == 1
</span></span><span style="display:flex;"><span>            fBig.  ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def factorial(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 1
</span></span><span style="display:flex;"><span>        ensures result == factDef(n)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var i: Z = 1 //how many multiplications we have done
</span></span><span style="display:flex;"><span>    var product: Z = 1  //my current calculation
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Prove invariant before loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. i == 1                       premise
</span></span><span style="display:flex;"><span>        2. product == 1                 premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //pull in first Logika fact rule
</span></span><span style="display:flex;"><span>        3. factDef(1) == 1              fact fOne     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //proves first loop invariant holds  
</span></span><span style="display:flex;"><span>        4. product == factDef(i)        algebra 1 2 3   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //proves second loop invariant holds
</span></span><span style="display:flex;"><span>        5. i &gt;= 1                       algebra 1       
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (i != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant product == factDef(i)
</span></span><span style="display:flex;"><span>                i &gt;= 1
</span></span><span style="display:flex;"><span>            modifies i, product
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            //from &#34;i = i + 1&#34;
</span></span><span style="display:flex;"><span>            1. i == i_old + 1               premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //loop invariant held before changing i
</span></span><span style="display:flex;"><span>            2. product == factDef(i_old)    premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //rewrite invariant with no &#34;_old&#34;
</span></span><span style="display:flex;"><span>            3. product == factDef(i-1)      algebra 1 2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //second loop invariant held before changing i
</span></span><span style="display:flex;"><span>            4. i_old &gt;= 1                   premise     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //needed for the Logika fact
</span></span><span style="display:flex;"><span>            5. i &gt; 1                        algebra 1 4 
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        product = product * i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //Prove invariant still holds at end of iteration
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            //from &#34;product = product * i&#34;
</span></span><span style="display:flex;"><span>            1. product == product_old*i                         premise 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //from previous logic block
</span></span><span style="display:flex;"><span>            2. product_old == factDef(i-1)                      premise 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //pull in Logika fact
</span></span><span style="display:flex;"><span>            3. ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x  fact fBig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //plug in &#34;i&#34; for &#34;x&#34;
</span></span><span style="display:flex;"><span>            4. i &gt; 1 → factDef(i) == factDef(i - 1) * i         Ae 3 i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //from previous logic block
</span></span><span style="display:flex;"><span>            5. i &gt; 1                                            premise   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //i &gt; 1, so get right side of →
</span></span><span style="display:flex;"><span>            6. factDef(i) == factDef(i - 1) * i                 →e 4 5     
</span></span><span style="display:flex;"><span>            7. product == factDef(i-1)*i                        algebra 1 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //proves first invariant still holds
</span></span><span style="display:flex;"><span>            8. product == factDef(i)                            algebra 6 7 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //proves first invariant still holds
</span></span><span style="display:flex;"><span>            9. i &gt;= 1                                           algebra 5
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //Prove postcondition
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. product == factDef(i)        premise //loop invariant
</span></span><span style="display:flex;"><span>        2. !(i != n)                    premise //loop condition false
</span></span><span style="display:flex;"><span>        3. i == n                       algebra 2
</span></span><span style="display:flex;"><span>        4. product == factDef(n)        algebra 1 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return product
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////// Test code ///////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var num: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//Prove precondition
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == 2             premise
</span></span><span style="display:flex;"><span>    2. num &gt;= 1             algebra 1   //proves factorial precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = factorial(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. answer == factDef(num)           premise     //factorial postcondition
</span></span><span style="display:flex;"><span>    2. num == 2                         premise
</span></span><span style="display:flex;"><span>    3. answer == factDef(2)             algebra 1 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in Logika fact
</span></span><span style="display:flex;"><span>    4. ∀x: Z  x &gt; 1 → factDef(x) == factDef(x - 1) * x  fact fBig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //plug in &#34;2&#34; for &#34;x&#34;
</span></span><span style="display:flex;"><span>    5. 2 &gt; 1 → factDef(2) == factDef(2 - 1) * 2         Ae 4 2 
</span></span><span style="display:flex;"><span>    6. 2 &gt; 1                            algebra
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //2 &gt; 1, so use →
</span></span><span style="display:flex;"><span>    7. factDef(2) == factDef(2 - 1) * 2  →e 5 6  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in Logika fact
</span></span><span style="display:flex;"><span>    8. factDef(1) == 1                  fact fOne       
</span></span><span style="display:flex;"><span>    9. factDef(2) == factDef(1) * 2     algebra 7
</span></span><span style="display:flex;"><span>    10. factDef(2) == 2                 algebra 8 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //proves claim in assert
</span></span><span style="display:flex;"><span>    11. answer == 2                     algebra 1 2 10
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 2)</span></span></code></pre></div><h2 id="logika-fact-for-multiplication">Logika fact for multiplication</h2>
<p>Suppose we wanted to create a Logika fact that recursively defined multiplication. We first recursively define how we would multiply 
<span class="math align-center">$x * y$</span>. We know that our base case will be when 
<span class="math align-center">$y == 0$</span>, because anything times 0 is 0. We also saw that multiplication can be defined as repeated addition, so that 
<span class="math align-center">$x * y == x + x + ... x$</span> for a total of 
<span class="math align-center">$y$</span> additions. We also see that 
<span class="math align-center">$x * y == x + x * (y-1)$</span>, since we can pull out one of the additions and then have 
<span class="math align-center">$y-1$</span> additions left to do.</p>
<p>Here is our recursive definition of the problem:</p>
<ul>
<li>Base case: for all numbers x, x * 0 is 0</li>
<li>Recursive case: for all numbers x and all positive numbers y, x * y = x + x * (y-1)</li>
</ul>
<p>We can translate this directly to a Logika fact:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines m * n = m + m + ... + m (n times)
</span></span><span style="display:flex;"><span>        def multDef(m: Z, n: Z): Z
</span></span><span style="display:flex;"><span>            //anything multiplied by 0 is just 0
</span></span><span style="display:flex;"><span>            mult0. ∀ x: Z multDef(x, 0) == 0
</span></span><span style="display:flex;"><span>            multPos. ∀ x: Z (∀ y: Z y &gt; 0 → multDef(x, y) == x + multDef(x, y-1))
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>We could use this Logika fact in the postcondition and loop invariant block for a multiplication function as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines m * n = m + m + ... + m (n times)
</span></span><span style="display:flex;"><span>        def multDef(m: Z, n: Z): Z
</span></span><span style="display:flex;"><span>            //anything multiplied by 0 is just 0
</span></span><span style="display:flex;"><span>            mult0. A x: Z multDef(x, 0) == 0
</span></span><span style="display:flex;"><span>            multPos. A x: Z (A y: Z y &gt; 0 -&gt; multDef(x, y) == multDef(x, y-1) + x)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//want to find: num1 + num1 + ... + num1 (a total of num2 times)
</span></span><span style="display:flex;"><span>def mult(num1: Z, num2: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires num2 &gt;= 0
</span></span><span style="display:flex;"><span>        ensures result == multDef(num1, num2)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var answer: Z = 0
</span></span><span style="display:flex;"><span>    var cur: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (cur != num2) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant
</span></span><span style="display:flex;"><span>                answer == multDef(num1, cur)
</span></span><span style="display:flex;"><span>                cur &gt;= 0
</span></span><span style="display:flex;"><span>            modifies cur, answer
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>        cur = cur + 1
</span></span><span style="display:flex;"><span>        answer = answer + num1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return answer
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>The example above does not include the verification steps to prove the loop invariant and postcondition, but those things could be accomplished in the same way as for the <code>factorial</code> function.</p>
<h2 id="logika-fact-for-fibonacci-numbers">Logika fact for Fibonacci numbers</h2>
<p>The Fibonacci sequence is:</p>

<span class="math align-center">$$
1, 1, 2, 3, 5, 8, 13, ...
$$</span><p><br><br></p>
<p>The first two Fibonacci numbers are both 1, and subsequent Fibonacci numbers are found by adding the two previous values. In the sequence above, we see that the two latest numbers were 8 and 13, so the next number in the sequence will be 
<span class="math align-center">$8 + 13 = 21$</span>.</p>
<p>We can recursively define the Fibonacci sequence as follows:</p>
<ul>
<li>Base case 1: the first Fibonacci number is 1</li>
<li>Base case 2: the second Fibonacci number is 1</li>
<li>Recursive case: for all numbers x greater than 2, the x-th Fibonacci number is the (x-1)-th Fibonacci number + the (x-2)-th Fibonacci number</li>
</ul>
<p>We can translate this directly to a Logika fact:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    fact
</span></span><span style="display:flex;"><span>        //defines the nth number in the Fibonacci sequence
</span></span><span style="display:flex;"><span>        //1, 1, 2, 3, 5, 8, 13, ...
</span></span><span style="display:flex;"><span>        def fibDef(n: Z): Z
</span></span><span style="display:flex;"><span>            fib1. fibDef(1) == 1
</span></span><span style="display:flex;"><span>            fib2. fibDef(2) == 1
</span></span><span style="display:flex;"><span>            fibN. ∀ x: Z x &gt; 2 → fibDef(x) == fibDef(x-1) + fibDef(x-2)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Which we could use in a postcondition and loop invariant if we wrote a function to compute the Fibonacci numbers.</p>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Julie Thornton
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/af82a65dc1c94cb6d0310a624077a2e135001155">Dec 7, 2023</a>
</p>
</div>

    
    </div>
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">

<a id="logo" href="https://ksu-cs-textbooks.github.io/cis301/">
  CIS 301: Logical Foundations of Programming
</a>

        </div>
        <form action="https://ksu-cs-textbooks.github.io/cis301/search.html" method="get"><div class="searchbox default-animation">
          <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
          <label class="a11y-only" for="search-by">Search</label>
          <input data-search-input id="search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
          <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
        </div></form>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/auto-complete.js?1711307484" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr/lunr.min.js?1711307484" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr/lunr.stemmer.support.min.js?1711307484" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr/lunr.multi.min.js?1711307484" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr/lunr.en.min.js?1711307484" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/search.js?1711307484" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics enlarge morespace collapsible-menu">
          <li data-nav-id="/0-chapter/index.html" class=""><input type="checkbox" id="section-c55c9f751a28ecc9415234375cddd395" aria-controls="subsections-c55c9f751a28ecc9415234375cddd395"><label for="section-c55c9f751a28ecc9415234375cddd395"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Getting Started</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/index.html"><b>0. </b>Getting Started</a><ul id="subsections-c55c9f751a28ecc9415234375cddd395" class="morespace collapsible-menu">
          <li data-nav-id="/0-chapter/0_1-toolsguide/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/0_1-toolsguide/index.html">0.1. Tools Guide</a></li></ul></li>
          <li data-nav-id="/1-chapter/index.html" class=""><input type="checkbox" id="section-7a71fe25dd66b523fca4004b7c4d01d0" aria-controls="subsections-7a71fe25dd66b523fca4004b7c4d01d0"><label for="section-7a71fe25dd66b523fca4004b7c4d01d0"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Basics and Logic Puzzles</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/index.html"><b>1. </b>Basics and Logic Puzzles</a><ul id="subsections-7a71fe25dd66b523fca4004b7c4d01d0" class="morespace collapsible-menu">
          <li data-nav-id="/1-chapter/1_1-logicbasics/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_1-logicbasics/index.html">1.1. Basic Logical Reasoning</a></li>
          <li data-nav-id="/1-chapter/1_2-knightsknaves/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_2-knightsknaves/index.html">1.2. Knights and Knaves</a></li>
          <li data-nav-id="/1-chapter/1_3-otherpuzzles/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_3-otherpuzzles/index.html">1.3. Other Puzzles</a></li></ul></li>
          <li data-nav-id="/2-chapter/index.html" class=""><input type="checkbox" id="section-c23f766dd7728aa0e1cff094001eac05" aria-controls="subsections-c23f766dd7728aa0e1cff094001eac05"><label for="section-c23f766dd7728aa0e1cff094001eac05"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Truth Tables</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/index.html"><b>2. </b>Truth Tables</a><ul id="subsections-c23f766dd7728aa0e1cff094001eac05" class="morespace collapsible-menu">
          <li data-nav-id="/2-chapter/2_1-opscircuits/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_1-opscircuits/index.html">2.1. Operators and Circuits</a></li>
          <li data-nav-id="/2-chapter/2_2-logikatruth/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_2-logikatruth/index.html">2.2. Truth Tables in Logika</a></li>
          <li data-nav-id="/2-chapter/2_3-satis/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_3-satis/index.html">2.3. Satisfiability</a></li>
          <li data-nav-id="/2-chapter/2_4-logicalequiv/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/index.html">2.4. Logical Equivalence</a></li>
          <li data-nav-id="/2-chapter/2_5-sementail/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_5-sementail/index.html">2.5. Semantic Entailment</a></li></ul></li>
          <li data-nav-id="/3-chapter/index.html" class=""><input type="checkbox" id="section-ccb531d159d5247057d21618514721b6" aria-controls="subsections-ccb531d159d5247057d21618514721b6"><label for="section-ccb531d159d5247057d21618514721b6"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Propositional Logic Translations</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/index.html"><b>3. </b>Propositional Logic Translations</a><ul id="subsections-ccb531d159d5247057d21618514721b6" class="morespace collapsible-menu">
          <li data-nav-id="/3-chapter/3_1-propatom/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_1-propatom/index.html">3.1. Propositional Atoms</a></li>
          <li data-nav-id="/3-chapter/3_2-notandor/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_2-notandor/index.html">3.2. NOT, AND, OR Translations</a></li>
          <li data-nav-id="/3-chapter/3_3-implies/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_3-implies/index.html">3.3. Implies Translations</a></li>
          <li data-nav-id="/3-chapter/3_4-equiv/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_4-equiv/index.html">3.4. Equivalent Translations</a></li>
          <li data-nav-id="/3-chapter/3_5-knightsknavestt/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_5-knightsknavestt/index.html">3.5. Knights and Knaves, revisited</a></li></ul></li>
          <li data-nav-id="/4-chapter/index.html" class=""><input type="checkbox" id="section-8ebf970484325d93d52075c7c72ba517" aria-controls="subsections-8ebf970484325d93d52075c7c72ba517"><label for="section-8ebf970484325d93d52075c7c72ba517"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Propositional Logic Proofs</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/index.html"><b>4. </b>Propositional Logic Proofs</a><ul id="subsections-8ebf970484325d93d52075c7c72ba517" class="morespace collapsible-menu">
          <li data-nav-id="/4-chapter/4_1-intro/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_1-intro/index.html">4.1. Introduction</a></li>
          <li data-nav-id="/4-chapter/4_2-andrules/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_2-andrules/index.html">4.2. AND Rules</a></li>
          <li data-nav-id="/4-chapter/4_3-orrules/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_3-orrules/index.html">4.3. OR Rules</a></li>
          <li data-nav-id="/4-chapter/4_4-impliesrules/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_4-impliesrules/index.html">4.4. Implies Rules</a></li>
          <li data-nav-id="/4-chapter/4_5-notrules/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_5-notrules/index.html">4.5. Negation Rules</a></li>
          <li data-nav-id="/4-chapter/4_6-strategies/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_6-strategies/index.html">4.6. Summary and Strategies</a></li>
          <li data-nav-id="/4-chapter/4_7-theorems/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/index.html">4.7. Theorems</a></li>
          <li data-nav-id="/4-chapter/4_8-equivalence/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_8-equivalence/index.html">4.8. Equivalence</a></li>
          <li data-nav-id="/4-chapter/4_9-soundcomplete/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_9-soundcomplete/index.html">4.9. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/5-chapter/index.html" class=""><input type="checkbox" id="section-b69c30f957b0ff55c1e9673979ceb29d" aria-controls="subsections-b69c30f957b0ff55c1e9673979ceb29d"><label for="section-b69c30f957b0ff55c1e9673979ceb29d"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Predicate Logic Translations</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/index.html"><b>5. </b>Predicate Logic Translations</a><ul id="subsections-b69c30f957b0ff55c1e9673979ceb29d" class="morespace collapsible-menu">
          <li data-nav-id="/5-chapter/5_1-motivation/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_1-motivation/index.html">5.1. Motivation</a></li>
          <li data-nav-id="/5-chapter/5_2-predsyntax/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_2-predsyntax/index.html">5.2. Syntax</a></li>
          <li data-nav-id="/5-chapter/5_3-singlequantifier/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_3-singlequantifier/index.html">5.3. Single Quantifier</a></li>
          <li data-nav-id="/5-chapter/5_4-multquant/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_4-multquant/index.html">5.4. Multiple Quantifiers</a></li></ul></li>
          <li data-nav-id="/6-chapter/index.html" class=""><input type="checkbox" id="section-482218cb3a05b9572157ed70ed9a5c02" aria-controls="subsections-482218cb3a05b9572157ed70ed9a5c02"><label for="section-482218cb3a05b9572157ed70ed9a5c02"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Predicate Logic Proofs</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.html"><b>6. </b>Predicate Logic Proofs</a><ul id="subsections-482218cb3a05b9572157ed70ed9a5c02" class="morespace collapsible-menu">
          <li data-nav-id="/6-chapter/6_1-univrules/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_1-univrules/index.html">6.1. Rules with ∀</a></li>
          <li data-nav-id="/6-chapter/6_2-existrules/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_2-existrules/index.html">6.2. Rules with ∃</a></li>
          <li data-nav-id="/6-chapter/6_3-nested/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_3-nested/index.html">6.3. Nested Quantifiers</a></li>
          <li data-nav-id="/6-chapter/6_4-equiv/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_4-equiv/index.html">6.4. Equivalence</a></li>
          <li data-nav-id="/6-chapter/6_5-strategies/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_5-strategies/index.html">6.5. Summary and Strategies</a></li>
          <li data-nav-id="/6-chapter/6_6-soundcomplete/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/index.html">6.6. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/7-chapter/index.html" class=""><input type="checkbox" id="section-fc25ecfcb3d8e929949e8db759e88bab" aria-controls="subsections-fc25ecfcb3d8e929949e8db759e88bab"><label for="section-fc25ecfcb3d8e929949e8db759e88bab"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Mathematical Induction</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/index.html"><b>7. </b>Mathematical Induction</a><ul id="subsections-fc25ecfcb3d8e929949e8db759e88bab" class="morespace collapsible-menu">
          <li data-nav-id="/7-chapter/7_1-process/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_1-process/index.html">7.1. Induction Process</a></li>
          <li data-nav-id="/7-chapter/7_2-algebraex/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_2-algebraex/index.html">7.2. Algebra example</a></li>
          <li data-nav-id="/7-chapter/7_3-divex/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_3-divex/index.html">7.3. Divisibility example</a></li>
          <li data-nav-id="/7-chapter/7_4-setex/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_4-setex/index.html">7.4. Set example</a></li></ul></li>
          <li data-nav-id="/8-chapter/index.html" class=""><input type="checkbox" id="section-bd411d4b09a07aa69f5152043fa837ed" aria-controls="subsections-bd411d4b09a07aa69f5152043fa837ed"><label for="section-bd411d4b09a07aa69f5152043fa837ed"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Intro to Programming Logic</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/index.html"><b>8. </b>Intro to Programming Logic</a><ul id="subsections-bd411d4b09a07aa69f5152043fa837ed" class="morespace collapsible-menu">
          <li data-nav-id="/8-chapter/8_1-goal/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_1-goal/index.html">8.1. Programming Logic Goal</a></li>
          <li data-nav-id="/8-chapter/8_2-logikaprograms/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_2-logikaprograms/index.html">8.2. Logika Programs</a></li>
          <li data-nav-id="/8-chapter/8_3-assertassume/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_3-assertassume/index.html">8.3. Assert and Assume</a></li>
          <li data-nav-id="/8-chapter/8_4-algebrasubst/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_4-algebrasubst/index.html">8.4. Algebra and subst Rules</a></li>
          <li data-nav-id="/8-chapter/8_5-assignment/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/index.html">8.5. Assignment Statements</a></li>
          <li data-nav-id="/8-chapter/8_6-divmod/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_6-divmod/index.html">8.6. Integer Division and Modulo</a></li>
          <li data-nav-id="/8-chapter/8_7-conditionals/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_7-conditionals/index.html">8.7. Conditional Statements</a></li></ul></li>
          <li data-nav-id="/9-chapter/index.html" class="parent "><input type="checkbox" id="section-708a4026c5b157dd8da0a277e359073f" aria-controls="subsections-708a4026c5b157dd8da0a277e359073f" checked><label for="section-708a4026c5b157dd8da0a277e359073f"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Functions and Loops</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/index.html"><b>9. </b>Functions and Loops</a><ul id="subsections-708a4026c5b157dd8da0a277e359073f" class="morespace collapsible-menu">
          <li data-nav-id="/9-chapter/9_1-functions/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/index.html">9.1. Functions</a></li>
          <li data-nav-id="/9-chapter/9_2-recursion/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_2-recursion/index.html">9.2. Recursion</a></li>
          <li data-nav-id="/9-chapter/9_3-loops/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/index.html">9.3. Loops</a></li>
          <li data-nav-id="/9-chapter/9_4-logikafacts/index.html" class="active"><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/index.html">9.4. Logika Facts</a></li>
          <li data-nav-id="/9-chapter/9_5-summary/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_5-summary/index.html">9.5. Summary</a></li></ul></li>
          <li data-nav-id="/10-chapter/index.html" class=""><input type="checkbox" id="section-83e8e84779c32ba319a378089810947b" aria-controls="subsections-83e8e84779c32ba319a378089810947b"><label for="section-83e8e84779c32ba319a378089810947b"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Sequences, Globals, and Termination</span></label><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/index.html"><b>10. </b>Sequences, Globals, and Termination</a><ul id="subsections-83e8e84779c32ba319a378089810947b" class="morespace collapsible-menu">
          <li data-nav-id="/10-chapter/10_1-modes/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_1-modes/index.html">10.1 Logika Modes</a></li>
          <li data-nav-id="/10-chapter/10_2-intosequences/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_2-intosequences/index.html">10.2 Intro to Sequences</a></li>
          <li data-nav-id="/10-chapter/10_3-seqfn/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_3-seqfn/index.html">10.3 Sequences in Functions</a></li>
          <li data-nav-id="/10-chapter/10_4-seqloop/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_4-seqloop/index.html">10.4 Sequences in Loops</a></li>
          <li data-nav-id="/10-chapter/10_5_seqlogfact/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_5_seqlogfact/index.html">10.5 Logika Facts, revisited</a></li>
          <li data-nav-id="/10-chapter/10_6-globals/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_6-globals/index.html">10.6 Global Variables</a></li>
          <li data-nav-id="/10-chapter/10_7-termination/index.html" class=""><a class="padding" href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.html">10.7 Termination</a></li></ul></li>
        </ul>
        <div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter">
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <div class="padding menu-control">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="control-style">
                  <label class="a11y-only" for="select-language">Language</label>
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="clear"></div>
              </div>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch showVariantSwitch">
              <div class="padding menu-control">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="control-style">
                  <label class="a11y-only" for="select-variant">Theme</label>
                  <select id="select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                    <option id="auto" value="auto" selected>Auto</option>
                    <option id="light-theme" value="light-theme">Light Theme</option>
                    <option id="dark-theme" value="dark-theme">Dark Theme</option>
                  </select>
                </div>
                <div class="clear"></div>
              </div>
              <script>window.variants && variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks">
              <div class="padding menu-control">
                <i class="fas fa-history fa-fw"></i>
                <span>&nbsp;</span>
                <div class="control-style">
                  <button onclick="clearHistory();">Clear History</button>
                </div>
                <div class="clear"></div>
              </div>
            </li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter"><style>
  #footer {
      font-size: 13px;
      margin-left: auto;
      margin-right: auto;
      padding: 2rem 1rem;
      min-width: 230px;
      max-width: 300px;
  }
  #footer p {
      margin: 0;
  }
</style>
  
<p>Built using <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/K-State-Computational-Core/hugo-theme-relearn/tree/main">Hugo Relearn Theme</a>.</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; margin: .5rem auto" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p>

        </div>
      </div>
    </aside>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1711307485" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1711307485" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://ksu-cs-textbooks.github.io/cis301/js/mathjax/tex-mml-chtml.js?1711307485"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1711307485" defer></script>
  </body>
</html>
