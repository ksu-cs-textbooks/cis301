<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * ... * 2 * 1$, but we don’t have a way to describe the “…” portion using our current tools.
In this section, we introduce Logika facts, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a “…” to demonstrate a pattern."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Logika Facts :: CIS 301 Textbook"><meta name=twitter:description content="We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * ... * 2 * 1$, but we don’t have a way to describe the “…” portion using our current tools.
In this section, we introduce Logika facts, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a “…” to demonstrate a pattern."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/9-chapter/9_4-logikafacts/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Logika Facts :: CIS 301 Textbook"><meta property="og:description" content="We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * ... * 2 * 1$, but we don’t have a way to describe the “…” portion using our current tools.
In this section, we introduce Logika facts, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a “…” to demonstrate a pattern."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Functions and Loops"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2025-04-29T11:46:26-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Logika Facts :: CIS 301 Textbook"><meta itemprop=description content="We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * ... * 2 * 1$, but we don’t have a way to describe the “…” portion using our current tools.
In this section, we introduce Logika facts, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a “…” to demonstrate a pattern."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2025-04-29T11:46:26-05:00"><meta itemprop=wordCount content="2731"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Logika Facts :: CIS 301 Textbook</title><link href=/cis301/9-chapter/9_4-logikafacts/index.xml rel=alternate type=application/rss+xml title="Logika Facts :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_4-logikafacts/index.print.html rel=alternate type=text/html title="Logika Facts :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_4-logikafacts/tele.html rel=alternate type=text/html title="Logika Facts :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_4-logikafacts/embed.html rel=alternate type=text/html title="Logika Facts :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1755885657 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1755885657 defer></script><script src=/cis301/js/search-lunr.min.js?1755885657 defer></script><script src=/cis301/js/search.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1755885657"</script><script src=/cis301/js/lunr/lunr.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1755885657 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1755885657 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755885657 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1755885657 rel=stylesheet><link href=/cis301/css/theme.min.css?1755885657 rel=stylesheet><link href=/cis301/css/format-html.min.css?1755885657 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/9-chapter/9_4-logikafacts/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["auto","light-theme","dark-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!0,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1755885657 rel=stylesheet></head><body class="mobile-support html" data-url=/cis301/9-chapter/9_4-logikafacts/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#logika-fact-syntax>Logika fact syntax</a></li><li><a href=#example-logika-fact-to-define-factorial>Example: Logika fact to define factorial</a></li><li><a href=#evaluating-a-logika-fact>Evaluating a Logika fact</a></li><li><a href=#using-logika-facts-as-justifications>Using Logika facts as justifications</a></li><li><a href=#using-logika-facts-in-postconditions-and-invariants>Using Logika facts in postconditions and invariants</a><ul><li><a href=#writing-a-function-contract-using-a-logika-fact>Writing a function contract using a Logika fact</a></li><li><a href=#writing-a-loop-invariant-block-using-a-logika-fact>Writing a loop invariant block using a Logika fact</a></li><li><a href=#finishing-the-verification>Finishing the verification</a></li></ul></li><li><a href=#logika-fact-for-multiplication>Logika fact for multiplication</a></li><li><a href=#logika-fact-for-fibonacci-numbers>Logika fact for Fibonacci numbers</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><a itemprop=item href=/cis301/index.html><span itemprop=name>CIS 301 Textbook</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/9-chapter/index.html><span itemprop=name>Functions and Loops</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Logika Facts</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/9-chapter/9_4-logikaFacts.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_4-logikafacts/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_3-loops/index.html title="Loops (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_5-summary/index.html title="Summary (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_4-logikafacts/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_4-logikafacts/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 9-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=logika-facts>Logika Facts</h1><p>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that <span class="math align-center">$n! = n * (n-1) * (n-2) * ... * 2 * 1$</span>, but we don&rsquo;t have a way to describe the &ldquo;&mldr;&rdquo; portion using our current tools.</p><p>In this section, we introduce <em>Logika facts</em>, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a &ldquo;&mldr;&rdquo; to demonstrate a pattern.</p><h2 id=logika-fact-syntax>Logika fact syntax</h2><p>Logika allows these proof functions to be written in multiple ways, but we will start with the most straightforward of these options:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def proofFunction(paramList): returnType = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def proofFacts = Fact(
</span></span><span style=display:flex><span>    proofFunction(baseCase) == baseValue,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; (rangeOfX) → (proofFunction(x) == proofFunction(x - 1) * x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>In the above definition, <code>proofFunction</code> is the name we give our proof function, <code>paramList</code> is the list of parameter names and types needed for this proof function (which are formatted exactly like a parameter list in a regular Logika function), and <code>returnType</code> is the return type of the proof function (usually either <code>Z</code> for integer or <code>B</code> for boolean). The <code>= $</code> at the end of the proof function is indicating that its definition will be provided later.</p><p>Below the proof function, we include the <em>proof facts</em>, which is a recursive definition of the values for our proof function. We include one or more base cases, which list the value of our proof function for its smallest possible input (or for the smallest several inputs). Finally, we include our recursive case as a quantified statement &ndash; it lists the value of our proof function on all inputs bigger than our base cases. This recursive case uses the proof function&rsquo;s definition for a smaller value, like <code>proofFunction(x-1)</code>.</p><p>Logika facts are defined at the top of the Logika file, below the <code>import</code>s but before any of the code.</p><h2 id=example-logika-fact-to-define-factorial>Example: Logika fact to define factorial</h2><p>It is much easier to see how Logika facts work by using an example. Suppose we want to define the factorial operation. The first step is to come up with a <em>recursive definition</em>, which has us defining the operation the same way we would in a recursive function &ndash; with one or more <em>base cases</em> where we can define the operation for the simplest case, and one or more <em>recursive cases</em> that express a general instance of the problem in terms of a smaller instance.</p><p>For factorial, the simplest version is <span class="math align-center">$1!$</span>, which is just 1. In the general case, we have that:</p><span class="math align-center">$$
n! = n * (n-1) * (n-2) * ... * 2 * 1 = n * (n-1)!
$$</span><br><p>So we can write the following recursive definition:</p><ul><li>Base case: <span class="math align-center">$1! = 1$</span></li><li>Recursive case: for values of <span class="math align-center">$n$</span> greater than 1, <span class="math align-center">$n! = n * (n-1)!$</span></li></ul><p>And we can then translate the recursive definition to a Logika fact:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    ∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Let&rsquo;s consider each portion of this proof function. Here, <code>factFunction</code> is the name given to the proof function. It takes one parameter, <code>n</code>, which is an integer, and it returns an integer. We have two possible ways of calculating the value for the proof function, which we detail in <code>factorialFacts</code>. First, we define our base case:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(1) == 1</span></span></code></pre></div><p>Which says that <code>factFunction(n)</code> is 1 if <span class="math align-center">$n == 1$</span>. This is the same as our base case in our recursive definition for factorial &ndash; <span class="math align-center">$1! = 1$</span>.</p><p>Next, consider the recursive case of our proof function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )</span></span></code></pre></div><p>This case states that for all integers <code>x</code> that are bigger than 1, we define <code>factFunction(x) == x * factFunction(x - 1)</code>. This is the same as our recursive case in our recursive definition for factorial &ndash; for values of <span class="math align-center">$n$</span> greater than 1, <span class="math align-center">$n! = n * (n-1)!$</span>.</p><h2 id=evaluating-a-logika-fact>Evaluating a Logika fact</h2><p>Suppose we used our <code>factorialFacts</code> proof function to calculate <code>factFunction(3)</code>. We would have:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(3) == 3 * factFunction(2)      //we use the recursive case, since 3 &gt; 1
</span></span><span style=display:flex><span>factFunction(2) == 2 * factFunction(1)      //we use the recursive case, since 2 &gt; 1
</span></span><span style=display:flex><span>factFunction(1) == 1                        //we use the base case       </span></span></code></pre></div><p>Once we work down to:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(1) == 1</span></span></code></pre></div><p>We can plug <code>1</code> in for <code>facfactFunctiontDef(1)</code> in <code>factFunction(2) == 2 * factFunction(1)</code>, which gives us:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(2) == 2</span></span></code></pre></div><p>Similarly, we can plug <code>2</code> in for <code>factFunction(2)</code> in <code>factFunction(3) == 3 * factFunction(2)</code>, and see that:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>factFunction(3) == 6</span></span></code></pre></div><h2 id=using-logika-facts-as-justifications>Using Logika facts as justifications</h2><p>If we had our proof function, <code>factFunction</code>, then we could pull its two facts from its <code>factorialFacts</code> recursive definition into a proof block like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     factFunction(1) == 1                                                )   by ClaimOf(factorialFacts _),                                             
</span></span><span style=display:flex><span>    2 (     ∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )  )   by ClaimOf(factorialFacts _)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Note that we must pull in the definitions EXACTLY as they are written in the proof function. The justification is always <code>ClaimOf(proofFacts _)</code> where <code>proofFacts</code> is the name of the recursive definition.</p><h2 id=using-logika-facts-in-postconditions-and-invariants>Using Logika facts in postconditions and invariants</h2><p>Consider the following full Logika program that includes a function to find and return a factorial, as well as test code that calls our factorial function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// n! = n * (n-1) * (n-2) * .. * 1
</span></span><span style=display:flex><span>// 1! = 1
</span></span><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style=display:flex><span>    var product: Z = 1  //our current calculation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>        product = product * i
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return product
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = factorial(num)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 2)</span></span></code></pre></div><p>We want to add a function contract, loop invariant block, and supporting logic blocks to demonstrate that <code>factorial</code> is returning <code>n!</code> and to prove the assert in our text code.</p><h3 id=writing-a-function-contract-using-a-logika-fact>Writing a function contract using a Logika fact</h3><p>We want our <code>factorial</code> function contract to say that it is returning <code>n!</code>, and that it is only defined for values of <code>n</code> that are greater than or equal to 0. We recall that our Logika fact, <code>factFunction</code>, defines the factorial operation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    ∀ ( (x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>And we will use <code>factFunction</code> to define what we mean by &ldquo;factorial&rdquo; in our <code>factorial</code> function contract:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 1                      ),  //factFunction(n) is only defined when n &gt;= 1
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == factFunction(n)   )   //we promise to return factFunction(n), where factFunction defines n!
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //code for factorial function
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=writing-a-loop-invariant-block-using-a-logika-fact>Writing a loop invariant block using a Logika fact</h3><p>We can similarly use <code>factFunction</code> in our loop invariant block. We noted at the end of section 9.3 that the invariant in our loop should be: <em>prod equals i factorial</em>. Now we have a way to express what we mean by &ldquo;factorial&rdquo;, so our invariant will be: <code>prod == factFunction(i)</code>. Since the <code>factFunction</code> proof function is only defined for parameters greater than or equal to 1, we need to add a second piece to the invariant to guarantee that <code>i</code> will always be greater than or equal to 1. We now have the following loop invariant block:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (i != n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(i, product),
</span></span><span style=display:flex><span>        product == factFunction(i),
</span></span><span style=display:flex><span>        i &gt;= 1
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //loop body
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=finishing-the-verification>Finishing the verification</h3><p>All that remains is to:</p><ul><li>Prove our loop invariant holds before the loop begins</li><li>When we assume the loop invariant holds at the beginning of an iteration, prove that it still holds at the end of the iteration</li><li>Use the loop invariant together with the negation of the loop condition to prove the <code>factorial</code> postcondition</li><li>Prove the precondition holds in the calling code just before calling <code>factorial</code></li><li>Use the postcondition after calling <code>factorial</code> to prove the final assert</li></ul><p>Here is the completed verification:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def factorialFacts = Fact(
</span></span><span style=display:flex><span>    factFunction(1) == 1,
</span></span><span style=display:flex><span>    ∀((x: Z) =&gt; (x &gt; 1) → (factFunction(x) == factFunction(x-1)*x))
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def factorial(n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires(   n &gt;= 1                      ),  //factFunction(n) is only defined when n &gt;= 1
</span></span><span style=display:flex><span>        Ensures(    Res[Z] == factFunction(n)   )   //we promise to return factFunction(n), where factFunction defines n!
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var i: Z = 1        //how many multiplications we have done
</span></span><span style=display:flex><span>    var product: Z = 1  //my current calculation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Prove invariant before loop begins
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     i == 1                      ) by Premise,
</span></span><span style=display:flex><span>        2 (     product == 1                ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         //pull in proof function base case
</span></span><span style=display:flex><span>        3 (     factFunction(1) == 1        ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //proves first loop invariant holds 
</span></span><span style=display:flex><span>        4 (     product == factFunction(i)  ) by Algebra*(1, 2, 3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //proves second loop invariant holds 
</span></span><span style=display:flex><span>        5 (     i &gt;= 1                      ) by Algebra*(1)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (i != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(i, product),
</span></span><span style=display:flex><span>            product == factFunction(i),
</span></span><span style=display:flex><span>            i &gt;= 1
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        i = i + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            //from &#34;i = i + 1&#34;
</span></span><span style=display:flex><span>            1 (     i == Old(i) + 1                  ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //loop invariant held before changing i
</span></span><span style=display:flex><span>            2 (     product == factFunction(Old(i))  ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //rewrite invariant with no &#34;Old&#34;
</span></span><span style=display:flex><span>            3 (     product == factFunction(i - 1)   ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //second loop invariant held before changing i
</span></span><span style=display:flex><span>            4 (     Old(i) &gt;= 1                      ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //needed for the Logika fact
</span></span><span style=display:flex><span>            5 (     i &gt; 1                            ) by Algebra*(1, 4)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        product = product * i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //Prove invariant still holds at end of iteration
</span></span><span style=display:flex><span>        Deduce(
</span></span><span style=display:flex><span>            //from &#34;product = product * i&#34;
</span></span><span style=display:flex><span>            1 (  product == Old(product) * i                                        ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //from previous logic block
</span></span><span style=display:flex><span>            2 (  Old(product) == factFunction(i - 1)                                ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             //pull in recursive case from proof function
</span></span><span style=display:flex><span>            3 (  ∀( (x: Z) =&gt; x &gt; 1 → factFunction(x) == factFunction(x - 1) * x )  ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //plug in &#34;i&#34; for &#34;x&#34; (where i is of type Z)
</span></span><span style=display:flex><span>            4 (  i &gt; 1 → factFunction(i) == factFunction(i - 1) * i                 ) by AllE[Z](3),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //from previous logic block
</span></span><span style=display:flex><span>            5 (  i &gt; 1                                                              ) by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //i &gt; 1, so get right side of →
</span></span><span style=display:flex><span>            6 (  factFunction(i) == factFunction(i - 1) * i                         ) by ImplyE(4, 5),
</span></span><span style=display:flex><span>            7 (  product == factFunction(i - 1) * i                                 ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //proves first invariant still holds
</span></span><span style=display:flex><span>            8 (  product == factFunction(i)                                         ) by Algebra*(6, 7),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //proves second invariant still holds
</span></span><span style=display:flex><span>            9 (  i &gt;= 1                                                             ) by Algebra*(5)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Prove postcondition
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        1 (     product == factFunction(i)  ) by Premise,      //loop invariant
</span></span><span style=display:flex><span>        2 (     !(i != n)                   ) by Premise,      //loop condition false
</span></span><span style=display:flex><span>        3 (     i == n                      ) by Algebra*(2),
</span></span><span style=display:flex><span>        4 (     product == factFunction(n)  ) by Algebra*(1, 3)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return product
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//////// Test code ///////////
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var num: Z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//Prove precondition
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (     num == 2  ) by Premise,
</span></span><span style=display:flex><span>    2 (     num &gt;= 1  ) by Algebra*(1)     //proves factorial precondition
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var answer: Z = factorial(num)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deduce(
</span></span><span style=display:flex><span>    1 (  answer == factFunction(num)                                        ) by Premise,       //factorial postcondition
</span></span><span style=display:flex><span>    2 (  num == 2                                                           ) by Premise,
</span></span><span style=display:flex><span>    3 (  answer == factFunction(2)                                          ) by Algebra*(1, 2),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in recursive case from proof function
</span></span><span style=display:flex><span>    4 (  ∀( (x: Z) =&gt; x &gt; 1 → factFunction(x) == factFunction(x - 1) * x )  ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     //plug in &#34;2&#34; for &#34;x&#34; (where 2 is an integer of type Z)
</span></span><span style=display:flex><span>    5 (  2 &gt; 1 → factFunction(2) == factFunction(2 - 1) * 2                 ) by AllE[Z](4),
</span></span><span style=display:flex><span>    6 (  2 &gt; 1                                                              ) by Algebra*(),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //2 &gt; 1, so use →
</span></span><span style=display:flex><span>    7 (  factFunction(2) == factFunction(2 - 1) * 2                         ) by ImplyE(5, 6),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //pull in base case from proof function
</span></span><span style=display:flex><span>    8 (  factFunction(1) == 1                                               ) by ClaimOf(factorialFacts _),
</span></span><span style=display:flex><span>    9 (  factFunction(2) == factFunction(1) * 2                             ) by Algebra*(7),
</span></span><span style=display:flex><span>    10 (  factFunction(2) == 2                                              ) by Algebra*(8, 9),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //proves claim in assert
</span></span><span style=display:flex><span>    11 (  answer == 2                                                       ) by Algebra*(1, 2, 10)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(answer == 2)</span></span></code></pre></div><h2 id=logika-fact-for-multiplication>Logika fact for multiplication</h2><p>Suppose we wanted to create a Logika fact that recursively defined multiplication. We first recursively define how we would multiply <span class="math align-center">$x * y$</span>. We know that our base case will be when <span class="math align-center">$y == 0$</span>, because anything times 0 is 0. We also saw that multiplication can be defined as repeated addition, so that <span class="math align-center">$x * y == x + x + ... x$</span> for a total of <span class="math align-center">$y$</span> additions. We also see that <span class="math align-center">$x * y == x + x * (y-1)$</span>, since we can pull out one of the additions and then have <span class="math align-center">$y-1$</span> additions left to do.</p><p>Here is our recursive definition of the problem:</p><ul><li>Base case: for all numbers x, x * 0 is 0</li><li>Recursive case: for all numbers x and all positive numbers y, x * y = x + x * (y-1)</li></ul><p>We can translate this directly to a proof function:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@spec def multFunction(m: Z, n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFacts = Fact(
</span></span><span style=display:flex><span>    //anything multiplied by 0 is just 0
</span></span><span style=display:flex><span>    ∀((x: Z) =&gt; multFunction(x, 0) == 0 ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; ∀( (y: Z) =&gt; (y &gt; 1) → (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>We could use this Logika fact in the postcondition and loop invariant block for a multiplication function as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --manual --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>import org.sireum.justification._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.prop._
</span></span><span style=display:flex><span>import org.sireum.justification.natded.pred._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFunction(m: Z, n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def multFacts = Fact(
</span></span><span style=display:flex><span>    //anything multiplied by 0 is just 0
</span></span><span style=display:flex><span>    ∀((x: Z) =&gt; multFunction(x, 0) == 0 ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; ∀( (y: Z) =&gt; (y &gt; 1) → (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//want to find: num1 + num1 + ... + num1 (a total of num2 times)
</span></span><span style=display:flex><span>def mult(num1: Z, num2: Z): Z = {
</span></span><span style=display:flex><span>    Contract( 
</span></span><span style=display:flex><span>        Requires( num2 &gt;= 1 ),
</span></span><span style=display:flex><span>        Ensures( Res[Z] == multFunction(num1, num2) )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    var answer: Z = 0
</span></span><span style=display:flex><span>    var cur: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (cur != num2) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(cur, answer),
</span></span><span style=display:flex><span>            answer == multFunction(num1, cur),
</span></span><span style=display:flex><span>            cur &gt;= 0
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cur = cur + 1
</span></span><span style=display:flex><span>        answer = answer + num1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return answer
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>The example above does not include the verification steps to prove the loop invariant and postcondition, but those things could be accomplished in the same way as for the <code>factorial</code> function.</p><h2 id=logika-fact-for-fibonacci-numbers>Logika fact for Fibonacci numbers</h2><p>The Fibonacci sequence is:</p><span class="math align-center">$$
1, 1, 2, 3, 5, 8, 13, ...
$$</span><p><br><br></p><p>The first two Fibonacci numbers are both 1, and subsequent Fibonacci numbers are found by adding the two previous values. In the sequence above, we see that the two latest numbers were 8 and 13, so the next number in the sequence will be <span class="math align-center">$8 + 13 = 21$</span>.</p><p>We can recursively define the Fibonacci sequence as follows:</p><ul><li>Base case 1: the first Fibonacci number is 1</li><li>Base case 2: the second Fibonacci number is 1</li><li>Recursive case: for all numbers x greater than 2, the x-th Fibonacci number is the (x-1)-th Fibonacci number + the (x-2)-th Fibonacci number</li></ul><p>We can translate this directly to a Logika fact:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//defines the nth number in the Fibonacci sequence
</span></span><span style=display:flex><span>//1, 1, 2, 3, 5, 8, 13, ...
</span></span><span style=display:flex><span>@spec def fibFunction(n: Z): Z = $
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@spec def fibFacts = Fact(
</span></span><span style=display:flex><span>    fibFunction(1) == 1,
</span></span><span style=display:flex><span>    fibFunction(2) == 2,
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; (x &gt; 2) → fibFunction(x-1) + fibFunction(x-2) )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //defines m * n = m + m + ... + m (n times)
</span></span><span style=display:flex><span>    ∀( (x: Z) =&gt; ∀( (y: Z) =&gt; (y &gt; 1) → (multFunction(x, y) == multFunction(x,y-1)) ) )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Which we could use in a postcondition and loop invariant if we wrote a function to compute the Fibonacci numbers.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/1a0cb24a2d0480b36969f618111a326fb481a5f5>Apr 29, 2025</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class=default-animation><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/index.html><input type=checkbox id=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9 aria-controls=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9><label for=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/index.html><b>0. </b>Getting Started</a><ul id=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9 class=collapsible-menu><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/index.html><a class=padding href=/cis301/0-chapter/0_1-toolsguide/index.html>0.1. Tools Guide</a></li><li data-nav-id=/cis301/0-chapter/0_2-gitinstall/index.html><a class=padding href=/cis301/0-chapter/0_2-gitinstall/index.html>0.2. git Install</a></li></ul></li><li data-nav-id=/cis301/1-chapter/index.html><input type=checkbox id=R-section-cbcda2db56d129074f1e03beb13f9103 aria-controls=R-subsections-cbcda2db56d129074f1e03beb13f9103><label for=R-section-cbcda2db56d129074f1e03beb13f9103><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/index.html><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-cbcda2db56d129074f1e03beb13f9103 class=collapsible-menu><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/index.html><a class=padding href=/cis301/1-chapter/1_1-logicbasics/index.html>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/index.html><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/index.html>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/index.html><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/index.html>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/index.html><input type=checkbox id=R-section-d672bd5f3e40d734b815889ecb0b088e aria-controls=R-subsections-d672bd5f3e40d734b815889ecb0b088e><label for=R-section-d672bd5f3e40d734b815889ecb0b088e><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/index.html><b>2. </b>Truth Tables</a><ul id=R-subsections-d672bd5f3e40d734b815889ecb0b088e class=collapsible-menu><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/index.html><a class=padding href=/cis301/2-chapter/2_1-opscircuits/index.html>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/index.html><a class=padding href=/cis301/2-chapter/2_2-logikatruth/index.html>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/index.html><a class=padding href=/cis301/2-chapter/2_3-satis/index.html>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/index.html><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/index.html>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/index.html><a class=padding href=/cis301/2-chapter/2_5-sementail/index.html>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/index.html><input type=checkbox id=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73 aria-controls=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73><label for=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/index.html><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73 class=collapsible-menu><li data-nav-id=/cis301/3-chapter/3_1-propatom/index.html><a class=padding href=/cis301/3-chapter/3_1-propatom/index.html>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/index.html><a class=padding href=/cis301/3-chapter/3_2-notandor/index.html>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/index.html><a class=padding href=/cis301/3-chapter/3_3-implies/index.html>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/index.html><a class=padding href=/cis301/3-chapter/3_4-equiv/index.html>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/index.html><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/index.html>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/index.html><input type=checkbox id=R-section-a0d0660e4f5f539642b53fac77ff44c7 aria-controls=R-subsections-a0d0660e4f5f539642b53fac77ff44c7><label for=R-section-a0d0660e4f5f539642b53fac77ff44c7><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/index.html><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-a0d0660e4f5f539642b53fac77ff44c7 class=collapsible-menu><li data-nav-id=/cis301/4-chapter/4_1-intro/index.html><a class=padding href=/cis301/4-chapter/4_1-intro/index.html>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/index.html><a class=padding href=/cis301/4-chapter/4_2-andrules/index.html>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/index.html><a class=padding href=/cis301/4-chapter/4_3-orrules/index.html>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/index.html><a class=padding href=/cis301/4-chapter/4_4-impliesrules/index.html>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/index.html><a class=padding href=/cis301/4-chapter/4_5-notrules/index.html>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/index.html><a class=padding href=/cis301/4-chapter/4_6-strategies/index.html>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/index.html><a class=padding href=/cis301/4-chapter/4_7-theorems/index.html>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/index.html><a class=padding href=/cis301/4-chapter/4_8-equivalence/index.html>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/index.html><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/index.html>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/index.html><input type=checkbox id=R-section-589c35b8ff6263b7311a10a4d0fa83a9 aria-controls=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9><label for=R-section-589c35b8ff6263b7311a10a4d0fa83a9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/index.html><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9 class=collapsible-menu><li data-nav-id=/cis301/5-chapter/5_1-motivation/index.html><a class=padding href=/cis301/5-chapter/5_1-motivation/index.html>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/index.html><a class=padding href=/cis301/5-chapter/5_2-predsyntax/index.html>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/index.html><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/index.html>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/index.html><a class=padding href=/cis301/5-chapter/5_4-multquant/index.html>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/index.html><input type=checkbox id=R-section-55edc31437b1ec5edead9beb4ef7d1fa aria-controls=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa><label for=R-section-55edc31437b1ec5edead9beb4ef7d1fa><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/index.html><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa class=collapsible-menu><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/index.html><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/index.html>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/index.html><a class=padding href=/cis301/6-chapter/6_1-univrules/index.html>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/index.html><a class=padding href=/cis301/6-chapter/6_2-existrules/index.html>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/index.html><a class=padding href=/cis301/6-chapter/6_3-nested/index.html>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/index.html><a class=padding href=/cis301/6-chapter/6_4-equiv/index.html>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/index.html><a class=padding href=/cis301/6-chapter/6_5-strategies/index.html>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/index.html><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/index.html>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/index.html><input type=checkbox id=R-section-cbba04bde749b4229ea56fb5a7c6a953 aria-controls=R-subsections-cbba04bde749b4229ea56fb5a7c6a953><label for=R-section-cbba04bde749b4229ea56fb5a7c6a953><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/index.html><b>7. </b>Mathematical Induction</a><ul id=R-subsections-cbba04bde749b4229ea56fb5a7c6a953 class=collapsible-menu><li data-nav-id=/cis301/7-chapter/7_1-process/index.html><a class=padding href=/cis301/7-chapter/7_1-process/index.html>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/index.html><a class=padding href=/cis301/7-chapter/7_2-algebraex/index.html>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/index.html><a class=padding href=/cis301/7-chapter/7_3-divex/index.html>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/index.html><a class=padding href=/cis301/7-chapter/7_4-setex/index.html>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/index.html><input type=checkbox id=R-section-010016ee1ce3fc8b575a95f1204dba7b aria-controls=R-subsections-010016ee1ce3fc8b575a95f1204dba7b><label for=R-section-010016ee1ce3fc8b575a95f1204dba7b><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/index.html><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-010016ee1ce3fc8b575a95f1204dba7b class=collapsible-menu><li data-nav-id=/cis301/8-chapter/8_1-goal/index.html><a class=padding href=/cis301/8-chapter/8_1-goal/index.html>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/index.html><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/index.html>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/index.html><a class=padding href=/cis301/8-chapter/8_3-assertassume/index.html>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/index.html><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/index.html>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/index.html><a class=padding href=/cis301/8-chapter/8_5-assignment/index.html>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/index.html><a class=padding href=/cis301/8-chapter/8_6-divmod/index.html>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/index.html><a class=padding href=/cis301/8-chapter/8_7-conditionals/index.html>8.7. Conditional Statements</a></li></ul></li><li class=parent data-nav-id=/cis301/9-chapter/index.html><input type=checkbox id=R-section-6864880b2cc643485ab906a5e309eaaf aria-controls=R-subsections-6864880b2cc643485ab906a5e309eaaf checked><label for=R-section-6864880b2cc643485ab906a5e309eaaf><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/index.html><b>9. </b>Functions and Loops</a><ul id=R-subsections-6864880b2cc643485ab906a5e309eaaf class=collapsible-menu><li data-nav-id=/cis301/9-chapter/9_1-functions/index.html><a class=padding href=/cis301/9-chapter/9_1-functions/index.html>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/index.html><a class=padding href=/cis301/9-chapter/9_2-recursion/index.html>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/index.html><a class=padding href=/cis301/9-chapter/9_3-loops/index.html>9.3. Loops</a></li><li class=active data-nav-id=/cis301/9-chapter/9_4-logikafacts/index.html><a class=padding href=/cis301/9-chapter/9_4-logikafacts/index.html>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/index.html><a class=padding href=/cis301/9-chapter/9_5-summary/index.html>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/index.html><input type=checkbox id=R-section-b363793b1b72566b579f69cd488e8039 aria-controls=R-subsections-b363793b1b72566b579f69cd488e8039><label for=R-section-b363793b1b72566b579f69cd488e8039><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/index.html><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-b363793b1b72566b579f69cd488e8039 class=collapsible-menu><li data-nav-id=/cis301/10-chapter/10_1-modes/index.html><a class=padding href=/cis301/10-chapter/10_1-modes/index.html>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/index.html><a class=padding href=/cis301/10-chapter/10_2-intosequences/index.html>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/index.html><a class=padding href=/cis301/10-chapter/10_3-seqfn/index.html>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/index.html><a class=padding href=/cis301/10-chapter/10_4-seqloop/index.html>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/index.html><a class=padding href=/cis301/10-chapter/10_5-globals/index.html>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/index.html><a class=padding href=/cis301/10-chapter/10_6-termination/index.html>10.6 Termination</a></li></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul><li class=R-variantswitcher><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.relearn.markVariant()</script></li></ul></div><div id=R-footer><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></aside><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis301/js/mathjax/tex-mml-chtml.js?1755885657></script><script src=/cis301/js/clipboard/clipboard.min.js?1755885657 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1755885657 defer></script><script src=/cis301/js/theme.min.js?1755885657 defer></script></body></html>