<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="A function in Scala is analogous to a method in Java or C# – it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:
def functionName(paramList): returnType = { }We will use the keyword Unit (like void in other languages) for a function that does not return a value. If a function has a non-Unit return type, then all paths through the function must end in a return statement:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Functions :: CIS 301 Textbook"><meta name=twitter:description content="A function in Scala is analogous to a method in Java or C# – it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:
def functionName(paramList): returnType = { }We will use the keyword Unit (like void in other languages) for a function that does not return a value. If a function has a non-Unit return type, then all paths through the function must end in a return statement:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/9-chapter/9_1-functions/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Functions :: CIS 301 Textbook"><meta property="og:description" content="A function in Scala is analogous to a method in Java or C# – it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:
def functionName(paramList): returnType = { }We will use the keyword Unit (like void in other languages) for a function that does not return a value. If a function has a non-Unit return type, then all paths through the function must end in a return statement:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Functions and Loops"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-10-18T12:02:03-05:00"><meta itemprop=name content="Functions :: CIS 301 Textbook"><meta itemprop=description content="A function in Scala is analogous to a method in Java or C# – it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:
def functionName(paramList): returnType = { }We will use the keyword Unit (like void in other languages) for a function that does not return a value. If a function has a non-Unit return type, then all paths through the function must end in a return statement:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-10-18T12:02:03-05:00"><meta itemprop=wordCount content="2551"><title>Functions :: CIS 301 Textbook</title>
<link href=/cis301/9-chapter/9_1-functions/index.xml rel=alternate type=application/rss+xml title="Functions :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_1-functions/index.print.html rel=alternate type=text/html title="Functions :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_1-functions/tele.html rel=alternate type=text/html title="Functions :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_1-functions/embed.html rel=alternate type=text/html title="Functions :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1736960784 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1736960784 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1736960784 rel=stylesheet><link href=/cis301/css/auto-complete.css?1736960784 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1736960784 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1736960784 rel=stylesheet><link href=/cis301/css/fonts.css?1736960784 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1736960784 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1736960784 rel=stylesheet><link href=/cis301/css/theme-auto.css?1736960784 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1736960784 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1736960784 rel=stylesheet><link href=/cis301/css/print.css?1736960784 rel=stylesheet media=print><script src=/cis301/js/variant.js?1736960784></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1736960784 rel=stylesheet></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=/cis301/9-chapter/9_1-functions/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#function-contracts>Function contracts</a><ul><li><a href=#preconditions>Preconditions</a></li><li><a href=#postconditions>Postconditions</a></li></ul></li><li><a href=#work-of-the-calling-code>Work of the calling code</a><ul><li><a href=#proving-preconditions>Proving preconditions</a></li><li><a href=#using-postconditions>Using postconditions</a></li></ul></li><li><a href=#examples>Examples</a><ul><li><a href=#example-1>Example 1</a></li><li><a href=#example-2>Example 2</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/9-chapter/><span itemprop=name>Functions and Loops</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Functions</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/9-chapter/9_1-functions.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_1-functions/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/ title="Functions and Loops (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_2-recursion/ title="Recursion (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/9-chapter/9_1-functions/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/9-chapter/9_1-functions/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=functions>Functions</h1><p>A <em>function</em> in Scala is analogous to a method in Java or C# &ndash; it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def functionName(paramList): returnType = {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We will use the keyword <code>Unit</code> (like <code>void</code> in other languages) for a function that does not return a value. If a function has a non-<code>Unit</code> return type, then all paths through the function must end in a return statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>return expression</span></span></code></pre></div><p>Where <code>expression</code> is a variable, literal, or expression matching <code>returnType</code>.</p><h2 id=function-contracts>Function contracts</h2><p>In order to prove the correctness of a function, it must include a <em>function contract</em> just inside the function header. This function contract specifies what we need to know to use the function correctly. While we will use these specifications to help us prove correctness, they are good to include in ANY library function that will be used by someone else (even more informally in other languages). <em>The person/program who calls the function is not supposed to read the function&rsquo;s code to know how to use the function</em>. A function contract shows them what parameters to pass (including what range of values are acceptable), what the function will return in terms of the parameter, and whether/how the function will modify things like sequences (arrays/lists in other languages) or global variables.</p><p>Here is the syntax for a function contract in Logika:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Contract(
</span></span><span class=line><span class=cl>    Requires (  preconditions   ),
</span></span><span class=line><span class=cl>    Ensures (   postconditions  )
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Here is a summary of the different function contract clauses:</p><ul><li><code>Requires</code>: lists the <em>preconditions</em> for the function in a comma-separated list. If there are no preconditions, we can skip this clause.</li><li><code>Ensures</code>: lists the <em>postconditions</em> for the function in a comma-separated list.</li></ul><h3 id=preconditions>Preconditions</h3><p>The <em>preconditions</em> for a function are requirements the function has in order to operate correctly. Generally, preconditions constrain the values of the parameters and/or global variables. For example, this function returns the integer division between two parameters. The function can only operate correctly when the denominator (the second parameter, <code>b</code>) is non-zero:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def div(a: Z, b: Z) : Z =  {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (  b != 0  ),
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    val ans: Z = a/b
</span></span><span class=line><span class=cl>    return ans
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Logika will display an error if any preconditions are not proven before calling a function. Because we are required to prove the preconditions before any function call, the function itself can list the preconditions as premises in a proof block just after the function contract:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def example(a: Z, b: Z) : Z =  {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (  Precondition1, Precondition2, ...),
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //we can list the preconditions as premises
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 ( precondition1   )   by Premise,
</span></span><span class=line><span class=cl>        2 ( precondition2   )   by Premise
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><h3 id=postconditions>Postconditions</h3><p>The <em>postconditions</em> of a function state what the function has accomplished when it terminates. In particular, postconditions should include:</p><ul><li><p>A formalization of what the function promises to return in terms of the parameters/global variables. We use the keyword <code>Res[returnType]</code> to refer to the object returned by the function (we will only use this keyword in the function contract). For example, in a function that returns an integer (<code>Z</code>), we can use the keyword <code>Res[Z]</code> in a postcondition to refer to the return value.</p></li><li><p>A description of how any global variables and/or sequence parameters will be modified by the function (we will not use global variables or sequences until chapter 10).</p></li></ul><p>For example, the <code>div</code> function above should promise to return the integer division of its two parameters, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def div(a: Z, b: Z) : Z =  {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(   b != 0  ),
</span></span><span class=line><span class=cl>        Ensures(    Res[Z] == a/b   )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    val ans: Z = a/b
</span></span><span class=line><span class=cl>    return ans
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>In order to prove a postcondition involving the return value, we must have proof blocks just before returning that demonstrate each postcondition claim, using the variable name being returned instead of the <code>Res[returnType]</code> keyword. In the example above, since we are returning a variable named <code>ans</code>, then we must prove the claim <code>ans == a/b</code> in order to satisfy the postcondition. We can complete the verification of the <code>div</code> function as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def div(a: Z, b: Z) : Z =  {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(   b != 0  ),
</span></span><span class=line><span class=cl>        Ensures(    Res[Z] == a/b   )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    val ans: Z = a/b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 ( b != 0      )   by Premise, //precondition (needed for division)
</span></span><span class=line><span class=cl>        2 ( ans == a/b  )   by Premise  //satisifes the postcondition
</span></span><span class=line><span class=cl>                                        //(from the &#34;ans = a/b&#34; assignment)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return ans
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Logika will display an error if postconditions are not proven before leaving a function. Because we are required to prove the postconditions before the function ends, any calling code can list those postconditions as premises after calling the function. We will see this in more detail in the next section.</p><h2 id=work-of-the-calling-code>Work of the calling code</h2><p>We saw above that when writing code that calls a function, we must PROVE the preconditions before the function call (since the function requires that we meet those preconditions in order to work correctly). After the function terminates, the calling code can list the function&rsquo;s postconditions as PREMISES (since the function ensured that certain things would happen).</p><p>The &ldquo;calling code&rdquo; in Scala goes outside of any function definition. Typically, I place the calling code at the bottom of the Scala file, after all functions. This is the code executed first by Scala, just like in Python programs.</p><h3 id=proving-preconditions>Proving preconditions</h3><p>Suppose we wish to call the <code>div</code> function to divide two numbers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 10
</span></span><span class=line><span class=cl>val y: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = div(x, y)</span></span></code></pre></div><p>If we included that calling code in a file with our <code>div</code> function, we would see an error that we had not yet proved the precondition. To prove each precondition, we must have a proof block just before the function call that demonstrate each precondition claim, using value being passed instead of the parameter name. Since we are passing the value <code>y</code> as our second parameter, and since the <code>div</code> function requires that <code>b != 0</code> (where <code>b</code> is the second parameter), then we must demonstrate that <code>y != 0</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 10
</span></span><span class=line><span class=cl>val y: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span class=line><span class=cl>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span class=line><span class=cl>    3 ( y != 0      )   by Algebra*(2)  //satisfies the precondition for div
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = div(x, y)</span></span></code></pre></div><p>Note that Logika is picky about proving the precondition using EXACTLY the value being passed for the corresponding parameter. For example, suppose instead that we wanted to divide <code>x-1</code> and <code>y+1</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 10
</span></span><span class=line><span class=cl>val y: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span class=line><span class=cl>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span class=line><span class=cl>    3 ( y != 0      )   by Algebra*(2)  //NO! precondition is not satisfied!
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = div(x-1, y+1)</span></span></code></pre></div><p>If we made no changes to our logic block, Logika would complain that we had not satisfied the precondition. And indeed we haven&rsquo;t &ndash; while we&rsquo;ve shown that <code>y</code> isn&rsquo;t 0, we haven&rsquo;t shown that our second parameter <code>y+1</code> isn&rsquo;t 0. Here is the correction:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 10
</span></span><span class=line><span class=cl>val y: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span class=line><span class=cl>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span class=line><span class=cl>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = div(x-1, y+1)</span></span></code></pre></div><h3 id=using-postconditions>Using postconditions</h3><p>Recall that since the function is ensuring that it will do/return specific things (its postconditions), then the calling code can list those postconditions as premises after the function call. If a postcondition uses the keyword <code>Res[returnType]</code>, then the calling code can list exactly that postcondition using whatever variable it used to store the return value in place of <code>Res[returnType]</code> and using whatever values were passed in place of the parameter names. In the <code>div</code> example above where we divide <code>x-1</code> by <code>y+1</code>, the calling code stores the value returned by <code>div</code> in a variable called <code>num</code>. Since the <code>div</code> postcondition is <code>result == a/b</code>, then we can claim the premise <code>num == (x-1)/(y+1)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 10
</span></span><span class=line><span class=cl>val y: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span class=line><span class=cl>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span class=line><span class=cl>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = div(x-1, y+1)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( num == (x-1)/(y+1)  )   by Premise  //postcondition of div
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We know from looking at this example that <code>(x-1)/(y+1)</code> is really <code>9/3</code>, which is 3. We would like to be able to assert that <code>num</code>, the value returned from <code>div</code>, equals 3. We can do this by adding a few more steps to our final proof block, plugging in the values for <code>x</code> and <code>y</code> and doing some algebra:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>val x: Z = 10
</span></span><span class=line><span class=cl>val y: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( x == 10     )   by Premise,     //from the &#34;x = 10&#34; assignment
</span></span><span class=line><span class=cl>    2 ( y == 2      )   by Premise,     //from the &#34;y = 2&#34; assignment
</span></span><span class=line><span class=cl>    3 ( y+1 != 0    )   by Algebra*(2)  //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num: Z = div(x-1, y+1)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 ( num == (x-1)/(y+1)  )   by Premise,     //postcondition of div
</span></span><span class=line><span class=cl>    2 ( x == 10             )   by Premise,     //previous variable assignment
</span></span><span class=line><span class=cl>    3 ( y == 2              )   by Premise,     //previous variable assignment
</span></span><span class=line><span class=cl>    4 ( num == 9/3          )   by Algebra*(1,2,3),
</span></span><span class=line><span class=cl>    5 ( num == 3            )   by Algebra*(4)  //needed for assert 
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(num == 3)</span></span></code></pre></div><p>Using a function contract and our deduction rules, we have PROVED that the <code>div</code> function will return 3 in our example (without needing to test the code at all).</p><h2 id=examples>Examples</h2><p>In this section, we will see two completed examples of Logika programs with a function and calling code.</p><h3 id=example-1>Example 1</h3><p>In this example, we write a <code>plusOne</code> function that takes a non-negative parameter and returns one more than that parameter:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def plusOne(n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(   n &gt;= 0  ),
</span></span><span class=line><span class=cl>        Ensures(
</span></span><span class=line><span class=cl>            Res[Z] == n + 1,
</span></span><span class=line><span class=cl>            Res[Z] &gt; 0
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    val answer: Z = n + 1
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1  (    n &gt;= 0          )   by Premise,
</span></span><span class=line><span class=cl>        2  (    answer == n + 1 )   by Premise,
</span></span><span class=line><span class=cl>        3  (    answer &gt; 0      )   by Algebra*(1, 2)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return answer
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////////// Test code ///////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 5
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    x == 5  )   by Premise,
</span></span><span class=line><span class=cl>    2  (    x &gt;= 0  )   by Algebra*(1)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var added: Z = plusOne(x)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1  (    x == 5                  ) by Premise,
</span></span><span class=line><span class=cl>    2  (    added == x + 1          ) by Premise,
</span></span><span class=line><span class=cl>    3  (    added &gt; 0               ) by Premise,
</span></span><span class=line><span class=cl>    4  (    added == 6              ) by Algebra*(1, 2),
</span></span><span class=line><span class=cl>    5  (    added == ∧ &amp; added &gt; 0  ) by AndI(4, 3)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>assert(added == 6 ∧ added &gt; 0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var x: Z = 5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     x == 5      )   by Premise,     //from the &#34;x=5&#34; assignment
</span></span><span class=line><span class=cl>    2 (     x &gt;= 0      )   by Algebra*(1)  //proves the plusOne precondition
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var added: Z = plusOne(x)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    //I can list the postcondition (what is returned) as a premise
</span></span><span class=line><span class=cl>    1 (     x == 5                  )   by Premise, //x is unchanged 
</span></span><span class=line><span class=cl>    2 (     added == x+1            )   by Premise, //plusOne postcondition 1
</span></span><span class=line><span class=cl>    3 (     added &gt; 0               )   by Premise, //plusOne postcondition 2
</span></span><span class=line><span class=cl>    4 (     added == 6              )   by Algebra*(1,2),
</span></span><span class=line><span class=cl>    5 (     added == 6 ∧ added &gt; 0  )   by AndI(4,3)
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(added == 6 ∧ added &gt; 0)</span></span></code></pre></div><p>Note that when we have more than one postcondition, we must prove all postconditions inside the function, and we can list all postconditions as premises in the calling code after the function call.</p><h3 id=example-2>Example 2</h3><p>In this example, we write a <code>findMax</code> function that returns the biggest between two integer parameters. This is very similar to an example from section 8.7, which used an if/else statement to find the max. In that example, our assert that we had indeed found the max was: <code>assert((max >= x & max >= y) & (max == x | max == y))</code>. We will see that our postconditions for <code>findMax</code> come directly from the different claims in that assert. In our calling code, we call <code>findMax</code> with <code>num1</code> (which has the value 3) and <code>num2</code> (which has the value 2). We are able to prove that <code>findMax</code> returns 2:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//find the max between x and y
</span></span><span class=line><span class=cl>def findMax(x: Z, y: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        //no precondition needed
</span></span><span class=line><span class=cl>        Ensures(
</span></span><span class=line><span class=cl>            Res[Z] &gt;= x,                //postcondition 1
</span></span><span class=line><span class=cl>            Res[Z] &gt;= y,                //postcondition 2
</span></span><span class=line><span class=cl>            Res[Z] == x v Res[Z] == y   //postcondition 3
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var max: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (x &gt; y) {
</span></span><span class=line><span class=cl>        max = x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     max == x    )   by Premise,
</span></span><span class=line><span class=cl>            2 (     max &gt;= x    )   by Algebra*(1),     //build to postcondition 1
</span></span><span class=line><span class=cl>            3 (     x &gt; y       )   by Premise,         //IF condition is true
</span></span><span class=line><span class=cl>            4 (     max &gt;= y    )   by Algebra*(1,3)    //build to postcondition 2
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        max = y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     max == y    )   by Premise,
</span></span><span class=line><span class=cl>            2 (     ¬(x &gt; y)    )   by Premise,         //IF condition is false
</span></span><span class=line><span class=cl>            3 (     x &lt;= y      )   by Algebra*(2),
</span></span><span class=line><span class=cl>            4 (     max &gt;= x    )   by Algebra*(1, 2),  //build to postcondition 1
</span></span><span class=line><span class=cl>            5 (     max &gt;= y    )   by Algebra*(1)      //build to postcondition 2
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //prove the postconditions
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        //true in both the if and the else
</span></span><span class=line><span class=cl>        1 (     max &gt;= x            )   by Premise,     //proves postcondition 1 
</span></span><span class=line><span class=cl>        2 (     max &gt;= y            )   by Premise,     //proves postcondition 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //first was true in if, second true in else
</span></span><span class=line><span class=cl>        3 (     max == x v max == y )   by Premise     //proves postcondition 3
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return max
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////////////// Test code /////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val num1: Z = 3
</span></span><span class=line><span class=cl>val num2: Z = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//findMax has no preconditions, so nothing to prove here
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val biggest: Z = findMax(num1, num2)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     biggest &gt;= num1                     )   by Premise,     //findMax postcondition 1
</span></span><span class=line><span class=cl>    2 (     biggest &gt;= num2                     )   by Premise,     //findMax postcondition 2
</span></span><span class=line><span class=cl>    3 (     biggest == num1 v biggest == num2   )   by Premise,     //findMax postcondition 3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //pull in the initial values
</span></span><span class=line><span class=cl>    4 (     num1 == 3                           )   by Premise,
</span></span><span class=line><span class=cl>    5 (     num2 == 2                           )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    6 (     biggest &gt;= 3                        )   by Algebra*(1, 4),
</span></span><span class=line><span class=cl>    7 (     biggest &gt;= 2                        )   by Algebra*(2, 5),
</span></span><span class=line><span class=cl>    8 (     biggest == 3 v biggest == num2      )   by Subst_&lt;(4, 3),
</span></span><span class=line><span class=cl>    9 (     biggest == 3 v biggest == 2         )   by Subst_&lt;(5, 8),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //OR-elimination
</span></span><span class=line><span class=cl>    10 SubProof(
</span></span><span class=line><span class=cl>        11  Assume( biggest == 3 ) 
</span></span><span class=line><span class=cl>    ),
</span></span><span class=line><span class=cl>    12 SubProof(
</span></span><span class=line><span class=cl>        13  Assume( biggest == 2 ) 
</span></span><span class=line><span class=cl>        14 (    ¬(biggest &gt;= 3)                 )   by Algebra*(13),
</span></span><span class=line><span class=cl>        15 (    F                               )   by NegE(6, 14),
</span></span><span class=line><span class=cl>        16 (    biggest == 3                    )   by BottomE(15)
</span></span><span class=line><span class=cl>    ),
</span></span><span class=line><span class=cl>    17 (        biggest == 3                    )   by OrE(9,10,12) //needed for assert
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(biggest == 3)</span></span></code></pre></div><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/9273b47021c5d2b42a52c6e5579f28658157c1f4>Oct 18, 2024</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search><script>var contentLangs=["en"]</script><script src=/cis301/js/auto-complete.js?1736960784 defer></script><script src=/cis301/js/lunr/lunr.min.js?1736960784 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1736960784 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1736960784 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1736960784 defer></script><script src=/cis301/js/search.js?1736960784 defer></script></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/><input type=checkbox id=R-section-4dd9ea2241609372e21522ad467bdbcf aria-controls=R-subsections-4dd9ea2241609372e21522ad467bdbcf><label for=R-section-4dd9ea2241609372e21522ad467bdbcf><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/><b>0. </b>Getting Started</a><ul id=R-subsections-4dd9ea2241609372e21522ad467bdbcf class="morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/><a class=padding href=/cis301/0-chapter/0_1-toolsguide/>0.1. Tools Guide</a></li></ul></li><li data-nav-id=/cis301/1-chapter/><input type=checkbox id=R-section-17929730d34290b059d2edff1c690239 aria-controls=R-subsections-17929730d34290b059d2edff1c690239><label for=R-section-17929730d34290b059d2edff1c690239><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-17929730d34290b059d2edff1c690239 class="morespace collapsible-menu"><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/><a class=padding href=/cis301/1-chapter/1_1-logicbasics/>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/><input type=checkbox id=R-section-97391a296e58f4aff54bb6b925a2776b aria-controls=R-subsections-97391a296e58f4aff54bb6b925a2776b><label for=R-section-97391a296e58f4aff54bb6b925a2776b><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/><b>2. </b>Truth Tables</a><ul id=R-subsections-97391a296e58f4aff54bb6b925a2776b class="morespace collapsible-menu"><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/><a class=padding href=/cis301/2-chapter/2_1-opscircuits/>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/><a class=padding href=/cis301/2-chapter/2_2-logikatruth/>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/><a class=padding href=/cis301/2-chapter/2_3-satis/>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/><a class=padding href=/cis301/2-chapter/2_5-sementail/>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/><input type=checkbox id=R-section-b4e2df8934a6b804e9336da7e38d4126 aria-controls=R-subsections-b4e2df8934a6b804e9336da7e38d4126><label for=R-section-b4e2df8934a6b804e9336da7e38d4126><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-b4e2df8934a6b804e9336da7e38d4126 class="morespace collapsible-menu"><li data-nav-id=/cis301/3-chapter/3_1-propatom/><a class=padding href=/cis301/3-chapter/3_1-propatom/>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/><a class=padding href=/cis301/3-chapter/3_2-notandor/>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/><a class=padding href=/cis301/3-chapter/3_3-implies/>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/><a class=padding href=/cis301/3-chapter/3_4-equiv/>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/><input type=checkbox id=R-section-619d3749907cd3e1af90a59cf2fcd6bd aria-controls=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd><label for=R-section-619d3749907cd3e1af90a59cf2fcd6bd><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd class="morespace collapsible-menu"><li data-nav-id=/cis301/4-chapter/4_1-intro/><a class=padding href=/cis301/4-chapter/4_1-intro/>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/><a class=padding href=/cis301/4-chapter/4_2-andrules/>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/><a class=padding href=/cis301/4-chapter/4_3-orrules/>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/><a class=padding href=/cis301/4-chapter/4_4-impliesrules/>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/><a class=padding href=/cis301/4-chapter/4_5-notrules/>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/><a class=padding href=/cis301/4-chapter/4_6-strategies/>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/><a class=padding href=/cis301/4-chapter/4_7-theorems/>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/><a class=padding href=/cis301/4-chapter/4_8-equivalence/>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/><input type=checkbox id=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7 aria-controls=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7><label for=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7 class="morespace collapsible-menu"><li data-nav-id=/cis301/5-chapter/5_1-motivation/><a class=padding href=/cis301/5-chapter/5_1-motivation/>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/><a class=padding href=/cis301/5-chapter/5_2-predsyntax/>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/><a class=padding href=/cis301/5-chapter/5_4-multquant/>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/><input type=checkbox id=R-section-1afc7d1d7b98dcc397b91690230bcb55 aria-controls=R-subsections-1afc7d1d7b98dcc397b91690230bcb55><label for=R-section-1afc7d1d7b98dcc397b91690230bcb55><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-1afc7d1d7b98dcc397b91690230bcb55 class="morespace collapsible-menu"><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/><a class=padding href=/cis301/6-chapter/6_1-univrules/>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/><a class=padding href=/cis301/6-chapter/6_2-existrules/>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/><a class=padding href=/cis301/6-chapter/6_3-nested/>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/><a class=padding href=/cis301/6-chapter/6_4-equiv/>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/><a class=padding href=/cis301/6-chapter/6_5-strategies/>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/><input type=checkbox id=R-section-48461595e2f67d1468fbd78e51714428 aria-controls=R-subsections-48461595e2f67d1468fbd78e51714428><label for=R-section-48461595e2f67d1468fbd78e51714428><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/><b>7. </b>Mathematical Induction</a><ul id=R-subsections-48461595e2f67d1468fbd78e51714428 class="morespace collapsible-menu"><li data-nav-id=/cis301/7-chapter/7_1-process/><a class=padding href=/cis301/7-chapter/7_1-process/>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/><a class=padding href=/cis301/7-chapter/7_2-algebraex/>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/><a class=padding href=/cis301/7-chapter/7_3-divex/>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/><a class=padding href=/cis301/7-chapter/7_4-setex/>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/><input type=checkbox id=R-section-77afa9c6b199f7330fa5eb8966814b35 aria-controls=R-subsections-77afa9c6b199f7330fa5eb8966814b35><label for=R-section-77afa9c6b199f7330fa5eb8966814b35><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-77afa9c6b199f7330fa5eb8966814b35 class="morespace collapsible-menu"><li data-nav-id=/cis301/8-chapter/8_1-goal/><a class=padding href=/cis301/8-chapter/8_1-goal/>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/><a class=padding href=/cis301/8-chapter/8_3-assertassume/>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/><a class=padding href=/cis301/8-chapter/8_5-assignment/>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/><a class=padding href=/cis301/8-chapter/8_6-divmod/>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/><a class=padding href=/cis301/8-chapter/8_7-conditionals/>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/ class=parent><input type=checkbox id=R-section-ffb46ad61395302deae4c4fa734e982a aria-controls=R-subsections-ffb46ad61395302deae4c4fa734e982a checked><label for=R-section-ffb46ad61395302deae4c4fa734e982a><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/><b>9. </b>Functions and Loops</a><ul id=R-subsections-ffb46ad61395302deae4c4fa734e982a class="morespace collapsible-menu"><li data-nav-id=/cis301/9-chapter/9_1-functions/ class=active><a class=padding href=/cis301/9-chapter/9_1-functions/>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/><a class=padding href=/cis301/9-chapter/9_2-recursion/>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/><a class=padding href=/cis301/9-chapter/9_3-loops/>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/><a class=padding href=/cis301/9-chapter/9_4-logikafacts/>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/><a class=padding href=/cis301/9-chapter/9_5-summary/>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/><input type=checkbox id=R-section-9e1e97bcf82568ce724d247ecac0ed85 aria-controls=R-subsections-9e1e97bcf82568ce724d247ecac0ed85><label for=R-section-9e1e97bcf82568ce724d247ecac0ed85><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-9e1e97bcf82568ce724d247ecac0ed85 class="morespace collapsible-menu"><li data-nav-id=/cis301/10-chapter/10_1-modes/><a class=padding href=/cis301/10-chapter/10_1-modes/>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/><a class=padding href=/cis301/10-chapter/10_2-intosequences/>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/><a class=padding href=/cis301/10-chapter/10_3-seqfn/>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/><a class=padding href=/cis301/10-chapter/10_4-seqloop/>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/><a class=padding href=/cis301/10-chapter/10_5-globals/>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/><a class=padding href=/cis301/10-chapter/10_6-termination/>10.6 Termination</a></li></ul></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Language</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-en value=#R-select-language-en data-url=/cis301/9-chapter/9_1-functions/ lang=en-us selected></option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class=footerVisitedLinks><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Clear History</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></div></aside><script src=/cis301/js/clipboard.min.js?1736960784 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1736960784 defer></script><script src=/cis301/js/theme.js?1736960784 defer></script></body></html>