




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Functions :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/index.html" rel="canonical" type="text/html" title="Functions :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/index.xml" rel="alternate" type="application/rss+xml" title="Functions :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/index.print.html" rel="alternate" type="text/html" title="Functions :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/tele.html" rel="alternate" type="text/html" title="Functions :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1692118064" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1692118064" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1692118064" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1692118064" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1692118064" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1692118064" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1692118064" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1692118064" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1692118064" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1692118064" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1692118064" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1692118064" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1692118064" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1692118064"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1692118064"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1692118064" rel="stylesheet">

  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/embed.html">
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
    
    
    
<p>A <em>function</em> in Logika is analogous to a method in Java or C# &ndash; it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Logika:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def functionName(paramList): returnType = {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We will use the keyword <code>Unit</code> (like <code>void</code> in other languages) for a function that does not return a value. If a function has a non-<code>Unit</code> return type, then all paths through the function must end in a return statement:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>return expression</span></span></code></pre></div><p>Where <code>expression</code> is a variable, literal, or expression matching <code>returnType</code>.</p>
<h2 id="function-contracts">Function contracts</h2>
<p>In order to prove the correctness of a function, it must include a <em>function contract</em> just inside the function header. This function contract specifies what we need to know to use the function correctly. While we will use these specifications to help us prove correctness, they are good to include in ANY library function that will be used by someone else (even more informally in other languages). <em>The person/program who calls the function is not supposed to read the function&rsquo;s code to know how to use the function</em>. A function contract shows them what parameters to pass (including what range of values are acceptable), what the function will return in terms of the parameter, and whether/how the function will modify things like sequences (arrays/lists in other languages) or global variables.</p>
<p>Here is the syntax for a function contract in Logika:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    requires (preconditions)
</span></span><span style="display:flex;"><span>    modifies (variable list)
</span></span><span style="display:flex;"><span>    ensures (postconditions)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>Here is a summary of the different function contract clauses:</p>
<ul>
<li><code>requires</code>: lists the <em>preconditions</em> for the function. We can also use the keyword <code>pre</code> instead of <code>requires</code>. If there are no preconditions, we can skip this clause. If we have multiple preconditions, we can list them on separate lines (where subsequent lines are tabbed over under <code>requires</code>).</li>
<li><code>modifies</code>: lists the name of any sequence parameters and/or global variables that are modified by the function. We can skip this clause until chapter 10, when we will see sequences and global variables.</li>
<li><code>ensures</code>: lists the <em>postconditions</em> for the function. We can also use the keyword <code>post</code> instead of <code>ensures</code>. If we have multiple postconditions, we can list them on separate lines (where subsequent lines are tabbed over under <code>ensures</code>).</li>
</ul>
<h3 id="preconditions">Preconditions</h3>
<p>The <em>preconditions</em> for a function are requirements the function has in order to operate correctly. Generally, preconditions constrain the values of the parameters and/or global variables. For example, this function returns the integer division between two parameters. The function can only operate correctly when the denominator (the second parameter, <code>b</code>) is non-zero:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Logika will throw an error if any preconditions are not proven before calling a function. Because we are required to prove the preconditions before any function call, the function itself can list the preconditions as premises in a logic block just after the function contract:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def example(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires precondition1
</span></span><span style="display:flex;"><span>            precondition2
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we can list the preconditions as premises
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. precondition1            premise
</span></span><span style="display:flex;"><span>        2. precondition2            premise
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="postconditions">Postconditions</h3>
<p>The <em>postconditions</em> of a function state what the function has accomplished when it terminates. In particular, postconditions should include:</p>
<ul>
<li>
<p>A formalization of what the function promises to return in terms of the parameters/global variables. We can use the keyword <code>result</code> to refer to the object returned by the function (we will only use this keyword in the function contract).</p>
</li>
<li>
<p>A description of how any global variables and/or sequence parameters will be modified by the function (we will not use global variables or sequences until chapter 10).</p>
</li>
</ul>
<p>For example, the <code>div</code> function above should promise to return the integer division of its two parameters, like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>In order to prove a postcondition involving the return value, we must have logic blocks just before returning that demonstrate each postcondition claim, using the variable name being returned instead of the <code>result</code> keyword. In the example above, since we are returning a variable named <code>ans</code>, then we must prove the claim <code>ans == a/b</code> in order to satisfy the postcondition. We can complete the verification of the <code>div</code> function as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. b != 0               premise     //precondition (needed for division)
</span></span><span style="display:flex;"><span>        2. ans == a/b           premise     //satisifies the postcondition
</span></span><span style="display:flex;"><span>                                            //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Logika will throw an error if postconditions are not proven before leaving a function. Because we are required to prove the postconditions before the function ends, any calling code can list those postconditions as premises after calling the function. We will see this in more detail in the next section.</p>
<h2 id="work-of-the-calling-code">Work of the calling code</h2>
<p>We saw above that when writing code that calls a function, we must PROVE the preconditions before the function call (since the function requires that we meet those preconditions in order to work correctly). After the function terminates, the calling code can list the function&rsquo;s postconditions as PREMISES (since the function ensured that certain things would happen).</p>
<p>Below, we will see the syntax for the verification of code that calls a function. We will refer to our finished <code>div</code> function:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def div(a: Z, b: Z) : Z =  {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires b != 0
</span></span><span style="display:flex;"><span>        ensures result == a/b
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val ans: Z = a/b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. b != 0               premise     //precondition (needed for division)
</span></span><span style="display:flex;"><span>        2. ans == a/b           premise     //satisifies the postcondition
</span></span><span style="display:flex;"><span>                                            //(from the &#34;ans = a/b&#34; assignment)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return ans
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>The &ldquo;calling code&rdquo; in Logika goes outside of any function definition. Typically, I place the calling code at the bottom of the Logika file, after all functions. Recall that this is the code executed first by Logika, just like in Python programs.</p>
<h3 id="proving-preconditions">Proving preconditions</h3>
<p>Suppose we wish to call the <code>div</code> function to divide two numbers:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x, y)</span></span></code></pre></div><p>If we included that calling code in a Logika file with our <code>div</code> function, we would see an error that we had not yet proved the precondition. To prove each precondition, we must have a logic block just before the function call that demonstrate each precondition claim, using value being passed instead of the parameter name. Since we are passing the value <code>y</code> as our second parameter, and since the <code>div</code> function requires that <code>b != 0</code> (where <code>b</code> is the second parameter), then we must demonstrate that <code>y != 0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y != 0               algebra 2   //satisifies the precondition for div
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x, y)</span></span></code></pre></div><p>Note that Logika is picky about proving the precondition using EXACTLY the value being passed for the corresponding parameter. For example, suppose instead that we wanted to divide <code>x-1</code> and <code>y+1</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y != 0               algebra 2   //NO! precondition is not satisifed!
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)</span></span></code></pre></div><p>If we made no changes to our logic block, Logika would complain that we had not satisfied the precondition. And indeed we haven&rsquo;t &ndash; while we&rsquo;ve shown that <code>y</code> isn&rsquo;t 0, we haven&rsquo;t shown that our second parameter <code>y+1</code> isn&rsquo;t 0. Here is the correction:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Yes! Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)</span></span></code></pre></div><h3 id="using-postconditions">Using postconditions</h3>
<p>Recall that since the function is ensuring that it will do/return specific things (its postconditions), then the calling code can list those postconditions as premises after the function call. If a postcondition uses the keyword <code>result</code>, then the calling code can list exactly that postcondition using whatever variable it used to store the return value in place of <code>result</code> and using whatever values were passed in place of the parameter names. In the <code>div</code> example above where we divde <code>x-1</code> by <code>y+1</code>, the calling code stores the value returned by <code>div</code> in a variable called <code>num</code>. Since the <code>div</code> postcondition is <code>result == a/b</code>, then we can claim the premise <code>num == (x-1)/(y+1)</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == (x-1)/(y+1)   premise     //postcondition of div
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;</span></span></code></pre></div><p>We know from looking at this example that <code>(x-1)/(y+1)</code> is really <code>9/3</code>, which is 3. We would like to be able to assert that <code>num</code>, the value returned from <code>div</code>, equals 3. We can do this by adding a few more steps to our final logic block, plugging in the values for <code>x</code> and <code>y</code> and doing some algebra:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>val x: Z = 10
</span></span><span style="display:flex;"><span>val y: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 10              premise     //from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    2. y == 2               premise     //from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    3. y+1 != 0             algebra 2   //Satisfies the precondition for our second parameter (y+1)
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num: Z = div(x-1, y+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. num == (x-1)/(y+1)   premise     //postcondition of div
</span></span><span style="display:flex;"><span>    2. x == 10              premise     //x is unchanged from the &#34;x = 10&#34; assignment
</span></span><span style="display:flex;"><span>    3. y == 2               premise     //y is unchanged from the &#34;y = 2&#34; assignment
</span></span><span style="display:flex;"><span>    4. num == 9/3           algebra 1 2 3
</span></span><span style="display:flex;"><span>    5. num == 3             algebra 4   //needed for assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(num == 3)</span></span></code></pre></div><p>Using a function contract and our deduction rules, we have PROVED that the <code>div</code> function will return 3 in our example (without needing to test the code at all).</p>
<h2 id="examples">Examples</h2>
<p>In this section, we will see two completed examples of Logika programs with a function and calling code.</p>
<h3 id="example-1">Example 1</h3>
<p>In this example, we write a <code>plusOne</code> function that takes a non-negative parameter and returns one more than that parameter:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def plusOne(n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //precondition: parameter should be non-negative
</span></span><span style="display:flex;"><span>        ensures result == n+1   //postcondition 1: we promise returned value is one more than parameter
</span></span><span style="display:flex;"><span>            result &gt; 0          //postcondition 2: we promise returned value is greater than 0
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    val answer: Z = n+1
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. n &gt;= 0               premise     //from the precondition
</span></span><span style="display:flex;"><span>        2. answer == n+1        premise     //from the &#34;answer = n+1&#34; assignment
</span></span><span style="display:flex;"><span>                                            //proves the first postcondition
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        3. answer &gt; 0           algebra 1 2 //proves the second postcondition
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return answer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////// Test code ///////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var x: Z = 5
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. x == 5                   premise     //from the &#34;x=5&#34; assignment
</span></span><span style="display:flex;"><span>    2. x &gt;= 0                   algebra 1   //proves the plusOne precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var added: Z = plusOne(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    //I can list the postcondition (what is returned) as a premise
</span></span><span style="display:flex;"><span>    1. x == 5                   premise     //x is unchanged 
</span></span><span style="display:flex;"><span>    2. added == x+1             premise     //plusOne postcondition 1
</span></span><span style="display:flex;"><span>    3. added &gt; 0                premise     //plusOne postcondition 2
</span></span><span style="display:flex;"><span>    4. added == 6               algebra 1 2
</span></span><span style="display:flex;"><span>    5. added == 6 
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(added == 6 ∧ added &gt; 0)</span></span></code></pre></div><p>Note that when we have more than one postcondition, we must prove all postconditions inside the function, and we can list all postconditions as premises in the calling code after the function call.</p>
<h3 id="example-2">Example 2</h3>
<p>In this example, we write a <code>findMax</code> function that returns the biggest between two integer parameters. This is very similar to an example from section 8.7, which used an if/else statement to find the max. In that example, our assert that we had indeed found the max was: <code>assert((max &gt;= x &amp; max &gt;= y) &amp; (max == x | max == y))</code>. We will see that our postconditions for <code>findMax</code> come directly from the different claims in that assert. In our calling code, we call <code>findMax</code> with <code>num1</code> (which has the value 3) and <code>num2</code> (which has the value 2). We are able to prove that <code>findMax</code> returns 2:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//find the max between x and y
</span></span><span style="display:flex;"><span>def findMax(x: Z, y: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //no precondition needed
</span></span><span style="display:flex;"><span>        ensures
</span></span><span style="display:flex;"><span>            result &gt;= x                 //postcondition 1
</span></span><span style="display:flex;"><span>            result &gt;= y                 //postcondition 2
</span></span><span style="display:flex;"><span>            result == x v result == y   //postcondition 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var max: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. max == 0             premise
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if (x &gt; y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == 0         premise
</span></span><span style="display:flex;"><span>            2. x &gt; y            premise     //IF condition is true
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        max = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == x         premise
</span></span><span style="display:flex;"><span>            2. max &gt;= x         algebra 1
</span></span><span style="display:flex;"><span>            3. x &gt; y            premise
</span></span><span style="display:flex;"><span>            4. max &gt;= y         algebra 1 3
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == 0         premise
</span></span><span style="display:flex;"><span>            2. ¬(x &gt; y)         premise     //IF condition is not true
</span></span><span style="display:flex;"><span>            3. x &lt;= y           algebra 2
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        max = y
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. max == y         premise
</span></span><span style="display:flex;"><span>            2. x &lt;= y           premise
</span></span><span style="display:flex;"><span>            3. max &gt;= x         algebra 1 2
</span></span><span style="display:flex;"><span>            4. max &gt;= y         algebra 1
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the postconditions
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        //true in both the if and the else
</span></span><span style="display:flex;"><span>        1. max &gt;= x                 premise     //proves postcondition 1 
</span></span><span style="display:flex;"><span>        2. max &gt;= y                 premise     //proves postcondition 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //first was true in if, second true in else
</span></span><span style="display:flex;"><span>        3. max == x v max == y      premise     //proves postcondition 3
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return max
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>////////////// Test code /////////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val num1: Z = 3
</span></span><span style="display:flex;"><span>val num2: Z = 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//findMax has no preconditions, so nothing to prove here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val biggest: Z = findMax(num1, num2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. biggest &gt;= num1                      premise     //findMax postcondition 1
</span></span><span style="display:flex;"><span>    2. biggest &gt;= num2                      premise     //findMax postcondition 2
</span></span><span style="display:flex;"><span>    3. biggest == num1 v biggest == num2    premise     //findMax postcondition 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //pull in the initial values
</span></span><span style="display:flex;"><span>    4. num1 == 3                            premise
</span></span><span style="display:flex;"><span>    5. num2 == 2                            premise
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    6. biggest &gt;= 3                         algebra 1 4
</span></span><span style="display:flex;"><span>    7. biggest &gt;= 2                         algebra 2 5
</span></span><span style="display:flex;"><span>    8. biggest == 3 v biggest == num2       subst1 4 3
</span></span><span style="display:flex;"><span>    9. biggest == 3 v biggest == 2          subst1 5 8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //OR-elimination
</span></span><span style="display:flex;"><span>    10. {
</span></span><span style="display:flex;"><span>        11. biggest == 3                    assume
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    12. {
</span></span><span style="display:flex;"><span>        13. biggest == 2                    assume
</span></span><span style="display:flex;"><span>        14. ¬(biggest &gt;= 3)                 algebra 6 13
</span></span><span style="display:flex;"><span>        15. ⊥                               ¬e 6 14
</span></span><span style="display:flex;"><span>        16. biggest == 3                    ⊥e 15
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    17. biggest == 3                        ve 9 10 12  //needed for assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(biggest == 3)</span></span></code></pre></div>
            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1692118065" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1692118065" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1692118065" defer></script>
  </body>
</html>
