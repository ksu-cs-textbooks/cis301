<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="A loop is a command that restarts itself over and over while its loop condition remains true. Loops are trickier to analyze than if/else statements, because we don’t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations…we don’t know."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Loops :: CIS 301 Textbook"><meta name=twitter:description content="A loop is a command that restarts itself over and over while its loop condition remains true. Loops are trickier to analyze than if/else statements, because we don’t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations…we don’t know."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/9-chapter/9_3-loops/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Loops :: CIS 301 Textbook"><meta property="og:description" content="A loop is a command that restarts itself over and over while its loop condition remains true. Loops are trickier to analyze than if/else statements, because we don’t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations…we don’t know."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Functions and Loops"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-05-28T14:22:57-05:00"><meta itemprop=name content="Loops :: CIS 301 Textbook"><meta itemprop=description content="A loop is a command that restarts itself over and over while its loop condition remains true. Loops are trickier to analyze than if/else statements, because we don’t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations…we don’t know."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-05-28T14:22:57-05:00"><meta itemprop=wordCount content="3789"><title>Loops :: CIS 301 Textbook</title>
<link href=/cis301/9-chapter/9_3-loops/index.xml rel=alternate type=application/rss+xml title="Loops :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_3-loops/index.print.html rel=alternate type=text/html title="Loops :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_3-loops/tele.html rel=alternate type=text/html title="Loops :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_3-loops/embed.html rel=alternate type=text/html title="Loops :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1754341382 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1754341382 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1754341382 rel=stylesheet><link href=/cis301/css/auto-complete.css?1754341382 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1754341382 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1754341382 rel=stylesheet><link href=/cis301/css/fonts.css?1754341382 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1754341382 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1754341382 rel=stylesheet><link href=/cis301/css/theme-auto.css?1754341382 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1754341382 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1754341382 rel=stylesheet><link href=/cis301/css/print.css?1754341382 rel=stylesheet media=print><script src=/cis301/js/variant.js?1754341382></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1754341382 rel=stylesheet></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=/cis301/9-chapter/9_3-loops/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#loop-invariants>Loop invariants</a></li><li><a href=#loop-invariants-and-mathematical-induction>Loop invariants and mathematical induction</a></li><li><a href=#loop-invariant-block-syntax>Loop invariant block syntax</a></li><li><a href=#example-loop-invariant-block-for-a-multiplication-loop>Example: loop invariant block for a multiplication loop</a></li><li><a href=#proving-the-loop-invariant>Proving the loop invariant</a><ul><li><a href=#proving-loop-invariant-before-loop-begins>Proving loop invariant before loop begins</a></li><li><a href=#proving-loop-invariant-at-the-end-of-each-iteration>Proving loop invariant at the end of each iteration</a></li><li><a href=#knowledge-after-loop-ends>Knowledge after loop ends</a></li></ul></li><li><a href=#functions-with-loops>Functions with loops</a></li><li><a href=#how-to-construct-a-loop-invariant>How to construct a loop invariant</a><ul><li><a href=#example-1-sum-of-odds>Example 1: Sum of odds</a></li><li><a href=#example-2-factorial>Example 2: factorial</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/9-chapter/><span itemprop=name>Functions and Loops</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Loops</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/9-chapter/9_3-loops.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_3-loops/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_2-recursion/ title="Recursion (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_4-logikafacts/ title="Logika Facts (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/9-chapter/9_3-loops/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/9-chapter/9_3-loops/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=loops>Loops</h1><p>A <em>loop</em> is a command that restarts itself over and over while its <em>loop condition</em> remains true. Loops are trickier to analyze than if/else statements, because we don&rsquo;t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations&mldr;we don&rsquo;t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.</p><p>The only loop available in Logika is a <em>while</em> loop, which behaves in the same way as while loops in other languages. If the loop condition is initially false, then the body of the while loop is skipped entirely. If the loop condition is initially true, then we execute the loop body and then recheck the condition. This continues until the loop condition becomes false.</p><p>Here is the syntax of a Scala while loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>while (condition) {
</span></span><span class=line><span class=cl>   //body of loop
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><h2 id=loop-invariants>Loop invariants</h2><p>Our solution to analyzing loops despite not knowing the number of iterations is a tool called a <em>loop invariant</em>. The job of the loop invariant is to summarize what is always true about the loop. Often, the loop invariant describes the relationship between variables and demonstrates how much progress the loop has made. Sometimes the loop invariant also contains claims that certain variables will always stay in a particular range.</p><p>Whatever we choose as the loop invariant, we must be able to do the following:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li></ul><h2 id=loop-invariants-and-mathematical-induction>Loop invariants and mathematical induction</h2><p>The process of proving the correctness of loop invariants is very similar to a mathematical induction proof. We must prove the loop invariant is true before the loop begins, which is analogous to the <em>base case</em> in mathematical induction. The process of assuming the invariant is true at the beginning of an iteration and proving that it is still true at the end of an iteration is just like mathematical induction&rsquo;s <em>inductive step</em>.</p><p>If we prove those two things about our invariant, we can be certain the invariant will still hold after the loop terminates. Why? For the same reason mathematical induction proves a property for a general
<span class="math align-center">$n$</span>:</p><ul><li>We know the invariant holds before the loop begins</li><li>Because the invariant holds before the loop begins, we are sure it holds at the beginning of the first iteration</li><li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the first iteration</li><li>Because we&rsquo;re sure it still holds at the end of the first iteration, we know it holds at the beginning of the second iteration</li><li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the second iteration
&mldr;</li><li>We&rsquo;re sure the invariant still holds at the end of each iteration, including the end of the LAST iteration. Thus we&rsquo;re certain the invariant holds just after the loop ends.</li></ul><h2 id=loop-invariant-block-syntax>Loop invariant block syntax</h2><p>In Logika, we will write a <em>loop invariant block</em> to describe our loop invariants. This block will go just inside the loop, before the loop body:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>while (condition) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(comma-separated list of variables),
</span></span><span class=line><span class=cl>        Invariant_1,
</span></span><span class=line><span class=cl>        Invariant_2,
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //loop body
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Here is a summary of the different loop invariant clauses:</p><ul><li><code>Modifies</code>: uses a comma-separated list to name each variable whose value changes in the loop body</li><li><code>Invariant_i</code>: lists an invariant for the function. If we have multiple invariants, we can list them on separate lines (<code>Invariant_1</code>, <code>Invariant_2</code>, etc.)</li></ul><h2 id=example-loop-invariant-block-for-a-multiplication-loop>Example: loop invariant block for a multiplication loop</h2><p>Suppose we have the following loop to multiply two numbers, <code>x</code> and <code>y</code>, using repeated addition. (This is very similar to our <code>mult</code> function from section 9.2, except it does the additions using a loop instead of using recursion):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = Z.read()
</span></span><span class=line><span class=cl>val y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var sum: Z = 0
</span></span><span class=line><span class=cl>var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>while (count != y) {
</span></span><span class=line><span class=cl>    sum = sum + x
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//now sum is x*y</span></span></code></pre></div><p>Before writing the loop invariant block, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>After iteration 3</th><th>&mldr;</th><th>After iteration y</th></tr></thead><tbody><tr><td><code>count</code></td><td>0</td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>y</td></tr><tr><td><code>sum</code></td><td><span class="math align-center">$0 (= 0*x)$</span></td><td><span class="math align-center">$x (= 1*x)$</span></td><td><span class="math align-center">$x + x (= 2*x)$</span></td><td><span class="math align-center">$x + x + x (= 3*x)$</span></td><td>&mldr;</td><td><span class="math align-center">$x + x + ... + x (= y*x)$</span></td></tr></tbody></table><p>Before the loop begins, we&rsquo;ve added 0
<span class="math align-center">$x$</span>&rsquo;s together, so the sum is 0. After the first iteration, we&rsquo;ve added 1
<span class="math align-center">$x$</span> together, so the sum is
<span class="math align-center">$x$</span>. After the second iteration, we&rsquo;ve added 2
<span class="math align-center">$x$</span>&rsquo;s together, so the sum is
<span class="math align-center">$x + x$</span> which is really
<span class="math align-center">$2 * x$</span>. This continues until after the y-th iteration, when we&rsquo;ve added y
<span class="math align-center">$x$</span>&rsquo;s together (and the sum is
<span class="math align-center">$y*x$</span>).</p><p>Using this table, it is easy to see that at any point, <code>sum == count*x</code> (since <code>count</code> tracks the number of iterations). This is true both before the loop begins and at the end of each iteration, so it will be our loop invariant.</p><p>We now add a loop invariant block to our loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = Z.read()
</span></span><span class=line><span class=cl>val y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var sum: Z = 0
</span></span><span class=line><span class=cl>var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>while (count != y) {
</span></span><span class=line><span class=cl>    //loop invariant block (still needs to be proved)
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(sum, count),
</span></span><span class=line><span class=cl>        sum == count * x
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + x
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//now sum is x*y</span></span></code></pre></div><p>We list <code>sum</code> and <code>count</code> in the <code>Modifies</code> clause because those are the two variables that change value inside the loop.</p><h2 id=proving-the-loop-invariant>Proving the loop invariant</h2><p>In order to prove the correctness of a loop, we must do two things:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li></ul><h3 id=proving-loop-invariant-before-loop-begins>Proving loop invariant before loop begins</h3><p>In our multiplication loop above, let&rsquo;s start by proving the loop invariant before the loop begins. This means that just before the loop, we must prove exactly the claim <code>sum == count*x</code>. We can do this with algebra on the current variable values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = Z.read()
</span></span><span class=line><span class=cl>val y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var sum: Z = 0
</span></span><span class=line><span class=cl>var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//prove the invariant before the loop begins
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span class=line><span class=cl>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span class=line><span class=cl>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>while (count != y) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(sum, count),
</span></span><span class=line><span class=cl>        sum == count * x
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + x
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //we still need to prove the invariant after each iteration
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//now sum is x*y</span></span></code></pre></div><h3 id=proving-loop-invariant-at-the-end-of-each-iteration>Proving loop invariant at the end of each iteration</h3><p>To prove the loop invariant still holds at the end of an iteration, we must have a logic block at the end of the loop body with exactly the claim in the loop invariant (which will now be referring to the updated values of each variable). Since this step has us assuming the loop invariant is true at the beginning of each iteration, we can list the loop invariant as a <em>premise</em> in a logic block just inside the loop body. Here is the structure we wish to follow for our multiplication loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>while (count != y) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(sum, count),
</span></span><span class=line><span class=cl>        sum == count * x
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span class=line><span class=cl>                                                        //at the beginning of an iteration
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + x
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //need to prove exactly &#34;sum == count*x&#34;
</span></span><span class=line><span class=cl>    //to prove our invariant still holds at the end of an iteration
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We can complete the loop invariant proof by using our tools for processing assignment statements with mutations. Here is the completed verification:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val x: Z = Z.read()
</span></span><span class=line><span class=cl>val y: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var sum: Z = 0
</span></span><span class=line><span class=cl>var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//prove the invariant before the loop begins
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span class=line><span class=cl>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span class=line><span class=cl>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>while (count != y) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(sum, count),
</span></span><span class=line><span class=cl>        sum == count * x
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span class=line><span class=cl>                                                        //at the beginning of an iteration
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span class=line><span class=cl>        2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span class=line><span class=cl>        3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span class=line><span class=cl>        2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span class=line><span class=cl>                                                                //but count has changed
</span></span><span class=line><span class=cl>        3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span class=line><span class=cl>        4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span class=line><span class=cl>        5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//now sum is x*y</span></span></code></pre></div><h3 id=knowledge-after-loop-ends>Knowledge after loop ends</h3><p>In the example above, suppose we add the following assert after the loop ends:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>assert(sum == x*y)</span></span></code></pre></div><p>This seems like a reasonable claim &ndash; after all, we said that our loop was supposed to calculated <code>x * y</code> using repeated addition. We have proved the loop invariant, so we can be sure that <code>sum == count*x</code> after the loop&mldr;but that&rsquo;s not quite the same thing. Does <code>count</code> equal <code>y</code>? How do we know?</p><p>We can prove our assert statement by considering one more piece of information &ndash; if we have exited the loop, we know that the loop condition must be false. In fact, you always know two things (which you can claim as premises) after the loop ends:</p><ol><li>The loop condition is false (so we can claim <code>¬(condition)</code>)</li><li>The loop invariant is true, since we proved is true at the end of each iteration</li></ol><p>We can use those pieces of information to prove our assert statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//the multiplication loop example goes here
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     sum == count*x  )   by Premise,     //the loop invariant holds
</span></span><span class=line><span class=cl>    2 (     ¬(count != y)   )   by Premise,     //the loop condition is not true
</span></span><span class=line><span class=cl>    3 (     count == y      )   by Algebra*(2),
</span></span><span class=line><span class=cl>    4 (     sum == x*y      )   by Algebra*1,3  //proves our assert statement
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(sum == x*y)</span></span></code></pre></div><h2 id=functions-with-loops>Functions with loops</h2><p>If we have a function that includes a loop, we must do the following:</p><ul><li>Prove the loop invariant is true before the loop begins</li><li>Given that the loop invariant is true at the beginning of an iteration, prove that it is still true at the end of the iteration</li><li>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition</li></ul><p>For example, suppose our loop multiplication is inside a function which is tested by some calling code. We would like to add a function contract, our loop invariant proof, and necessary logic blocks to show that our assert holds at the end of the calling code. Here is just the code for the example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def mult(x: Z, y: Z) : Z = {
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != y) {
</span></span><span class=line><span class=cl>        sum = sum + x
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//////////// Test code //////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var one: Z = 3
</span></span><span class=line><span class=cl>var two: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var answer: Z = mult(one, two)
</span></span><span class=line><span class=cl>assert(answer == 12)</span></span></code></pre></div><p>We start by adding a function contract to <code>mult</code>, which will be the same as our function contract for the recursive version of this function in section 9.2 &ndash; <code>y</code> needs to be nonnegative, and we promise to return <code>x*y</code>. Here is the code after adding the function contract and our previous loop verificaton:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def mult(x: Z, y: Z) : Z = {
</span></span><span class=line><span class=cl>    //function contract
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(   y &gt;= 0          ),  //precondition: y should be nonnegative
</span></span><span class=line><span class=cl>        Ensures(    Res[Z] == x * y )   //postcondition (we promise to return x*y)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //prove the invariant before the loop begins
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span class=line><span class=cl>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span class=line><span class=cl>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != y) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == count * x
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span class=line><span class=cl>                                                            //at the beginning of an iteration
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        sum = sum + x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span class=line><span class=cl>            2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span class=line><span class=cl>            3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span class=line><span class=cl>            2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span class=line><span class=cl>                                                                    //but count has changed
</span></span><span class=line><span class=cl>            3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span class=line><span class=cl>            4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span class=line><span class=cl>            5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //STILL NEED TO PROVE POSTCONDITION
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//////////// Test code //////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var one: Z = 3
</span></span><span class=line><span class=cl>var two: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//STILL NEED TO ADD VERIFICATION FOR ASSERT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var answer: Z = mult(one, two)
</span></span><span class=line><span class=cl>assert(answer == 12)</span></span></code></pre></div><p>We can use the negation of the loop condition (<code>¬(count != y)</code>) together with the loop invariant to prove the postcondition will hold before the function returns. We can also apply the same process as in sections 9.1 and 9.2 to prove the precondition in the calling code before calling the <code>mult</code> function, and to use the function&rsquo;s postcondition after the call to <code>mult</code> to prove our goal assert. Here is the completed example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def mult(x: Z, y: Z) : Z = {
</span></span><span class=line><span class=cl>    //function contract
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(   y &gt;= 0          ),  //precondition: y should be nonnegative
</span></span><span class=line><span class=cl>        Ensures(    Res[Z] == x * y )   //postcondition (we promise to return x*y)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //prove the invariant before the loop begins
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>    1 (     sum == 0        )   by Premise,         //from the &#34;sum = 0&#34; assignment
</span></span><span class=line><span class=cl>    2 (     count == 0      )   by Premise,         //from the &#34;count = 0&#34; assignment
</span></span><span class=line><span class=cl>    3 (     sum == count*x  )   by Algebra*(1, 2)   //proved EXACTLY the loop invariant
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != y) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == count * x
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     sum == count*x      )   by Premise,     //the loop invariant holds
</span></span><span class=line><span class=cl>                                                            //at the beginning of an iteration
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        sum = sum + x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     sum == Old(sum) + x     )   by Premise,         //from &#34;sum = sum + x&#34; assignment
</span></span><span class=line><span class=cl>            2 (     Old(sum) == count*x     )   by Premise,         //loop invariant WAS true, but sum just changed
</span></span><span class=line><span class=cl>            3 (     sum == count*x + x      )   by Algebra*(1,2)    //current knowledge without using Old
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Deduce(
</span></span><span class=line><span class=cl>            1 (     count == Old(count)+ 1  )   by Premise,         //from &#34;count = count + 1&#34; assignment
</span></span><span class=line><span class=cl>            2 (     sum == Old(count)*x + x )   by Premise,         //from previous &#34;sum = count*x + x&#34;, 
</span></span><span class=line><span class=cl>                                                                    //but count has changed
</span></span><span class=line><span class=cl>            3 (     sum == (count-1)*x + x  )   by Algebra*(1,2),
</span></span><span class=line><span class=cl>            4 (     sum == count*x - x + x  )   by Algebra*(3),
</span></span><span class=line><span class=cl>            5 (     sum == count*x          )   by Algebra*(4)      //loop invariant holds at end of iteration
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        1 (     ¬(count != y)       )   by Premise,         //loop condition is now false
</span></span><span class=line><span class=cl>        2 (     sum == count*x      )   by Premise,         //loop invariant holds after loop
</span></span><span class=line><span class=cl>        3 (     count == y          )   by Algebra*(1),
</span></span><span class=line><span class=cl>        4 (     sum == x*y          )   by Algebra*(2,3)    //proves the postcondition
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//////////// Test code //////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var one: Z = 3
</span></span><span class=line><span class=cl>var two: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     two == 4        )   by Premise,     //from the &#34;two = 4&#34; assignment
</span></span><span class=line><span class=cl>    2 (     two &gt;= 0        )   by Algebra*(1)  //proves the mult precondition
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var answer: Z = mult(one, two)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    1 (     one == 3            )   by Premise,
</span></span><span class=line><span class=cl>    2 (     two == 4            )   by Premise,
</span></span><span class=line><span class=cl>    3 (     answer == one*two   )   by Premise          //from the mult postcondition
</span></span><span class=line><span class=cl>    4 (     answer == 12        )   by Algebra*(1,2,3)  //proves the assert 
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(answer == 12)</span></span></code></pre></div><h2 id=how-to-construct-a-loop-invariant>How to construct a loop invariant</h2><p>The most difficult part of the entire process of proving the correctness of a function with a loop is coming up with an appropriate loop invariant. In this section, we will study two additional loops and learn techniques for deriving loop invariants. In general, we need to think about what the loop is doing as it iterates, and what progress it has made so far towards its goal. A good first approach is to trace through the values of variables for several iterations of the loop, as we did with <code>mult</code> above &ndash; this helps us identify patterns that can then become the loop invariant.</p><h3 id=example-1-sum-of-odds>Example 1: Sum of odds</h3><p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var total: Z = 0
</span></span><span class=line><span class=cl>var i: Z = 0
</span></span><span class=line><span class=cl>while (i &lt; n) {
</span></span><span class=line><span class=cl>    i = i + 1
</span></span><span class=line><span class=cl>    total = total + (2*i - 1)
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>It might be difficult to tell what this code is doing before walking through a few iterations. Let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>After iteration 3</th><th>&mldr;</th><th>After iteration n</th></tr></thead><tbody><tr><td><code>i</code></td><td>0</td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>n</td></tr><tr><td><code>total</code></td><td><span class="math align-center">$0 $</span></td><td><span class="math align-center">$1 $</span></td><td><span class="math align-center">$1 + 3 (= 4)$</span></td><td><span class="math align-center">$1 + 3 + 5 (= 9)$</span></td><td>&mldr;</td><td><span class="math align-center">$1 + 3 + 5 + ... + (2*n-1) (=n^2)$</span></td></tr></tbody></table><p>Now we can see the pattern &ndash; we are adding up the first
<span class="math align-center">$n$</span> odd numbers. We can see that at the end of the i-th iteration we have added the first
<span class="math align-center">$i$</span> odd numbers, where
<span class="math align-center">$(2*i-1)$</span> is our most recent odd number. We also see that the sum of the first 1 odd number is 1, the sum of the first 2 odd numbers is
<span class="math align-center">$2^2 = 4$</span>, &mldr;, and the sum of the first
<span class="math align-center">$n$</span> odd numbers is
<span class="math align-center">$n^2$</span>.</p><p>Since our loop invariant should describe what progress it has made towards its goal of adding the first
<span class="math align-center">$n$</span> odd numbers, we can see that the loop invariant should be that at any point (before the loop begins and at the end each iteration),
<span class="math align-center">$total$</span> holds the sum of the first
<span class="math align-center">$i$</span> numbers (whose value is
<span class="math align-center">$i^2$</span>). We first try this as our loop invariant:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var total: Z = 0
</span></span><span class=line><span class=cl>var i: Z = 0
</span></span><span class=line><span class=cl>while (i &lt; n) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(i, n),
</span></span><span class=line><span class=cl>        total == i*i
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    i = i + 1
</span></span><span class=line><span class=cl>    total = total + (2*i - 1)
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Another consideration of writing a loop invariant is that we should be able to deduce our overall goal once the loop ends. After our loop, we want to be sure that <code>total</code> holds the sum of the first <code>n</code> odd numbers &ndash; i.e., that <code>total == n*n</code>. Our loop invariant tells us that <code>total == i*i</code> after the loop ends &ndash; but does <code>n</code> necessarily equal <code>i</code>?</p><p>The way it is written, we can&rsquo;t be certain. We do know that the loop condition must be false after the loop, or that <code>¬(i &lt; n)</code>. But this is equivalent to <code>i >= n</code> and not <code>i == n</code>. We need to tighten our invariant to add a restriction that <code>i</code> always be less than or equal to n:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var total: Z = 0
</span></span><span class=line><span class=cl>var i: Z = 0
</span></span><span class=line><span class=cl>while (i &lt; n) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(i, n),
</span></span><span class=line><span class=cl>        total == i*i,
</span></span><span class=line><span class=cl>        i &lt;= n
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    i = i + 1
</span></span><span class=line><span class=cl>    total = total + (2*i - 1)
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>After the loop ends, we can now combine the negation of the loop condition, <code>¬(i &lt; n)</code> together with the <code>i &lt;= n</code> portion of the invariant to deduce that <code>i == n</code>. Together with the other half of the invariant &ndash; <code>total == i*i</code> &ndash; we can be sure that <code>total == n*n</code> when the loop ends.</p><h3 id=example-2-factorial>Example 2: factorial</h3><p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var prod: Z = 1
</span></span><span class=line><span class=cl>var i: Z = 1
</span></span><span class=line><span class=cl>while (i != n) {
</span></span><span class=line><span class=cl>    i = i + 1
</span></span><span class=line><span class=cl>    prod = prod * i
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>As before, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p><table><thead><tr><th>Variable</th><th>Before loop</th><th>After iteration 1</th><th>After iteration 2</th><th>&mldr;</th><th>After iteration n</th></tr></thead><tbody><tr><td><code>i</code></td><td>1</td><td>2</td><td>3</td><td>&mldr;</td><td>n</td></tr><tr><td><code>prod</code></td><td><span class="math align-center">$1 $</span></td><td><span class="math align-center">$1 * 2$</span></td><td><span class="math align-center">$1 * 2 * 3$</span></td><td>&mldr;</td><td><span class="math align-center">$1 * 2 * 3 * ... * n$</span></td></tr></tbody></table><p>From this table, we can clearly see that after
<span class="math align-center">$i$</span> iterations,
<span class="math align-center">$prod == i!$</span> (i factorial). This <em>should</em> be our loop invariant&mldr;but as with many other languages, Logika does not recognize <code>!</code> as a factorial operator (instead, it is a negation operator). In the next section, we will see how to create a <em>Logika fact</em> to help define the factorial operation. We will then be able to use that Logika fact in place of <code>!</code> to let our invariant be a formalization of: <em>prod equals i factorial</em>.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/59f27743aacfa60cb99e24d1073100eb8a572e0f>May 28, 2024</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search><script>var contentLangs=["en"]</script><script src=/cis301/js/auto-complete.js?1754341382 defer></script><script src=/cis301/js/lunr/lunr.min.js?1754341382 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1754341382 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1754341382 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1754341382 defer></script><script src=/cis301/js/search.js?1754341382 defer></script></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/><input type=checkbox id=R-section-4dd9ea2241609372e21522ad467bdbcf aria-controls=R-subsections-4dd9ea2241609372e21522ad467bdbcf><label for=R-section-4dd9ea2241609372e21522ad467bdbcf><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/><b>0. </b>Getting Started</a><ul id=R-subsections-4dd9ea2241609372e21522ad467bdbcf class="morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/><a class=padding href=/cis301/0-chapter/0_1-toolsguide/>0.1. Tools Guide</a></li><li data-nav-id=/cis301/0-chapter/0_2-gitinstall/><a class=padding href=/cis301/0-chapter/0_2-gitinstall/>0.2. git Install</a></li></ul></li><li data-nav-id=/cis301/1-chapter/><input type=checkbox id=R-section-17929730d34290b059d2edff1c690239 aria-controls=R-subsections-17929730d34290b059d2edff1c690239><label for=R-section-17929730d34290b059d2edff1c690239><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-17929730d34290b059d2edff1c690239 class="morespace collapsible-menu"><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/><a class=padding href=/cis301/1-chapter/1_1-logicbasics/>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/><input type=checkbox id=R-section-97391a296e58f4aff54bb6b925a2776b aria-controls=R-subsections-97391a296e58f4aff54bb6b925a2776b><label for=R-section-97391a296e58f4aff54bb6b925a2776b><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/><b>2. </b>Truth Tables</a><ul id=R-subsections-97391a296e58f4aff54bb6b925a2776b class="morespace collapsible-menu"><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/><a class=padding href=/cis301/2-chapter/2_1-opscircuits/>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/><a class=padding href=/cis301/2-chapter/2_2-logikatruth/>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/><a class=padding href=/cis301/2-chapter/2_3-satis/>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/><a class=padding href=/cis301/2-chapter/2_5-sementail/>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/><input type=checkbox id=R-section-b4e2df8934a6b804e9336da7e38d4126 aria-controls=R-subsections-b4e2df8934a6b804e9336da7e38d4126><label for=R-section-b4e2df8934a6b804e9336da7e38d4126><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-b4e2df8934a6b804e9336da7e38d4126 class="morespace collapsible-menu"><li data-nav-id=/cis301/3-chapter/3_1-propatom/><a class=padding href=/cis301/3-chapter/3_1-propatom/>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/><a class=padding href=/cis301/3-chapter/3_2-notandor/>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/><a class=padding href=/cis301/3-chapter/3_3-implies/>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/><a class=padding href=/cis301/3-chapter/3_4-equiv/>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/><input type=checkbox id=R-section-619d3749907cd3e1af90a59cf2fcd6bd aria-controls=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd><label for=R-section-619d3749907cd3e1af90a59cf2fcd6bd><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd class="morespace collapsible-menu"><li data-nav-id=/cis301/4-chapter/4_1-intro/><a class=padding href=/cis301/4-chapter/4_1-intro/>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/><a class=padding href=/cis301/4-chapter/4_2-andrules/>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/><a class=padding href=/cis301/4-chapter/4_3-orrules/>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/><a class=padding href=/cis301/4-chapter/4_4-impliesrules/>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/><a class=padding href=/cis301/4-chapter/4_5-notrules/>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/><a class=padding href=/cis301/4-chapter/4_6-strategies/>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/><a class=padding href=/cis301/4-chapter/4_7-theorems/>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/><a class=padding href=/cis301/4-chapter/4_8-equivalence/>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/><input type=checkbox id=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7 aria-controls=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7><label for=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7 class="morespace collapsible-menu"><li data-nav-id=/cis301/5-chapter/5_1-motivation/><a class=padding href=/cis301/5-chapter/5_1-motivation/>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/><a class=padding href=/cis301/5-chapter/5_2-predsyntax/>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/><a class=padding href=/cis301/5-chapter/5_4-multquant/>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/><input type=checkbox id=R-section-1afc7d1d7b98dcc397b91690230bcb55 aria-controls=R-subsections-1afc7d1d7b98dcc397b91690230bcb55><label for=R-section-1afc7d1d7b98dcc397b91690230bcb55><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-1afc7d1d7b98dcc397b91690230bcb55 class="morespace collapsible-menu"><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/><a class=padding href=/cis301/6-chapter/6_1-univrules/>6.1. Rules with ∀</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/><a class=padding href=/cis301/6-chapter/6_2-existrules/>6.2. Rules with ∃</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/><a class=padding href=/cis301/6-chapter/6_3-nested/>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/><a class=padding href=/cis301/6-chapter/6_4-equiv/>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/><a class=padding href=/cis301/6-chapter/6_5-strategies/>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/><input type=checkbox id=R-section-48461595e2f67d1468fbd78e51714428 aria-controls=R-subsections-48461595e2f67d1468fbd78e51714428><label for=R-section-48461595e2f67d1468fbd78e51714428><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/><b>7. </b>Mathematical Induction</a><ul id=R-subsections-48461595e2f67d1468fbd78e51714428 class="morespace collapsible-menu"><li data-nav-id=/cis301/7-chapter/7_1-process/><a class=padding href=/cis301/7-chapter/7_1-process/>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/><a class=padding href=/cis301/7-chapter/7_2-algebraex/>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/><a class=padding href=/cis301/7-chapter/7_3-divex/>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/><a class=padding href=/cis301/7-chapter/7_4-setex/>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/><input type=checkbox id=R-section-77afa9c6b199f7330fa5eb8966814b35 aria-controls=R-subsections-77afa9c6b199f7330fa5eb8966814b35><label for=R-section-77afa9c6b199f7330fa5eb8966814b35><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-77afa9c6b199f7330fa5eb8966814b35 class="morespace collapsible-menu"><li data-nav-id=/cis301/8-chapter/8_1-goal/><a class=padding href=/cis301/8-chapter/8_1-goal/>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/><a class=padding href=/cis301/8-chapter/8_3-assertassume/>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/><a class=padding href=/cis301/8-chapter/8_5-assignment/>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/><a class=padding href=/cis301/8-chapter/8_6-divmod/>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/><a class=padding href=/cis301/8-chapter/8_7-conditionals/>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/ class=parent><input type=checkbox id=R-section-ffb46ad61395302deae4c4fa734e982a aria-controls=R-subsections-ffb46ad61395302deae4c4fa734e982a checked><label for=R-section-ffb46ad61395302deae4c4fa734e982a><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/><b>9. </b>Functions and Loops</a><ul id=R-subsections-ffb46ad61395302deae4c4fa734e982a class="morespace collapsible-menu"><li data-nav-id=/cis301/9-chapter/9_1-functions/><a class=padding href=/cis301/9-chapter/9_1-functions/>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/><a class=padding href=/cis301/9-chapter/9_2-recursion/>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/ class=active><a class=padding href=/cis301/9-chapter/9_3-loops/>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/><a class=padding href=/cis301/9-chapter/9_4-logikafacts/>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/><a class=padding href=/cis301/9-chapter/9_5-summary/>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/><input type=checkbox id=R-section-9e1e97bcf82568ce724d247ecac0ed85 aria-controls=R-subsections-9e1e97bcf82568ce724d247ecac0ed85><label for=R-section-9e1e97bcf82568ce724d247ecac0ed85><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-9e1e97bcf82568ce724d247ecac0ed85 class="morespace collapsible-menu"><li data-nav-id=/cis301/10-chapter/10_1-modes/><a class=padding href=/cis301/10-chapter/10_1-modes/>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/><a class=padding href=/cis301/10-chapter/10_2-intosequences/>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/><a class=padding href=/cis301/10-chapter/10_3-seqfn/>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/><a class=padding href=/cis301/10-chapter/10_4-seqloop/>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/><a class=padding href=/cis301/10-chapter/10_5-globals/>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/><a class=padding href=/cis301/10-chapter/10_6-termination/>10.6 Termination</a></li></ul></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Language</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-en value=#R-select-language-en data-url=/cis301/9-chapter/9_3-loops/ lang=en-us selected></option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class=footerVisitedLinks><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Clear History</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></div></aside><script src=/cis301/js/clipboard.min.js?1754341382 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1754341382 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis301/js/mathjax/tex-mml-chtml.js?1754341382></script><script src=/cis301/js/theme.js?1754341382 defer></script></body></html>