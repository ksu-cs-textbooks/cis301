<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.0.3+tip">




	
	
			

	
	
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Loops :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/index.xml" rel="alternate" type="application/rss+xml" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/_print/9-chapter/9_3-loops/" rel="alternate" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/tele.html" rel="alternate" type="text/html" title="CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/embed.html" rel="alternate" type="text/html" title="CIS 301 Textbook">
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1662241023" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1662241023" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1662241023" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <noscript>
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1662241023" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/featherlight.min.css?1662241023" rel="stylesheet">
      <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1662241023" rel="stylesheet">
    </noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1662241023" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1662241023" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1662241023" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1662241023" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-light-theme.css?1662241023" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1662241023" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1662241023" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1662241023" rel="stylesheet" media="print">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1662241023"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis301/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1662241023" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/jquery.min.js?1662241023" defer></script>

  </head>
  <body class="mobile-support disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/">
    
    
    <div id="body" class="default-animation">
      
      
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/" title="Logika Facts (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <a class="nav nav-prev" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_2-recursion/" title="Recursion (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-print-link">
            <a class="print-link" title='Print whole chapter (CTRL+ALT+p)' href="https://ksu-cs-textbooks.github.io/cis301/_print/9-chapter/9_3-loops/">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="top-github-link">
            <a class="github-link" title='Edit (CTRL+ALT+e)' href="https://gitlab.cs.ksu.edu/-/ide/project/cs-textbooks/cis301-textbook/edit/master/-/content/9-chapter/9_3-loops.md" target="blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span id="toc-menu" title='Table of Contents (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="3" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/"><span itemprop="name">Homepage</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="2" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/"><span itemprop="name">Functions and Loops</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/" aria-disabled="true"><span itemprop="name">Loops</span></a></li>
            </ol>
          </div>
          <div class="default-animation progress">
            <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li><a href="#loop-invariants">Loop invariants</a></li>
    <li><a href="#loop-invariants-and-mathematical-induction">Loop invariants and mathematical induction</a></li>
    <li><a href="#loop-invariant-block-syntax">Loop invariant block syntax</a></li>
    <li><a href="#example-loop-invariant-block-for-a-multiplication-loop">Example: loop invariant block for a multiplication loop</a></li>
    <li><a href="#proving-the-loop-invariant">Proving the loop invariant</a>
      <ul>
        <li><a href="#proving-loop-invariant-before-loop-begins">Proving loop invariant before loop begins</a></li>
        <li><a href="#proving-loop-invariant-at-the-end-of-each-iteration">Proving loop invariant at the end of each iteration</a></li>
        <li><a href="#knowledge-after-loop-ends">Knowledge after loop ends</a></li>
      </ul>
    </li>
    <li><a href="#functions-with-loops">Functions with loops</a></li>
    <li><a href="#how-to-construct-a-loop-invariant">How to construct a loop invariant</a>
      <ul>
        <li><a href="#example-1-sum-of-odds">Example 1: Sum of odds</a></li>
        <li><a href="#example-2-factorial">Example 2: factorial</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </div>
          </div>
        </div>
      </nav>
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
          <article class="default">
    
    
<h1>Loops</h1>
    
    
<p>A <em>loop</em> is a command that restarts itself over and over while its <em>loop condition</em> remains true. Loops are trickier to analyze than if/else statements, because we don&rsquo;t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations&hellip;we don&rsquo;t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.</p>
<p>The only loop available in Logika is a <em>while</em> loop, which behaves in the same way as while loops in other languages. If the loop condition is initially false, then the body of the while loop is skipped entirely. If the loop condition is initially true, then we execute the loop body and then recheck the condition. This continues until the loop condition becomes false.</p>
<p>Here is the syntax of a Logika while loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (condition) {
</span></span><span style="display:flex;"><span>   //body of loop
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="loop-invariants">Loop invariants</h2>
<p>Our solution to analyzing loops despite not knowing the number of iterations is a tool called a <em>loop invariant</em>. The job of the loop invariant is to summarize what is always true about the loop. Often, the loop invariant describes the relationship between variables and demonstrates how much progress the loop has made. Sometimes the loop invariant also contains claims that certain variables will always stay in a particular range.</p>
<p>Whatever we choose as the loop invariant, we must be able to do the following:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li>
</ul>
<h2 id="loop-invariants-and-mathematical-induction">Loop invariants and mathematical induction</h2>
<p>The process of proving the correctness of loop invariants is very similar to a mathematical induction proof. We must prove the loop invariant is true before the loop begins, which is analogous to the <em>base case</em> in mathematical induction. The process of assuming the invariant is true at the beginning of an iteration and proving that it is still true at the end of an iteration is just like mathematical induction&rsquo;s <em>inductive step</em>.</p>
<p>If we prove those two things about our invariant, we can be certain the invariant will still hold after the loop terminates. Why? For the same reason mathematical induction proves a property for a general $n$:</p>
<ul>
<li>We know the invariant holds before the loop begins</li>
<li>Because the invariant holds before the loop begins, we are sure it holds at the beginning of the first iteration</li>
<li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the first iteration</li>
<li>Because we&rsquo;re sure it still holds at the end of the first iteration, we know it holds at the beginning of the second iteration</li>
<li>Because we&rsquo;ve proved the invariant still holds at the end of each iteration, we&rsquo;re sure it still holds at the end of the second iteration
&hellip;</li>
<li>We&rsquo;re sure the invariant still holds at the end of each iteration, including the end of the LAST iteration. Thus we&rsquo;re certain the invariant holds just after the loop ends.</li>
</ul>
<h2 id="loop-invariant-block-syntax">Loop invariant block syntax</h2>
<p>In Logika, we will use a logic block to indiciate our loop invariant. This <em>loop invariant block</em> will go just inside the loop, before the loop body:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (condition) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant (expression(s))
</span></span><span style="display:flex;"><span>        modifies (variable list)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //loop body
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here is a summary of the different loop invariant clauses:</p>
<ul>
<li><code>invariant</code>: lists the invariant for the function. If we have multiple invariants, we can list them on separate lines (where subsequent lines are tabbed over under <code>invariant</code>).</li>
<li><code>modifies</code>: lists the name of any variables that are modified in the loop body.</li>
</ul>
<h2 id="example-loop-invariant-block-for-a-multiplication-loop">Example: loop invariant block for a multiplication loop</h2>
<p>Suppose we have the following loop to multiply two numbers, <code>x</code> and <code>y</code>, using repeated addition. (This is very similar to our <code>mult</code> function from section 9.2, except it does the additions using a loop instead of using recursion):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><p>Before writing the loop invariant block, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>After iteration 3</th>
<th>&hellip;</th>
<th>After iteration y</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>y</td>
</tr>
<tr>
<td><code>sum</code></td>
<td>$0 (= 0*x)$</td>
<td>$x (= 1*x)$</td>
<td>$x + x (= 2*x)$</td>
<td>$x + x + x (= 3*x)$</td>
<td>&hellip;</td>
<td>$x + x + &hellip; + x (= y*x)$</td>
</tr>
</tbody>
</table>
<p>Before the loop begins, we&rsquo;ve added 0 $x$&rsquo;s together, so the sum is 0. After the first iteration, we&rsquo;ve added 1 $x$ together, so the sum is $x$. After the second iteration, we&rsquo;ve added 2 $x$&rsquo;s together, so the sum is $x + x$ which is really $2 * x$. This continues until after the y-th iteration, when we&rsquo;ve added y $x$&rsquo;s together (and the sum is $y*x$).</p>
<p>Using this table, it is easy to see that at any point, <code>sum == count*x</code> (since <code>count</code> tracks the number of iterations). This is true both before the loop begins and at the end of each iteration, so it will be our loop invariant.</p>
<p>We now add a loop invariant block to our loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    //loop invariant block (still needs to be proved)
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><p>We list <code>sum</code> and <code>count</code> in the <code>modifies</code> clause because those are the two variables that change value inside the loop.</p>
<h2 id="proving-the-loop-invariant">Proving the loop invariant</h2>
<p>In order to prove the correctness of a loop, we must do two things:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Assume the loop invariant is true at the beginning of an iteration, and prove that the invariant is STILL true at the end of the iteration</li>
</ul>
<h3 id="proving-loop-invariant-before-loop-begins">Proving loop invariant before loop begins</h3>
<p>In our multiplication loop above, let&rsquo;s start by proving the loop invariant before the loop begins. This means that just before the loop, we must prove exactly the claim <code>sum == count*x</code>. We can do this with algebra on the current variable values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>    2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>    3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //we still need to prove the invariant after each iteration
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><h3 id="proving-loop-invariant-at-the-end-of-each-iteration">Proving loop invariant at the end of each iteration</h3>
<p>To prove the loop invariant still holds at the end of an iteration, we must have a logic block at the end of the loop body with exactly the claim in the loop invariant (which will now be referring to the updated values of each variable). Since this step has us assuming the loop invariant is true at the beginning of each iteration, we can list the loop invariant as a <em>premise</em> in a logic block just inside the loop body. Here is the structure we wish to follow for our multiplication loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == count*x           premise     //the loop invariant holds
</span></span><span style="display:flex;"><span>                                                //at the beginning of an iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //need to prove exactly &#34;sum == count*x&#34;
</span></span><span style="display:flex;"><span>    //to prove our invariant still holds at the end of an iteration
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can complete the loop invariant proof by using our tools for processing assignment statements with mutations. Here is the completed verification:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>val x: Z = readInt()
</span></span><span style="display:flex;"><span>val y: Z = readInt()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var sum: Z = 0
</span></span><span style="display:flex;"><span>var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>    2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>    3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (count != y) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == count*x
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                //at the beginning of an iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>        2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>        3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>        2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                    //but count has changed
</span></span><span style="display:flex;"><span>        3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>        4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>        5. sum == count*x               algebra 4   //loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//now sum is x*y
</span></span></code></pre></div><h3 id="knowledge-after-loop-ends">Knowledge after loop ends</h3>
<p>In the example above, suppose we add the following assert after the loop ends:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>assert(sum == x*y)
</span></span></code></pre></div><p>This seems like a reasonable claim &ndash; after all, we said that our loop was supposed to calculated <code>x * y</code> using repeated addition. We have proved the loop invariant, so we can be sure that <code>sum == count*x</code> after the loop&hellip;but that&rsquo;s not quite the same thing. Does <code>count</code> equal <code>y</code>? How do we know?</p>
<p>We can prove our assert statement by considering one more piece of information &ndash; if we have exited the loop, we know that the loop condition must be false. In fact, you always know two things (which you can claim as premises) after the loop ends:</p>
<ol>
<li>The loop condition is false (so we can claim <code>¬(condition)</code>)</li>
<li>The loop invariant is true, since we proved is true at the end of each iteration</li>
</ol>
<p>We can use those pieces of information to prove our assert statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>//the multiplication loop example goes here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. sum == count*x           premise     //the loop invariant holds
</span></span><span style="display:flex;"><span>    2. ¬(count != y)            premise     //the loop condition is not true
</span></span><span style="display:flex;"><span>    3. count == y               algebra 2
</span></span><span style="display:flex;"><span>    4. sum == x*y               algebra 1 3 //proves our assert statement
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(sum == x*y)
</span></span></code></pre></div><h2 id="functions-with-loops">Functions with loops</h2>
<p>If we have a function that includes a loop, we must do the following:</p>
<ul>
<li>Prove the loop invariant is true before the loop begins</li>
<li>Given that the loop invariant is true at the beginning of an iteration, prove that it is still true at the end of the iteration</li>
<li>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition</li>
</ul>
<p>For example, suppose our loop multiplication is inside a function which is tested by some calling code. We would like to add a function contract, our loop invariant proof, and necessary logic blocks to show that our assert holds at the end of the calling code. Here is just the code for the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>We start by adding a function contract to <code>mult</code>, which will be the same as our function contract for the recursive version of this function in section 9.2 &ndash; <code>y</code> needs to be nonnegative, and we promise to return <code>x*y</code>. Here is the code after adding the function contract and our previous loop verificaton:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>        2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>        3. sum == count*x       algebra 1 2 //proved EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                    //at the beginning of an iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>            3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                        //but count has changed
</span></span><span style="display:flex;"><span>            3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>            4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>            5. sum == count*x               algebra 4   //loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //STILL NEED TO PROVE POSTCONDITION
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//STILL NEED TO ADD VERIFICATION FOR ASSERT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><p>We can use the negation of the loop condition (<code>¬(count != y)</code>) together with the loop invariant to prove the postcondition will hold before the function returns. We can also apply the same process as in sections 9.1 and 9.2 to prove the precondition in the calling code before calling the <code>mult</code> function, and to use the function&rsquo;s postcondition after the call to <code>mult</code> to prove our goal assert. Here is the completed example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def mult(x: Z, y: Z) : Z = {
</span></span><span style="display:flex;"><span>    //function contract
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires y &gt;= 0         //precondition: y should be nonnegative
</span></span><span style="display:flex;"><span>        ensures result == x*y   //postcondition (we promise to return x*y)
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //prove the invariant before the loop begins
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. sum == 0             premise     //from the &#34;sum = 0&#34; assignment
</span></span><span style="display:flex;"><span>        2. count == 0           premise     //from the &#34;count = 0&#34; assignment
</span></span><span style="display:flex;"><span>        3. sum == count*x       algebra 1 2 //proves EXACTLY the loop invariant
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != y) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == count*x
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == count*x           premise     //the loop invariant holds 
</span></span><span style="display:flex;"><span>                                                    //at the beginning of an iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. sum == sum_old + x           premise     //from &#34;sum = sum + x&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum_old == count*x           premise     //loop invariant WAS true, but sum just changed
</span></span><span style="display:flex;"><span>            3. sum == count*x + x           algebra 1 2 //current knowledge without using _old
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            1. count == count_old + 1       premise     //from &#34;count = count + 1&#34; assignment
</span></span><span style="display:flex;"><span>            2. sum == count_old*x + x       premise     //from previous &#34;sum = count*x + x&#34;, 
</span></span><span style="display:flex;"><span>                                                        //but count has changed
</span></span><span style="display:flex;"><span>            3. sum == (count-1)*x + x       algebra 1 2
</span></span><span style="display:flex;"><span>            4. sum == count*x - x + x       algebra 3
</span></span><span style="display:flex;"><span>            5. sum == count*x               algebra 4   //proves loop invariant holds at end of iteration
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        1. ¬(count != y)                    premise     //loop condition is now false
</span></span><span style="display:flex;"><span>        2. sum == count*x                   premise     //loop invariant holds after loop
</span></span><span style="display:flex;"><span>        3. count == y                       algebra 1
</span></span><span style="display:flex;"><span>        4. sum == x*y                       algebra 2 3 //proves the postcondition
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//////////// Test code //////////////
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var one: Z = 3
</span></span><span style="display:flex;"><span>var two: Z = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. two == 4             premise     //from the &#34;two = 4&#34; assignment
</span></span><span style="display:flex;"><span>    2. two &gt;= 0             algebra 1   //proves the mult precondition
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var answer: Z = mult(one, two)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>    1. one == 3             premise
</span></span><span style="display:flex;"><span>    2. two == 4             premise
</span></span><span style="display:flex;"><span>    3. answer == one*two    premise         //from the mult postcondition
</span></span><span style="display:flex;"><span>    4. answer == 12         algebra 1 2 3   //proves the assert
</span></span><span style="display:flex;"><span>}&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>assert(answer == 12)
</span></span></code></pre></div><h2 id="how-to-construct-a-loop-invariant">How to construct a loop invariant</h2>
<p>The most difficult part of the entire process of proving the correctness of a function with a loop is coming up with an appropriate loop invariant. In this section, we will look study two additional loops and learn techniques for deriving loop invariants. In general, we need to think about what the loop is doing as it iterates, and what progress it has made so far towards its goal. A good first approach is to trace through the values of variables for several iterations of the loop, as we did with <code>mult</code> above &ndash; this helps us identify patterns that can then become the loop invariant.</p>
<h3 id="example-1-sum-of-odds">Example 1: Sum of odds</h3>
<p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It might be difficult to tell what this code is doing before walking through a few iterations. Let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>After iteration 3</th>
<th>&hellip;</th>
<th>After iteration n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>n</td>
</tr>
<tr>
<td><code>total</code></td>
<td>$0 $</td>
<td>$1 $</td>
<td>$1 + 3 (= 4)$</td>
<td>$1 + 3 + 5 (= 9)$</td>
<td>&hellip;</td>
<td>$1 + 3 + 5 + &hellip; + (2*n-1) (=n^2)$</td>
</tr>
</tbody>
</table>
<p>Now we can see the pattern &ndash; we are adding up the first $n$ odd numbers. We can see that at the end of the i-th iteration we have added the first $i$ odd numbers, where $(2*i-1)$ is our most recent odd number. We also see that the sum of the first 1 odd number is 1, the sum of the first 2 odd numbers is $2^2 = 4$, &hellip;, and the sum of the first $n$ odd numbers is $n^2$.</p>
<p>Since our loop invariant should describe what progress it has made towards its goal of adding the first $n$ odd numbers, we can see that the loop invariant should be that at any point (before the loop begins and at the end each iteration), $total$ holds the sum of the first $i$ numbers (whose value is $i^2$). We first try this as our loop invariant:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant total == i*i
</span></span><span style="display:flex;"><span>        modifies i, n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Another consideration of writing a loop invariant is that we should be able to deduce our overall goal once the loop ends. After our loop, we want to be sure that <code>total</code> holds the sum of the first <code>n</code> odd numbers &ndash; i.e., that <code>total == n*n</code>. Our loop invariant tells us that <code>total == i*i</code> after the loop ends &ndash; but does <code>n</code> necessarily equal <code>i</code>?</p>
<p>The way it is written, we can&rsquo;t be certain. We do know that the loop condition must be false after the loop, or that <code>¬(i &lt; n)</code>. But this is equivalent to <code>i &gt;= n</code> and not <code>i == n</code>. We need to tighten our invariant to add a restriction that <code>i</code> always be less than or equal to n:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var total: Z = 0
</span></span><span style="display:flex;"><span>var i: Z = 0
</span></span><span style="display:flex;"><span>while (i &lt; n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant total == i*i
</span></span><span style="display:flex;"><span>            i &lt;= n
</span></span><span style="display:flex;"><span>        modifies i, n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    total = total + (2*i - 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After the loop ends, we can now combine the negation of the loop condition, <code>¬(i &lt; n)</code> together with the <code>i &lt;= n</code> portion of the invariant to deduce that <code>i == n</code>. Together with the other half of the invariant &ndash; <code>total == i*i</code> &ndash; we can be sure that <code>total == n*n</code> when the loop ends.</p>
<h3 id="example-2-factorial">Example 2: factorial</h3>
<p>Suppose <code>n</code> has already been declared and initialized, and that we have this loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>var prod: Z = 1
</span></span><span style="display:flex;"><span>var i: Z = 1
</span></span><span style="display:flex;"><span>while (i != n) {
</span></span><span style="display:flex;"><span>    i = i + 1
</span></span><span style="display:flex;"><span>    prod = prod * i
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, let&rsquo;s make a table showing the values of different variables at different points in the loop:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Before loop</th>
<th>After iteration 1</th>
<th>After iteration 2</th>
<th>&hellip;</th>
<th>After iteration n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>&hellip;</td>
<td>n</td>
</tr>
<tr>
<td><code>prod</code></td>
<td>$1 $</td>
<td>$1 * 2$</td>
<td>$1 * 2 * 3$</td>
<td>&hellip;</td>
<td>$1 * 2 * 3 * &hellip; * n$</td>
</tr>
</tbody>
</table>
<p>From this table, we can clearly see that after $i$ iterations, $prod == i!$ (i factorial). This <em>should</em> be our loop invariant&hellip;but as with many other languages, Logika does not recognize <code>!</code> as a factorial operator (instead, it is a negation operator). In the next section, we will see how to create a <em>Logika fact</em> to help define the factorial operation. We will then be able to use that Logika fact in place of <code>!</code> to let our invariant be a formalization of: <em>prod equals i factorial</em>.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    
<div class="git-footer">
<p>Last modified by: 
            <i class='fas fa-user'></i> Julie Thornton
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/94227744a06b4787639a778352666166d82d1efb">Jun 10, 2022</a>
</p>
</div>

    
    </div>
    
    
    
    
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">

<a id="logo" href="https://ksu-cs-textbooks.github.io/cis301/">
  CIS 301: Logical Foundations of Programming
</a>

        </div>
        <div class="searchbox default-animation">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/auto-complete.js?1662241023" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.min.js?1662241023" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.stemmer.support.min.js?1662241023" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.multi.min.js?1662241023" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/lunr.en.min.js?1662241023" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis301/js/search.js?1662241023" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics collapsible-menu">
          <li data-nav-id="/0-chapter/" title="Getting Started" class="dd-item"><input type="checkbox" id="section-c55c9f751a28ecc9415234375cddd395" class="toggle"/><label for="section-c55c9f751a28ecc9415234375cddd395" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/"><b>0. </b>Getting Started</a><ul>
          <li data-nav-id="/0-chapter/0_1-toolsguide/" title="Tools Guide" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/0-chapter/0_1-toolsguide/">0.1. Tools Guide</a></li></ul></li>
          <li data-nav-id="/1-chapter/" title="Basics and Logic Puzzles" class="dd-item"><input type="checkbox" id="section-7a71fe25dd66b523fca4004b7c4d01d0" class="toggle"/><label for="section-7a71fe25dd66b523fca4004b7c4d01d0" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/"><b>1. </b>Basics and Logic Puzzles</a><ul>
          <li data-nav-id="/1-chapter/1_1-logicbasics/" title="Basic Logical Reasoning" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_1-logicbasics/">1.1. Basic Logical Reasoning</a></li>
          <li data-nav-id="/1-chapter/1_2-knightsknaves/" title="Knights and Knaves" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_2-knightsknaves/">1.2. Knights and Knaves</a></li>
          <li data-nav-id="/1-chapter/1_3-otherpuzzles/" title="Other Puzzles" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/1-chapter/1_3-otherpuzzles/">1.3. Other Puzzles</a></li></ul></li>
          <li data-nav-id="/2-chapter/" title="Truth Tables" class="dd-item"><input type="checkbox" id="section-c23f766dd7728aa0e1cff094001eac05" class="toggle"/><label for="section-c23f766dd7728aa0e1cff094001eac05" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/"><b>2. </b>Truth Tables</a><ul>
          <li data-nav-id="/2-chapter/2_1-opscircuits/" title="Operators and Circuits" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_1-opscircuits/">2.1. Operators and Circuits</a></li>
          <li data-nav-id="/2-chapter/2_2-logikatruth/" title="Truth Tables in Logika" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_2-logikatruth/">2.2. Truth Tables in Logika</a></li>
          <li data-nav-id="/2-chapter/2_3-satis/" title="Satisfiability" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_3-satis/">2.3. Satisfiability</a></li>
          <li data-nav-id="/2-chapter/2_4-logicalequiv/" title="Logical Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_4-logicalequiv/">2.4. Logical Equivalence</a></li>
          <li data-nav-id="/2-chapter/2_5-sementail/" title="Semantic Entailment" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/2-chapter/2_5-sementail/">2.5. Semantic Entailment</a></li></ul></li>
          <li data-nav-id="/3-chapter/" title="Propositional Logic Translations" class="dd-item"><input type="checkbox" id="section-ccb531d159d5247057d21618514721b6" class="toggle"/><label for="section-ccb531d159d5247057d21618514721b6" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/"><b>3. </b>Propositional Logic Translations</a><ul>
          <li data-nav-id="/3-chapter/3_1-propatom/" title="Propositional Atoms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_1-propatom/">3.1. Propositional Atoms</a></li>
          <li data-nav-id="/3-chapter/3_2-notandor/" title="NOT, AND, OR Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_2-notandor/">3.2. NOT, AND, OR Translations</a></li>
          <li data-nav-id="/3-chapter/3_3-implies/" title="Implies Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_3-implies/">3.3. Implies Translations</a></li>
          <li data-nav-id="/3-chapter/3_4-equiv/" title="Equivalent Translations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_4-equiv/">3.4. Equivalent Translations</a></li>
          <li data-nav-id="/3-chapter/3_5-knightsknavestt/" title="Knights and Knaves, revisited" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/3-chapter/3_5-knightsknavestt/">3.5. Knights and Knaves, revisited</a></li></ul></li>
          <li data-nav-id="/4-chapter/" title="Propositional Logic Proofs" class="dd-item"><input type="checkbox" id="section-8ebf970484325d93d52075c7c72ba517" class="toggle"/><label for="section-8ebf970484325d93d52075c7c72ba517" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/"><b>4. </b>Propositional Logic Proofs</a><ul>
          <li data-nav-id="/4-chapter/4_1-intro/" title="Introduction" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_1-intro/">4.1. Introduction</a></li>
          <li data-nav-id="/4-chapter/4_2-andrules/" title="AND Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_2-andrules/">4.2. AND Rules</a></li>
          <li data-nav-id="/4-chapter/4_3-orrules/" title="OR Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_3-orrules/">4.3. OR Rules</a></li>
          <li data-nav-id="/4-chapter/4_4-impliesrules/" title="Implies Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_4-impliesrules/">4.4. Implies Rules</a></li>
          <li data-nav-id="/4-chapter/4_5-notrules/" title="Negation Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_5-notrules/">4.5. Negation Rules</a></li>
          <li data-nav-id="/4-chapter/4_6-strategies/" title="Summary and Strategies" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_6-strategies/">4.6. Summary and Strategies</a></li>
          <li data-nav-id="/4-chapter/4_7-theorems/" title="Theorems" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_7-theorems/">4.7. Theorems</a></li>
          <li data-nav-id="/4-chapter/4_8-equivalence/" title="Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_8-equivalence/">4.8. Equivalence</a></li>
          <li data-nav-id="/4-chapter/4_9-soundcomplete/" title="Soundness and Completeness" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/4-chapter/4_9-soundcomplete/">4.9. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/5-chapter/" title="Predicate Logic Translations" class="dd-item"><input type="checkbox" id="section-b69c30f957b0ff55c1e9673979ceb29d" class="toggle"/><label for="section-b69c30f957b0ff55c1e9673979ceb29d" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/"><b>5. </b>Predicate Logic Translations</a><ul>
          <li data-nav-id="/5-chapter/5_1-motivation/" title="Motivation" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_1-motivation/">5.1. Motivation</a></li>
          <li data-nav-id="/5-chapter/5_2-predsyntax/" title="Syntax" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_2-predsyntax/">5.2. Syntax</a></li>
          <li data-nav-id="/5-chapter/5_3-singlequantifier/" title="Single Quantifier" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_3-singlequantifier/">5.3. Single Quantifier</a></li>
          <li data-nav-id="/5-chapter/5_4-multquant/" title="Multiple Quantifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/5-chapter/5_4-multquant/">5.4. Multiple Quantifiers</a></li></ul></li>
          <li data-nav-id="/6-chapter/" title="Predicate Logic Proofs" class="dd-item"><input type="checkbox" id="section-482218cb3a05b9572157ed70ed9a5c02" class="toggle"/><label for="section-482218cb3a05b9572157ed70ed9a5c02" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/"><b>6. </b>Predicate Logic Proofs</a><ul>
          <li data-nav-id="/6-chapter/6_1-univrules/" title="Rules with ∀" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_1-univrules/">6.1. Rules with ∀</a></li>
          <li data-nav-id="/6-chapter/6_2-existrules/" title="Rules with ∃" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_2-existrules/">6.2. Rules with ∃</a></li>
          <li data-nav-id="/6-chapter/6_3-nested/" title="Nested Quantifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_3-nested/">6.3. Nested Quantifiers</a></li>
          <li data-nav-id="/6-chapter/6_4-equiv/" title="Equivalence" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_4-equiv/">6.4. Equivalence</a></li>
          <li data-nav-id="/6-chapter/6_5-strategies/" title="Summary and Strategies" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_5-strategies/">6.5. Summary and Strategies</a></li>
          <li data-nav-id="/6-chapter/6_6-soundcomplete/" title="Soundness and Completeness" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/">6.6. Soundness and Completeness</a></li></ul></li>
          <li data-nav-id="/7-chapter/" title="Mathematical Induction" class="dd-item"><input type="checkbox" id="section-fc25ecfcb3d8e929949e8db759e88bab" class="toggle"/><label for="section-fc25ecfcb3d8e929949e8db759e88bab" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/"><b>7. </b>Mathematical Induction</a><ul>
          <li data-nav-id="/7-chapter/7_1-process/" title="Induction Process" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_1-process/">7.1. Induction Process</a></li>
          <li data-nav-id="/7-chapter/7_2-algebraex/" title="Algebra example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_2-algebraex/">7.2. Algebra example</a></li>
          <li data-nav-id="/7-chapter/7_3-divex/" title="Divisibility example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_3-divex/">7.3. Divisibility example</a></li>
          <li data-nav-id="/7-chapter/7_4-setex/" title="Set example" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/7-chapter/7_4-setex/">7.4. Set example</a></li></ul></li>
          <li data-nav-id="/8-chapter/" title="Intro to Programming Logic" class="dd-item"><input type="checkbox" id="section-bd411d4b09a07aa69f5152043fa837ed" class="toggle"/><label for="section-bd411d4b09a07aa69f5152043fa837ed" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/"><b>8. </b>Intro to Programming Logic</a><ul>
          <li data-nav-id="/8-chapter/8_1-goal/" title="Programming Logic Goal" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_1-goal/">8.1. Programming Logic Goal</a></li>
          <li data-nav-id="/8-chapter/8_2-logikaprograms/" title="Logika Programs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_2-logikaprograms/">8.2. Logika Programs</a></li>
          <li data-nav-id="/8-chapter/8_3-assertassume/" title="Assert and Assume" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_3-assertassume/">8.3. Assert and Assume</a></li>
          <li data-nav-id="/8-chapter/8_4-algebrasubst/" title="Algebra and subst Rules" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_4-algebrasubst/">8.4. Algebra and subst Rules</a></li>
          <li data-nav-id="/8-chapter/8_5-assignment/" title="Assignment Statements" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_5-assignment/">8.5. Assignment Statements</a></li>
          <li data-nav-id="/8-chapter/8_6-divmod/" title="Integer Division and Modulo" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_6-divmod/">8.6. Integer Division and Modulo</a></li>
          <li data-nav-id="/8-chapter/8_7-conditionals/" title="Conditional Statements" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/8-chapter/8_7-conditionals/">8.7. Conditional Statements</a></li></ul></li>
          <li data-nav-id="/9-chapter/" title="Functions and Loops" class="dd-item parent"><input type="checkbox" id="section-708a4026c5b157dd8da0a277e359073f" class="toggle" checked/><label for="section-708a4026c5b157dd8da0a277e359073f" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/"><b>9. </b>Functions and Loops</a><ul>
          <li data-nav-id="/9-chapter/9_1-functions/" title="Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_1-functions/">9.1. Functions</a></li>
          <li data-nav-id="/9-chapter/9_2-recursion/" title="Recursion" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_2-recursion/">9.2. Recursion</a></li>
          <li data-nav-id="/9-chapter/9_3-loops/" title="Loops" class="dd-item active"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_3-loops/">9.3. Loops</a></li>
          <li data-nav-id="/9-chapter/9_4-logikafacts/" title="Logika Facts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_4-logikafacts/">9.4. Logika Facts</a></li>
          <li data-nav-id="/9-chapter/9_5-summary/" title="Summary" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/9-chapter/9_5-summary/">9.5. Summary</a></li></ul></li>
          <li data-nav-id="/10-chapter/" title="Sequences, Globals, and Termination" class="dd-item"><input type="checkbox" id="section-83e8e84779c32ba319a378089810947b" class="toggle"/><label for="section-83e8e84779c32ba319a378089810947b" ></label><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/"><b>10. </b>Sequences, Globals, and Termination</a><ul>
          <li data-nav-id="/10-chapter/10_1-modes/" title="Logika Modes" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_1-modes/">10.1 Logika Modes</a></li>
          <li data-nav-id="/10-chapter/10_2-intosequences/" title="Intro to Sequences" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_2-intosequences/">10.2 Intro to Sequences</a></li>
          <li data-nav-id="/10-chapter/10_3-seqfn/" title="Sequences in Functions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_3-seqfn/">10.3 Sequences in Functions</a></li>
          <li data-nav-id="/10-chapter/10_4-seqloop/" title="Sequences in Loops" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_4-seqloop/">10.4 Sequences in Loops</a></li>
          <li data-nav-id="/10-chapter/10_5_seqlogfact/" title="Logika Facts, revisited" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_5_seqlogfact/">10.5 Logika Facts, revisited</a></li>
          <li data-nav-id="/10-chapter/10_6-globals/" title="Global Variables" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_6-globals/">10.6 Global Variables</a></li>
          <li data-nav-id="/10-chapter/10_7-termination/" title="Termination" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/">10.7 Termination</a></li></ul></li>
        </ul>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch showVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="variants.changeVariant( this.value );">
                    <option id="light-theme" value="light-theme" selected>Light Theme</option>
                    <option id="dark-theme" value="dark-theme">Dark Theme</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter"><style>
  #footer {
      font-size: 13px;
      margin-left: auto;
      margin-right: auto;
      padding: 2rem 1rem;
      min-width: 230px;
      max-width: 300px;
  }
  #footer p {
      margin: 0;
  }
</style>
  
<p>Built using <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/K-State-Computational-Core/hugo-theme-relearn/tree/main">Hugo Relearn Theme</a>.</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; margin: .5rem auto" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p>

        </div>
      </div>
    </aside>
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1662241023" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1662241023" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/featherlight.min.js?1662241023" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1662241023" defer></script>
    
    
    
    
  </body>
</html>
