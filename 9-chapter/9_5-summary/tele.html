<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:
Step 1: Write function contracts Write a function contract for any function that doesn’t already have one. Function contracts go just inside the function defintion, and look like:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Summary :: CIS 301 Textbook"><meta name=twitter:description content="Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:
Step 1: Write function contracts Write a function contract for any function that doesn’t already have one. Function contracts go just inside the function defintion, and look like:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/9-chapter/9_5-summary/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Summary :: CIS 301 Textbook"><meta property="og:description" content="Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:
Step 1: Write function contracts Write a function contract for any function that doesn’t already have one. Function contracts go just inside the function defintion, and look like:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Functions and Loops"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-04-30T15:01:51-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Summary :: CIS 301 Textbook"><meta itemprop=description content="Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:
Step 1: Write function contracts Write a function contract for any function that doesn’t already have one. Function contracts go just inside the function defintion, and look like:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-04-30T15:01:51-05:00"><meta itemprop=wordCount content="623"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Summary :: CIS 301 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis301/9-chapter/9_5-summary/index.html rel=canonical type=text/html title="Summary :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_5-summary/index.xml rel=alternate type=application/rss+xml title="Summary :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_5-summary/index.print.html rel=alternate type=text/html title="Summary :: CIS 301 Textbook"><link href=/cis301/9-chapter/9_5-summary/embed.html rel=alternate type=text/html title="Summary :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1765567784 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1765567784 defer></script><script src=/cis301/js/search-lunr.min.js?1765567784 defer></script><script src=/cis301/js/search.min.js?1765567784 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1765567784"</script><script src=/cis301/js/lunr/lunr.min.js?1765567784 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1765567784 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1765567784 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1765567784 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1765567784 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1765567784 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1765567784 rel=stylesheet><link href=/cis301/css/theme.min.css?1765567784 rel=stylesheet><link href=/cis301/css/format-html.min.css?1765567784 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/9-chapter/9_5-summary/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1765567784 rel=stylesheet></head><body class="mobile-support html" data-url=/cis301/9-chapter/9_5-summary/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 9-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:</p><h2 id=step-1-write-function-contracts>Step 1: Write function contracts</h2><p>Write a function contract for any function that doesn&rsquo;t already have one. Function contracts go just inside the function defintion, and look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Contract(
</span></span><span style=display:flex><span>    Requires( preconditions ),
</span></span><span style=display:flex><span>    Ensures( postconditions )
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Here, <em>preconditions</em> is a comma-separated list of any requirements your function has about the range of its parameters, and <em>postconditions</em> is a comma-separated list describing the impact of calling the function (in this chapter, the postcondition always describes how the return value relates to the parameters.) If you&rsquo;re not sure what to write as the postcondition, try walking through your function with different parameters to get a sense for the pattern of what the function is doing in relation to the parameters. If you were given a Logika proof function, you will likely need to use it in the postcondition (and loop invariant) to describe the behavior.</p><h2 id=step-2-write-loop-invariant-blocks>Step 2: Write loop invariant blocks</h2><p>Write a loop invariant block for any loop that doesn&rsquo;t already have one. Loop invariant blocks go just inside the loop (before any code) and look like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Invariant(
</span></span><span style=display:flex><span>    Modifies(comma-separated list of variables),
</span></span><span style=display:flex><span>    Invariant_1,
</span></span><span style=display:flex><span>    Invariant_2,
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Each <em>Invariant_i</em> describes an invariant for the loop, which should describe the progress the loop has made toward its goal (the loop invariant will often greatly resemble the postcondition for the enclosing function). Loop invariants occasionally need to specify the range of different variables, especially if the invariant uses Logika facts (which may only be defined for particular values) or if you need more information about the final value of a variable when a loop terminates. I recommend making a table of variable values for several iterations of your loop to get a sense of the relationship between variables &ndash; this relationship is what will become the loop invariant.</p><p>The <em>Modifies</em> clause lists all variables that are modified in the loop body.</p><h2 id=step-3-prove-invariant-holds-before-loop-begins>Step 3: Prove invariant holds before loop begins</h2><p>In each loop, prove your invariant holds before the loop begins. You may need to pull in the function&rsquo;s precondition as a premise in this step. You must prove EXACTLY the claim in all pieces of the loop invariant. If your loop invariant involves a Logika fact, you may need to pull in a piece of the fact definition to help prove the invariant.</p><h2 id=step-4-prove-invariant-still-holds-at-end-of-iteration>Step 4: Prove invariant still holds at end of iteration</h2><p>In each loop, prove your invariant still holds at the end of each iteration. Start by pulling in each part of the loop invariant as a premise before the loop body begins. Use logic blocks to process each statement in the body of the loop. By the end of the loop, you must prove EXACTLY the claim in all pieces of the loop invariant. (Again, if your loop invariant involves a Logika fact, you&rsquo;ll want to pull in a piece of the fact definition to help with this step.)</p><h2 id=step-5-prove-the-postcondition>Step 5: Prove the postcondition</h2><p>Use the combination of the loop invariant and the negation of the loop condition to prove the postcondition just before your function ends.</p><h2 id=step-6-prove-the-precondition-before-each-function-call>Step 6: Prove the precondition before each function call</h2><p>Before any function call, prove exactly the precondition(s) for the function (using whatever values you are passing as parameters).</p><h2 id=step-7-use-postcondition-after-each-function-call>Step 7: Use postcondition after each function call</h2><p>After returning from each function call, pull the function&rsquo;s postcondition into a logic block as a premise (using whatever values you passed as parameters). Use this information to help prove any asserts.</p><footer class=footline></footer></article></div></main></div><script src=/cis301/js/clipboard/clipboard.min.js?1765567784 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1765567784 defer></script><script src=/cis301/js/theme.min.js?1765567784 defer></script></div><script src=/cis301/js/tele-scroll.min.js?1765567784 defer></script></body></html>