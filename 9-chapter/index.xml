<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Functions and Loops :: CIS 301 Textbook</title><link>https://textbooks.cs.ksu.edu/cis301/9-chapter/</link><description>Programming Logic: Functions and Loops In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 29 Apr 2025 11:46:26 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis301/9-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Functions</title><link>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_1-functions/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_1-functions/</guid><description>A function in Scala is analogous to a method in Java or C# – it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:
def functionName(paramList): returnType = { }We will use the keyword Unit (like void in other languages) for a function that does not return a value. If a function has a non-Unit return type, then all paths through the function must end in a return statement:</description></item><item><title>Recursion</title><link>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_2-recursion/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_2-recursion/</guid><description>In this section, we will see how to prove the correctness of programs that use recursive functions. We will see that verifying a recursive function is exactly the same as verifying a non-recursive function:
We must prove a function’s preconditions before calling it (including before making a recursive call) After calling a function, we can list the function’s postconditions as premises (including after making a recursive call) The function can list its preconditions as premises The function must prove its postconditions just before it ends Writing a recursive mult function We know we can multiply two numbers, x and y, using the * operator – x * y.</description></item><item><title>Loops</title><link>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_3-loops/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_3-loops/</guid><description>A loop is a command that restarts itself over and over while its loop condition remains true. Loops are trickier to analyze than if/else statements, because we don’t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations…we don’t know.</description></item><item><title>Logika Facts</title><link>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_4-logikafacts/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_4-logikafacts/</guid><description>We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * ... * 2 * 1$, but we don’t have a way to describe the “…” portion using our current tools.
In this section, we introduce Logika facts, which will let us create our own recursive proof functions that we can use in invariants and postconditions.</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_5-summary/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/9-chapter/9_5-summary/</guid><description>Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:
Step 1: Write function contracts Write a function contract for any function that doesn’t already have one. Function contracts go just inside the function defintion, and look like:</description></item></channel></rss>