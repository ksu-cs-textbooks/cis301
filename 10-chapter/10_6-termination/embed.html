<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="What is termination? In this section, we will consider the notion of termination – whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions – IF the function’s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Termination :: CIS 301 Textbook"><meta name=twitter:description content="What is termination? In this section, we will consider the notion of termination – whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions – IF the function’s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/10-chapter/10_6-termination/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Termination :: CIS 301 Textbook"><meta property="og:description" content="What is termination? In this section, we will consider the notion of termination – whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions – IF the function’s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Sequences, Globals, and Termination"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-05-02T14:41:22-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Termination :: CIS 301 Textbook"><meta itemprop=description content="What is termination? In this section, we will consider the notion of termination – whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions – IF the function’s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-05-02T14:41:22-05:00"><meta itemprop=wordCount content="1596"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Termination :: CIS 301 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis301/10-chapter/10_6-termination/index.html rel=canonical type=text/html title="Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/10_6-termination/index.xml rel=alternate type=application/rss+xml title="Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/10_6-termination/index.print.html rel=alternate type=text/html title="Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/10_6-termination/tele.html rel=alternate type=text/html title="Termination :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1756154208 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1756154208 defer></script><script src=/cis301/js/search-lunr.min.js?1756154208 defer></script><script src=/cis301/js/search.min.js?1756154208 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1756154208"</script><script src=/cis301/js/lunr/lunr.min.js?1756154208 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1756154208 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1756154208 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1756154208 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1756154208 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1756154208 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1756154208 rel=stylesheet><link href=/cis301/css/theme.min.css?1756154208 rel=stylesheet><link href=/cis301/css/format-html.min.css?1756154208 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/10-chapter/10_6-termination/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1756154208 rel=stylesheet></head><body class="mobile-support embed html" data-url=/cis301/10-chapter/10_6-termination/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 10-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=termination>Termination</h1><h2 id=what-is-termination>What is termination?</h2><p>In this section, we will consider the notion of <em>termination</em> &ndash; whether a function will ever finish running.</p><h2 id=partial-correctness-vs-total-correctness>Partial correctness vs total correctness</h2><p>Up to this point, we have proved <em>partial correctness</em> for functions &ndash; IF the function&rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.</p><h3 id=example-of-partial-correctness>Example of partial correctness</h3><p>Consider the following version of our <code>mult</code> function, which uses repeated addition to multiply two numbers:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == m * count
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + m
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  return sum
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This function will be verified in Logika&rsquo;s auto mode, but in fact it has a subtle flaw. If we were to pass in <code>-1</code> for our second parameter (<code>n</code>), then we would get stuck in an infinite loop. <code>count</code> would be initially 0, and we would increment <code>count</code> each time in the loop, but of course it NEVER equal -1.</p><p>This is an example of partial correctness &ndash; if our function DOES finish (which it would for nonnegative values of <code>n</code>), then we have shown it will return the correct value. We can see that we will need to require that the <code>n</code> parameter be nonnegative .</p><h3 id=total-correctness-definition>Total correctness definition</h3><p><em>Total correctness</em> goes a step further than partial correctness &ndash; it says that IF the function&rsquo;s precondition holds, THEN we promise that it will terminate and that its postcondition will hold.</p><p>In order to show total correctness for our <code>mult</code> function, we must show that it always terminates.</p><h2 id=process-of-proving-termination>Process of proving termination</h2><p>We will see later in this section that the idea of termination is a much more challenging topic than it might seem. There is no button in Logika that will check for termination, but we can often insert manual assertions which, if they are verified, will guarantee termination. We will show how to create such manual assertions for simple loops that execute a set number of times.</p><p>First, we need to come up with a way to measure (as an integer) how much work the loop has left to do. Using this measure of work, we want to show two things:</p><ul><li>Each loop iteration decreases the integer measure (i.e., the amount of work left to do is strictly decreasing)</li><li>When our integer measure is 0 or less, then we are certain that we are done (i.e., the loop exits)</li></ul><h2 id=termination-in-mult>Termination in mult</h2><p>In our <code>mult</code> example, let&rsquo;s first try to establish an integer measure of work for the loop. We know that the loop is computing <code>m + m + ... + m</code>, for a total of <code>n</code> additions. When <code>count</code> is 0, we know we have <code>n</code> more additions to do (<code>n</code> more iterations of the loop). When <code>count</code> is 1, we know we have <code>n-1</code> more additions&mldr;and when <code>count</code> is <code>n</code>, we know that we have no more additions to do (and the loop ends). Our measure of work should be the number of additions left to do, which is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Measure of work: n - count</span></span></code></pre></div><p>We can calculate this measure at the beginning of each iteration and again at the end of each iteration:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>while (count != n) {
</span></span><span style=display:flex><span>    Invariant(
</span></span><span style=display:flex><span>        Modifies(sum, count),
</span></span><span style=display:flex><span>        sum == m * count
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //get measure value at beginning of iteration
</span></span><span style=display:flex><span>    val measureBegin: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sum = sum + m
</span></span><span style=display:flex><span>    count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //get measure value at end of iteration
</span></span><span style=display:flex><span>    val measureEnd: Z = n-count
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Next, we want to assert that <code>measureEnd &lt; measureBegin</code> &ndash; that the amount of work decreases with each iteration. We can also assert that <code>measureEnd > 0 || count == n</code> &ndash; that either we have more work to do, or our loop condition is false (meaning that if we have no more work to do, then our loop condition must be false and thus terminate):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (n &gt;= 0),          //needed for termination
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == m * count
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at beginning of iteration
</span></span><span style=display:flex><span>        val measureBegin: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + m
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at end of iteration
</span></span><span style=display:flex><span>        val measureEnd: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we are making progress
</span></span><span style=display:flex><span>        //the amount of work decreases with each iteration
</span></span><span style=display:flex><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we either have more work, or the loop will terminate
</span></span><span style=display:flex><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style=display:flex><span>        assert(measureEnd &gt; 0 || count == n)     //NOTE: will not hold!
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If we try verifying this program in Logika, the second assert, <code>assert(measureEnd > 0 || count == n)</code> will not hold. To see why, let&rsquo;s suppose that <code>measureEnd &lt;= 0</code>. For the assert to be true, we would need to be certain that <code>count == n</code> (since the left side of the OR would be false). Because <code>measureEnd = n-count</code>, we can infer that <code>count >= n</code> when <code>measureEnd &lt;= 0</code>. However, Logika is unable to infer that <code>count == n</code> from the knowledge that <code>count >= n</code> unless it also knows that <code>count &lt;= n</code> always holds. We can add this knowledge by strengthening our loop invariant to provide a range for the loop counter &ndash; <code>count >= 0</code> and <code>count &lt;= n</code>. Even if not required, it is a good habit anyway to include the loop counter range as part of the loop invariant.</p><p>We strengthen our loop invariant, and both asserts will hold &ndash; thus demonstrating termination:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>def mult(m: Z, n: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires (n &gt;= 0),          //needed for termination
</span></span><span style=display:flex><span>        Ensures(Res[Z] == m * n)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var sum: Z = 0
</span></span><span style=display:flex><span>    var count: Z = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while (count != n) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies(sum, count),
</span></span><span style=display:flex><span>            sum == m * count,
</span></span><span style=display:flex><span>            0 &lt;= count,
</span></span><span style=display:flex><span>            count &lt;= n
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at beginning of iteration
</span></span><span style=display:flex><span>        val measureBegin: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sum = sum + m
</span></span><span style=display:flex><span>        count = count + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //get measure value at end of iteration
</span></span><span style=display:flex><span>        val measureEnd: Z = n-count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we are making progress
</span></span><span style=display:flex><span>        //the amount of work decreases with each iteration
</span></span><span style=display:flex><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //we either have more work, or the loop will terminate
</span></span><span style=display:flex><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style=display:flex><span>        assert(measureEnd &gt; 0 || count == n)     //This holds now!
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return sum
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We could similarly use measures of work and manual assert statements to prove termination in some recursive functions. Here, we would demonstrate that a parameter value decreased with each recursive call, and that we either had more work to do or had reached the base case of our recursion (with no more recursive calls needed).</p><h2 id=collatz-function>Collatz function</h2><p>While it is possible to prove termination for certain kinds of programs &ndash; those that loop or make recursive calls a set number of times &ndash; it is not possible to prove termination for all programs.</p><p>Consider the <code>collatz</code> function below:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>// #Sireum #Logika
</span></span><span style=display:flex><span>//@Logika: --background save
</span></span><span style=display:flex><span>import org.sireum._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>def collatz(m: Z): Z = {
</span></span><span style=display:flex><span>    Contract(
</span></span><span style=display:flex><span>        Requires( m &gt; 0 ),
</span></span><span style=display:flex><span>        Ensures( Res[Z] == 1 )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var n: Z = m
</span></span><span style=display:flex><span>    while (n &gt; 1) {
</span></span><span style=display:flex><span>        Invariant(
</span></span><span style=display:flex><span>            Modifies( n ),
</span></span><span style=display:flex><span>            n &gt;= 1
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        if (n % 2 == 0) {
</span></span><span style=display:flex><span>            n = n / 2
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>            n = 3 * n + 1
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return n
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We see that we must pass <code>collatz</code> a positve parameter, and that it promises to return 1 (no matter what the parameter is). It contains a loop that repeatedly modifies a current value (which is initially the parameter value):</p><ul><li>If the current number is even, we divide the number by 2</li><li>If the current number is odd, we triple the number and add 1</li></ul><p>Suppose we compute <code>collatz(17)</code>. We can track the value of <code>n</code> as follows: 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. We can see that <code>n</code> does eventually reach 1, and that the program terminates in that case. We can similarly try other parameters, and will again see that we always end up with 1 (sometimes after a surprising number of iterations). But in fact:</p><ul><li>No one has proved that the Collatz function terminates for all positive numbers; and</li><li>No one has found a positive number on which the Collatz function does not terminate</li></ul><p>You may notice that part of the problem is that due to the nature of the problem, we cannot write a sufficient loop invariant describing what progress we have made towards our goal &ndash; our only loop invariant is nearly identical to our loop condition. In cases where we <em>can</em> write a loop invariant that adequately describes our progress, we often have enough information to prove termination as well.</p><h2 id=decidability-and-the-halting-problem>Decidability and the Halting problem</h2><p>It is an obvious question whether we could write a program to check whether another program always terminates. Unfortunately, this (the <em>Halting problem</em>) turns out to be impossible, as was demonstrated by Alan Turing. The Halting problem is an example of an <em>undecidable</em> problem in computer science &ndash; a decision problem (a problem with a yes/no answer) that we can&rsquo;t correctly answer one way or another on all inputs, even if we have unlimited resources.</p><footer class=footline></footer></article></div></main></div><script src=/cis301/js/clipboard/clipboard.min.js?1756154208 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1756154208 defer></script><script src=/cis301/js/theme.min.js?1756154208 defer></script><script src=/cis301/js/embed-iframe.min.js?1756154208 defer></script></body></html>