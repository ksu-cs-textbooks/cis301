<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="What is termination? In this section, we will consider the notion of termination â€“ whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions â€“ IF the functionâ€™s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Termination :: CIS 301 Textbook"><meta name=twitter:description content="What is termination? In this section, we will consider the notion of termination â€“ whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions â€“ IF the functionâ€™s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/10-chapter/10_6-termination/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Termination :: CIS 301 Textbook"><meta property="og:description" content="What is termination? In this section, we will consider the notion of termination â€“ whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions â€“ IF the functionâ€™s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Sequences, Globals, and Termination"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-05-02T14:41:22-05:00"><meta itemprop=name content="Termination :: CIS 301 Textbook"><meta itemprop=description content="What is termination? In this section, we will consider the notion of termination â€“ whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions â€“ IF the functionâ€™s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-05-02T14:41:22-05:00"><meta itemprop=wordCount content="1590"><title>Termination :: CIS 301 Textbook</title>
<link href=/cis301/10-chapter/10_6-termination/index.xml rel=alternate type=application/rss+xml title="Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/10_6-termination/index.print.html rel=alternate type=text/html title="Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/10_6-termination/tele.html rel=alternate type=text/html title="Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/10_6-termination/embed.html rel=alternate type=text/html title="Termination :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1736886193 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1736886193 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1736886193 rel=stylesheet><link href=/cis301/css/auto-complete.css?1736886193 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1736886193 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1736886193 rel=stylesheet><link href=/cis301/css/fonts.css?1736886193 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1736886193 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1736886193 rel=stylesheet><link href=/cis301/css/theme-auto.css?1736886193 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1736886193 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1736886193 rel=stylesheet><link href=/cis301/css/print.css?1736886193 rel=stylesheet media=print><script src=/cis301/js/variant.js?1736886193></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1736886193 rel=stylesheet></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=/cis301/10-chapter/10_6-termination/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#what-is-termination>What is termination?</a></li><li><a href=#partial-correctness-vs-total-correctness>Partial correctness vs total correctness</a><ul><li><a href=#example-of-partial-correctness>Example of partial correctness</a></li><li><a href=#total-correctness-definition>Total correctness definition</a></li></ul></li><li><a href=#process-of-proving-termination>Process of proving termination</a></li><li><a href=#termination-in-mult>Termination in mult</a></li><li><a href=#collatz-function>Collatz function</a></li><li><a href=#decidability-and-the-halting-problem>Decidability and the Halting problem</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/10-chapter/><span itemprop=name>Sequences, Globals, and Termination</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Termination</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/10-chapter/10_6-termination.md target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/10-chapter/10_6-termination/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/10-chapter/10_5-globals/ title="Global Variables (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><span class=topbar-control><i class="fa-fw fas fa-chevron-right"></i></span></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/10-chapter/10_6-termination/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=area-more data-width-l=area-more><a class=topbar-control href=/cis301/10-chapter/10_6-termination/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=termination>Termination</h1><h2 id=what-is-termination>What is termination?</h2><p>In this section, we will consider the notion of <em>termination</em> &ndash; whether a function will ever finish running.</p><h2 id=partial-correctness-vs-total-correctness>Partial correctness vs total correctness</h2><p>Up to this point, we have proved <em>partial correctness</em> for functions &ndash; IF the function&rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.</p><h3 id=example-of-partial-correctness>Example of partial correctness</h3><p>Consider the following version of our <code>mult</code> function, which uses repeated addition to multiply two numbers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == m * count
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + m
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  return sum
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>This function will be verified in Logika&rsquo;s auto mode, but in fact it has a subtle flaw. If we were to pass in <code>-1</code> for our second parameter (<code>n</code>), then we would get stuck in an infinite loop. <code>count</code> would be initially 0, and we would increment <code>count</code> each time in the loop, but of course it NEVER equal -1.</p><p>This is an example of partial correctness &ndash; if our function DOES finish (which it would for nonnegative values of <code>n</code>), then we have shown it will return the correct value. We can see that we will need to require that the <code>n</code> parameter be nonnegative .</p><h3 id=total-correctness-definition>Total correctness definition</h3><p><em>Total correctness</em> goes a step further than partial correctness &ndash; it says that IF the function&rsquo;s precondition holds, THEN we promise that it will terminate and that its postcondition will hold.</p><p>In order to show total correctness for our <code>mult</code> function, we must show that it always terminates.</p><h2 id=process-of-proving-termination>Process of proving termination</h2><p>We will see later in this section that the idea of termination is a much more challenging topic than it might seem. There is no button in Logika that will check for termination, but we can often insert manual assertions which, if they are verified, will guarantee termination. We will show how to create such manual assertions for simple loops that execute a set number of times.</p><p>First, we need to come up with a way to measure (as an integer) how much work the loop has left to do. Using this measure of work, we want to show two things:</p><ul><li>Each loop iteration decreases the integer measure (i.e., the amount of work left to do is strictly decreasing)</li><li>When our integer measure is 0 or less, then we are certain that we are done (i.e., the loop exits)</li></ul><h2 id=termination-in-mult>Termination in mult</h2><p>In our <code>mult</code> example, let&rsquo;s first try to establish an integer measure of work for the loop. We know that the loop is computing <code>m + m + ... + m</code>, for a total of <code>n</code> additions. When <code>count</code> is 0, we know we have <code>n</code> more additions to do (<code>n</code> more iterations of the loop). When <code>count</code> is 1, we know we have <code>n-1</code> more additions&mldr;and when <code>count</code> is <code>n</code>, we know that we have no more additions to do (and the loop ends). Our measure of work should be the number of additions left to do, which is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Measure of work: n - count</span></span></code></pre></div><p>We can calculate this measure at the beginning of each iteration and again at the end of each iteration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>while (count != n) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(sum, count),
</span></span><span class=line><span class=cl>        sum == m * count
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //get measure value at beginning of iteration
</span></span><span class=line><span class=cl>    val measureBegin: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + m
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //get measure value at end of iteration
</span></span><span class=line><span class=cl>    val measureEnd: Z = n-count
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Next, we want to assert that <code>measureEnd &lt; measureBegin</code> &ndash; that the amount of work decreases with each iteration. We can also assert that <code>measureEnd > 0 || count == n</code> &ndash; that either we have more work to do, or our loop condition is false (meaning that if we have no more work to do, then our loop condition must be false and thus terminate):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (n &gt;= 0),          //needed for termination
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == m * count
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at beginning of iteration
</span></span><span class=line><span class=cl>        val measureBegin: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        sum = sum + m
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at end of iteration
</span></span><span class=line><span class=cl>        val measureEnd: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we are making progress
</span></span><span class=line><span class=cl>        //the amount of work decreases with each iteration
</span></span><span class=line><span class=cl>        assert(measureEnd &lt; measureBegin)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we either have more work, or the loop will terminate
</span></span><span class=line><span class=cl>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span class=line><span class=cl>        assert(measureEnd &gt; 0 || count == n)     //NOTE: will not hold!
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>If we try verifying this program in Logika, the second assert, <code>assert(measureEnd > 0 || count == n)</code> will not hold. To see why, let&rsquo;s suppose that <code>measureEnd &lt;= 0</code>. For the assert to be true, we would need to be certain that <code>count == n</code> (since the left side of the OR would be false). Because <code>measureEnd = n-count</code>, we can infer that <code>count >= n</code> when <code>measureEnd &lt;= 0</code>. However, Logika is unable to infer that <code>count == n</code> from the knowledge that <code>count >= n</code> unless it also knows that <code>count &lt;= n</code> always holds. We can add this knowledge by strengthening our loop invariant to provide a range for the loop counter &ndash; <code>count >= 0</code> and <code>count &lt;= n</code>. Even if not required, it is a good habit anyway to include the loop counter range as part of the loop invariant.</p><p>We strengthen our loop invariant, and both asserts will hold &ndash; thus demonstrating termination:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (n &gt;= 0),          //needed for termination
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == m * count,
</span></span><span class=line><span class=cl>            0 &lt;= count,
</span></span><span class=line><span class=cl>            count &lt;= n
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at beginning of iteration
</span></span><span class=line><span class=cl>        val measureBegin: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        sum = sum + m
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at end of iteration
</span></span><span class=line><span class=cl>        val measureEnd: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we are making progress
</span></span><span class=line><span class=cl>        //the amount of work decreases with each iteration
</span></span><span class=line><span class=cl>        assert(measureEnd &lt; measureBegin)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we either have more work, or the loop will terminate
</span></span><span class=line><span class=cl>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span class=line><span class=cl>        assert(measureEnd &gt; 0 || count == n)     //This holds now!
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We could similarly use measures of work and manual assert statements to prove termination in some recursive functions. Here, we would demonstrate that a parameter value decreased with each recursive call, and that we either had more work to do or had reached the base case of our recursion (with no more recursive calls needed).</p><h2 id=collatz-function>Collatz function</h2><p>While it is possible to prove termination for certain kinds of programs &ndash; those that loop or make recursive calls a set number of times &ndash; it is not possible to prove termination for all programs.</p><p>Consider the <code>collatz</code> function below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def collatz(m: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires( m &gt; 0 ),
</span></span><span class=line><span class=cl>        Ensures( Res[Z] == 1 )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var n: Z = m
</span></span><span class=line><span class=cl>    while (n &gt; 1) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies( n ),
</span></span><span class=line><span class=cl>            n &gt;= 1
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if (n % 2 == 0) {
</span></span><span class=line><span class=cl>            n = n / 2
</span></span><span class=line><span class=cl>        } else {
</span></span><span class=line><span class=cl>            n = 3 * n + 1
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return n
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We see that we must pass <code>collatz</code> a positve parameter, and that it promises to return 1 (no matter what the parameter is). It contains a loop that repeatedly modifies a current value (which is initially the parameter value):</p><ul><li>If the current number is even, we divide the number by 2</li><li>If the current number is odd, we triple the number and add 1</li></ul><p>Suppose we compute <code>collatz(17)</code>. We can track the value of <code>n</code> as follows: 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. We can see that <code>n</code> does eventually reach 1, and that the program terminates in that case. We can similarly try other parameters, and will again see that we always end up with 1 (sometimes after a surprising number of iterations). But in fact:</p><ul><li>No one has proved that the Collatz function terminates for all positive numbers; and</li><li>No one has found a positive number on which the Collatz function does not terminate</li></ul><p>You may notice that part of the problem is that due to the nature of the problem, we cannot write a sufficient loop invariant describing what progress we have made towards our goal &ndash; our only loop invariant is nearly identical to our loop condition. In cases where we <em>can</em> write a loop invariant that adequately describes our progress, we often have enough information to prove termination as well.</p><h2 id=decidability-and-the-halting-problem>Decidability and the Halting problem</h2><p>It is an obvious question whether we could write a program to check whether another program always terminates. Unfortunately, this (the <em>Halting problem</em>) turns out to be impossible, as was demonstrated by Alan Turing. The Halting problem is an example of an <em>undecidable</em> problem in computer science &ndash; a decision problem (a problem with a yes/no answer) that we can&rsquo;t correctly answer one way or another on all inputs, even if we have unlimited resources.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/57869e279a37f6c3cf31c2a24f9b38ac04aea926>May 2, 2024</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search><script>var contentLangs=["en"]</script><script src=/cis301/js/auto-complete.js?1736886194 defer></script><script src=/cis301/js/lunr/lunr.min.js?1736886194 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1736886194 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1736886194 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1736886194 defer></script><script src=/cis301/js/search.js?1736886194 defer></script></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/><input type=checkbox id=R-section-4dd9ea2241609372e21522ad467bdbcf aria-controls=R-subsections-4dd9ea2241609372e21522ad467bdbcf><label for=R-section-4dd9ea2241609372e21522ad467bdbcf><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/><b>0. </b>Getting Started</a><ul id=R-subsections-4dd9ea2241609372e21522ad467bdbcf class="morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/><a class=padding href=/cis301/0-chapter/0_1-toolsguide/>0.1. Tools Guide</a></li></ul></li><li data-nav-id=/cis301/1-chapter/><input type=checkbox id=R-section-17929730d34290b059d2edff1c690239 aria-controls=R-subsections-17929730d34290b059d2edff1c690239><label for=R-section-17929730d34290b059d2edff1c690239><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-17929730d34290b059d2edff1c690239 class="morespace collapsible-menu"><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/><a class=padding href=/cis301/1-chapter/1_1-logicbasics/>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/><input type=checkbox id=R-section-97391a296e58f4aff54bb6b925a2776b aria-controls=R-subsections-97391a296e58f4aff54bb6b925a2776b><label for=R-section-97391a296e58f4aff54bb6b925a2776b><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/><b>2. </b>Truth Tables</a><ul id=R-subsections-97391a296e58f4aff54bb6b925a2776b class="morespace collapsible-menu"><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/><a class=padding href=/cis301/2-chapter/2_1-opscircuits/>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/><a class=padding href=/cis301/2-chapter/2_2-logikatruth/>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/><a class=padding href=/cis301/2-chapter/2_3-satis/>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/><a class=padding href=/cis301/2-chapter/2_5-sementail/>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/><input type=checkbox id=R-section-b4e2df8934a6b804e9336da7e38d4126 aria-controls=R-subsections-b4e2df8934a6b804e9336da7e38d4126><label for=R-section-b4e2df8934a6b804e9336da7e38d4126><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-b4e2df8934a6b804e9336da7e38d4126 class="morespace collapsible-menu"><li data-nav-id=/cis301/3-chapter/3_1-propatom/><a class=padding href=/cis301/3-chapter/3_1-propatom/>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/><a class=padding href=/cis301/3-chapter/3_2-notandor/>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/><a class=padding href=/cis301/3-chapter/3_3-implies/>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/><a class=padding href=/cis301/3-chapter/3_4-equiv/>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/><input type=checkbox id=R-section-619d3749907cd3e1af90a59cf2fcd6bd aria-controls=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd><label for=R-section-619d3749907cd3e1af90a59cf2fcd6bd><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-619d3749907cd3e1af90a59cf2fcd6bd class="morespace collapsible-menu"><li data-nav-id=/cis301/4-chapter/4_1-intro/><a class=padding href=/cis301/4-chapter/4_1-intro/>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/><a class=padding href=/cis301/4-chapter/4_2-andrules/>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/><a class=padding href=/cis301/4-chapter/4_3-orrules/>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/><a class=padding href=/cis301/4-chapter/4_4-impliesrules/>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/><a class=padding href=/cis301/4-chapter/4_5-notrules/>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/><a class=padding href=/cis301/4-chapter/4_6-strategies/>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/><a class=padding href=/cis301/4-chapter/4_7-theorems/>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/><a class=padding href=/cis301/4-chapter/4_8-equivalence/>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/><input type=checkbox id=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7 aria-controls=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7><label for=R-section-fbe0105598b5fc5de0d6a9a8eea1a2d7><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-fbe0105598b5fc5de0d6a9a8eea1a2d7 class="morespace collapsible-menu"><li data-nav-id=/cis301/5-chapter/5_1-motivation/><a class=padding href=/cis301/5-chapter/5_1-motivation/>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/><a class=padding href=/cis301/5-chapter/5_2-predsyntax/>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/><a class=padding href=/cis301/5-chapter/5_4-multquant/>5.4. Multiple Quantifiers</a></li></ul></li><li data-nav-id=/cis301/6-chapter/><input type=checkbox id=R-section-1afc7d1d7b98dcc397b91690230bcb55 aria-controls=R-subsections-1afc7d1d7b98dcc397b91690230bcb55><label for=R-section-1afc7d1d7b98dcc397b91690230bcb55><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-1afc7d1d7b98dcc397b91690230bcb55 class="morespace collapsible-menu"><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/><a class=padding href=/cis301/6-chapter/6_1-univrules/>6.1. Rules with âˆ€</a></li><li data-nav-id=/cis301/6-chapter/6_2-existrules/><a class=padding href=/cis301/6-chapter/6_2-existrules/>6.2. Rules with âˆƒ</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/><a class=padding href=/cis301/6-chapter/6_3-nested/>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/><a class=padding href=/cis301/6-chapter/6_4-equiv/>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/><a class=padding href=/cis301/6-chapter/6_5-strategies/>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/><input type=checkbox id=R-section-48461595e2f67d1468fbd78e51714428 aria-controls=R-subsections-48461595e2f67d1468fbd78e51714428><label for=R-section-48461595e2f67d1468fbd78e51714428><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/><b>7. </b>Mathematical Induction</a><ul id=R-subsections-48461595e2f67d1468fbd78e51714428 class="morespace collapsible-menu"><li data-nav-id=/cis301/7-chapter/7_1-process/><a class=padding href=/cis301/7-chapter/7_1-process/>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/><a class=padding href=/cis301/7-chapter/7_2-algebraex/>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/><a class=padding href=/cis301/7-chapter/7_3-divex/>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/><a class=padding href=/cis301/7-chapter/7_4-setex/>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/><input type=checkbox id=R-section-77afa9c6b199f7330fa5eb8966814b35 aria-controls=R-subsections-77afa9c6b199f7330fa5eb8966814b35><label for=R-section-77afa9c6b199f7330fa5eb8966814b35><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-77afa9c6b199f7330fa5eb8966814b35 class="morespace collapsible-menu"><li data-nav-id=/cis301/8-chapter/8_1-goal/><a class=padding href=/cis301/8-chapter/8_1-goal/>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/><a class=padding href=/cis301/8-chapter/8_3-assertassume/>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/><a class=padding href=/cis301/8-chapter/8_5-assignment/>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/><a class=padding href=/cis301/8-chapter/8_6-divmod/>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/><a class=padding href=/cis301/8-chapter/8_7-conditionals/>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/><input type=checkbox id=R-section-ffb46ad61395302deae4c4fa734e982a aria-controls=R-subsections-ffb46ad61395302deae4c4fa734e982a><label for=R-section-ffb46ad61395302deae4c4fa734e982a><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/><b>9. </b>Functions and Loops</a><ul id=R-subsections-ffb46ad61395302deae4c4fa734e982a class="morespace collapsible-menu"><li data-nav-id=/cis301/9-chapter/9_1-functions/><a class=padding href=/cis301/9-chapter/9_1-functions/>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/><a class=padding href=/cis301/9-chapter/9_2-recursion/>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/><a class=padding href=/cis301/9-chapter/9_3-loops/>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/><a class=padding href=/cis301/9-chapter/9_4-logikafacts/>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/><a class=padding href=/cis301/9-chapter/9_5-summary/>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/ class=parent><input type=checkbox id=R-section-9e1e97bcf82568ce724d247ecac0ed85 aria-controls=R-subsections-9e1e97bcf82568ce724d247ecac0ed85 checked><label for=R-section-9e1e97bcf82568ce724d247ecac0ed85><i class="fa-fw fas fa-chevron-down"></i><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-9e1e97bcf82568ce724d247ecac0ed85 class="morespace collapsible-menu"><li data-nav-id=/cis301/10-chapter/10_1-modes/><a class=padding href=/cis301/10-chapter/10_1-modes/>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/><a class=padding href=/cis301/10-chapter/10_2-intosequences/>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/><a class=padding href=/cis301/10-chapter/10_3-seqfn/>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/><a class=padding href=/cis301/10-chapter/10_4-seqloop/>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/><a class=padding href=/cis301/10-chapter/10_5-globals/>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/ class=active><a class=padding href=/cis301/10-chapter/10_6-termination/>10.6 Termination</a></li></ul></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Language</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-en value=#R-select-language-en data-url=/cis301/10-chapter/10_6-termination/ lang=en-us selected></option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class=footerVisitedLinks><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Clear History</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></div></aside><script src=/cis301/js/clipboard.min.js?1736886194 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1736886194 defer></script><script src=/cis301/js/theme.js?1736886194 defer></script></body></html>