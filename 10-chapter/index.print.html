<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="In our conclusion of programming logic, weâ€™ll examines programs with sequences and global variables. Weâ€™ll also learn the idea of termination in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sequences, Globals, and Termination :: CIS 301 Textbook"><meta name=twitter:description content="In our conclusion of programming logic, weâ€™ll examines programs with sequences and global variables. Weâ€™ll also learn the idea of termination in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/10-chapter/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Sequences, Globals, and Termination :: CIS 301 Textbook"><meta property="og:description" content="In our conclusion of programming logic, weâ€™ll examines programs with sequences and global variables. Weâ€™ll also learn the idea of termination in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Sequences, Globals, and Termination :: CIS 301 Textbook"><meta itemprop=description content="In our conclusion of programming logic, weâ€™ll examines programs with sequences and global variables. Weâ€™ll also learn the idea of termination in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem."><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2024-04-30T15:33:09-05:00"><meta itemprop=wordCount content="42"><title>Sequences, Globals, and Termination :: CIS 301 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis301/10-chapter/ rel=canonical type=text/html title="Sequences, Globals, and Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/index.xml rel=alternate type=application/rss+xml title="Sequences, Globals, and Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/tele.html rel=alternate type=text/html title="Sequences, Globals, and Termination :: CIS 301 Textbook"><link href=/cis301/10-chapter/embed.html rel=alternate type=text/html title="Sequences, Globals, and Termination :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1743605094 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1743605094 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1743605094 rel=stylesheet><link href=/cis301/css/auto-complete.css?1743605094 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1743605094 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1743605094 rel=stylesheet><link href=/cis301/css/fonts.css?1743605094 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1743605094 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1743605094 rel=stylesheet><link href=/cis301/css/theme-auto.css?1743605094 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1743605094 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1743605094 rel=stylesheet><link href=/cis301/css/print.css?1743605094 rel=stylesheet media=print><link href=/cis301/css/format-print.css?1743605094 rel=stylesheet><script src=/cis301/js/variant.js?1743605094></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1743605094 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis301/10-chapter/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Sequences, Globals, and Termination</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/9-chapter/9_5-summary/ title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/10-chapter/10_1-modes/ title="Logika Modes (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 10</div><h1 id=sequences-globals-and-termination>Sequences, Globals, and Termination</h1><p>In our conclusion of programming logic, we&rsquo;ll examines programs with sequences and global variables. We&rsquo;ll also learn the idea of <em>termination</em> in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Sequences, Globals, and Termination</h1><article class=default><header class=headline></header><h1 id=logika-modes>Logika Modes</h1><p>Logika has different modes for programming logic verification. We can switch between modes by going to File->Settings->Tools->Sireum->Logika.</p><h2 id=logikas-manual-mode>Logika&rsquo;s &ldquo;manual&rdquo; mode</h2><p>Up to now, we have been running Logika in &ldquo;manual mode&rdquo;, where we list the following settings at the beginning of a file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._</span></span></code></pre></div><p>We are now reaching the point where additional practice in manual mode may no longer be a learning activity, and where the proof blocks after claim transformations can become dozens of lines long.</p><h2 id=logikas-auto-mode>Logika&rsquo;s auto mode</h2><p>In Chapter 10, we will be switching to Logika&rsquo;s &ldquo;auto mode&rdquo;, where we remove the <code>--manual</code> from our file settings. We also no longer need the <code>org.sireum.justification._</code> library:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._</span></span></code></pre></div><p>Auto mode allows us to reason about our program by using ONLY invariants and function contracts. While the same work has to be done for a program to be verified (the precondition must be true before a function call, the loop invariant must be true before the loop begins, etc.), symexe mode does the work of analyzing your program statements to ensure that all parts of your loop invariant and function contract are satisfied. When you use symexe mode, you will only need to include a function contract for each function and a loop invariant block for each loop, and it will do the grunt work.</p><h3 id=multiplication-example>Multiplication example</h3><p>In section 9.3, we did a verification of a multiplication program using Logika&rsquo;s manual mode. Here is how we would write the verification of the same program using Logika&rsquo;s symexe mode:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(m &gt;= 0 &amp; n &gt;= 0),  //precondition: y should be nonnegative
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)    //postcondition (we promise to return x*y)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var r: Z = 0
</span></span><span class=line><span class=cl>    var i: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (i != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(r, i),
</span></span><span class=line><span class=cl>            r == m * i
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        r = r + m
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return r
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//////////// Test code //////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var one: Z = 3
</span></span><span class=line><span class=cl>var two: Z = 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var answer: Z = mult(one, two)
</span></span><span class=line><span class=cl>assert(answer == 12)</span></span></code></pre></div><p>Note that the only proof blocks we needed to provide were the function contract and the loop invariant block.</p><h3 id=pitfalls>Pitfalls</h3><p>When using this more advanced mode, it is not always obvious why Logika will not verify. Sometimes semantic errors in the program keep it from verifying; i.e. Logika has found a corner or edge case for which the program does not account. Other times the invariants and conditions do not actually help prove the goal in an assert or postcondition. Inevitably, sometimes it will be both.</p><p>In either case an option is to begin typing each proof-block as if in manual mode until you find the logical or programming error.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=intro-to-sequences>Intro to Sequences</h1><p><em>Sequences</em> in Logika are fairly similar to lists in Python and arrays in Java and C#. As with lists and arrays, Logika sequences are ordered. Each element is stored at a particular (zero-based) position, and there are no gaps in the sequence.</p><p>Logika can work with sequences of integers (type <code>ZS</code>).</p><h2 id=sequence-syntax>Sequence syntax</h2><p>We can create new sequence variables like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//creates the sequence (5, 10, 15)
</span></span><span class=line><span class=cl>var seq: ZS = ZS(5,10,15)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//creates an empty sequence of integers
</span></span><span class=line><span class=cl>var empty: ZS = ZS()</span></span></code></pre></div><p>Given the following sequence:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var a: ZS = ZS(1, 2, 3)</span></span></code></pre></div><p>Here is a table of the different sequence operations we will use in this course:</p><table><thead><tr><th>Operation</th><th>Explanation</th></tr></thead><tbody><tr><td>Indexing: <code>a(pos)</code></td><td>Accesses the value in the sequence at position <code>pos</code>.<br>Sequences are zero-based, and Logika will show an error if you have not proven (or if it cannot infer, in symexe mode) that the position lies within the sequence range.<br><br>For example, <code>a(0)</code> is 1.<br><code>a(0) = 11</code> would change the first value to be 11, so the sequence would be <code>(11,2,3)</code>.<br><code>a(3)</code> would give an error, as position 3 is past the end of the sequence.</td></tr><tr><td>Size: <code>a.size</code></td><td>Evaluates to the number of elements in the sequence: <code>a.size == 3</code></td></tr><tr><td>Reassignment</td><td>Sequences instantiated as <code>var</code> can be reassigned.<br><br>For example, after <code>a = ZS(5,6)</code>, <code>a</code> is now <code>(5,6)</code>.</td></tr></tbody></table><h2 id=sample-program-with-a-sequence>Sample program with a sequence</h2><p>Here is a sample program that uses a sequence. The <code>makeFirstZero</code> function sets the first element in a sequence to 0:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//&#34;Unit&#34; is like a void return type
</span></span><span class=line><span class=cl>def makeFirstZero(seq: ZS): Unit = {
</span></span><span class=line><span class=cl>    seq(0) = 0
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>///// Test code ///////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var nums: ZS = ZS(1,2,3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>makeFirstZero(nums)
</span></span><span class=line><span class=cl>assert(nums == ZS(0,2,3))</span></span></code></pre></div><p>This program will not be verified as we have not yet provided a function contract for <code>makeZeroFirst</code>. We will complete the verification for the program later in the section.</p><h2 id=predicate-logic-statements-with-sequences>Predicate logic statements with sequences</h2><p>When we write function contracts and loop invariants with sequences, we will need to make statements about <em>all</em> or <em>some</em> elements in a sequence. We can do this with predicate logic statements.</p><h3 id=statements-about-all-sequence-elements>Statements about all sequence elements</h3><p>As we did in chapters 4 and 5, we will use the universal (<code>âˆ€</code>) quantifier for statements involving all elements in a sequence. The basic forms of specifying some claim <code>P(a(x))</code> holds for every element in a sequence <code>a</code> are:</p><table><thead><tr><th>Statement</th><th>Explanation</th></tr></thead><tbody><tr><td><code>âˆ€ (lower to upper)(x => P(a(x)))</code></td><td><code>P(a(x))</code> holds for every element in <code>a</code> from position <code>lower</code> to position <code>upper</code> (including both <code>lower</code> and <code>upper</code>)</td></tr><tr><td><code>âˆ€ (lower until upper)(x => P(a(x)))</code></td><td><code>P(a(x))</code> holds for every element in <code>a</code> from position <code>lower</code> up to but not including position <code>upper</code> (<code>lower</code> but not <code>upper</code>)</td></tr></tbody></table><p>Here are several sample claims and explanations about integer sequence <code>a</code>:</p><table><thead><tr><th>Claim</th><th>Explanation</th></tr></thead><tbody><tr><td><code>âˆ€ (0 until a.size)(x => a(x) > 0)</code></td><td>Every element in <code>a</code> is greater than 0</td></tr><tr><td><code>âˆ€ (1 to 3)(x => a(x) == 0)</code></td><td>All elements in <code>a</code> between positions 1 and 3 (inclusive of 1 and 3) have value 0</td></tr><tr><td><code>âˆ€ (0 until a.size)(x => (a(x) &lt; 0 â†’ a(x) == -10)</code></td><td>All negative elements in <code>a</code> have value -10</td></tr></tbody></table><h3 id=statements-about-some-sequence-elements>Statements about some sequence elements</h3><p>We will use the existential (<code>âˆƒ</code>) quantifier for statements involving one or more elements in a sequence. The basic forms of specifying claims is the same as for the universal quantifier, but using the existential quantifier instead of the universal quantifier.</p><p>Here are several sample claims and explanations about integer sequences <code>a</code> and <code>b</code>:</p><table><thead><tr><th>Claim</th><th>Explanation</th></tr></thead><tbody><tr><td><code>âˆƒ (0 until a.size)(x => a(x) > 0)</code></td><td>There is an element in <code>a</code> that is greater than 0</td></tr><tr><td><code>âˆƒ (2 to 4)(x => a(x) == a(x-1) * 2)</code></td><td>There is an element in <code>a</code> between positions 2 and 4 (inclusive) that is twice as big as the previous element</td></tr><tr><td><code>âˆ€ (0 until a.size)(x => (âˆƒ (0 until b.size) (y => a(x) == b(y)))</code></td><td>Every value in <code>a</code> appears somewhere in <code>b</code></td></tr></tbody></table><h3 id=statements-about-initial-and-current-sequence-values>Statements about initial and current sequence values</h3><p>When we write preconditions, postconditions, and loop invariants involving sequences, we will want a way to distinguish between the INITIAL value a sequence had at the beginning of a function and the CURRENT value for that same sequence. We will use the notation <code>In(sequenceName)</code> to mean the value the sequence <code>sequenceName</code> had at the beginning of a function. In contrast, using just <code>sequenceName</code> refers to the value the sequence has right now (or, in the case of a postcondition, the value a sequence is promised to have at the end of a function).</p><p>For example, the postcondition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>âˆ€ (0 until a.size)(i =&gt; a(i) == In(a)(i) + 1</span></span></code></pre></div><p>Means that when the function ends, every value in the sequence <code>a</code> (so each element <code>a(i)</code>) will be one bigger than the initial value at the same position (<code>In(a)(i) + 1</code>).</p><h3 id=shortcut-to-describing-sequence-changes>Shortcut to describing sequence changes</h3><p>Occasionally we wish to claim that a sequence is unchanged except for a handful of positions. We can do this in a more pedantic way by describing which elements have changed and which elements have not changed, but there is also a cleaner sequence update notation we can use instead.</p><p>For example, these postconditions state that a function sets the first element (position 0) in sequence a to 10, but leaves every other element unchanged:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>a(0) == 10,
</span></span><span class=line><span class=cl>âˆ€ (1 until a.size)(x =&gt; (a(x) == In(a)(x)))</span></span></code></pre></div><p>We could have described the same set of changes using the sequence update notation as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>a â‰¡ In(a)(0 ~&gt; 10)</span></span></code></pre></div><p>The statement above says that the resulting value of sequence <code>a</code> is equivalent to the initial value of sequence <code>a</code> (<code>In(a)</code>) except that position <code>0</code> now holds a <code>10</code>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sequences-in-functions>Sequences in Functions</h1><p>Sequences in Scala are passed to functions by reference. This means that if a function makes changes to a sequence parameter, then it will also change whatever sequence object was passed to the function. For example, the test code below passes <code>nums</code>, which has the value <code>ZS(1,2,3)</code>, to the <code>makeFirstZero</code> function. The <code>makeFirstZero</code> function changes the first position in its parameter (<code>seq</code>) to be 0, which means that the <code>nums</code> sequence in the test code will also have its first position set to 0 (making it have the value <code>ZS(0,2,3)</code>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def makeFirstZero(seq: ZS): Unit = {  // Unit is like void in Java and C#
</span></span><span class=line><span class=cl>    seq(0) = 0
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>///////////// Test code /////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var nums: ZS = ZS(1,2,3)
</span></span><span class=line><span class=cl>makeFirstZero(nums)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(nums == ZS(0,2,3))</span></span></code></pre></div><h2 id=preconditions-with-sequences>Preconditions with sequences</h2><p>When writing the precondition for a function that takes a sequence parameter, we must consider whether our function will only work correctly for particular sequence values or sizes. For example, our <code>makeFirstZero</code> function will not work if the size of the <code>seq</code> parameter is zero. We would need to add this requirement to the function&rsquo;s precondition (to its <code>Requires</code> clause):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>seq.size &gt; 0</span></span></code></pre></div><p>If we wanted to require that all values in a sequence parameter (say, <code>nums</code>) be between 10 and 20, we would add the following to the precondition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>âˆ€ (0 until nums.size)(x =&gt; (nums(x) &gt;= 10 âˆ§ nums(x) &lt;= 20))</span></span></code></pre></div><p>Sometimes, functions with sequence parameters will work for any size/values &ndash; in those cases, we don&rsquo;t need to list anything about the sequence in the precondition.</p><h2 id=function-modifies-clause>Function <code>Modifies</code> clause</h2><p>We learned in chapter 9 that the format of a function contract is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Contract(
</span></span><span class=line><span class=cl>    Requires (  preconditions   ),
</span></span><span class=line><span class=cl>    Ensures (   postconditions  )
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>However, there is actually a third portion of the function contract that we have ommitted until this point &ndash; the <code>Modifies</code> clause. This clause is required whenever a function changes the values in a sequence parameter or changes global variables. For example, the <code>makeFirstZero</code> function DOES change its sequence parameter, <code>seq</code>, as it sets its first position to 0. <code>makeFirstZero</code> should therefore include this <code>Modifies</code> clause:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Modifies ( seq ),</span></span></code></pre></div><p>This clause goes between the precondition (<code>Requires</code>) and the postcondition (<code>Ensures</code>), making the new template for the function contract look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Contract(
</span></span><span class=line><span class=cl>    Requires (  preconditions   ),
</span></span><span class=line><span class=cl>    Modifies (  comma-separated list of sequences/global variables modified by the function ),
</span></span><span class=line><span class=cl>    Ensures (   postconditions  )
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>If the function modifies more than one sequence or global variable, they are listed together in a comma-separated list in the <code>Modifies</code> clause.</p><h2 id=postconditions-with-sequences>Postconditions with sequences</h2><p>When writing the postcondition for a function that uses a sequence parameter, we must consider two things:</p><ul><li>How the return value relates to the sequence</li><li>How the function will change the sequence</li></ul><h3 id=relating-return-values-to-sequence-elements>Relating return values to sequence elements</h3><p>We will still use the <code>Res[Type]</code> keyword for describing the function&rsquo;s return value in the postcondition. For example, if a function was returning the smallest value in the integer sequence <code>nums</code>, we would say:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Ensures(
</span></span><span class=line><span class=cl>    âˆ€ (0 until nums.size)(x =&gt; (Res[Z] &lt;= nums(x))),
</span></span><span class=line><span class=cl>    âˆƒ (0 until nums.size)(x =&gt; (Res[Z] == nums(x)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Here, the first postcondition states that our return value will be less than or equal to every value in the sequence, and the second postcondition states that our return value is one of the sequence elements. (The second postcondition prevents us from sneakily returning some negative number and claiming that it was the smallest element in the sequence, when in fact it wasn&rsquo;t one of the sequence elements.)</p><p>Sometimes, our postconditions will promise to return a particular value if some claim about the sequence is true. Suppose we have a function that returns whether or not (i.e., a boolean) all elements in the sequence <code>a</code> are negative. Our postcondition would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Ensures(
</span></span><span class=line><span class=cl>    ( âˆ€ (0 until a.size)(x =&gt; (a(x) &lt; 0)) ) â†’ (result == true),
</span></span><span class=line><span class=cl>    ( âˆƒ (0 until a.size)(x =&gt; (a(x) &gt;= 0)) ) â†’ (result == false),
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Here, the first postcondition promises that if all sequence elements are negative, then the function will return true. The second postcondition promises the opposite &ndash; that if there is a nonnegative sequence element, then the function will return false.</p><h3 id=describing-how-the-function-changes-the-sequence>Describing how the function changes the sequence</h3><p>Consider again the <code>makeFirstZero</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def makeFirstZero(seq: ZS): Unit = {
</span></span><span class=line><span class=cl>    seq(0) = 0
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>This function doesn&rsquo;t return anything (hence the <code>Unit</code> return type), but we do need to describe what impact calling this function will have on the sequence. We can partially accomplish our goal with this postcondition (in our <code>Ensures</code> clause):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>seq(0) == 0</span></span></code></pre></div><p>Which promises that after the function ends, the first value in the sequence will be 0. However, suppose we wrote this instead for the <code>makeFirstZero</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def makeFirstZero(seq: ZS): Unit = {
</span></span><span class=line><span class=cl>    seq(0) = 0
</span></span><span class=line><span class=cl>    seq(1) = 100
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>This version of the function DOES satisfy the postcondition &ndash; the first element is indeed set to 0 &ndash; but it changes other elements, too. The postcondition should be descriptive enough that anyone calling it can be certain EXACTLY what every single value in the sequence will be afterwards. Our postcondition needs to describe exactly what values in the sequence WILL change and exactly what values WON&rsquo;T change.</p><p>This means that our <code>makeFirstZero</code> function needs to state that the first element in <code>seq</code> gets set to 0, and that every other value in the sequence <em>stays the same as its original value</em>. To help us describe the <em>original value</em> of a sequence, we can use the special <code>In(sequenceName)</code> syntax, which holds the value of a sequence parameter <code>sequenceName</code> at the time the function was called. (This <code>In</code> syntax can only be used in logic blocks, not in the code.)</p><p>We can specify exactly what happens to each sequence element in our first version of <code>makeFirstZero</code> like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Ensures(
</span></span><span class=line><span class=cl>    seq(0) == 0,
</span></span><span class=line><span class=cl>    âˆ€ (1 until seq.size)(x =&gt; ( seq(x) == In(seq)(x)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>The second postcondition says: &ldquo;All elements from position 1 on keep their original values&rdquo;.</p><h2 id=example-finished-makefirstzero-verification>Example: finished <code>makeFirstZero</code> verification</h2><p>Now that we have seen all the pieces of writing function contracts for functions that work with sequences, we can put together the full function contract for our <code>makeFirstZero</code> function. The assert statement in the test code will be verified by Logika&rsquo;s auto mode:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def makeFirstZero(seq: ZS): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(  seq.size &gt; 0  ),
</span></span><span class=line><span class=cl>        Modifies(  seq  ), 
</span></span><span class=line><span class=cl>        Ensures(
</span></span><span class=line><span class=cl>        seq(0) == 0,
</span></span><span class=line><span class=cl>        âˆ€ (1 until seq.size)(x =&gt; ( seq(x) == In(seq)(x)))
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    seq(0) = 0
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//////////////// Test code //////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var nums: ZS = ZS(1,2,3)
</span></span><span class=line><span class=cl>makeFirstZero(nums)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(nums == ZS(0,2,3))</span></span></code></pre></div><h2 id=example-swap-program>Example: swap program</h2><p>Suppose we have the following swap program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def swap(list: ZS, pos1: Z, pos2: Z): Unit = {
</span></span><span class=line><span class=cl>    val temp: Z = list(pos1)
</span></span><span class=line><span class=cl>    list(pos1) = list(pos2)
</span></span><span class=line><span class=cl>    list(pos2) = temp
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>///////////// Test code ///////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var testList: ZS = ZS(1,2,3,4)
</span></span><span class=line><span class=cl>swap(testList,0,3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//the values in positions 0 and 3 should be swapped
</span></span><span class=line><span class=cl>//all other elements should be the same
</span></span><span class=line><span class=cl>assert(testList == ZS(4,2,3,1))</span></span></code></pre></div><p>Here, <code>swap</code> takes an integer sequence (<code>list</code>) and two positions (<code>pos1</code> and <code>pos2</code>). It uses a temp variable to swap the values in <code>list</code> at <code>pos1</code> and <code>pos2</code>. We would like to write an appropriate function contract so the assert statement in the test code holds.</p><p>We must first consider the precondition &ndash; does <code>swap</code> have any requirements about its parameters? Since <code>swap</code> uses <code>pos1</code> and <code>pos2</code> as positions within <code>list</code>, we can see that <code>swap</code> will crash if either position is out of bounds &ndash; either negative or past the end of the sequence.</p><p>The function is changing the sequence, so we will need a <code>Modifies</code> clause. Finally, we must consider the postcondition. This function isn&rsquo;t returning a value, but it is changing the sequence &ndash; so we should describe exactly what values HAVE changed (and their new values) and what values have NOT changed. We want to say that:</p><ul><li><code>list(pos1)</code> has the value that was originally at <code>list(pos2)</code> (i.e, the value at <code>In(list)(pos2)</code>)</li><li><code>list(pos2)</code> has the value that was originally at <code>list(pos1)</code> (i.e, the value at <code>In(list)(pos1)</code>)</li><li>All other positions are unchanged (i.e., they are the same as they were in <code>In(list)</code>)</li><li>The size doesn&rsquo;t change (which we must always list if a sequence is modified)</li></ul><p>We can now complete the function contract for <code>swap</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def swap(list: ZS, pos1: Z, pos2: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(
</span></span><span class=line><span class=cl>            0 &lt;= pos1 &amp; pos1 &lt; list.size, // pos1 is a valid index
</span></span><span class=line><span class=cl>            0 &lt;= pos2 &amp; pos2 &lt; list.size  // pos2 is a valid index
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        Modifies(list),           // documents list is modified
</span></span><span class=line><span class=cl>        Ensures(
</span></span><span class=line><span class=cl>            list(pos1) == In(list)(pos2),
</span></span><span class=line><span class=cl>            list(pos2) == In(list)(pos1),
</span></span><span class=line><span class=cl>            list.size == In(list).size,
</span></span><span class=line><span class=cl>            âˆ€ (0 until list.size)(x =&gt; (x != pos1 &amp; x != pos2 â†’ list(x) == In(list)(x)))
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  val temp: Z = list(pos1)
</span></span><span class=line><span class=cl>  list(pos1) = list(pos2)
</span></span><span class=line><span class=cl>  list(pos2) = temp
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//////////////// Test code //////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var testList: ZS = ZS(1,2,3,4)
</span></span><span class=line><span class=cl>swap(testList,0,3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(testList == ZS(4,2,3,1))</span></span></code></pre></div><p>If we test this program in Logika&rsquo;s symexe mode, the final assert will hold &ndash; we have enough information to make a claim about EXACTLY what the sequence will look like after calling <code>swap</code>.</p><p>Note that we could have simplified the postcondition by using the <em>sequence update notation</em> described at the end of section 10.2. We want to say that the value of <code>list</code> at the end of the function is equivalent to the value of list at the beginning of the function (<code>In(list)</code>) with the following exceptions:</p><ul><li>The new value at <code>pos1</code> should be the original value at <code>pos2</code> (<code>In(list)(pos2)</code>)</li><li>The new value at <code>pos2</code> should be the original value at <code>pos1</code> (<code>In(list)(pos1)</code>)</li></ul><p>Here is the equivalent (but shorter) postcondition for <code>swap</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Ensures(
</span></span><span class=line><span class=cl>    list â‰¡ In(list)(pos1 ~&gt; In(list)(pos2), pos2 ~&gt; In(list)(pos1))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sequences-in-loops>Sequences in Loops</h1><p>We also must consider sequences when writing loop invariants. Typically, we must include the following in our invariant:</p><ul><li>If the sequence changes in the loop<ul><li>Describe what sequence elements have already changed in the loop (and what their new values are)</li><li>Describe what sequence elements still have their original value</li><li>Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence)</li><li>State that the sequence size does not change (to reinforce that the variable used as the sequence position will not go out of bounds)</li><li>List the sequence along with other changing variables in the loop invariant block&rsquo;s <code>Modifies</code> clause</li></ul></li><li>If the sequence does not change in the loop<ul><li>Consider what we are doing with each sequence element as we look at them. Usually we have another variable that is storing our progress (and often, this variable is returned from the function after the loop). Express how the variable&rsquo;s value relates to the part of the sequence we&rsquo;ve looked at so far &ndash; this statement should look very similar to your postcondition, but should only describe part of the sequence.</li><li>Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence)</li></ul></li></ul><h2 id=example-add-one-to-all-program>Example: add one to all program</h2><p>Suppose we have the following program, which adds one to every element in a sequence parameter:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def addOne(list: ZS): Unit = {
</span></span><span class=line><span class=cl>    var i: Z = 0
</span></span><span class=line><span class=cl>    while (i &lt; list.size) {
</span></span><span class=line><span class=cl>        list(i) = list(i) + 1
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////////////// Calling code ///////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var test: ZS = ZS(1,2,3,4)
</span></span><span class=line><span class=cl>addOne(test)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(test == ZS(2,3,4,5))</span></span></code></pre></div><p>We would like to write an appropriate function contract and loop invariant block so the assert statement in the test code holds (which asserts that the sequence <code>ZS(1,2,3,4)</code> becomes the sequence <code>ZS(2,3,4,5)</code> after calling the function).</p><p>For the function contract, we must consider:</p><ul><li><em>Precondition</em>: this function will work correctly on all sequences &ndash; even empty ones. We can leave the <code>Requires</code> clause off.</li><li><code>Modifies</code> clause: this function is changing the <code>list</code> sequence parameter, so we must list it in a <code>modifies</code> clause.</li><li><em>Postcondition</em>: the function is not returning anything, but we must describe that all sequence parameters will be one bigger than their original values.</li></ul><p>For the loop invariant block, we notice that the loop is changing the sequence. We must include:</p><ul><li><em>Which elements have already changed</em>. Since <code>i</code> is tracking our position in the sequence, we know that at the end of each iteration, all elements from position 0 up to but not including position <code>i</code> have been changed to be one bigger than their original values.</li><li><em>Which elements have not changed</em>. All other elements in the sequence &ndash; from position <code>i</code> to the end of the sequence &ndash; still have their original values</li><li><em>Upper and lower bounds for position variables</em>. Since <code>i</code> is tracking our position, we must state that i is always a valid sequence index. Here, we need to claim that <code>i</code> will always be greater than or equal to 0 and less than or equal to the sequence size. (While the sequence size itself is not a valid sequence index, we see from looking at the loop that <code>i</code> is incrementing as the very last step in the loop. On the last iteration, <code>i</code> will start off at <code>list.size-1</code>, and we will correctly access and modify the last element in <code>list</code>. Then we will increment <code>i</code>, making it EQUAL <code>list.size</code> &ndash; at that point, the loop ends. If we made part of our invariant be <code>i &lt; list.size</code>, it would be incorrect because of that last iteration.)</li><li><em>State that the sequence size does not change</em>. This is necessary any time we are writing a loop modifying a sequence in order to ensure that the sequence index (<code>i</code> in this case) will not go past the end of the sequence.</li></ul><p>We can now complete the function contract and loop invariant for <code>addOne</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def addOne(list: ZS): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Modifies(list),
</span></span><span class=line><span class=cl>        Ensures(
</span></span><span class=line><span class=cl>            âˆ€ (0 until list.size)(x =&gt; (list(x) == In(list)(x) + 1))
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var i: Z = 0
</span></span><span class=line><span class=cl>    while (i &lt; list.size) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(i, list),
</span></span><span class=line><span class=cl>            i &gt;= 0,
</span></span><span class=line><span class=cl>            i &lt;= list.size,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>             //the sequence size never changes
</span></span><span class=line><span class=cl>            list.size == In(list).size,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>             //what I HAVE changed
</span></span><span class=line><span class=cl>            âˆ€ (0 until i)(x =&gt; (list(x) == In(list)(x) + 1)),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>             //what I HAVEN&#39;T changed
</span></span><span class=line><span class=cl>            âˆ€ (i until list.size)(x =&gt; (list(x) == In(list)(x)))
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        list(i) = list(i) + 1
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////////////// Calling code ///////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var test: ZS = ZS(1,2,3,4)
</span></span><span class=line><span class=cl>addOne(test)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(test == ZS(2,3,4,5))</span></span></code></pre></div><p>If we try to verify this program in Logika&rsquo;s auto mode, the final assert will hold &ndash; we have enough information to know what the sequence will look like after calling <code>addOne</code>.</p><h2 id=example-min-program>Example: min program</h2><p>In our next example, we examine a function that does <em>not</em> modify its sequence parameter, and that <em>does</em> return a value. Consider the following <code>min</code> function and test code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//return the smallest element in list
</span></span><span class=line><span class=cl>def min(list: ZS): Z = {
</span></span><span class=line><span class=cl>    var small: Z = list(0)
</span></span><span class=line><span class=cl>    var i: Z = 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (i &lt; list.size) {
</span></span><span class=line><span class=cl>        if (list(i) &lt; small) {
</span></span><span class=line><span class=cl>            small = list(i)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return small
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////////////// Calling code ///////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var test: ZS = ZS(8,1,0,10,9,2,0)
</span></span><span class=line><span class=cl>var testMin: Z = min(test)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(testMin == 0)</span></span></code></pre></div><p>Here, our <code>min</code> function is supposed to find and return the smallest value in an integer sequence. We can see that our test code passes <code>min</code> the sequence (<code>ZS(8,1,0,10,9,2,0)</code>), and that we are trying to assert that <code>min</code> correctly returns <code>0</code> as the smallest value in the sequence. We need to add an appropriate function contract and loop invariant block to make this assert hold.</p><p>For the function contract, we must consider:</p><ul><li><em>Precondition</em>: this function starts by saving out the element at position 0. If the sequence was empty, the function would crash. We need to require that the sequence size be at least 1.</li><li><code>Modifies</code> clause: this function is NOT modifying its sequence parameter, so we can omit this clause</li><li><em>Postcondition</em>: the function is not changing the sequence, so we do not need to describe the final values of each sequence element. We <em>do</em> need to describe what value we are returning, and how it relates to the sequence. We want to describe that <code>Res[Z]</code> (our return value) is the smallest integer in <code>list</code>, so that:<ul><li><code>Res[Z]</code> is less than or equal to every element in <code>list</code></li><li>There is an element in <code>list</code> that equals <code>Res[Z]</code> (i.e., we really are returning one of our sequence values)</li></ul></li></ul><p>For the loop invariant block, we notice that the loop is NOT changing the sequence. We must include:</p><ul><li><em>What we are doing with each sequence element, and how that relates to another variable</em>. We can see that <code>small</code> tracks the smallest element we&rsquo;ve seen in the sequence so far &ndash; up to but not including position <code>i</code>. Similar to the postcondition, we want to claim that:<ul><li><code>small</code> is less than or equal to every element in <code>list</code> <em>that we have seen so far</em></li><li>There is an element <em>we have already seen</em> in <code>list</code> that equals small</li></ul></li><li><em>Upper and lower bounds for position variables</em>. Here, <code>i</code> is our position variable. We see that it is initialized to 1, so we will claim that it is always greater than or equal to 1 and less than or equal to the list size.</li><li><code>Modifies</code> clause - the variables <code>small</code> and <code>i</code> are modified in the while loop</li></ul><p>We can now complete the function contract and loop invariant for <code>min</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def min(list: ZS): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (list.size &gt;= 1),
</span></span><span class=line><span class=cl>        Ensures(
</span></span><span class=line><span class=cl>            âˆ€ (0 until list.size)(x =&gt; (Res[Z] &lt;= list(x))),
</span></span><span class=line><span class=cl>            âˆƒ (0 until list.size)(x =&gt; (Res[Z] == list(x)))
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var small: Z = list(0)
</span></span><span class=line><span class=cl>    var i: Z = 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (i &lt; list.size) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(i, small),
</span></span><span class=line><span class=cl>            i &gt;= 1,
</span></span><span class=line><span class=cl>            i &lt;= list.size,
</span></span><span class=line><span class=cl>            âˆ€ (0 until i)(x =&gt; (small &lt;= list(x))),
</span></span><span class=line><span class=cl>            âˆƒ (0 until i)(x =&gt; (small == list(x)))
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if (list(i) &lt; small) {
</span></span><span class=line><span class=cl>            small = list(i)
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        i = i + 1
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return small
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>////////////// Calling code ///////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var test: ZS = ZS(8,1,0,10,9,2,0)
</span></span><span class=line><span class=cl>var testMin: Z = min(test)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>assert(testMin == 0)</span></span></code></pre></div><p>If we try to verify this program in Logika&rsquo;s auto mode, the final assert will hold &ndash; we have enough information to know exactly the minimum value in <code>test</code>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=global-variables>Global Variables</h1><h2 id=motivation>Motivation</h2><p>We will now consider programs with multiple functions that modify a shared pool of <em>global variables</em>. (This is very similar to the concerns in general classes in Java or C#, where multiple methods might edit fields/property values for an object). We want to be sure that global variables will maintain desired ranges and relationships between one another, even as multiple functions modify their values.</p><h2 id=global-variables-in-logika>Global variables in Logika</h2><p>A global variable exists before any function call, and still exists after any function ends.</p><h3 id=functions-that-access-global-variables>Functions that access global variables</h3><p>Consider the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//global variable
</span></span><span class=line><span class=cl>var feetPerMile: Z = 5280  // feet in a mile mile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def convertToFeet(m : Z): Z = {
</span></span><span class=line><span class=cl>    val feet: Z = m * feetPerMile
</span></span><span class=line><span class=cl>    return feet
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/////////// Calling code ////////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var miles: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var totalFeet: Z = 0
</span></span><span class=line><span class=cl>if (miles &gt;= 0){
</span></span><span class=line><span class=cl>    totalFeet = convertToFeet(miles)
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Here, <code>feetPerMile</code> is a global variable &ndash; it exists before the <code>convertToFeet</code> function is called, and still exists after <code>convertToFeet</code> ends. In contrast, the <code>feet</code> variable inside <code>convertToFeet</code> is NOT global &ndash; its scope ends when the <code>convertToFeet</code> function returns.</p><p>(The <code>miles</code> and <code>totalFeet</code> variables in the calling code do not behave as global variables, as they were declared after any function definition. However, if we did add additional functions after our calling code, then <code>miles</code> and <code>totalFeet</code> would be global to those later functions. In Logika, the scope for any variable declared outside of a function begins at the point in the code where it is declared.)</p><p>In the example above, <code>convertToFeet</code> only accesses the <code>feetPerMile</code> global variable. A global variable that is read (but not updated) by a function body can be safely used in the functions precondition and postcondition &ndash; it acts just like an extra parameter to the function. We might edit <code>convertToFeet</code> to have this function contract:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//global variable
</span></span><span class=line><span class=cl>var feetPerMile: Z = 5280  // feet in a mile mile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def convertToFeet(m : Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        Requires (
</span></span><span class=line><span class=cl>            m &gt;= 0,             //only do conversions on nonnegative distances
</span></span><span class=line><span class=cl>            feetPerMile &gt; 5200  //not needed, but demonstrates using global variables in preconditions
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //can use global variable in postcondition
</span></span><span class=line><span class=cl>        Ensures (Res[Z]== m * feetPerMile)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    val feet: Z = m * feetPerMile
</span></span><span class=line><span class=cl>    return feet
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/////////// Calling code ////////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var miles: Z = Z.read()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var totalFeet: Z = 0
</span></span><span class=line><span class=cl>if (miles &gt;= 0){
</span></span><span class=line><span class=cl>    totalFeet = convertToFeet(miles)
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>However, we cannot assign to a global variable the result of calling a function. That is, <code>totalFeet = convertToFeet(5)</code> is ok, and so is <code>totalFeet = convertToFeet(feetPerMile)</code>, but <code>feetPerMile = convertToFeet(5)</code> is not.</p><h3 id=functions-that-modify-global-variables>Functions that modify global variables</h3><p>Every global variable that is modified by a function must be listed in that function&rsquo;s <code>Modifies</code> clause. Such functions must also describe in their postconditions how these global variables will be changed by the function from their original (pre-function call) values. We will use the notation <code>In(globalVariableName)</code> for the value of global variable <code>globalVariableName</code> at the start of the function, just as we did for sequences.</p><p>Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//global variable
</span></span><span class=line><span class=cl>var time: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def tick(): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires(time &gt; 0),
</span></span><span class=line><span class=cl>        Modifies (time),
</span></span><span class=line><span class=cl>        Ensures (time == In(time) + 1)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    time = time + 1
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Here, we have a global <code>time</code> variable and a <code>tick</code> function that increases the time by 1 with each function call. Since the <code>tick</code> function changes the <code>time</code> global variable, we must include two things in its function contract:</p><ul><li>A <code>Modifies</code> clause that lists <code>time</code> as one of the global variables modified by this function</li><li>A postcondition that describes how the value of <code>time</code> after the function call compares to the value of <code>time</code> just before the function call. The statement <code>time == In(time) + 1</code> means: &ldquo;the value of time after the function call equals the value of time just before the function call, plus one&rdquo;.</li></ul><h2 id=global-invariants>Global invariants</h2><p>When we have a program with global variables that are modified by multiple functions, we often want some way to ensure that the global variables always stay within a desired range, or always maintain a particular relationship among each other. We can accomplish these goals with <em>global invariants</em>, which specify what must always be true about global variables.</p><h3 id=bank-example>Bank example</h3><p>For example, consider the following partial program that represents a bank account:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//global variables
</span></span><span class=line><span class=cl>var balance: Z = 0
</span></span><span class=line><span class=cl>var elite: B = false
</span></span><span class=line><span class=cl>val eliteMin: Z = 1000000 //$1M is the minimum balance for elite status
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//global invariants
</span></span><span class=line><span class=cl>@spec def inv = Invariant(  
</span></span><span class=line><span class=cl>    balance &gt;= 0,                   //balance should be non-negative
</span></span><span class=line><span class=cl>    elite == (balance &gt;= eliteMin)  //elite status should reflect if balance is at least a million
</span></span><span class=line><span class=cl>)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def deposit(amount: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        //We still need to complete the function contract
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    balance = balance + amount
</span></span><span class=line><span class=cl>    if (balance &gt;= eliteMin) {
</span></span><span class=line><span class=cl>        elite = true
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        elite = false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def withdraw(amount: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        //We still need to complete the function contract
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    balance = balance - amount
</span></span><span class=line><span class=cl>    if (balance &gt;= eliteMin) {
</span></span><span class=line><span class=cl>        elite = true
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        elite = false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Here, we have three global variables: <code>balance</code> (the bank account balance), <code>elite</code> (whether or not the customer has &ldquo;elite status&rdquo; with the bank, which is given to customers maintaining above a certain balance threshold), and <code>eliteMin</code> (a value representing the minimum account balance to achieve elite status). We have two global invariants describing what must always be true about these global variables:</p><ul><li><code>balance >= 0</code>, which states that the account balance must never be negative</li><li><code>elite == (balance >= eliteMin)</code>, which states that the <code>elite</code> boolean flag should always accurately represent whether the customer&rsquo;s current account balance is over the minimum threshold for elite status</li></ul><h3 id=global-invariants-must-hold-before-each-function-call>Global invariants must hold before each function call</h3><p>In any program with global invariants, we either must prove (in manual mode) or there must be sufficient evidence (in auto mode) that each global invariant holds immediately before any function call (including when the program first begins, before any function call). In our bank example, we see that the global variables are initialized as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>var balance: Z = 0
</span></span><span class=line><span class=cl>var elite: B = false
</span></span><span class=line><span class=cl>val eliteMin: Z = 1000000</span></span></code></pre></div><p>In auto mode, there is clearly enough evidence that the global invariants all hold with those initial values &ndash; the balance is nonnegative, and the customer correctly does not have elite status (because they do not have about the $1,000,000 threshold).</p><h3 id=global-invariants-must-still-hold-at-the-end-of-each-function-call>Global invariants must still hold at the end of each function call</h3><p>Since we must demonstrate that global invariants hold before each function call, functions themselves can assume the global invariants are true at the beginning of the function. If we were using manual mode, we could list each global invariant as a <code>Premise</code> at the beginning of the function &ndash; much like we do with preconditions. Then, it is the job of each function to ensure that the global invariants STILL hold when the function ends. In manual mode, we would need to demonstrate that each global invariant claim <code>globalInvariant</code> still held in a logic block just before the end of the function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Deduce(
</span></span><span class=line><span class=cl>    //each global invariant must still hold at the end of the function
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    1 ( globalInvariant )   by SomeJustification 
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>In auto mode, we do not need to include such logic blocks, but there must be sufficient detail in the function contract to infer that each global invariant will hold no matter what at the end of the function.</p><h3 id=bank-function-contracts>Bank function contracts</h3><p>Consider the <code>deposit</code> function in our bank example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def deposit(amount: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        //We still need to complete the function contract
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    balance = balance + amount
</span></span><span class=line><span class=cl>    if (balance &gt;= eliteMin) {
</span></span><span class=line><span class=cl>        elite = true
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        elite = false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Since <code>deposit</code> is modifying the global variables <code>balance</code> and <code>elite</code>, we know we must include two things in its function contract:</p><ul><li>A <code>Modifies</code> clause that lists <code>balance</code> and <code>elite</code> as global variables modified by this function</li><li>A postcondition that describes how the value of <code>balance</code> after the function call compares to the value of <code>balance</code> just before the function call. We want to say, <code>balance == In(balance) + amount</code>, because the value of <code>balance</code> at the end of the function equals the value of <code>balance</code> at the beginning of the function, plus <code>amount</code>.</li></ul><p>We also must consider how the <code>elite</code> variable changes as a result of the function call. In the code, we use an if/else statement to ensure that <code>elite</code> gets correctly updated if the customer&rsquo;s new balance is above or below the threshold for elite status. If we were to write a postcondition that summarized how <code>elite</code> was updated by the function, we would write: <code>elite == (balance >= eliteMin)</code> to say that the value of elite after the function equaled whether the new balance was above the threshold. However, this claim is already a global invariant, which already must hold at the end of the function. We do not need to list it again as a postcondition.</p><p>Consider this potential function contract for <code>deposit</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def deposit(amount: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        //this function contract is not quite correct
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        Modifies (balance, elite ),
</span></span><span class=line><span class=cl>        Ensures( balance == In(balance) + amount )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    balance = balance + amount
</span></span><span class=line><span class=cl>    if (balance &gt;= eliteMin) {
</span></span><span class=line><span class=cl>        elite = true
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        elite = false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>This function contract is close to correct, but contains a major flaw. In symexe mode, the function contract must be tight enough to guarantee that the global invariants will still hold after the function ends. Suppose <code>balance</code> still has its starting value of 0, and that we called <code>deposit(-100)</code>. With no other changes, the function code would dutifully update the <code>balance</code> global variable to be -100&mldr;which would violate the global invariant that <code>balance >= 0</code>. In order to guarantee that the balance will never be negative after the <code>deposit</code> function ends, we must restrict the deposit amounts to be greater than or equal to 0. Since functions are can assume that the global invariants hold when they are called, we know that <code>balance</code> will be 0 at minimum at the beginning of <code>deposit</code>. If <code>amount</code> is also nonnegative, we can guarantee that the value of <code>balance</code> at the end of the <code>deposit</code> function will be greater than or equal to 0 &ndash; thus satisfying our global invariant.</p><p>Here is the corrected <code>deposit</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def deposit(amount: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires( amount &gt;= 0 ),
</span></span><span class=line><span class=cl>        Modifies( balance, elit e),
</span></span><span class=line><span class=cl>        Ensures( In(balance) == balance - amount )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    balance = balance + amount
</span></span><span class=line><span class=cl>    if (balance &gt;= eliteMin) {
</span></span><span class=line><span class=cl>        elite = true
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        elite = false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We can similarly write the function contract for the <code>withdraw</code> function. Since withdraw is subtracting an amount from the balance, we must require that the withdraw amount be less than or equal to the account balance &ndash; otherwise, the account balance might become negative, and we would violate the global invariant. We will also require that our withdrawal amount be nonnegative, as it doesn&rsquo;t make any sense to withdraw a negative amount from a bank account:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def withdraw(amount: Z): Unit = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires( balance &gt;= amount ),
</span></span><span class=line><span class=cl>        Modifies( balance, elite ),
</span></span><span class=line><span class=cl>        Ensures( balance == In(balance) - amount )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    balance = balance - amount
</span></span><span class=line><span class=cl>    if (balance &gt;= eliteMin) {
</span></span><span class=line><span class=cl>        elite = true
</span></span><span class=line><span class=cl>    } else {
</span></span><span class=line><span class=cl>        elite = false
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><h3 id=bank-calling-code>Bank calling code</h3><p>When we call a function in a program with global invariants (whether in the calling code or from another function), we must consider four things:</p><ul><li>We must demonstrate that all global variables hold before the function call</li><li>We must demonstrate that the preconditions for the function holds</li><li>We can assume that all global variables hold after the function call (as the function itself if responsible for showing that the global invariants still hold just before the function ends)</li><li>We can assume the postcondition for the function holds after the function call</li></ul><p>Suppose we had this test code at the end of our bank program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>deposit(500000)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Assert will hold
</span></span><span class=line><span class=cl>assert(balance == 500000 &amp;&amp; elite == false)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>deposit(500000)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Assert will hold
</span></span><span class=line><span class=cl>assert(balance == 1000000 &amp;&amp; elite == true)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Precondition will not hold
</span></span><span class=line><span class=cl>withdraw(2000000)</span></span></code></pre></div><p>We already showed how our global invariants initially held for the starting values of the global variables (<code>balance = 0</code> and <code>elite = false</code>). When we consider the first function call, <code>deposit(500000)</code>, we can also see that the precondition holds (we are depositing a non-negative amount). The <code>deposit</code> postcondition tells us that the new value of <code>balance</code> is 500000 more than it was before the function call, so we know balance is now 500000. We can also assume that all global invariants hold after the <code>deposit</code> call, so we can infer that <code>elite</code> is still false (since the balance is not more than the threshold). Thus the next assert statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>assert(balance == 500000 &amp;&amp; elite == false)</span></span></code></pre></div><p>will hold in Logika&rsquo;s auto mode.</p><p>The very next statement in the calling code is another call to <code>deposit</code>. Since we could assume the global invariants held immediately after the last call to deposit, we can infer that they still hold before the next <code>deposit</code> call. We also see that the function&rsquo;s precondition is satisfied, as we are depositing another nonnegative value. Just as before, we can use the <code>deposit</code> postcondition to see that <code>balance</code> will be 1000000 after the next function call (the postcondition tells us that <code>balance</code> is 500000 more than it was just before the function call). We also know that the global invariants hold, so we are sure <code>elite</code> has been updated to true. Thus our next assert holds as well:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>assert(balance == 1000000 &amp;&amp; elite == true)</span></span></code></pre></div><p>Our final function call, <code>withdraw(2000000)</code>, will not be allowed. We are trying to withdraw $2,000,000, but our account balance at this point is $1,000,000. We will get an error saying that the <code>withdraw</code> precondition has not been satisfied, as that function requires that our withdrawal amount be less than or equal to the account balance.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=termination>Termination</h1><h2 id=what-is-termination>What is termination?</h2><p>In this section, we will consider the notion of <em>termination</em> &ndash; whether a function will ever finish running.</p><h2 id=partial-correctness-vs-total-correctness>Partial correctness vs total correctness</h2><p>Up to this point, we have proved <em>partial correctness</em> for functions &ndash; IF the function&rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.</p><h3 id=example-of-partial-correctness>Example of partial correctness</h3><p>Consider the following version of our <code>mult</code> function, which uses repeated addition to multiply two numbers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == m * count
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + m
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  return sum
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>This function will be verified in Logika&rsquo;s auto mode, but in fact it has a subtle flaw. If we were to pass in <code>-1</code> for our second parameter (<code>n</code>), then we would get stuck in an infinite loop. <code>count</code> would be initially 0, and we would increment <code>count</code> each time in the loop, but of course it NEVER equal -1.</p><p>This is an example of partial correctness &ndash; if our function DOES finish (which it would for nonnegative values of <code>n</code>), then we have shown it will return the correct value. We can see that we will need to require that the <code>n</code> parameter be nonnegative .</p><h3 id=total-correctness-definition>Total correctness definition</h3><p><em>Total correctness</em> goes a step further than partial correctness &ndash; it says that IF the function&rsquo;s precondition holds, THEN we promise that it will terminate and that its postcondition will hold.</p><p>In order to show total correctness for our <code>mult</code> function, we must show that it always terminates.</p><h2 id=process-of-proving-termination>Process of proving termination</h2><p>We will see later in this section that the idea of termination is a much more challenging topic than it might seem. There is no button in Logika that will check for termination, but we can often insert manual assertions which, if they are verified, will guarantee termination. We will show how to create such manual assertions for simple loops that execute a set number of times.</p><p>First, we need to come up with a way to measure (as an integer) how much work the loop has left to do. Using this measure of work, we want to show two things:</p><ul><li>Each loop iteration decreases the integer measure (i.e., the amount of work left to do is strictly decreasing)</li><li>When our integer measure is 0 or less, then we are certain that we are done (i.e., the loop exits)</li></ul><h2 id=termination-in-mult>Termination in mult</h2><p>In our <code>mult</code> example, let&rsquo;s first try to establish an integer measure of work for the loop. We know that the loop is computing <code>m + m + ... + m</code>, for a total of <code>n</code> additions. When <code>count</code> is 0, we know we have <code>n</code> more additions to do (<code>n</code> more iterations of the loop). When <code>count</code> is 1, we know we have <code>n-1</code> more additions&mldr;and when <code>count</code> is <code>n</code>, we know that we have no more additions to do (and the loop ends). Our measure of work should be the number of additions left to do, which is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Measure of work: n - count</span></span></code></pre></div><p>We can calculate this measure at the beginning of each iteration and again at the end of each iteration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>while (count != n) {
</span></span><span class=line><span class=cl>    Invariant(
</span></span><span class=line><span class=cl>        Modifies(sum, count),
</span></span><span class=line><span class=cl>        sum == m * count
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //get measure value at beginning of iteration
</span></span><span class=line><span class=cl>    val measureBegin: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sum = sum + m
</span></span><span class=line><span class=cl>    count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //get measure value at end of iteration
</span></span><span class=line><span class=cl>    val measureEnd: Z = n-count
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Next, we want to assert that <code>measureEnd &lt; measureBegin</code> &ndash; that the amount of work decreases with each iteration. We can also assert that <code>measureEnd > 0 || count == n</code> &ndash; that either we have more work to do, or our loop condition is false (meaning that if we have no more work to do, then our loop condition must be false and thus terminate):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (n &gt;= 0),          //needed for termination
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == m * count
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at beginning of iteration
</span></span><span class=line><span class=cl>        val measureBegin: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        sum = sum + m
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at end of iteration
</span></span><span class=line><span class=cl>        val measureEnd: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we are making progress
</span></span><span class=line><span class=cl>        //the amount of work decreases with each iteration
</span></span><span class=line><span class=cl>        assert(measureEnd &lt; measureBegin)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we either have more work, or the loop will terminate
</span></span><span class=line><span class=cl>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span class=line><span class=cl>        assert(measureEnd &gt; 0 || count == n)     //NOTE: will not hold!
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>If we try verifying this program in Logika, the second assert, <code>assert(measureEnd > 0 || count == n)</code> will not hold. To see why, let&rsquo;s suppose that <code>measureEnd &lt;= 0</code>. For the assert to be true, we would need to be certain that <code>count == n</code> (since the left side of the OR would be false). Because <code>measureEnd = n-count</code>, we can infer that <code>count >= n</code> when <code>measureEnd &lt;= 0</code>. However, Logika is unable to infer that <code>count == n</code> from the knowledge that <code>count >= n</code> unless it also knows that <code>count &lt;= n</code> always holds. We can add this knowledge by strengthening our loop invariant to provide a range for the loop counter &ndash; <code>count >= 0</code> and <code>count &lt;= n</code>. Even if not required, it is a good habit anyway to include the loop counter range as part of the loop invariant.</p><p>We strengthen our loop invariant, and both asserts will hold &ndash; thus demonstrating termination:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>def mult(m: Z, n: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires (n &gt;= 0),          //needed for termination
</span></span><span class=line><span class=cl>        Ensures(Res[Z] == m * n)
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var sum: Z = 0
</span></span><span class=line><span class=cl>    var count: Z = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while (count != n) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies(sum, count),
</span></span><span class=line><span class=cl>            sum == m * count,
</span></span><span class=line><span class=cl>            0 &lt;= count,
</span></span><span class=line><span class=cl>            count &lt;= n
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at beginning of iteration
</span></span><span class=line><span class=cl>        val measureBegin: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        sum = sum + m
</span></span><span class=line><span class=cl>        count = count + 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //get measure value at end of iteration
</span></span><span class=line><span class=cl>        val measureEnd: Z = n-count
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we are making progress
</span></span><span class=line><span class=cl>        //the amount of work decreases with each iteration
</span></span><span class=line><span class=cl>        assert(measureEnd &lt; measureBegin)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //we either have more work, or the loop will terminate
</span></span><span class=line><span class=cl>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span class=line><span class=cl>        assert(measureEnd &gt; 0 || count == n)     //This holds now!
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return sum
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We could similarly use measures of work and manual assert statements to prove termination in some recursive functions. Here, we would demonstrate that a parameter value decreased with each recursive call, and that we either had more work to do or had reached the base case of our recursion (with no more recursive calls needed).</p><h2 id=collatz-function>Collatz function</h2><p>While it is possible to prove termination for certain kinds of programs &ndash; those that loop or make recursive calls a set number of times &ndash; it is not possible to prove termination for all programs.</p><p>Consider the <code>collatz</code> function below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --background save
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def collatz(m: Z): Z = {
</span></span><span class=line><span class=cl>    Contract(
</span></span><span class=line><span class=cl>        Requires( m &gt; 0 ),
</span></span><span class=line><span class=cl>        Ensures( Res[Z] == 1 )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    var n: Z = m
</span></span><span class=line><span class=cl>    while (n &gt; 1) {
</span></span><span class=line><span class=cl>        Invariant(
</span></span><span class=line><span class=cl>            Modifies( n ),
</span></span><span class=line><span class=cl>            n &gt;= 1
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if (n % 2 == 0) {
</span></span><span class=line><span class=cl>            n = n / 2
</span></span><span class=line><span class=cl>        } else {
</span></span><span class=line><span class=cl>            n = 3 * n + 1
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return n
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>We see that we must pass <code>collatz</code> a positve parameter, and that it promises to return 1 (no matter what the parameter is). It contains a loop that repeatedly modifies a current value (which is initially the parameter value):</p><ul><li>If the current number is even, we divide the number by 2</li><li>If the current number is odd, we triple the number and add 1</li></ul><p>Suppose we compute <code>collatz(17)</code>. We can track the value of <code>n</code> as follows: 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. We can see that <code>n</code> does eventually reach 1, and that the program terminates in that case. We can similarly try other parameters, and will again see that we always end up with 1 (sometimes after a surprising number of iterations). But in fact:</p><ul><li>No one has proved that the Collatz function terminates for all positive numbers; and</li><li>No one has found a positive number on which the Collatz function does not terminate</li></ul><p>You may notice that part of the problem is that due to the nature of the problem, we cannot write a sufficient loop invariant describing what progress we have made towards our goal &ndash; our only loop invariant is nearly identical to our loop condition. In cases where we <em>can</em> write a loop invariant that adequately describes our progress, we often have enough information to prove termination as well.</p><h2 id=decidability-and-the-halting-problem>Decidability and the Halting problem</h2><p>It is an obvious question whether we could write a program to check whether another program always terminates. Unfortunately, this (the <em>Halting problem</em>) turns out to be impossible, as was demonstrated by Alan Turing. The Halting problem is an example of an <em>undecidable</em> problem in computer science &ndash; a decision problem (a problem with a yes/no answer) that we can&rsquo;t correctly answer one way or another on all inputs, even if we have unlimited resources.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/f155a3cc8172d3b667846d8e869b1961b20de09e>Apr 30, 2024</a></p></div></div><script src=/cis301/js/clipboard.min.js?1743605094 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1743605094 defer></script><script src=/cis301/js/theme.js?1743605094 defer></script></body></html>