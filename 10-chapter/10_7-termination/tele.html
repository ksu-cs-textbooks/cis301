




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Termination :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.html" rel="canonical" type="text/html" title="Termination :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.xml" rel="alternate" type="application/rss+xml" title="Termination :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.print.html" rel="alternate" type="text/html" title="Termination :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/embed.html" rel="alternate" type="text/html" title="Termination :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1696369553" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1696369553" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1696369553" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1696369553" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1696369553" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1696369553" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1696369553" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1696369553" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1696369553" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1696369553" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1696369553" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1696369553" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1696369553" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1696369553"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1696369553"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1696369553" rel="stylesheet">

  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="termination">Termination</h1>

<h2 id="what-is-termination">What is termination?</h2>
<p>In this section, we will consider the notion of <em>termination</em> &ndash; whether a function will ever finish running.</p>
<h2 id="partial-correctness-vs-total-correctness">Partial correctness vs total correctness</h2>
<p>Up to this point, we have proved <em>partial correctness</em> for functions &ndash; IF the function&rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.</p>
<h3 id="example-of-partial-correctness">Example of partial correctness</h3>
<p>Consider the following version of our <code>mult</code> function, which uses repeated addition to multiply two numbers:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def mult(m: Z, n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        ensures result == m*n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == m*count
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + m
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>This function will be verified in Logika&rsquo;s symexe mode, but in fact it has a subtle flaw. If we were to pass in <code>-1</code> for our second parameter (<code>n</code>), then we would get stuck in an infinite loop. <code>count</code> would be initially 0, and we would increment <code>count</code> each time in the loop, but of course it NEVER equal -1.</p>
<p>This is an example of partial correctness &ndash; if our function DOES finish (which it would for nonnegative values of <code>n</code>), then we have shown it will return the correct value. We can see that we will need to require that the <code>n</code> parameter be nonnegative .</p>
<h3 id="total-correctness-definition">Total correctness definition</h3>
<p><em>Total correctness</em> goes a step further than partial correctness &ndash; it says that IF the function&rsquo;s precondition holds, THEN we promise that it will terminate and that its postcondition will hold.</p>
<p>In order to show total correctness for our <code>mult</code> function, we must show that it always terminates.</p>
<h2 id="process-of-proving-termination">Process of proving termination</h2>
<p>We will see later in this section that the idea of termination is a much more challenging topic than it might seem. There is no button in Logika that will check for termination, but we can often insert manual assertions which, if they are verified, will guarantee termination. We will show how to create such manual assertions for simple loops that execute a set number of times.</p>
<p>First, we need to come up with a way to measure (as an integer) how much work the loop has left to do. Using this measure of work, we want to show two things:</p>
<ul>
<li>Each loop iteration decreases the integer measure (i.e., the amount of work left to do is strictly decreasing)</li>
<li>When our integer measure is 0 or less, then we are certain that we are done (i.e., the loop exits)</li>
</ul>
<h2 id="termination-in-mult">Termination in mult</h2>
<p>In our <code>mult</code> example, let&rsquo;s first try to establish an integer measure of work for the loop. We know that the loop is computing <code>m + m + ... + m</code>, for a total of <code>n</code> additions. When <code>count</code> is 0, we know we have <code>n</code> more additions to do (<code>n</code> more iterations of the loop). When <code>count</code> is 1, we know we have <code>n-1</code> more additions&hellip;and when <code>count</code> is <code>n</code>, we know that we have no more additions to do (and the loop ends). Our measure of work should be the number of additions left to do, which is:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Measure of work: n - count</span></span></code></pre></div><p>We can calculate this measure at the beginning of each iteration and again at the end of each iteration:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>while (count != n) {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        invariant sum == m*count
</span></span><span style="display:flex;"><span>        modifies sum, count
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //get measure value at beginning of iteration
</span></span><span style="display:flex;"><span>    val measureBegin: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum = sum + m
</span></span><span style="display:flex;"><span>    count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //get measure value at end of iteration
</span></span><span style="display:flex;"><span>    val measureEnd: Z = n-count
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Next, we want to assert that <code>measureEnd &lt; measureBegin</code> &ndash; that the amount of work decreases with each iteration. We can also assert that <code>measureEnd &gt; 0 | count == n</code> &ndash; that either we have more work to do, or our loop condition is false (meaning that if we have no more work to do, then our loop condition must be false and thus terminate):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def mult(m: Z, n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //needed for termination
</span></span><span style="display:flex;"><span>        ensures result == m*n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == m*count
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at beginning of iteration
</span></span><span style="display:flex;"><span>        val measureBegin: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + m
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at end of iteration
</span></span><span style="display:flex;"><span>        val measureEnd: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we are making progress
</span></span><span style="display:flex;"><span>        //the amount of work decreases with each iteration
</span></span><span style="display:flex;"><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we either have more work, or the loop will terminate
</span></span><span style="display:flex;"><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style="display:flex;"><span>        assert(measureEnd &gt; 0 | count == n)     //NOTE: will not hold!
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>If we try verifying this program in Logika, the second assert, <code>assert(measureEnd &gt; 0 | count == n)</code> will not hold. To see why, let&rsquo;s suppose that <code>measureEnd &lt;= 0</code>. For the assert to be true, we would need to be certain that <code>count == n</code> (since the left side of the OR would be false). Because <code>measureEnd = n-count</code>, we can infer that <code>count &gt;= n</code> when <code>measureEnd &lt;= 0</code>. However, Logika is unable to infer that <code>count == n</code> from the knowledge that <code>count &gt;= n</code> unless it also knows that <code>count &lt;= n</code> always holds. We can add this knowledge by strengthening our loop invariant to provide a range for the loop counter &ndash; <code>count &gt;= 0</code> and <code>count &lt;= n</code>. Even if not required, it is a good habit anyway to include the loop counter range as part of the loop invariant.</p>
<p>We strengthen our loop invariant, and both asserts will hold &ndash; thus demonstrating termination:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def mult(m: Z, n: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires n &gt;= 0         //needed for termination
</span></span><span style="display:flex;"><span>        ensures result == m*n
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var sum: Z = 0
</span></span><span style="display:flex;"><span>    var count: Z = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (count != n) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant sum == m*count
</span></span><span style="display:flex;"><span>                count &gt;= 0
</span></span><span style="display:flex;"><span>                count &lt;= n      //bound loop counter
</span></span><span style="display:flex;"><span>                                //needed for assert to hold
</span></span><span style="display:flex;"><span>            modifies sum, count
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at beginning of iteration
</span></span><span style="display:flex;"><span>        val measureBegin: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sum = sum + m
</span></span><span style="display:flex;"><span>        count = count + 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //get measure value at end of iteration
</span></span><span style="display:flex;"><span>        val measureEnd: Z = n-count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we are making progress
</span></span><span style="display:flex;"><span>        //the amount of work decreases with each iteration
</span></span><span style="display:flex;"><span>        assert(measureEnd &lt; measureBegin)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //we either have more work, or the loop will terminate
</span></span><span style="display:flex;"><span>        //(if there is no work work to do, then the loop condition must be false)
</span></span><span style="display:flex;"><span>        assert(measureEnd &gt; 0 | count == n) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return sum
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We could similarly use measures of work and manual assert statements to prove termination in some recursive functions. Here, we would demonstrate that a parameter value decreased with each recursive call, and that we either had more work to do or had reached the base case of our recursion (with no more recursive calls needed).</p>
<h2 id="collatz-function">Collatz function</h2>
<p>While it is possible to prove termination for certain kinds of programs &ndash; those that loop or make recursive calls a set number of times &ndash; it is not possible to prove termination for all programs.</p>
<p>Consider the <code>collatz</code> function below:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>import org.sireum.logika._
</span></span><span style="display:flex;"><span>def collatz(m: Z): Z = {
</span></span><span style="display:flex;"><span>    l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>        requires m &gt; 0
</span></span><span style="display:flex;"><span>        ensures result == 1
</span></span><span style="display:flex;"><span>    }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var n: Z = m
</span></span><span style="display:flex;"><span>    while (n &gt; 1) {
</span></span><span style="display:flex;"><span>        l&#34;&#34;&#34;{
</span></span><span style="display:flex;"><span>            invariant n &gt;= 1
</span></span><span style="display:flex;"><span>            modifies n
</span></span><span style="display:flex;"><span>        }&#34;&#34;&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (n % 2 == 0) {
</span></span><span style="display:flex;"><span>            n = n / 2
</span></span><span style="display:flex;"><span>        } else {
</span></span><span style="display:flex;"><span>            n = 3 * n + 1
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return n
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We see that we must pass <code>collatz</code> a positve parameter, and that it promises to return 1 (no matter what the parameter is). It contains a loop that repeatedly modifies a current value (which is initially the parameter value):</p>
<ul>
<li>If the current number is even, we divide the number by 2</li>
<li>If the current number is odd, we triple the number and add 1</li>
</ul>
<p>Suppose we compute <code>collatz(17)</code>. We can track the value of <code>n</code> as follows: 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. We can see that <code>n</code> does eventually reach 1, and that the program terminates in that case. We can similarly try other parameters, and will again see that we always end up with 1 (sometimes after a surprising number of iterations). But in fact:</p>
<ul>
<li>No one has proved that the Collatz function terminates for all postiive numbers; and</li>
<li>No one has found a positive number on which the Collatz function does not terminate</li>
</ul>
<h2 id="decidability-and-the-halting-problem">Decidability and the Halting problem</h2>
<p>It is an obvious question whether we could write a program to check whether another program always terminates. Unfortunately, this (the <em>Halting problem</em>) turns out to be impossible, as was demonstrated by Alan Turing. The Halting problem is an example of an <em>undecidable</em> problem in computer science &ndash; a decision problem (a problem with a yes/no answer) that we can&rsquo;t correctly answer one way or another on all inputs, even if we have unlimited resources.</p>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    </div>
    
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1696369554" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1696369554" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1696369554" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/tele-scroll.js?1696369554 defer"></script>
    
  </body>
</html>
