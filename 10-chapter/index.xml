




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sequences, Globals, and Termination on CIS 301 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/index.html</link>
    <description>Recent content in Sequences, Globals, and Termination on CIS 301 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis301/10-chapter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Logika Modes</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_1-modes/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_1-modes/index.html</guid>
      <description>Logika has different modes for programming logic verification. We can switch between modes by going to File-&amp;gt;Settings-&amp;gt;Tools-&amp;gt;Sireum-&amp;gt;Logika.
Logika&amp;rsquo;s &amp;ldquo;manual&amp;rdquo; mode Up to now, we have been running Logika in &amp;ldquo;manual mode&amp;rdquo;, which uses these Logika settings:
We are now reaching the point where additional practice in manual mode may no longer be a learning activity, and where the proof-blocks after claim transformations can become dozens of lines long.
Logika&amp;rsquo;s symexe mode In Chapter 10, we will be switching to Logika&amp;rsquo;s &amp;ldquo;symexe mode&amp;rdquo;, which uses these Logika settings:</description>
    </item>
    <item>
      <title>Intro to Sequences</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_2-intosequences/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_2-intosequences/index.html</guid>
      <description>Sequences in Logika are fairly similar to lists in Python and arrays in Java and C#. As with lists and arrays, Logika sequences are ordered. Each element is stored at a particular (zero-based) position, and there are no gaps in the sequence.
Logika sequences can either store integers (type ZS) or booleans (type BS).
Sequence syntax We can create new sequence variables like this:
//creates the sequence (5, 10, 15) var seq: ZS = ZS(5,10,15) //creates the sequence (false, true) var bools: BS = BS(false, true) //creates an empty sequence of integers var empty: ZS = ZS()Given the following sequence:</description>
    </item>
    <item>
      <title>Sequences in Functions</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_3-seqfn/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_3-seqfn/index.html</guid>
      <description>Sequences in Logika are passed to functions by reference. This means that if a function makes changes to a sequence parameter, then it will also change whatever sequence object was passed to the function. For example, the test code above passes nums, which has the value ZS(1,2,3), to the makeFirstZero function. The makeFirstZero function changes the first position in its parameter (seq) to be 0, which means that the nums sequence in the test code will also have its first position set to 0 (making it have the value ZS(0,2,3)).</description>
    </item>
    <item>
      <title>Sequences in Loops</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_4-seqloop/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_4-seqloop/index.html</guid>
      <description>We also must consider sequences when writing loop invariants. Typically, we must include the following in our invariant:
If the sequence changes in the loop Describe what sequence elements have already changed in the loop (and what their new values are) Describe what sequence elements still have their original value State that the sequence size does not change Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence) List the sequence along with other changing variables in the loop invariant block&amp;rsquo;s modifies clause If the sequence does not change in the loop Consider what we are doing with each sequence element as we look at them.</description>
    </item>
    <item>
      <title>Logika Facts, revisited</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_5_seqlogfact/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_5_seqlogfact/index.html</guid>
      <description>As in other programs with loops, programs with sequences sometimes necessitate the use of a Logika fact to describe how a particular value is calculated. For example, consider the following program that finds and returns the sum of all elements in an integer sequence:
import org.sireum.logika._ def seqSum(list: ZS): Z = { var i: Z = 0 var total: Z = 0 while (i &amp;lt; list.size) { total = total + list(i) i = i + 1 } return total } ////////////// Calling code /////////////////// var test: ZS = ZS(1,2,3,4) var added: Z = seqSum(test) assert(added == 10)In the seqSum function contract, we need to describe that the return value equals the sum of all sequence elements &amp;ndash; that is, that result == list(0) + list(1) + .</description>
    </item>
    <item>
      <title>Global Variables</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_6-globals/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_6-globals/index.html</guid>
      <description>Motivation We will now consider programs with multiple functions that modify a shared pool of global variables. (This is very similar to the concerns in general classes in Java or C#, where multiple methods might edit fields/property values for an object). We want to be sure that global variables will maintain desired ranges and relationships between one another, even as multiple functions modify their values.
Global variables in Logika A global variable in Logika exists before any function call, and still exists after any function ends.</description>
    </item>
    <item>
      <title>Termination</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/10-chapter/10_7-termination/index.html</guid>
      <description>What is termination? In this section, we will consider the notion of termination &amp;ndash; whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions &amp;ndash; IF the function&amp;rsquo;s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:</description>
    </item>
  </channel>
</rss>