<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sequences, Globals, and Termination :: CIS 301 Textbook</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/</link><description>In our conclusion of programming logic, we’ll examines programs with sequences and global variables. We’ll also learn the idea of termination in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 02 May 2024 14:41:22 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis301/10-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Logika Modes</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_1-modes/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_1-modes/</guid><description>Logika has different modes for programming logic verification. We can switch between modes by going to File->Settings->Tools->Sireum->Logika.
Logika’s “manual” mode Up to now, we have been running Logika in “manual mode”, where we list the following settings at the beginning of a file:
// #Sireum #Logika //@Logika: --manual --background save import org.sireum._ import org.sireum.justification._We are now reaching the point where additional practice in manual mode may no longer be a learning activity, and where the proof blocks after claim transformations can become dozens of lines long.</description></item><item><title>Intro to Sequences</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_2-intosequences/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_2-intosequences/</guid><description>Sequences in Logika are fairly similar to lists in Python and arrays in Java and C#. As with lists and arrays, Logika sequences are ordered. Each element is stored at a particular (zero-based) position, and there are no gaps in the sequence.
Logika can work with sequences of integers (type ZS).
Sequence syntax We can create new sequence variables like this:
// #Sireum #Logika //@Logika: --background save import org.sireum._ //creates the sequence (5, 10, 15) var seq: ZS = ZS(5,10,15) //creates an empty sequence of integers var empty: ZS = ZS()Given the following sequence:</description></item><item><title>Sequences in Functions</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_3-seqfn/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_3-seqfn/</guid><description>Sequences in Scala are passed to functions by reference. This means that if a function makes changes to a sequence parameter, then it will also change whatever sequence object was passed to the function. For example, the test code below passes nums, which has the value ZS(1,2,3), to the makeFirstZero function. The makeFirstZero function changes the first position in its parameter (seq) to be 0, which means that the nums sequence in the test code will also have its first position set to 0 (making it have the value ZS(0,2,3)).</description></item><item><title>Sequences in Loops</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_4-seqloop/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_4-seqloop/</guid><description>We also must consider sequences when writing loop invariants. Typically, we must include the following in our invariant:
If the sequence changes in the loop Describe what sequence elements have already changed in the loop (and what their new values are) Describe what sequence elements still have their original value Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence) State that the sequence size does not change (to reinforce that the variable used as the sequence position will not go out of bounds) List the sequence along with other changing variables in the loop invariant block’s Modifies clause If the sequence does not change in the loop Consider what we are doing with each sequence element as we look at them.</description></item><item><title>Global Variables</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_5-globals/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_5-globals/</guid><description>Motivation We will now consider programs with multiple functions that modify a shared pool of global variables. (This is very similar to the concerns in general classes in Java or C#, where multiple methods might edit fields/property values for an object). We want to be sure that global variables will maintain desired ranges and relationships between one another, even as multiple functions modify their values.
Global variables in Logika A global variable exists before any function call, and still exists after any function ends.</description></item><item><title>Termination</title><link>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_6-termination/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/10-chapter/10_6-termination/</guid><description>What is termination? In this section, we will consider the notion of termination – whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions – IF the function’s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:</description></item></channel></rss>