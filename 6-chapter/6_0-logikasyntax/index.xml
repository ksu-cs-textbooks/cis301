<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Logika Predicate Logic Proof Syntax :: CIS 301 Textbook</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_0-logikasyntax/index.html</link><description>We will use the following format in Logika to start a natural deduction proof for predicate logic. Each proof will be saved in a new file with a .sc (Scala) extension:
// #Sireum #Logika //@Logika: --manual --background type import org.sireum._ import org.sireum.justification._ import org.sireum.justification.natded.prop._ import org.sireum.justification.natded.pred._ @pure def ProofName[T](pred1: T => B @pure, pred2: T => B @pure, ..., indiv1: T, indiv2: T, ...): Unit = { Deduce( //@formatter:off (comma-separated list of premises with variable1, variable2, ...) ⊢ (conclusion) Proof( //the actual proof steps go here ) //@formatter:on ) } Here, T is the type of elements in our domain. Usually, we will just use T to denote a generic type (much like generics in Java and C#), but occasionally we will use specific types like Z (which means “integer”). Next, pred1, pred2, etc. are the predicates for our proofs. The T => B means that they take an element in our domain as a parameter (which has type T) and return a boolean (which has type B). Finally, indiv1, indiv2, etc. are specific individuals within our domain, each of which have type T.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate/><atom:link href="https://textbooks.cs.ksu.edu/cis301/6-chapter/6_0-logikasyntax/index.xml" rel="self" type="application/rss+xml"/></channel></rss>