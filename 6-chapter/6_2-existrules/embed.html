<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rules with ∃ :: CIS 301 Textbook"><meta name=twitter:description content="In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/6-chapter/6_2-existrules/embed.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Rules with ∃ :: CIS 301 Textbook"><meta property="og:description" content="In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Proofs"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-10-23T10:50:31-05:00"><meta itemprop=name content="Rules with ∃ :: CIS 301 Textbook"><meta itemprop=description content="In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-10-23T10:50:31-05:00"><meta itemprop=wordCount content="1781"><title>Rules with ∃ :: CIS 301 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis301/6-chapter/6_2-existrules/ rel=canonical type=text/html title="Rules with ∃ :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_2-existrules/index.xml rel=alternate type=application/rss+xml title="Rules with ∃ :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_2-existrules/index.print.html rel=alternate type=text/html title="Rules with ∃ :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_2-existrules/tele.html rel=alternate type=text/html title="Rules with ∃ :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1736806682 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1736806682 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1736806682 rel=stylesheet><link href=/cis301/css/auto-complete.css?1736806682 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1736806682 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1736806682 rel=stylesheet><link href=/cis301/css/fonts.css?1736806682 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1736806682 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1736806682 rel=stylesheet><link href=/cis301/css/theme-light-theme.css?1736806682 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-relearn-light.css?1736806682 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1736806682 rel=stylesheet><link href=/cis301/css/print.css?1736806682 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1736806682 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis301/6-chapter/6_2-existrules/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><p>In this section, we will see the two inference rules for the existential (∃) quantifier.</p><h2 id=exists-introduction>Exists introduction</h2><p>We can use the exists introduction rule, <code>ExistsI[T]</code>, when we have a proposition of the form <code>P(a)</code> for an arbitrary member <code>a</code> of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                   P(d)         where  d  is an individual of type T
</span></span><span class=line><span class=cl>ExistsI[T]: ---------------------
</span></span><span class=line><span class=cl>              ∃((x: T) =&gt; P(x))</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>ExistsI[T]</code> rule (where <em>Socrates</em> is a parameter of type <code>T</code> to our proof function):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   isHuman(Socrates)   ) ⊢ (   ∃((x: T) =&gt; isHuman(x))  )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span class=line><span class=cl>        2 (     ∃((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>When we use the <code>ExistsI[T]</code> rule to justify a claim like <code>∃((x: T) => P(x))</code>, we include the line number of where the proposition held for a particular individual. In the proof above, we claim <code>∃((x: T) => isHuman(x))</code> with justification <code>ExistsI[T](1)</code> &ndash; line 1 corresponds to <code>isHuman(Socrates)</code>, where our <code>∃((x: T) => isHuman(x))</code> proposition held for a particular individual. The full proof function, which shows how <em>Socrates</em> can be accepted as a parameter of type <code>T</code>, is here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>@pure def ExistsExample[T](isHuman: T =&gt; B @pure, Socrates: T): Unit = {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        (   isHuman(Socrates)   ) ⊢ (   ∃((x: T) =&gt; isHuman(x))  )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        Proof(
</span></span><span class=line><span class=cl>            1 (     isHuman(Socrates)       )   by Premise,
</span></span><span class=line><span class=cl>            2 (     ∃((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Note that we can use the <code>ExistsI[T]</code> rule to introduce any variable, not just <code>x</code>. You can choose which variable to introduce based on the variables used in the conclusion. For example, the following proof is also valid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   isHuman(Socrates)   ) ⊢ (   ∃((z: T) =&gt; isHuman(z))  )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span class=line><span class=cl>        2 (     ∃((z: T) =&gt; isHuman(z)) )   by ExistsI[T](1)
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><h2 id=exists-elimination>Exists elimination</h2><p>Since the <code>ExistsI[T]</code>-rule constructs propositions that begin with <code>∃</code>, the <code>ExistsE[T]</code>-rule (exists elimination) disassembles propositions that begin with <code>∃</code>.</p><p>Here is a quick example (where our domain is living things):</p><ul><li>All humans are mortal</li><li>Someone is human</li><li>Therefore, someone is mortal</li></ul><p>We don&rsquo;t know the name of the human, but it does not matter. Since ALL humans are mortal and SOMEONE is human, then our anonymous human must be mortal. The steps will go like this:</p><ul><li><p>Since &ldquo;someone is human&rdquo; and since we do not know his/her name, we will just make up our own name for them – &ldquo;Jane&rdquo;. So, we assume that &ldquo;Jane is human&rdquo;.</p></li><li><p>We use the logic rules we already know to prove that &ldquo;Jane is mortal&rdquo;.</p></li><li><p>Therefore, SOMEONE is mortal and their name does not matter.</p></li></ul><p>This approach is coded into the last logic law, <code>ExistsE[T]</code> (exists elimination).</p><p>Suppose we have a premise of the form <code>∃((x: T) => P(x))</code>. Since we do not know the name of the individual &ldquo;hidden&rdquo; behind the <code>∃(x: T)</code>, we make up a name for it, say <code>a</code>, and discuss what must follow from the assumption that <code>P(a)</code> holds true. Here is the formalization of the <code>ExistsE[T]</code> rule:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                                        Let ((a: T) =&gt; SubProof(          // where  a  is a new, fresh name
</span></span><span class=line><span class=cl>                                             Assume( P(a) ),              // a  MUST NOT appear in  Q
</span></span><span class=line><span class=cl>                ∃((x: T) =&gt; P(x))            ...
</span></span><span class=line><span class=cl>                                             Q         
</span></span><span class=line><span class=cl>                                        )),             
</span></span><span class=line><span class=cl>ExistsE[T]: ----------------------------------------------------
</span></span><span class=line><span class=cl>                     Q</span></span></code></pre></div><p>That is, if we can deduce <code>Q</code> from <code>P(a)</code>, and we do not mention <code>a</code> within <code>Q</code>, then it means <code>Q</code> can be deduced no matter what name the hidden individual has. So, <code>Q</code> follows from <code>∃((x: T) => P(x))</code>.</p><p>We can work the previous example, with <code>ExistsE[T]</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>All humans are mortal
</span></span><span class=line><span class=cl>Someone is human
</span></span><span class=line><span class=cl>Therefore, someone is mortal</span></span></code></pre></div><p>We make up the name, <code>jane</code>, for the human whose name we do not know:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∀((h: T) =&gt; (isHuman(h) → isMortal(h))),
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; isHuman(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>⊢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∃((y: T) =&gt; (isMortal(y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ∀((h: T) =&gt; (isHuman(h) → isMortal(h)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ∃((x: T) =&gt; isHuman(x))                     )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (jane: T) =&gt; SubProof (
</span></span><span class=line><span class=cl>        4 Assume(   isHuman(jane)                       ),
</span></span><span class=line><span class=cl>        5 (         isHuman(jane) → isMortal(jane)      )   by AllE[T](1),
</span></span><span class=line><span class=cl>        6 (         isMortal(jane)                      )   by ImplyE(5, 4)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    7 (     ∃((y: T) =&gt; (isMortal(y)))                  )   by ExistsE[T](2, 3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Line 3 proposes the name <code>jane</code> for our subproof and line 4 makes the assumption <code>isHuman(jane)</code> (based on the premise <code>∃((x: T) => isHuman(x))</code>). The subproof leads to Line 6, which says that someone is mortal. (We never learned the individual&rsquo;s name!) Since Line 6 does not explicitly mention the made-up name, <code>jane</code>, we use Line 7 to repeat Line 6 – without knowing the name of the individual &ldquo;hiding&rdquo; inside Line 2, we made a subproof that proves the result, anyway. This is how <code>ExistsE[T]</code> works.</p><p>Note that when we use the <code>ExistsE[T]</code> rule as a justification we include first the line number of the there exists statement that we processed (by naming the hidden individual) in the previous subproof, and then the line number of that subproof. In the example above, we say <code>ExistsE[T](2, 3)</code> because line 2 includes the there-exists statement we processed (<code>∃ ∃((x: T) => isHuman(x))</code>) in the previous subproof and line 3 is the subproof.</p><p>When using <code>ExistsE[T]</code>, the previous subproof must begin with introducing a name for a hidden individual in a there-exists statement and then immediately make an assumption that substitutes the name into the there exists statement. The last line in the subproof should contain NO mention of the chosen name. Whatever we claim on the last line in the subproof, we must claim EXACTLY the same thing immediately afterwards when we use the <code>ExistsE[T]</code> rule.</p><p>You are welcome to use any name for the hidden individual &ndash; not just <code>jane</code> or <code>a</code>. The only restriction is that you cannot have used the name anywhere else in the proof.</p><h2 id=examples>Examples</h2><p>In this section, we will look at other proofs involving the existential quantifier.</p><h3 id=example-1>Example 1</h3><p>Suppose we wish to prove the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   ∃((x: T) =&gt; (Adult(x) ∨ Kid(x)))  ) ⊢ (   ∃((x: T) =&gt; Adult(x) )) ∨ ∃((x: T) =&gt; Kid(x)  )</span></span></code></pre></div><p>We will begin as we did previously: by introducing an alias for our person that is either an adult or a kid (say, <code>alice</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   ∃((x: T) =&gt; (Adult(x) ∨ Kid(x)))  ) ⊢ (   ∃((x: T) =&gt; Adult(x) )) ∨ ∃((x: T) =&gt; Kid(x)  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ∃((x: T) =&gt; (Adult(x) ∨ Kid(x)) )       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        3 Assume(   Adult(alice) ∨ Kid(alice)       ),
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        //goal: get to our conclusion, ∃( (x: T) =&gt; Adult(x) )) ∨ ∃( (x: T) =&gt; Kid(x)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>To finish our proof, we can use OR elimination on <code>Adult(alice) ∨ Kid(alice)</code>, and then <code>ExistsE[T]</code> afterwards to restate our conclusion. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   ∃((x: T) =&gt; (Adult(x) ∨ Kid(x)))  ) ⊢ (   ∃((x: T) =&gt; Adult(x) )) ∨ ∃((x: T) =&gt; Kid(x)  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ∃((x: T) =&gt; (Adult(x) ∨ Kid(x)) )                   )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        3 Assume(   Adult(alice) ∨ Kid(alice)                   ),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        4 SubProof(
</span></span><span class=line><span class=cl>            5 Assume (  Adult(alice)                            ),
</span></span><span class=line><span class=cl>            6 (     ∃((x: T) =&gt; Adult(x)                        )   by ExistsI[T](5),
</span></span><span class=line><span class=cl>            7 (     ∃((x: T) =&gt; Adult(x) ∨ ∃((x: T) =&gt; Kid(x)   )   by OrI1(6)
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        8 SubProof(
</span></span><span class=line><span class=cl>            9 Assume (  Kid(alice)                              ),
</span></span><span class=line><span class=cl>            10 (    ∃((x: T) =&gt; Kid(x)                          )   by ExistsI[T](9),
</span></span><span class=line><span class=cl>            11 (    ∃((x: T) =&gt; Adult(x) ∨ ∃((x: T) =&gt; Kid(x)   )   by OrI2(10)
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        12 (    ∃((x: T) =&gt; Adult(x) ∨ ∃((x: T) =&gt; Kid(x)       )   by OrE(3, 4, 8)
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        //goal: get to our conclusion, ∃( (x: T) =&gt; Adult(x) )) ∨ ∃( (x: T) =&gt; Kid(x)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    13 (        ∃((x: T) =&gt; Adult(x) ∨ ∃((x: T) =&gt; Kid(x)       )   by ExistsE[T](1, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h3 id=example-2>Example 2</h3><p>Suppose we wish to prove the following (in the domain of living things):</p><ul><li>All bunnies are fluffy</li><li>There is a fast bunny</li><li>Therefore, there is a creature that is fast and fluffy</li></ul><p>We can translate our premises and desired conclusion to predicate logic, and write the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∀((x: T) =&gt; (Bunny(x) → Fluffy(x))),
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>⊢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>Since we are trying to prove a claim about some individual, it makes sense that we would start the process of an <code>ExistsE[T]</code> subproof where we introduce an alias (<code>thumper</code>) for the fast bunny. We will try to reach the conclusion by the end of that subproof. Here is the setup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∀((x: T) =&gt; (Bunny(x) → Fluffy(x))),
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>⊢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ∀((x: T) =&gt; (Bunny(x) → Fluffy(x)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ∃((x: T) =&gt; (Fast(x) &amp; Bunny(x)))       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 Assume(   Fast(thumper) ∧ Bunny(thumper)  ),
</span></span><span class=line><span class=cl>        5 (         Fast(thumper)                   )   by AndE1(4),
</span></span><span class=line><span class=cl>        6 (         Bunny(thumper)                  )   by AndE2(4),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>To finish our subproof, we see that we have a proposition about all creatures (<code>∀((x: T) => (Bunny(x) → Fluffy(x)))</code>) and that we are working with an individual creature (<code>thumper</code>). We can use <code>AllE[T]</code> to prove <code>Bunny(thumper) → Fluffy(thumper)</code>. After that, we have a few more manipulations using propositional logic rules, our <code>ExistsI[T]</code> rule to transition our claim from being about our alias <code>thumper</code> to being about an unnamed individual, and then our <code>ExistsE[T]</code> rule to pull our final claim out of the subproof. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∀((x: T) =&gt; (Bunny(x) → Fluffy(x))),
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>⊢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ∀((x: T) =&gt; (Bunny(x) → Fluffy(x)))         )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ∃((x: T) =&gt; (Fast(x) &amp; Bunny(x)))           )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 Assume(   Fast(thumper) ∧ Bunny(thumper)      ),
</span></span><span class=line><span class=cl>        5 (         Fast(thumper)                       )   by AndE1(4),
</span></span><span class=line><span class=cl>        6 (         Bunny(thumper)                      )   by AndE2(4),
</span></span><span class=line><span class=cl>        7 (         Bunny(thumper) → Fluffy(thumper)    )   by AllE[T](1),
</span></span><span class=line><span class=cl>        8 (         Fluffy(thumper)                     )   by ImplyE(7, 6),
</span></span><span class=line><span class=cl>        9 (         Fast(thumper) ∧ Fluffy(thumper)     )   by AndI(5, 8),
</span></span><span class=line><span class=cl>        10 (        ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))  )   by ExistsI[T](9)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    11 (    ∃((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))          )   by ExistsE[T](2, 3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><footer class=footline></footer></article></div></main></div><script src=/cis301/js/clipboard.min.js?1736806682 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1736806682 defer></script><script src=/cis301/js/theme.js?1736806682 defer></script><script src=/cis301/js/embed-iframe.js?1736806682 defer></script></body></html>