<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="In this section, we will see the two inference rules for the existential (âˆƒ) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Rules with âˆƒ :: CIS 301 Textbook"><meta name=twitter:description content="In this section, we will see the two inference rules for the existential (âˆƒ) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/6-chapter/6_2-existrules/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Rules with âˆƒ :: CIS 301 Textbook"><meta property="og:description" content="In this section, we will see the two inference rules for the existential (âˆƒ) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Proofs"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-10-23T10:50:31-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Rules with âˆƒ :: CIS 301 Textbook"><meta itemprop=description content="In this section, we will see the two inference rules for the existential (âˆƒ) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-10-23T10:50:31-05:00"><meta itemprop=wordCount content="1793"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Rules with âˆƒ :: CIS 301 Textbook</title><link href=/cis301/6-chapter/6_2-existrules/index.xml rel=alternate type=application/rss+xml title="Rules with âˆƒ :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_2-existrules/index.print.html rel=alternate type=text/html title="Rules with âˆƒ :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_2-existrules/tele.html rel=alternate type=text/html title="Rules with âˆƒ :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_2-existrules/embed.html rel=alternate type=text/html title="Rules with âˆƒ :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1768493675 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1768493675 defer></script><script src=/cis301/js/search-lunr.min.js?1768493675 defer></script><script src=/cis301/js/search.min.js?1768493675 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1768493675"</script><script src=/cis301/js/lunr/lunr.min.js?1768493675 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1768493675 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1768493675 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1768493675 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1768493675 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1768493675 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1768493675 rel=stylesheet><link href=/cis301/css/theme.min.css?1768493675 rel=stylesheet><link href=/cis301/css/format-html.min.css?1768493675 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/6-chapter/6_2-existrules/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["auto","light-theme","dark-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!0,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1768493675 rel=stylesheet></head><body class="mobile-support html" data-url=/cis301/6-chapter/6_2-existrules/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#exists-introduction>Exists introduction</a></li><li><a href=#exists-elimination>Exists elimination</a></li><li><a href=#examples>Examples</a><ul><li><a href=#example-1>Example 1</a></li><li><a href=#example-2>Example 2</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><a itemprop=item href=/cis301/index.html><span itemprop=name>CIS 301 Textbook</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/6-chapter/index.html><span itemprop=name>Predicate Logic Proofs</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Rules with âˆƒ</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis301/edit/main/content/6-chapter/6_2-existRules.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_2-existrules/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_1-univrules/index.html title="Rules with âˆ€ (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_3-nested/index.html title="Nested Quantifiers (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_2-existrules/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_2-existrules/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 6-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=rules-with->Rules with âˆƒ</h1><p>In this section, we will see the two inference rules for the existential (âˆƒ) quantifier.</p><h2 id=exists-introduction>Exists introduction</h2><p>We can use the exists introduction rule, <code>ExistsI[T]</code>, when we have a proposition of the form <code>P(a)</code> for an arbitrary member <code>a</code> of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                   P(d)         where  d  is an individual of type T
</span></span><span style=display:flex><span>ExistsI[T]: ---------------------
</span></span><span style=display:flex><span>              âˆƒ((x: T) =&gt; P(x))</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>ExistsI[T]</code> rule (where <em>Socrates</em> is a parameter of type <code>T</code> to our proof function):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   isHuman(Socrates)   ) âŠ¢ (   âˆƒ((x: T) =&gt; isHuman(x))  )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span style=display:flex><span>        2 (     âˆƒ((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>When we use the <code>ExistsI[T]</code> rule to justify a claim like <code>âˆƒ((x: T) => P(x))</code>, we include the line number of where the proposition held for a particular individual. In the proof above, we claim <code>âˆƒ((x: T) => isHuman(x))</code> with justification <code>ExistsI[T](1)</code> &ndash; line 1 corresponds to <code>isHuman(Socrates)</code>, where our <code>âˆƒ((x: T) => isHuman(x))</code> proposition held for a particular individual. The full proof function, which shows how <em>Socrates</em> can be accepted as a parameter of type <code>T</code>, is here:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>@pure def ExistsExample[T](isHuman: T =&gt; B @pure, Socrates: T): Unit = {
</span></span><span style=display:flex><span>    Deduce(
</span></span><span style=display:flex><span>        (   isHuman(Socrates)   ) âŠ¢ (   âˆƒ((x: T) =&gt; isHuman(x))  )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        Proof(
</span></span><span style=display:flex><span>            1 (     isHuman(Socrates)       )   by Premise,
</span></span><span style=display:flex><span>            2 (     âˆƒ((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Note that we can use the <code>ExistsI[T]</code> rule to introduce any variable, not just <code>x</code>. You can choose which variable to introduce based on the variables used in the conclusion. For example, the following proof is also valid:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   isHuman(Socrates)   ) âŠ¢ (   âˆƒ((z: T) =&gt; isHuman(z))  )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Proof(
</span></span><span style=display:flex><span>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span style=display:flex><span>        2 (     âˆƒ((z: T) =&gt; isHuman(z)) )   by ExistsI[T](1)
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><h2 id=exists-elimination>Exists elimination</h2><p>Since the <code>ExistsI[T]</code>-rule constructs propositions that begin with <code>âˆƒ</code>, the <code>ExistsE[T]</code>-rule (exists elimination) disassembles propositions that begin with <code>âˆƒ</code>.</p><p>Here is a quick example (where our domain is living things):</p><ul><li>All humans are mortal</li><li>Someone is human</li><li>Therefore, someone is mortal</li></ul><p>We don&rsquo;t know the name of the human, but it does not matter. Since ALL humans are mortal and SOMEONE is human, then our anonymous human must be mortal. The steps will go like this:</p><ul><li><p>Since &ldquo;someone is human&rdquo; and since we do not know his/her name, we will just make up our own name for them â€“ &ldquo;Jane&rdquo;. So, we assume that &ldquo;Jane is human&rdquo;.</p></li><li><p>We use the logic rules we already know to prove that &ldquo;Jane is mortal&rdquo;.</p></li><li><p>Therefore, SOMEONE is mortal and their name does not matter.</p></li></ul><p>This approach is coded into the last logic law, <code>ExistsE[T]</code> (exists elimination).</p><p>Suppose we have a premise of the form <code>âˆƒ((x: T) => P(x))</code>. Since we do not know the name of the individual &ldquo;hidden&rdquo; behind the <code>âˆƒ(x: T)</code>, we make up a name for it, say <code>a</code>, and discuss what must follow from the assumption that <code>P(a)</code> holds true. Here is the formalization of the <code>ExistsE[T]</code> rule:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>                                        Let ((a: T) =&gt; SubProof(          // where  a  is a new, fresh name
</span></span><span style=display:flex><span>                                             Assume( P(a) ),              // a  MUST NOT appear in  Q
</span></span><span style=display:flex><span>                âˆƒ((x: T) =&gt; P(x))            ...
</span></span><span style=display:flex><span>                                             Q         
</span></span><span style=display:flex><span>                                        )),             
</span></span><span style=display:flex><span>ExistsE[T]: ----------------------------------------------------
</span></span><span style=display:flex><span>                     Q</span></span></code></pre></div><p>That is, if we can deduce <code>Q</code> from <code>P(a)</code>, and we do not mention <code>a</code> within <code>Q</code>, then it means <code>Q</code> can be deduced no matter what name the hidden individual has. So, <code>Q</code> follows from <code>âˆƒ((x: T) => P(x))</code>.</p><p>We can work the previous example, with <code>ExistsE[T]</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>All humans are mortal
</span></span><span style=display:flex><span>Someone is human
</span></span><span style=display:flex><span>Therefore, someone is mortal</span></span></code></pre></div><p>We make up the name, <code>jane</code>, for the human whose name we do not know:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((h: T) =&gt; (isHuman(h) â†’ isMortal(h))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; isHuman(x))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((y: T) =&gt; (isMortal(y)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((h: T) =&gt; (isHuman(h) â†’ isMortal(h)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆƒ((x: T) =&gt; isHuman(x))                     )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (jane: T) =&gt; SubProof (
</span></span><span style=display:flex><span>        4 Assume(   isHuman(jane)                       ),
</span></span><span style=display:flex><span>        5 (         isHuman(jane) â†’ isMortal(jane)      )   by AllE[T](1),
</span></span><span style=display:flex><span>        6 (         isMortal(jane)                      )   by ImplyE(5, 4)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    7 (     âˆƒ((y: T) =&gt; (isMortal(y)))                  )   by ExistsE[T](2, 3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>Line 3 proposes the name <code>jane</code> for our subproof and line 4 makes the assumption <code>isHuman(jane)</code> (based on the premise <code>âˆƒ((x: T) => isHuman(x))</code>). The subproof leads to Line 6, which says that someone is mortal. (We never learned the individual&rsquo;s name!) Since Line 6 does not explicitly mention the made-up name, <code>jane</code>, we use Line 7 to repeat Line 6 â€“ without knowing the name of the individual &ldquo;hiding&rdquo; inside Line 2, we made a subproof that proves the result, anyway. This is how <code>ExistsE[T]</code> works.</p><p>Note that when we use the <code>ExistsE[T]</code> rule as a justification we include first the line number of the there exists statement that we processed (by naming the hidden individual) in the previous subproof, and then the line number of that subproof. In the example above, we say <code>ExistsE[T](2, 3)</code> because line 2 includes the there-exists statement we processed (<code>âˆƒ âˆƒ((x: T) => isHuman(x))</code>) in the previous subproof and line 3 is the subproof.</p><p>When using <code>ExistsE[T]</code>, the previous subproof must begin with introducing a name for a hidden individual in a there-exists statement and then immediately make an assumption that substitutes the name into the there exists statement. The last line in the subproof should contain NO mention of the chosen name. Whatever we claim on the last line in the subproof, we must claim EXACTLY the same thing immediately afterwards when we use the <code>ExistsE[T]</code> rule.</p><p>You are welcome to use any name for the hidden individual &ndash; not just <code>jane</code> or <code>a</code>. The only restriction is that you cannot have used the name anywhere else in the proof.</p><h2 id=examples>Examples</h2><p>In this section, we will look at other proofs involving the existential quantifier.</p><h3 id=example-1>Example 1</h3><p>Suppose we wish to prove the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)))  ) âŠ¢ (   âˆƒ((x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)  )</span></span></code></pre></div><p>We will begin as we did previously: by introducing an alias for our person that is either an adult or a kid (say, <code>alice</code>):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)))  ) âŠ¢ (   âˆƒ((x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)) )       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        3 Assume(   Adult(alice) âˆ¨ Kid(alice)       ),
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        //goal: get to our conclusion, âˆƒ( (x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ( (x: T) =&gt; Kid(x)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>To finish our proof, we can use OR elimination on <code>Adult(alice) âˆ¨ Kid(alice)</code>, and then <code>ExistsE[T]</code> afterwards to restate our conclusion. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(   âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)))  ) âŠ¢ (   âˆƒ((x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆƒ((x: T) =&gt; (Adult(x) âˆ¨ Kid(x)) )                   )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        3 Assume(   Adult(alice) âˆ¨ Kid(alice)                   ),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        4 SubProof(
</span></span><span style=display:flex><span>            5 Assume (  Adult(alice)                            ),
</span></span><span style=display:flex><span>            6 (     âˆƒ((x: T) =&gt; Adult(x)                        )   by ExistsI[T](5),
</span></span><span style=display:flex><span>            7 (     âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)   )   by OrI1(6)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        8 SubProof(
</span></span><span style=display:flex><span>            9 Assume (  Kid(alice)                              ),
</span></span><span style=display:flex><span>            10 (    âˆƒ((x: T) =&gt; Kid(x)                          )   by ExistsI[T](9),
</span></span><span style=display:flex><span>            11 (    âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)   )   by OrI2(10)
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        12 (    âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)       )   by OrE(3, 4, 8)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        //goal: get to our conclusion, âˆƒ( (x: T) =&gt; Adult(x) )) âˆ¨ âˆƒ( (x: T) =&gt; Kid(x)
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    13 (        âˆƒ((x: T) =&gt; Adult(x) âˆ¨ âˆƒ((x: T) =&gt; Kid(x)       )   by ExistsE[T](1, 2)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><h3 id=example-2>Example 2</h3><p>Suppose we wish to prove the following (in the domain of living things):</p><ul><li>All bunnies are fluffy</li><li>There is a fast bunny</li><li>Therefore, there is a creature that is fast and fluffy</li></ul><p>We can translate our premises and desired conclusion to predicate logic, and write the following sequent:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )</span></span></code></pre></div><p>Since we are trying to prove a claim about some individual, it makes sense that we would start the process of an <code>ExistsE[T]</code> subproof where we introduce an alias (<code>thumper</code>) for the fast bunny. We will try to reach the conclusion by the end of that subproof. Here is the setup:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x)))     )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x)))       )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 Assume(   Fast(thumper) âˆ§ Bunny(thumper)  ),
</span></span><span style=display:flex><span>        5 (         Fast(thumper)                   )   by AndE1(4),
</span></span><span style=display:flex><span>        6 (         Bunny(thumper)                  )   by AndE2(4),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span style=display:flex><span>)</span></span></code></pre></div><p>To finish our subproof, we see that we have a proposition about all creatures (<code>âˆ€((x: T) => (Bunny(x) â†’ Fluffy(x)))</code>) and that we are working with an individual creature (<code>thumper</code>). We can use <code>AllE[T]</code> to prove <code>Bunny(thumper) â†’ Fluffy(thumper)</code>. After that, we have a few more manipulations using propositional logic rules, our <code>ExistsI[T]</code> rule to transition our claim from being about our alias <code>thumper</code> to being about an unnamed individual, and then our <code>ExistsE[T]</code> rule to pull our final claim out of the subproof. Here is the completed proof:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x))),
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>âŠ¢
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>Proof(
</span></span><span style=display:flex><span>    1 (     âˆ€((x: T) =&gt; (Bunny(x) â†’ Fluffy(x)))         )   by Premise,
</span></span><span style=display:flex><span>    2 (     âˆƒ((x: T) =&gt; (Fast(x) &amp; Bunny(x)))           )   by Premise,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span style=display:flex><span>        4 Assume(   Fast(thumper) âˆ§ Bunny(thumper)      ),
</span></span><span style=display:flex><span>        5 (         Fast(thumper)                       )   by AndE1(4),
</span></span><span style=display:flex><span>        6 (         Bunny(thumper)                      )   by AndE2(4),
</span></span><span style=display:flex><span>        7 (         Bunny(thumper) â†’ Fluffy(thumper)    )   by AllE[T](1),
</span></span><span style=display:flex><span>        8 (         Fluffy(thumper)                     )   by ImplyE(7, 6),
</span></span><span style=display:flex><span>        9 (         Fast(thumper) âˆ§ Fluffy(thumper)     )   by AndI(5, 8),
</span></span><span style=display:flex><span>        10 (        âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))  )   by ExistsI[T](9)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //goal: âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span style=display:flex><span>    )),
</span></span><span style=display:flex><span>    //use ExistsE[T] to restate âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    11 (    âˆƒ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))          )   by ExistsE[T](2, 3)
</span></span><span style=display:flex><span>)</span></span></code></pre></div><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/fa072b78d09cd5f45bace19f89c339906ac87d98>Oct 23, 2024</a></p></div></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=/cis301/>CIS 301: Logical Foundations of Programming</a></div><search><form action=/cis301/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class=default-animation><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/cis301/0-chapter/index.html><input type=checkbox id=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9 aria-controls=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9><label for=R-section-7e83aa12039d4bb654d0ecd6f2bdf7b9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Getting Started</span></label><a class=padding href=/cis301/0-chapter/index.html><b>0. </b>Getting Started</a><ul id=R-subsections-7e83aa12039d4bb654d0ecd6f2bdf7b9 class=collapsible-menu><li data-nav-id=/cis301/0-chapter/0_1-toolsguide/index.html><a class=padding href=/cis301/0-chapter/0_1-toolsguide/index.html>0.1. Tools Guide</a></li><li data-nav-id=/cis301/0-chapter/0_2-gitinstall/index.html><a class=padding href=/cis301/0-chapter/0_2-gitinstall/index.html>0.2. git Install</a></li></ul></li><li data-nav-id=/cis301/1-chapter/index.html><input type=checkbox id=R-section-cbcda2db56d129074f1e03beb13f9103 aria-controls=R-subsections-cbcda2db56d129074f1e03beb13f9103><label for=R-section-cbcda2db56d129074f1e03beb13f9103><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Basics and Logic Puzzles</span></label><a class=padding href=/cis301/1-chapter/index.html><b>1. </b>Basics and Logic Puzzles</a><ul id=R-subsections-cbcda2db56d129074f1e03beb13f9103 class=collapsible-menu><li data-nav-id=/cis301/1-chapter/1_1-logicbasics/index.html><a class=padding href=/cis301/1-chapter/1_1-logicbasics/index.html>1.1. Basic Logical Reasoning</a></li><li data-nav-id=/cis301/1-chapter/1_2-knightsknaves/index.html><a class=padding href=/cis301/1-chapter/1_2-knightsknaves/index.html>1.2. Knights and Knaves</a></li><li data-nav-id=/cis301/1-chapter/1_3-otherpuzzles/index.html><a class=padding href=/cis301/1-chapter/1_3-otherpuzzles/index.html>1.3. Other Puzzles</a></li></ul></li><li data-nav-id=/cis301/2-chapter/index.html><input type=checkbox id=R-section-d672bd5f3e40d734b815889ecb0b088e aria-controls=R-subsections-d672bd5f3e40d734b815889ecb0b088e><label for=R-section-d672bd5f3e40d734b815889ecb0b088e><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Truth Tables</span></label><a class=padding href=/cis301/2-chapter/index.html><b>2. </b>Truth Tables</a><ul id=R-subsections-d672bd5f3e40d734b815889ecb0b088e class=collapsible-menu><li data-nav-id=/cis301/2-chapter/2_1-opscircuits/index.html><a class=padding href=/cis301/2-chapter/2_1-opscircuits/index.html>2.1. Operators and Circuits</a></li><li data-nav-id=/cis301/2-chapter/2_2-logikatruth/index.html><a class=padding href=/cis301/2-chapter/2_2-logikatruth/index.html>2.2. Truth Tables in Logika</a></li><li data-nav-id=/cis301/2-chapter/2_3-satis/index.html><a class=padding href=/cis301/2-chapter/2_3-satis/index.html>2.3. Satisfiability</a></li><li data-nav-id=/cis301/2-chapter/2_4-logicalequiv/index.html><a class=padding href=/cis301/2-chapter/2_4-logicalequiv/index.html>2.4. Logical Equivalence</a></li><li data-nav-id=/cis301/2-chapter/2_5-sementail/index.html><a class=padding href=/cis301/2-chapter/2_5-sementail/index.html>2.5. Semantic Entailment</a></li></ul></li><li data-nav-id=/cis301/3-chapter/index.html><input type=checkbox id=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73 aria-controls=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73><label for=R-section-09cc6a9ad2b94e26ef9b1dcd9f8eff73><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Translations</span></label><a class=padding href=/cis301/3-chapter/index.html><b>3. </b>Propositional Logic Translations</a><ul id=R-subsections-09cc6a9ad2b94e26ef9b1dcd9f8eff73 class=collapsible-menu><li data-nav-id=/cis301/3-chapter/3_1-propatom/index.html><a class=padding href=/cis301/3-chapter/3_1-propatom/index.html>3.1. Propositional Atoms</a></li><li data-nav-id=/cis301/3-chapter/3_2-notandor/index.html><a class=padding href=/cis301/3-chapter/3_2-notandor/index.html>3.2. NOT, AND, OR Translations</a></li><li data-nav-id=/cis301/3-chapter/3_3-implies/index.html><a class=padding href=/cis301/3-chapter/3_3-implies/index.html>3.3. Implies Translations</a></li><li data-nav-id=/cis301/3-chapter/3_4-equiv/index.html><a class=padding href=/cis301/3-chapter/3_4-equiv/index.html>3.4. Equivalent Translations</a></li><li data-nav-id=/cis301/3-chapter/3_5-knightsknavestt/index.html><a class=padding href=/cis301/3-chapter/3_5-knightsknavestt/index.html>3.5. Knights and Knaves, revisited</a></li></ul></li><li data-nav-id=/cis301/4-chapter/index.html><input type=checkbox id=R-section-a0d0660e4f5f539642b53fac77ff44c7 aria-controls=R-subsections-a0d0660e4f5f539642b53fac77ff44c7><label for=R-section-a0d0660e4f5f539642b53fac77ff44c7><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Propositional Logic Proofs</span></label><a class=padding href=/cis301/4-chapter/index.html><b>4. </b>Propositional Logic Proofs</a><ul id=R-subsections-a0d0660e4f5f539642b53fac77ff44c7 class=collapsible-menu><li data-nav-id=/cis301/4-chapter/4_1-intro/index.html><a class=padding href=/cis301/4-chapter/4_1-intro/index.html>4.1. Introduction</a></li><li data-nav-id=/cis301/4-chapter/4_2-andrules/index.html><a class=padding href=/cis301/4-chapter/4_2-andrules/index.html>4.2. AND Rules</a></li><li data-nav-id=/cis301/4-chapter/4_3-orrules/index.html><a class=padding href=/cis301/4-chapter/4_3-orrules/index.html>4.3. OR Rules</a></li><li data-nav-id=/cis301/4-chapter/4_4-impliesrules/index.html><a class=padding href=/cis301/4-chapter/4_4-impliesrules/index.html>4.4. Implies Rules</a></li><li data-nav-id=/cis301/4-chapter/4_5-notrules/index.html><a class=padding href=/cis301/4-chapter/4_5-notrules/index.html>4.5. Negation Rules</a></li><li data-nav-id=/cis301/4-chapter/4_6-strategies/index.html><a class=padding href=/cis301/4-chapter/4_6-strategies/index.html>4.6. Summary and Strategies</a></li><li data-nav-id=/cis301/4-chapter/4_7-theorems/index.html><a class=padding href=/cis301/4-chapter/4_7-theorems/index.html>4.7. Theorems</a></li><li data-nav-id=/cis301/4-chapter/4_8-equivalence/index.html><a class=padding href=/cis301/4-chapter/4_8-equivalence/index.html>4.8. Equivalence</a></li><li data-nav-id=/cis301/4-chapter/4_9-soundcomplete/index.html><a class=padding href=/cis301/4-chapter/4_9-soundcomplete/index.html>4.9. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/5-chapter/index.html><input type=checkbox id=R-section-589c35b8ff6263b7311a10a4d0fa83a9 aria-controls=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9><label for=R-section-589c35b8ff6263b7311a10a4d0fa83a9><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Translations</span></label><a class=padding href=/cis301/5-chapter/index.html><b>5. </b>Predicate Logic Translations</a><ul id=R-subsections-589c35b8ff6263b7311a10a4d0fa83a9 class=collapsible-menu><li data-nav-id=/cis301/5-chapter/5_1-motivation/index.html><a class=padding href=/cis301/5-chapter/5_1-motivation/index.html>5.1. Motivation</a></li><li data-nav-id=/cis301/5-chapter/5_2-predsyntax/index.html><a class=padding href=/cis301/5-chapter/5_2-predsyntax/index.html>5.2. Syntax</a></li><li data-nav-id=/cis301/5-chapter/5_3-singlequantifier/index.html><a class=padding href=/cis301/5-chapter/5_3-singlequantifier/index.html>5.3. Single Quantifier</a></li><li data-nav-id=/cis301/5-chapter/5_4-multquant/index.html><a class=padding href=/cis301/5-chapter/5_4-multquant/index.html>5.4. Multiple Quantifiers</a></li></ul></li><li class=parent data-nav-id=/cis301/6-chapter/index.html><input type=checkbox id=R-section-55edc31437b1ec5edead9beb4ef7d1fa aria-controls=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa checked><label for=R-section-55edc31437b1ec5edead9beb4ef7d1fa><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Predicate Logic Proofs</span></label><a class=padding href=/cis301/6-chapter/index.html><b>6. </b>Predicate Logic Proofs</a><ul id=R-subsections-55edc31437b1ec5edead9beb4ef7d1fa class=collapsible-menu><li data-nav-id=/cis301/6-chapter/6_0-logikasyntax/index.html><a class=padding href=/cis301/6-chapter/6_0-logikasyntax/index.html>6.0. Logika Predicate Logic Proof Syntax</a></li><li data-nav-id=/cis301/6-chapter/6_1-univrules/index.html><a class=padding href=/cis301/6-chapter/6_1-univrules/index.html>6.1. Rules with âˆ€</a></li><li class=active data-nav-id=/cis301/6-chapter/6_2-existrules/index.html><a class=padding href=/cis301/6-chapter/6_2-existrules/index.html>6.2. Rules with âˆƒ</a></li><li data-nav-id=/cis301/6-chapter/6_3-nested/index.html><a class=padding href=/cis301/6-chapter/6_3-nested/index.html>6.3. Nested Quantifiers</a></li><li data-nav-id=/cis301/6-chapter/6_4-equiv/index.html><a class=padding href=/cis301/6-chapter/6_4-equiv/index.html>6.4. Equivalence</a></li><li data-nav-id=/cis301/6-chapter/6_5-strategies/index.html><a class=padding href=/cis301/6-chapter/6_5-strategies/index.html>6.5. Summary and Strategies</a></li><li data-nav-id=/cis301/6-chapter/6_6-soundcomplete/index.html><a class=padding href=/cis301/6-chapter/6_6-soundcomplete/index.html>6.6. Soundness and Completeness</a></li></ul></li><li data-nav-id=/cis301/7-chapter/index.html><input type=checkbox id=R-section-cbba04bde749b4229ea56fb5a7c6a953 aria-controls=R-subsections-cbba04bde749b4229ea56fb5a7c6a953><label for=R-section-cbba04bde749b4229ea56fb5a7c6a953><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Mathematical Induction</span></label><a class=padding href=/cis301/7-chapter/index.html><b>7. </b>Mathematical Induction</a><ul id=R-subsections-cbba04bde749b4229ea56fb5a7c6a953 class=collapsible-menu><li data-nav-id=/cis301/7-chapter/7_1-process/index.html><a class=padding href=/cis301/7-chapter/7_1-process/index.html>7.1. Induction Process</a></li><li data-nav-id=/cis301/7-chapter/7_2-algebraex/index.html><a class=padding href=/cis301/7-chapter/7_2-algebraex/index.html>7.2. Algebra example</a></li><li data-nav-id=/cis301/7-chapter/7_3-divex/index.html><a class=padding href=/cis301/7-chapter/7_3-divex/index.html>7.3. Divisibility example</a></li><li data-nav-id=/cis301/7-chapter/7_4-setex/index.html><a class=padding href=/cis301/7-chapter/7_4-setex/index.html>7.4. Set example</a></li></ul></li><li data-nav-id=/cis301/8-chapter/index.html><input type=checkbox id=R-section-010016ee1ce3fc8b575a95f1204dba7b aria-controls=R-subsections-010016ee1ce3fc8b575a95f1204dba7b><label for=R-section-010016ee1ce3fc8b575a95f1204dba7b><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Intro to Programming Logic</span></label><a class=padding href=/cis301/8-chapter/index.html><b>8. </b>Intro to Programming Logic</a><ul id=R-subsections-010016ee1ce3fc8b575a95f1204dba7b class=collapsible-menu><li data-nav-id=/cis301/8-chapter/8_1-goal/index.html><a class=padding href=/cis301/8-chapter/8_1-goal/index.html>8.1. Programming Logic Goal</a></li><li data-nav-id=/cis301/8-chapter/8_2-logikaprograms/index.html><a class=padding href=/cis301/8-chapter/8_2-logikaprograms/index.html>8.2. Logika Programs</a></li><li data-nav-id=/cis301/8-chapter/8_3-assertassume/index.html><a class=padding href=/cis301/8-chapter/8_3-assertassume/index.html>8.3. Assert and Assume</a></li><li data-nav-id=/cis301/8-chapter/8_4-algebrasubst/index.html><a class=padding href=/cis301/8-chapter/8_4-algebrasubst/index.html>8.4. Algebra and Subst Rules</a></li><li data-nav-id=/cis301/8-chapter/8_5-assignment/index.html><a class=padding href=/cis301/8-chapter/8_5-assignment/index.html>8.5. Assignment Statements</a></li><li data-nav-id=/cis301/8-chapter/8_6-divmod/index.html><a class=padding href=/cis301/8-chapter/8_6-divmod/index.html>8.6. Integer Division and Modulo</a></li><li data-nav-id=/cis301/8-chapter/8_7-conditionals/index.html><a class=padding href=/cis301/8-chapter/8_7-conditionals/index.html>8.7. Conditional Statements</a></li></ul></li><li data-nav-id=/cis301/9-chapter/index.html><input type=checkbox id=R-section-6864880b2cc643485ab906a5e309eaaf aria-controls=R-subsections-6864880b2cc643485ab906a5e309eaaf><label for=R-section-6864880b2cc643485ab906a5e309eaaf><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Functions and Loops</span></label><a class=padding href=/cis301/9-chapter/index.html><b>9. </b>Functions and Loops</a><ul id=R-subsections-6864880b2cc643485ab906a5e309eaaf class=collapsible-menu><li data-nav-id=/cis301/9-chapter/9_1-functions/index.html><a class=padding href=/cis301/9-chapter/9_1-functions/index.html>9.1. Functions</a></li><li data-nav-id=/cis301/9-chapter/9_2-recursion/index.html><a class=padding href=/cis301/9-chapter/9_2-recursion/index.html>9.2. Recursion</a></li><li data-nav-id=/cis301/9-chapter/9_3-loops/index.html><a class=padding href=/cis301/9-chapter/9_3-loops/index.html>9.3. Loops</a></li><li data-nav-id=/cis301/9-chapter/9_4-logikafacts/index.html><a class=padding href=/cis301/9-chapter/9_4-logikafacts/index.html>9.4. Logika Facts</a></li><li data-nav-id=/cis301/9-chapter/9_5-summary/index.html><a class=padding href=/cis301/9-chapter/9_5-summary/index.html>9.5. Summary</a></li></ul></li><li data-nav-id=/cis301/10-chapter/index.html><input type=checkbox id=R-section-b363793b1b72566b579f69cd488e8039 aria-controls=R-subsections-b363793b1b72566b579f69cd488e8039><label for=R-section-b363793b1b72566b579f69cd488e8039><i class="fa-fw fas fa-chevron-right"></i><span class=a11y-only>Submenu Sequences, Globals, and Termination</span></label><a class=padding href=/cis301/10-chapter/index.html><b>10. </b>Sequences, Globals, and Termination</a><ul id=R-subsections-b363793b1b72566b579f69cd488e8039 class=collapsible-menu><li data-nav-id=/cis301/10-chapter/10_1-modes/index.html><a class=padding href=/cis301/10-chapter/10_1-modes/index.html>10.1 Logika Modes</a></li><li data-nav-id=/cis301/10-chapter/10_2-intosequences/index.html><a class=padding href=/cis301/10-chapter/10_2-intosequences/index.html>10.2 Intro to Sequences</a></li><li data-nav-id=/cis301/10-chapter/10_3-seqfn/index.html><a class=padding href=/cis301/10-chapter/10_3-seqfn/index.html>10.3 Sequences in Functions</a></li><li data-nav-id=/cis301/10-chapter/10_4-seqloop/index.html><a class=padding href=/cis301/10-chapter/10_4-seqloop/index.html>10.4 Sequences in Loops</a></li><li data-nav-id=/cis301/10-chapter/10_5-globals/index.html><a class=padding href=/cis301/10-chapter/10_5-globals/index.html>10.5 Global Variables</a></li><li data-nav-id=/cis301/10-chapter/10_6-termination/index.html><a class=padding href=/cis301/10-chapter/10_6-termination/index.html>10.6 Termination</a></li></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul><li class=R-variantswitcher><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant><option id=R-select-variant-auto value=auto selected>KSU Auto</option><option id=R-select-variant-light-theme value=light-theme>KSU Light</option><option id=R-select-variant-dark-theme value=dark-theme>KSU Dark</option></select></div><div class=clear></div></div><script>window.relearn.markVariant()</script></li></ul></div><div id=R-footer><p>Built using <a href=http://gohugo.io/>Hugo</a> and <a href=https://github.com/ksu-cs-textbooks/hugo-theme-relearn>Hugo Relearn Theme</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt="Creative Commons License" style="border-width:0;margin:.5rem auto" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</a></p></div></div></aside><script src=/cis301/js/clipboard/clipboard.min.js?1768493675 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1768493675 defer></script><script src=/cis301/js/theme.min.js?1768493675 defer></script></body></html>