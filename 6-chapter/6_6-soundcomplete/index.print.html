<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Soundness and Completeness :: CIS 301 Textbook"><meta name=twitter:description content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/6-chapter/6_6-soundcomplete/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Soundness and Completeness :: CIS 301 Textbook"><meta property="og:description" content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Proofs"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-08-13T15:44:21-05:00"><meta itemprop=name content="Soundness and Completeness :: CIS 301 Textbook"><meta itemprop=description content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-08-13T15:44:21-05:00"><meta itemprop=wordCount content="963"><title>Soundness and Completeness :: CIS 301 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis301/6-chapter/6_6-soundcomplete/ rel=canonical type=text/html title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_6-soundcomplete/index.xml rel=alternate type=application/rss+xml title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_6-soundcomplete/tele.html rel=alternate type=text/html title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_6-soundcomplete/embed.html rel=alternate type=text/html title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1729873064 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1729873064 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1729873064 rel=stylesheet><link href=/cis301/css/auto-complete.css?1729873064 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1729873064 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1729873064 rel=stylesheet><link href=/cis301/css/fonts.css?1729873064 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1729873064 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1729873064 rel=stylesheet><link href=/cis301/css/theme-auto.css?1729873064 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1729873064 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1729873064 rel=stylesheet><link href=/cis301/css/print.css?1729873064 rel=stylesheet media=print><link href=/cis301/css/format-print.css?1729873064 rel=stylesheet><script src=/cis301/js/variant.js?1729873064></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1729873064 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis301/6-chapter/6_6-soundcomplete/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis301/6-chapter/><span itemprop=name>Predicate Logic Proofs</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Soundness and Completeness</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_5-strategies/ title="Summary and Strategies (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/7-chapter/ title="Mathematical Induction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=soundness-and-completeness>Soundness and Completeness</h1><h2 id=soundness-and-completeness-definitions>Soundness and completeness definitions</h2><p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p><h2 id=interpretations>Interpretations</h2><p>When we write statements in logic, we use predicates and function symbols (e.g., <code>∀ i (i * 2) > i</code>). An interpretation gives the meaning of:</p><ul><li><p>The underlying domain – what set of elements it names</p></li><li><p>Each function symbol – what answers it computes from its parameters from the domain</p></li><li><p>Each predicate – which combinations of arguments from the domain lead to true answers and false answers</p></li></ul><h3 id=interpretation-example---integers>Interpretation example - integers</h3><p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>></code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p><p>The standard interpretation of arithmetic is that:</p><ul><li><p><code>int</code> names the set of all integers</p></li><li><p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p></li><li><p><code>=</code> and <code>></code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p></li></ul><p>With this interpretation of arithmetic, we can interpret statements. For example,<code>∀ i (i * 2) > i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>∃ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p><p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>></code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>></code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n > m</code>.</p><p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 > 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p><p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p><h3 id=interpretation-example---predicates>Interpretation example - predicates</h3><p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p><p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p><h2 id=valid-sequents-in-predicate-logic>Valid sequents in predicate logic</h2><blockquote><p>A sequent, <code>P_1, P_2, ..., P_n ⊢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &mldr;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p></blockquote><h2 id=soundness-and-completeness-in-predicate-logic>Soundness and completeness in predicate logic</h2><p>We can then define soundness and completeness for predicate logic:</p><blockquote><p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n ⊢ Q</code>, then the sequent is valid (in all possible interpretations)</p></blockquote><blockquote><p><em>completeness:</em> When <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p></blockquote><p>Note that, if <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>></code>, and <code>=</code>. No appropriate rule set was devised.</p><p>In the early 20th century, Kurt Gödel showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. Gödel showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p><p>Gödel’s construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p><p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program that will tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/a737c96970a1f19ec3d1aacc63180f0d3769adbe>Aug 13, 2024</a></p></div></div><script src=/cis301/js/clipboard.min.js?1729873064 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1729873064 defer></script><script src=/cis301/js/theme.js?1729873064 defer></script></body></html>