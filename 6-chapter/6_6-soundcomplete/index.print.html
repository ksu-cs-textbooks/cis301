<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta name=twitter:title content="Soundness and Completeness :: CIS 301 Textbook"><meta name=twitter:description content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/6-chapter/6_6-soundcomplete/index.html"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Soundness and Completeness :: CIS 301 Textbook"><meta property="og:description" content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Predicate Logic Proofs"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-08-13T15:44:21-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><meta itemprop=name content="Soundness and Completeness :: CIS 301 Textbook"><meta itemprop=description content="Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:"><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-08-13T15:44:21-05:00"><meta itemprop=wordCount content="963"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis301/images/hero.png"><title>Soundness and Completeness :: CIS 301 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis301/6-chapter/6_6-soundcomplete/index.html rel=canonical type=text/html title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_6-soundcomplete/index.xml rel=alternate type=application/rss+xml title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_6-soundcomplete/tele.html rel=alternate type=text/html title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/6-chapter/6_6-soundcomplete/embed.html rel=alternate type=text/html title="Soundness and Completeness :: CIS 301 Textbook"><link href=/cis301/css/auto-complete/auto-complete.min.css?1755623696 rel=stylesheet><script src=/cis301/js/auto-complete/auto-complete.min.js?1755623696 defer></script><script src=/cis301/js/search-lunr.min.js?1755623696 defer></script><script src=/cis301/js/search.min.js?1755623696 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis301/searchindex.en.js?1755623696"</script><script src=/cis301/js/lunr/lunr.min.js?1755623696 defer></script><script src=/cis301/js/lunr/lunr.stemmer.support.min.js?1755623696 defer></script><script src=/cis301/js/lunr/lunr.multi.min.js?1755623696 defer></script><script src=/cis301/js/lunr/lunr.en.min.js?1755623696 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755623696 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/fonts/fontawesome/css/fontawesome-all.min.css?1755623696 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar/perfect-scrollbar.min.css?1755623696 rel=stylesheet><link href=/cis301/css/theme.min.css?1755623696 rel=stylesheet><link href=/cis301/css/format-print.min.css?1755623696 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/6-chapter/6_6-soundcomplete/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis301/css/custom.css?1755623696 rel=stylesheet></head><body class="mobile-support print" data-url=/cis301/6-chapter/6_6-soundcomplete/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 6-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=soundness-and-completeness>Soundness and Completeness</h1><h2 id=soundness-and-completeness-definitions>Soundness and completeness definitions</h2><p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p><h2 id=interpretations>Interpretations</h2><p>When we write statements in logic, we use predicates and function symbols (e.g., <code>∀ i (i * 2) > i</code>). An interpretation gives the meaning of:</p><ul><li><p>The underlying domain – what set of elements it names</p></li><li><p>Each function symbol – what answers it computes from its parameters from the domain</p></li><li><p>Each predicate – which combinations of arguments from the domain lead to true answers and false answers</p></li></ul><h3 id=interpretation-example---integers>Interpretation example - integers</h3><p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>></code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p><p>The standard interpretation of arithmetic is that:</p><ul><li><p><code>int</code> names the set of all integers</p></li><li><p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p></li><li><p><code>=</code> and <code>></code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p></li></ul><p>With this interpretation of arithmetic, we can interpret statements. For example,<code>∀ i (i * 2) > i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>∃ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p><p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>></code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>></code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n > m</code>.</p><p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 > 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p><p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p><h3 id=interpretation-example---predicates>Interpretation example - predicates</h3><p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p><p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p><h2 id=valid-sequents-in-predicate-logic>Valid sequents in predicate logic</h2><blockquote><p>A sequent, <code>P_1, P_2, ..., P_n ⊢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &mldr;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p></blockquote><h2 id=soundness-and-completeness-in-predicate-logic>Soundness and completeness in predicate logic</h2><p>We can then define soundness and completeness for predicate logic:</p><blockquote><p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n ⊢ Q</code>, then the sequent is valid (in all possible interpretations)</p></blockquote><blockquote><p><em>completeness:</em> When <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p></blockquote><p>Note that, if <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>></code>, and <code>=</code>. No appropriate rule set was devised.</p><p>In the early 20th century, Kurt Gödel showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. Gödel showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p><p>Gödel’s construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p><p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program that will tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p><footer class=footline></footer></article></div></main></div><script src=/cis301/js/clipboard/clipboard.min.js?1755623696 defer></script><script src=/cis301/js/perfect-scrollbar/perfect-scrollbar.min.js?1755623696 defer></script><script src=/cis301/js/theme.min.js?1755623696 defer></script></div><script src=/cis301/js/tele-scroll.min.js?1755623696 defer></script></body></html>