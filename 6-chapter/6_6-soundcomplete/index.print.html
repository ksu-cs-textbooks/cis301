




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Soundness and Completeness :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/index.html" rel="canonical" type="text/html" title="Soundness and Completeness :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/index.xml" rel="alternate" type="application/rss+xml" title="Soundness and Completeness :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/tele.html" rel="alternate" type="text/html" title="Soundness and Completeness :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/embed.html" rel="alternate" type="text/html" title="Soundness and Completeness :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1708359539" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1708359539" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1708359539" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1708359539" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1708359539" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1708359539" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1708359539" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1708359539" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1708359539" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1708359539" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1708359539" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1708359539" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/format-print.css?1708359539" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1708359539" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1708359539"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1708359539"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1708359539" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/index.html"><span itemprop="name">CIS 301 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.html"><span itemprop="name">Predicate Logic Proofs</span></a><meta itemprop="position" content="2"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Soundness and Completeness</span><meta itemprop="position" content="3"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="soundness-and-completeness">Soundness and Completeness</h1>

<h2 id="soundness-and-completeness-definitions">Soundness and completeness definitions</h2>
<p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p>
<h2 id="interpretations">Interpretations</h2>
<p>When we write statements in logic, we use predicates and function symbols (e.g., <code>∀ i (i * 2) &gt; i</code>). An interpretation gives the meaning of:</p>
<ul>
<li>
<p>The underlying domain – what set of elements it names</p>
</li>
<li>
<p>Each function symbol – what answers it computes from its parameters from the domain</p>
</li>
<li>
<p>Each predicate – which combinations of arguments from the domain lead to true answers and false answers</p>
</li>
</ul>
<h3 id="interpretation-example---integers">Interpretation example - integers</h3>
<p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>&gt;</code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p>
<p>The standard interpretation of arithmetic is that:</p>
<ul>
<li>
<p><code>int</code> names the set of all integers</p>
</li>
<li>
<p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p>
</li>
<li>
<p><code>=</code> and <code>&gt;</code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p>
</li>
</ul>
<p>With this interpretation of arithmetic, we can interpret statements. For example,<code>∀ i (i * 2) &gt; i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>∃ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p>
<p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>&gt;</code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>&gt;</code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n &gt; m</code>.</p>
<p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 &gt; 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p>
<p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p>
<h3 id="interpretation-example---predicates">Interpretation example - predicates</h3>
<p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p>
<p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p>
<h2 id="valid-sequents-in-predicate-logic">Valid sequents in predicate logic</h2>
<blockquote>
<p>A sequent, <code>P_1, P_2, ..., P_n ⊢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &hellip;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p>
</blockquote>
<h2 id="soundness-and-completeness-in-predicate-logic">Soundness and completeness in predicate logic</h2>
<p>We can then define soundness and completeness for predicate logic:</p>
<blockquote>
<p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n ⊢ Q</code>, then the sequent is valid (in all possible interpretations)</p>
</blockquote>
<blockquote>
<p><em>completeness:</em> When <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p>
</blockquote>
<p>Note that, if <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;</code>, and <code>=</code>. No appropriate rule set was devised.</p>
<p>In the early 20th century, Kurt Gödel showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. Gödel showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p>
<p>Gödel’s construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p>
<p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program that will tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p>

            <footer class="footline">

            </footer>
          </article>


        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Julie Thornton
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/d8fabecfb18d552b47c80e2c64c22af8b560ef55">Oct 18, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1708359539" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1708359539" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1708359539" defer></script>
  </body>
</html>
