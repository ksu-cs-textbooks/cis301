<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Predicate Logic Proofs :: CIS 301 Textbook</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/</link><description>Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as first order logic.
As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 23 Oct 2024 10:50:31 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis301/6-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Logika Predicate Logic Proof Syntax</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_0-logikasyntax/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_0-logikasyntax/</guid><description>We will use the following format in Logika to start a natural deduction proof for predicate logic. Each proof will be saved in a new file with a .sc (Scala) extension:
// #Sireum #Logika //@Logika: --manual --background type import org.sireum._ import org.sireum.justification._ import org.sireum.justification.natded.prop._ import org.sireum.justification.natded.pred._ @pure def ProofName[T](pred1: T => B @pure, pred2: T => B @pure, ..., indiv1: T, indiv2: T, ...): Unit = { Deduce( //@formatter:off (comma-separated list of premises with variable1, variable2, .</description></item><item><title>Rules with ∀</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_1-univrules/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_1-univrules/</guid><description>Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers – an “introduction rule and an “elimination” rule.
In this section, we will see the two inference rules for the universal (∀) quantifier.
For all elimination For all elimination allows us to take a claim that uses a universal quantifier – a statement about ALL individuals in a domain – and make the same statement about a specific individual in the domain.</description></item><item><title>Rules with ∃</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_2-existrules/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_2-existrules/</guid><description>In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</description></item><item><title>Nested Quantifiers</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_3-nested/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_3-nested/</guid><description>Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that ∀ x ∀ y P(x, y) is equivalent to ∀ x (∀ y P(x, y)).</description></item><item><title>Equivalence</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_4-equiv/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_4-equiv/</guid><description>In Chapter 5, we saw DeMorgan’s laws for quantifiers – that if we have some domain, and if P(x) is a predicate for individuals in that domain, then the following statements are equivalent:
¬(∃ x P(x)) is equivalent to ∀ x ¬P(x) ¬(∀ x P(x)) is equivalent to ∃ x ¬P(x) The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic – we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.</description></item><item><title>Summary and Strategies</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_5-strategies/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_5-strategies/</guid><description>In this section, we summarize all available rules in propositional logic, and discuss strategies for approaching proofs.
Rules with universal quantifier (∀) Rule summaries:
∀ ((x: T) => P(x)) AllE[T]: --------------------- P(v) where v is a particular individual in the domain (i.e, v has type T) Let ( (a: T) => SubProof( ... P(a) )), AllI[T] : ------------------------------- ∀ ((x: T) => P(x)) Rule syntax summaries:
( ... r ( ∀ ((x: T) => P(x)) ) by SomeJustification, s ( P(v) ) by AllE[T](r), //where v has been previously shown to have type T .</description></item><item><title>Soundness and Completeness</title><link>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_6-soundcomplete/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis301/6-chapter/6_6-soundcomplete/</guid><description>Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:</description></item></channel></rss>