




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Predicate Logic Proofs on CIS 301 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.html</link>
    <description>Recent content in Predicate Logic Proofs on CIS 301 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rules with ∀</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_1-univrules/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_1-univrules/index.html</guid>
      <description>Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers &amp;ndash; an &amp;ldquo;introduction rule and an &amp;ldquo;elimination&amp;rdquo; rule.
In this section, we will see the two inference rules for the universal (∀) quantifier.
For all elimination For all elimination allows us to take a claim that uses a universal quantifier &amp;ndash; a statement about ALL individuals in a domain &amp;ndash; and make the same statement about a specific individual in the domain.</description>
    </item>
    <item>
      <title>Rules with ∃</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_2-existrules/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_2-existrules/index.html</guid>
      <description>In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ∃i, when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</description>
    </item>
    <item>
      <title>Nested Quantifiers</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_3-nested/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_3-nested/index.html</guid>
      <description>Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that ∀ x ∀ y P(x, y) is equivalent to ∀ x (∀ y P(x, y)).</description>
    </item>
    <item>
      <title>Equivalence</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_4-equiv/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_4-equiv/index.html</guid>
      <description>In Chapter 5, we saw DeMorgan&amp;rsquo;s laws for quantifiers &amp;ndash; that if we have some domain, and if P(x) is a predicate for individuals in that domain, then the following statements are equivalent:
¬(∃ x P(x)) is equivalent to ∀ x ¬P(x) ¬(∀ x P(x)) is equivalent to ∃ x ¬P(x) The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic &amp;ndash; we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.</description>
    </item>
    <item>
      <title>Summary and Strategies</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_5-strategies/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_5-strategies/index.html</guid>
      <description>In this section, we summarize all available rules in propositional logic, and discuss strategies for approaching proofs.
Rules with universal quantifier (∀) Rule summaries:
∀ x P(x) ∀e: ----------- P(v) where v is a particular individual in the domain { a (a is fresh) ... P(a) } ∀i: --------------- ∀ x P(x) Rule syntax summaries:
{ ... r. ∀ x P(x) (...) s. P(v) ∀e r v ... }{ ... r.</description>
    </item>
    <item>
      <title>Soundness and Completeness</title>
      <link>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis301/6-chapter/6_6-soundcomplete/index.html</guid>
      <description>Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) &amp;gt; i). An interpretation gives the meaning of:</description>
    </item>
  </channel>
</rss>