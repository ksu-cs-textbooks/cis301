




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 301: Logical Foundations of Programming">
    <meta name="author" content="Julie Thornton">
    <title>Predicate Logic Proofs :: CIS 301 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.html" rel="canonical" type="text/html" title="Predicate Logic Proofs :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.xml" rel="alternate" type="application/rss+xml" title="Predicate Logic Proofs :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/tele.html" rel="alternate" type="text/html" title="Predicate Logic Proofs :: CIS 301 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/embed.html" rel="alternate" type="text/html" title="Predicate Logic Proofs :: CIS 301 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1697036896" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fontawesome-all.min.css?1697036896" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/nucleus.css?1697036896" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1697036896" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/auto-complete.css?1697036896" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/perfect-scrollbar.min.css?1697036896" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1697036896" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis301/css/fonts.css?1697036896" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme.css?1697036896" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/theme-auto.css?1697036896" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/variant.css?1697036896" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/print.css?1697036896" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/format-print.css?1697036896" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/ie.css?1697036896" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/url.js?1697036896"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/variant.js?1697036896"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis301/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis301/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis301/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis301/css/custom.css?1697036896" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis301/6-chapter/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis301/6-chapter/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis301/index.html"><span itemprop="name">CIS 301 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Predicate Logic Proofs</span><meta itemprop="position" content="2"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 6</div>
<h1 id="predicate-logic-proofs">Predicate Logic Proofs</h1>

<p>Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as <em>first order logic</em>.</p>
<p>As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules. However, these new rules also exist outside of Logika, and we could express the same proofs with our rules in a different environment or on paper &ndash; the concepts are the same.</p>

            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Predicate Logic Proofs</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="rules-with-">Rules with ∀</h1>

<p>Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers &ndash; an &ldquo;introduction rule and an &ldquo;elimination&rdquo; rule.</p>
<p>In this section, we will see the two inference rules for the universal (∀) quantifier.</p>
<h2 id="for-all-elimination">For all elimination</h2>
<p>For all elimination allows us to take a claim that uses a universal quantifier &ndash; a statement about ALL individuals in a domain &ndash; and make the same statement about a specific individual in the domain. After all, if the statement is true for ALL individuals, then it follows that it should be true for a particular individual. We can formalize the rule as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     ∀ x P(x)
</span></span><span style="display:flex;"><span>∀e: ----------- 
</span></span><span style="display:flex;"><span>       P(v)     where v is a particular individual in the domain</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∀e</code> rule. It shows that given the premises: <em>All humans are mortal</em> and <em>Socrates is a human</em>, that we can prove that <em>Socrates is mortal</em>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isHuman(x) → isMortal(x)),  isHuman(Socrates) ⊢ isMortal(Socrates)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isHuman(x) → isMortal(x))               premise
</span></span><span style="display:flex;"><span>    2. isHuman(Socrates)                            premise
</span></span><span style="display:flex;"><span>    3. isHuman(Socrates) → isMortal(Socrates)       ∀e 1 Socrates
</span></span><span style="display:flex;"><span>    4. isMortal(Socrates)                           →e 3 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We can read the justification <code>∀e 1 Socrates</code> as: &ldquo;for all elimination of the for-all statement on line 1, plugging in the individual Socrates&rdquo;.</p>
<h2 id="for-all-introduction">For all introduction</h2>
<p>If we can show that a property of the form <code>P(a)</code> holds for an arbitrary member <code>a</code> of a domain, then we can use for all introduction to conclude that the property must hold for ALL individuals in the domain &ndash; i.e., that <code>∀ x P(x)</code>. We can formalize the fule as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     { a              (a is fresh)
</span></span><span style="display:flex;"><span>       ... P(a) }
</span></span><span style="display:flex;"><span>∀i: ---------------
</span></span><span style="display:flex;"><span>      ∀ x P(x) </span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∀i</code> rule: &ldquo;Everyone is healthy; everyone is happy. Therefore, everyone is both healthy and happy.&rdquo;:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x isHealthy(x), ∀ y isHappy(y)  |-  ∀ z(isHealthy(z) ∧ isHappy(z))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  1. ∀ x isHealthy(x)                   premise
</span></span><span style="display:flex;"><span>  2. ∀ y isHappy(y)                     premise
</span></span><span style="display:flex;"><span>  3. {
</span></span><span style="display:flex;"><span>       4. a
</span></span><span style="display:flex;"><span>       5. isHealthy(a)                  ∀e 1 a
</span></span><span style="display:flex;"><span>       6. isHappy(a)                    ∀e 2 a
</span></span><span style="display:flex;"><span>       7. isHealthy(a) ∧ isHappy(a)     ∧i 5 6
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  8. ∀ z (isHealthy(z) ∧ isHappy(z))    ∀i 3
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>If we wish to introduce a for-all statement, the pattern is:</p>
<ul>
<li>
<p>Open a subproof and introduce an arbitrary/fresh individual in the domain (in the example above, we used <code>a</code>). It MUST be a name that we have not used elsewhere in the proof. The idea is that your individual could have been anyone/anything in the domain.</p>
</li>
<li>
<p>When you introduce your individual, you do NOT include a justification on that line</p>
</li>
<li>
<p>If you have other for-all statements available within the scope of the subproof, then it is often useful to use <code>∀e</code> to plug your fresh individual into them. After all, if those statements are true for ALL individuals, then they are also true for your fresh individual.</p>
</li>
<li>
<p>If you are trying to prove something of the form <code>∀ x P(x)</code>, then you need to reach <code>P(a)</code> by the end of the subproof. You need to show that your goal for-all statement holds for your fresh individual. In our case, we wished to prove <code>∀ z (isHealthy(z) ∧ isHappy(z))</code>, so we reached <code>isHealthy(a) ∧ isHappy(a)</code> by the end of the subproof.</p>
</li>
<li>
<p>After the subproof, you can use <code>∀i</code> to introduce a for-all statement for your last claim in the subproof &ndash; that since the individual could have been anyone, then the proposition holds for ALL individuals. The <code>∀i</code> justification needs the line number of the subproof.</p>
</li>
<li>
<p>When you use <code>∀i</code>, it does not matter what variable you introduce into the for-all statement. In the example above, we introduced <code>∀ z</code> &ndash; but that was only to match the goal conclusion in the proof. We could have instead introduced <code>∀ x</code>, <code>∀ y</code>, <code>∀ people</code>, etc. We would use whatever variable we chose in the rest of that proposition &ndash; i.e., <code>∀ z (isHealthy(z) ∧ isHappy(z))</code>, or <code>∀ people (isHealthy(people) ∧ isHappy(people))</code>, etc.</p>
</li>
</ul>
<h2 id="examples">Examples</h2>
<p>In this section, we will look at several proofs involving the universal quantifier.</p>
<h3 id="example-1">Example 1</h3>
<p>Suppose we wish to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)</span></span></code></pre></div><p>This will let us show that it doesn&rsquo;t matter what variable we use with a universal quantifier &ndash; both <code>∀ x P(x)</code> and <code>∀ y P(y)</code> are saying the same thing: <em>for all individuals, P holds for that individual</em>.</p>
<p>Since the top-level operator of our conclusion is a for-all statement, we see that we will need to use for all introduction. Following the pattern above, we open a subproof and introduce a fresh individual, <code>a</code>. Since we wish to introduce the for-all statement <code>∀ y P(y)</code>, then we know we need to reach <code>P(a)</code> by the end of our subproof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x P(x)         premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a            //our fresh individual
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: P(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y P(y)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Since we have an available for-all statement in our subproof (<code>∀ x P(x)</code>, from line 1), then we use <code>∀e</code> to plug <code>a</code> into it:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x P(x)         premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a            //our fresh individual
</span></span><span style="display:flex;"><span>        4. P(a)         ∀e 1 a
</span></span><span style="display:flex;"><span>        //need: P(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y P(y)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>At that point, we see that we have exactly the proposition we wanted to end our subproof &ndash; <code>P(a)</code>. All that remains is to use <code>∀i</code> to state that since <code>a</code> could have been anyone, that the proposition we reached at the end of subproof 2 must hold for all individuals. Here is the completed proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x P(x) ⊢ ∀ y P(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x P(x)         premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a            //our fresh individual
</span></span><span style="display:flex;"><span>        4. P(a)         ∀e 1 a
</span></span><span style="display:flex;"><span>        //need: P(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y P(y)
</span></span><span style="display:flex;"><span>    5. ∀ y P(y)         ∀i 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="example-2">Example 2</h3>
<p>Suppose we wish to prove that, given the following premises in the domain of people:</p>
<ul>
<li>All students have a phone and/or a laptop</li>
<li>Everyone is a student</li>
</ul>
<p>Then we can conclude:</p>
<ul>
<li>Everyone has a phone and/or a laptop</li>
</ul>
<p>First, we identify the following predicates:</p>
<ul>
<li><code>isStudent(x)</code> - whether person x is a student</li>
<li><code>hasPhone(x)</code> - whether person x has a phone</li>
<li><code>hasLaptop(x)</code> = whether person x has a laptop</li>
</ul>
<p>Then, we can translate our premises and goal conclusion to predicate logic:</p>
<ul>
<li><em>All students have a phone and/or a laptop</em> translates to: <code>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))</code></li>
<li><em>Everyone is a student</em> translates to: <code>∀ x isStudent(x)</code></li>
<li><em>Everyone has a phone and/or a laptop</em> translates to: <code>∀ x (hasPhone(x) ∨ hasLaptop(x))</code></li>
</ul>
<p>We need to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))</span></span></code></pre></div><p>As with our previous example, we see that we are trying to prove a for-all statement (<code>∀ x (hasPhone(x) ∨ hasLaptop(x))</code>). This means we will need to open a subproof and introduce a fresh individual &ndash; perhaps <code>bob</code>. By the end of the subproof, we must show that our goal for-all statement holds for that individual &ndash; that <code>hasPhone(bob) ∨ hasLaptop(bob)</code>. We start the proof as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))          premise
</span></span><span style="display:flex;"><span>    2. ∀ x isStudent(x)                                         premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. bob
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        //goal: hasPhone(bob) ∨ hasLaptop(bob)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We have two available for-all statements within the subproof &ndash; <code>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))</code> and <code>∀ x isStudent(x)</code>. Since those propositions hold for all individuals, they also hold for <code>bob</code>. We use <code>Ae</code> to plug in <code>bob</code> to those two propositions:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))          premise
</span></span><span style="display:flex;"><span>    2. ∀ x isStudent(x)                                         premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. bob
</span></span><span style="display:flex;"><span>        5. isStudent(bob) → hasPhone(bob) ∨ hasLaptop(bob)      ∀e 1 bob
</span></span><span style="display:flex;"><span>        6. isStudent(bob)                                       ∀e 2 bob 
</span></span><span style="display:flex;"><span>        //goal: hasPhone(bob) ∨ hasLaptop(bob)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Line 5 is an implies statement the form <code>p → q</code>, and line 6 is a statement of the form <code>p</code>. Thus we can use <code>→e</code> to conclude <code>hasPhone(bob) ∨ hasLaptop(bob)</code> (the &ldquo;q&rdquo; in that statement) &ndash; which is exactly what we needed to end the subproof. All that remains is to apply our <code>∀i</code> rule after the subproof. Here is the completed proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x)), ∀ x isStudent(x) ⊢ ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (isStudent(x) → hasPhone(x) ∨ hasLaptop(x))          premise
</span></span><span style="display:flex;"><span>    2. ∀ x isStudent(x)                                         premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. bob
</span></span><span style="display:flex;"><span>        5. isStudent(bob) → hasPhone(bob) ∨ hasLaptop(bob)      ∀e 1 bob
</span></span><span style="display:flex;"><span>        6. isStudent(bob)                                       ∀e 2 bob   
</span></span><span style="display:flex;"><span>        7. hasPhone(bob) ∨ hasLaptop(bob)                       →e 5 6
</span></span><span style="display:flex;"><span>        //goal: hasPhone(bob) ∨ hasLaptop(bob)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x (hasPhone(x) ∨ hasLaptop(x))
</span></span><span style="display:flex;"><span>    8. ∀ x (hasPhone(x) ∨ hasLaptop(x))                         ∀i 3
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="example-3">Example 3</h3>
<p>Next, suppose we wish to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)</span></span></code></pre></div><p>We again see that the top-level operator of what we are trying to prove is a universal quantifier. We use our strategy to open a subproof, introduce a fresh individual (maybe <code>a</code>), and plug that individual into any available for-all statements. Since we wish to prove <code>∀ x ¬S(x)</code>, then we will want to reach <code>¬S(a)</code> by the end of the subproof. Here is a sketch:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (S(x) → Pz(x))               premise
</span></span><span style="display:flex;"><span>    2. ∀ x (Pz(x) → D(x))               premise
</span></span><span style="display:flex;"><span>    3. ∀ x ¬D(x)                        premise
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. a
</span></span><span style="display:flex;"><span>        6. S(a) → Pz(a)                 ∀e 1 a
</span></span><span style="display:flex;"><span>        7. Pz(a) → D(a)                 ∀e 2 a
</span></span><span style="display:flex;"><span>        8. ¬D(a)                        ∀e 3 a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ¬S(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Now, we see that our goal is to reach <code>¬S(a)</code> by the end of the subproof &ndash; so we need to prove something whose top-level operator is a NOT. We recall that we have a strategy to prove NOT(something) from propositional logic &ndash; we open a subproof, assuming <em>something</em> (<code>S(a)</code>, in our case), try to get a contradiction, and use NOT introduction after the subproof to conclude NOT (something) (<code>¬S(a)</code> for us). Here is the strategy:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (S(x) → Pz(x))               premise
</span></span><span style="display:flex;"><span>    2. ∀ x (Pz(x) → D(x))               premise
</span></span><span style="display:flex;"><span>    3. ∀ x ¬D(x)                        premise
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. a
</span></span><span style="display:flex;"><span>        6. S(a) → Pz(a)                 ∀e 1 a
</span></span><span style="display:flex;"><span>        7. Pz(a) → D(a)                 ∀e 2 a
</span></span><span style="display:flex;"><span>        8. ¬D(a)                        ∀e 3 a
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. S(a)                    assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //goal: contradiction
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //use ¬i to conclude ¬S(a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ¬S(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We can complete the proof as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (S(x) → Pz(x)), ∀ x (Pz(x) → D(x)), ∀ x ¬D(x) ⊢ ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (S(x) → Pz(x))               premise
</span></span><span style="display:flex;"><span>    2. ∀ x (Pz(x) → D(x))               premise
</span></span><span style="display:flex;"><span>    3. ∀ x ¬D(x)                        premise
</span></span><span style="display:flex;"><span>    4. {
</span></span><span style="display:flex;"><span>        5. a
</span></span><span style="display:flex;"><span>        6. S(a) → Pz(a)                 ∀e 1 a
</span></span><span style="display:flex;"><span>        7. Pz(a) → D(a)                 ∀e 2 a
</span></span><span style="display:flex;"><span>        8. ¬D(a)                        ∀e 3 a
</span></span><span style="display:flex;"><span>        9. {
</span></span><span style="display:flex;"><span>            10. S(a)                    assume
</span></span><span style="display:flex;"><span>            11. Pz(a)                   →e 6 10
</span></span><span style="display:flex;"><span>            12. D(a)                    →e 7 11
</span></span><span style="display:flex;"><span>            13. ⊥                       ¬e 12 8
</span></span><span style="display:flex;"><span>            //goal: contradiction
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //use ¬i to conclude ¬S(a)
</span></span><span style="display:flex;"><span>        14. ¬S(a)                       ¬i 9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ¬S(a)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∀i to conclude ∀ x ¬S(x)
</span></span><span style="display:flex;"><span>    15. ∀ x ¬S(x)                       ∀i 4
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="rules-with-">Rules with ∃</h1>

<p>In this section, we will see the two inference rules for the existential (∃) quantifier.</p>
<h2 id="exists-introduction">Exists introduction</h2>
<p>We can use the exists introduction rule, <code>∃i</code>, when we have a proposition of the form <code>P(a)</code> for an arbitrary member <code>a</code> of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       P(d)         where  d  is an individual
</span></span><span style="display:flex;"><span>∃i: -----------
</span></span><span style="display:flex;"><span>      ∃ x P(x)</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>∃i</code> rule:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>isHuman(Socrates) ⊢  ∃ x isHuman(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. isHuman(Socrates)            premise
</span></span><span style="display:flex;"><span>    2. ∃ x isHuman(x)               ∃i 1 Socrates
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>When we use the <code>∃i</code> rule to justify a claim like <code>∃ x P(x)</code>, we include the line number of where the proposition held for a particular individual, as well as the name of the individual. In the proof above, we claim <code>∃ x isHuman(x)</code> with justification <code>∃i 1 Socrates</code> &ndash; line 1 corresponds to <code>isHuman(Socrates)</code>, where our <code>∃ x isHuman(x)</code> proposition held for a particular individual. The <code>Socrates</code> part of the justification is the name of the individual.</p>
<p>Note that we can use the <code>∃i</code> rule to introduce any variable, not just <code>x</code>. You can choose which variable to introduce based on the variables used in the conclusion. For example, the following proof is also valid:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>isHuman(Socrates) ⊢  ∃ z isHuman(z)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. isHuman(Socrates)            premise
</span></span><span style="display:flex;"><span>    2. ∃ z isHuman(z)               ∃i 1 Socrates
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="exists-elimination">Exists elimination</h2>
<p>Since the <code>∃i</code>-rule constructs propositions that begin with <code>∃</code>, the <code>∃e</code>-rule (exists elimination) disassembles propositions that begin with <code>∃</code>.</p>
<p>Here is a quick example (where our domain is living things):</p>
<ul>
<li>All humans are mortal</li>
<li>Someone is human</li>
<li>Therefore, someone is mortal</li>
</ul>
<p>We don&rsquo;t know the name of the human, but it does not matter. Since ALL humans are mortal and SOMEONE is human, then our anonymous human must be mortal. The steps will go like this:</p>
<ul>
<li>
<p>Since &ldquo;someone is human&rdquo; and since we do not know his/her name, we will just make up our own name for them – &ldquo;Jane&rdquo;. So, we assume that &ldquo;Jane is human&rdquo;.</p>
</li>
<li>
<p>We use the logic rules we already know to prove that &ldquo;Jane is mortal&rdquo;.</p>
</li>
<li>
<p>Therefore, SOMEONE is mortal and their name does not matter.</p>
</li>
</ul>
<p>This approach is coded into the last logic law, <code>∃e</code> (exists elimination).</p>
<p>Suppose we have a premise of the form <code>∃ x P(x)</code>. Since we do not know the name of the individual &ldquo;hidden&rdquo; behind the <code>∃ x</code>, we make up a name for it, say <code>a</code>, and discuss what must follow from the assumption that <code>P(a)</code> holds true. Here is the formalization of the <code>∃e</code> rule:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                  {a  P(a)   assume       // where  a  is a new, fresh name
</span></span><span style="display:flex;"><span>      ∃ x P(x)      ...  Q         }      // a  MUST NOT appear in  Q
</span></span><span style="display:flex;"><span>∃e: -----------------------------------
</span></span><span style="display:flex;"><span>                     Q</span></span></code></pre></div><p>That is, if we can deduce <code>Q</code> from <code>P(a)</code>, and we do not mention <code>a</code> within <code>Q</code>, then it means <code>Q</code> can be deduced no matter what name the hidden individual has. So, <code>Q</code> follows from <code>∃  P(x)</code>.</p>
<p>We can work the previous example, with <code>∃e</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>All humans are mortal
</span></span><span style="display:flex;"><span>Someone is human
</span></span><span style="display:flex;"><span>Therefore, someone is mortal</span></span></code></pre></div><p>We make up the name, <code>jane</code>, for the human whose name we do not know:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ h(isHuman(h) → isMortal(h)), ∃ x isHuman(x) |- ∃ y isMortal(y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ h(isHuman(h) → isMortal(h))        premise
</span></span><span style="display:flex;"><span>    2. ∃ x isHuman(x)                       premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. jane isHuman(jane)               assume
</span></span><span style="display:flex;"><span>        5. isHuman(jane) → isMortal(jane)   ∀e 1 jane
</span></span><span style="display:flex;"><span>        6. isMortal(jane)                   →e 5 4
</span></span><span style="display:flex;"><span>        7. ∃y isMortal(y)                   ∃i 6 jane
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    8. ∃y isMortal(y)                       ∃e 2 3
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Line 4 proposes the name <code>jane</code> and the assumption that <code>isHuman(jane)</code>. The subproof leads to Line 7, which says that someone is mortal. (We never learned the individual&rsquo;s name!) Since Line 7 does not explicitly mention the made-up name, <code>jane</code>, we use Line 8 to repeat Line 7 – without knowing the name of the individual &ldquo;hiding&rdquo; inside Line 2, we made a subproof that proves the result, anyway. This is how <code>∃e</code> works.</p>
<p>Note that when we use the <code>∃e</code> rule as a justification we include first the line number of the there-exists statement that we processed (by naming the hidden individual) in the prrevious subproof, and then the line number of that subproof. In the example above, we say <code>∃e 2 3</code> because line 2 includes the there-exists statement we processed (<code>∃ x isHuman(x)</code>) in the previous subproof and line 3 is the subproof.</p>
<p>When using <code>∃e</code>, the previous subproof must begin with introducing a name for a hidden individual in a there-exists statement and then immediately substituting that name into the there-exists statement. The justification on the first line is always <code>assume</code>. The last line in the subproof should contain NO mention of the chosen name. Whatever we claim on the last line in the subproof, we must claim EXACTLY the same thing immediately afterwards when we use the <code>∃e</code> rule.</p>
<p>You are welcome to use any name for the hidden individual &ndash; not just <code>jane</code> or <code>a</code>. The only restriction is that you cannot have used the name anywhere else in the proof.</p>
<h2 id="examples">Examples</h2>
<p>In this section, we will look at several proofs involving the existential quantifier.</p>
<h3 id="example-1">Example 1</h3>
<p>Suppose we wish to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))</span></span></code></pre></div><p>Following the same approach in the <code>∃e</code> example above, we know that there is SOME human. Let&rsquo;s introduce the alias <code>bob</code> for that human:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Human(x))               premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. bob Human(bob)           assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, ∃ y (Human(y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such human exists
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Since we have <code>Human(bob)</code> in our subproof, we can use <code>∃i</code> in our subproof to instead say that there exists some human. We will introduce the <code>y</code> variable, since that&rsquo;s what we want in our conclusion:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Human(x))               premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. bob Human(bob)           assume
</span></span><span style="display:flex;"><span>        4. ∃ y (Human(y))           ∃i 3 bob
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, ∃ y (Human(y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such human exists
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>All that remains is to use <code>∃e</code> to restate our conclusion after the subproof. Since we knew someone was a human, and since we reached a claim that didn&rsquo;t use our alias, then we can restate the result outside the scope of the subproof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Human(x)) ⊢ ∃ y (Human(y))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Human(x))               premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. bob Human(bob)           assume
</span></span><span style="display:flex;"><span>        4. ∃ y (Human(y))           ∃i 3 bob
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, ∃ y (Human(y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such human exists
</span></span><span style="display:flex;"><span>    5. ∃ y (Human(y))               ∃e 1 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="example-2">Example 2</h3>
<p>Suppose we wish to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Adult(x) ∨ Kid(x)) ⊢ (∃ x Adult(x)) ∨ (∃ x Kid(x))</span></span></code></pre></div><p>We will begin as we did previously: by introducing an alias for our person that is either an adult or a kid (say, <code>alice</code>):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Adult(x) ∨ Kid(x)) ⊢ (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Adult(x) ∨ Kid(x))              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. alice Adult(alice) ∨ Kid(alice)  assume
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>To finish our proof, we can use OR elimination on <code>Adult(alice) ∨ Kid(alice)</code>, and then <code>∃e</code> afterwards to restate our conclusion. Here is the completed proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x (Adult(x) ∨ Kid(x)) ⊢ (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∃ x (Adult(x) ∨ Kid(x))                  premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. alice Adult(alice) ∨ Kid(alice)      assume
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. Adult(alice)                     assume
</span></span><span style="display:flex;"><span>            6. ∃ x Adult(x)                     ∃i 5 alice
</span></span><span style="display:flex;"><span>            7. (∃ x Adult(x)) ∨ (∃ x Kid(x))    ∨i1 6
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. {
</span></span><span style="display:flex;"><span>            9. Kid(alice)                       assume
</span></span><span style="display:flex;"><span>            10. ∃ x Kid(x)                      ∃i  9 alice
</span></span><span style="display:flex;"><span>            11. (∃ x Adult(x)) ∨ (∃ x Kid(x))   ∨i2 10
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        12. (∃ x Adult(x)) ∨ (∃ x Kid(x))       ∨e 3 4 8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: get to our conclusion, (∃ x Adult(x)) ∨ (∃ x Kid(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    13. (∃ x Adult(x)) ∨ (∃ x Kid(x))           ∃e 1 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="example-3">Example 3</h3>
<p>Suppose we wish to prove the following (in the domain of living things):</p>
<ul>
<li>All bunnies are fluffy</li>
<li>There is a fast bunny</li>
<li>Therefore, there is a creature that is fast and fluffy</li>
</ul>
<p>We can translate our premises and desired conclusion to predicate logic, and write the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (Bunny(x) → Fluffy(x)), ∃ x (Fast(x) ∧ Bunny(x)) ⊢ ∃ x (Fast(x) ∧ Fluffy(x))</span></span></code></pre></div><p>Since we are trying to prove a claim about some individual, it makes sense that we would start the process of an <code>∃e</code> subproof where we introduce an alias (<code>thumper</code>) for the fast bunny. We will try to reach the conclusion by the end of that subproof. Here is the setup:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (Bunny(x) → Fluffy(x)), ∃ x (Fast(x) ∧ Bunny(x)) ⊢ ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (Bunny(x) → Fluffy(x))                   premise
</span></span><span style="display:flex;"><span>    2. ∃ x (Fast(x) ∧ Bunny(x))                     premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. thumper Fast(thumper) ∧ Bunny(thumper)   assume
</span></span><span style="display:flex;"><span>        5. Fast(thumper)                            ∧e1 4
</span></span><span style="display:flex;"><span>        6. Bunny(thumper)                           ∧e2 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //use ∃e to restate ∃ x (Fast(x) ∧ Fluffy(x)), since we know there is SOME fast bunny
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>To finish our subproof, we see that we have a proposition about all creatures (<code>∀ x (Bunny(x) → Fluffy(x))</code>) and that we are working with an individual creature (<code>thumper</code>). We can use <code>∀e</code> to prove <code>Bunny(thumper) → Fluffy(thumper)</code>. After that, we have a few more manipulations using propositional logic rules, our <code>∃i</code> rule to transition our claim from being about our alias <code>thumper</code> to being about an unnamed individual, and then our <code>∃e</code> rule to pull our final claim out of the subproof. Here is the completed proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x (Bunny(x) → Fluffy(x)), ∃ x (Fast(x) ∧ Bunny(x)) ⊢ ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x (Bunny(x) → Fluffy(x))                   premise
</span></span><span style="display:flex;"><span>    2. ∃ x (Fast(x) ∧ Bunny(x))                     premise
</span></span><span style="display:flex;"><span>    3. {
</span></span><span style="display:flex;"><span>        4. thumper Fast(thumper) ∧ Bunny(thumper)   assume
</span></span><span style="display:flex;"><span>        5. Fast(thumper)                            ∧e1 4
</span></span><span style="display:flex;"><span>        6. Bunny(thumper)                           ∧e2 4
</span></span><span style="display:flex;"><span>        7. Bunny(thumper) → Fluffy(thumper)         ∀e 1 thumper
</span></span><span style="display:flex;"><span>        8. Fluffy(thumper)                          →e 7 6
</span></span><span style="display:flex;"><span>        9. Fast(thumper) ∧ Fluffy(thumper)          ∧i 5 8
</span></span><span style="display:flex;"><span>        10. ∃ x (Fast(x) ∧ Fluffy(x))               ∃i 9 thumper
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //goal: ∃ x (Fast(x) ∧ Fluffy(x))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //use ∃e to restate ∃ x (Fast(x) ∧ Fluffy(x)), since we know there is SOME fast bunny
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    11. ∃ x (Fast(x) ∧ Fluffy(x))                   ∃e 2 3
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="nested-quantifiers">Nested Quantifiers</h1>

<p>Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that <code>∀ x ∀ y P(x, y)</code> is equivalent to <code>∀ x (∀ y P(x, y))</code>.</p>
<h2 id="example-1">Example 1</h2>
<p>Suppose we wish to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)</span></span></code></pre></div><p>Since we wish to prove a for-all statement of the form <code>∀ y (SOMETHING)</code>, then we know we must start with our for all introduction template:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>But now we see that we want to prove ANOTHER for-all statement, <code>∀ x P(a, x)</code>. So we again use our for all introduction strategy in a nested subproof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //need: P(a, b)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //want to use ∀i to conclude ∀ x P(a, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Now, in subproof 4, we see that we must use <code>∀e</code> on our premise (<code>∀ x ∀ y P(x, y)</code>) to work towards our goal of <code>P(a, b)</code>. We have two available individuals &ndash; <code>a</code> and <code>b</code>. When we use <code>∀e</code>, we must eliminate the OUTER (top-level) quantifier and its variable. In the case of <code>∀ x ∀ y P(x, y)</code>, we see that we must eliminate the <code>∀ x</code>. Since the <code>x</code> is the first parameter in <code>P(x, y)</code>, and since we are hoping to reach <code>P(a, b)</code> by the end of subproof 4, we can see that we need to plug in the <code>a</code> for the <code>x</code> so that it will be in the desired position:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>            6. ∀ y P(a, y)          ∀e 1 a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //need: P(a, b)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //want to use ∀i to conclude ∀ x P(a, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Note that on line 6, we could NOT have used <code>∀e</code> to eliminate the <code>∀ y</code> in <code>∀ x ∀ y P(x, y)</code>, as it was not the top-level operator.</p>
<p>Next, we apply <code>∀e</code> again to <code>∀ y P(a, y)</code> to leave us with <code>P(a, b)</code>. All that remains at that point is to use <code>∀i</code> twice as planned to wrap up the two subproofs. Here is the completed proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ∀ y P(x, y) ⊢ ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ∀ y P(x, y)              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a 
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>            6. ∀ y P(a, y)          ∀e 1 a
</span></span><span style="display:flex;"><span>            7. P(a, b)              ∀e 6 b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //need: P(a, b)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        //want to use ∀i to conclude ∀ x P(a, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        8. ∀ x P(a, x)              ∀i 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //need: ∀ x P(a, x)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //want to use ∀i to conclude ∀ y ∀ x P(y, x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    9. ∀ y ∀ x P(y, x)              ∀i 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="example-2">Example 2</h2>
<p>Suppose we have the predicate <code>IsBossof(x, y)</code> in the domain of people, which describes whether person <code>x</code> is the boss of person <code>y</code>. We wish to prove the following sequent:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∀ y IsBossOf(x, y) ⊢ ∀ y ∃ x IsBossOf(x, y)</span></span></code></pre></div><p>You can read the premise as &ldquo;There is a person that is everyone&rsquo;s boss&rdquo;. From this statement, we are trying to prove the conclusion: &ldquo;All people have a boss&rdquo;. Here is the completed proof:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∀ y IsBossOf(x, y) ⊢ ∀ y ∃ x IsBossOf(x, y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  1. ∃ x ∀ y IsBossOf(x, y)             premise
</span></span><span style="display:flex;"><span>  2. {
</span></span><span style="display:flex;"><span>       3. a ∀ y IsBossOf(a, y)          assume
</span></span><span style="display:flex;"><span>       4. {
</span></span><span style="display:flex;"><span>            5. b
</span></span><span style="display:flex;"><span>            6. IsBossOf(a, b)           ∀e 3 b
</span></span><span style="display:flex;"><span>            7. ∃ x IsBossOf(x, b)       ∃i 6 a
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>       8. ∀ y ∃ x IsBossOf(x, y))       ∀i 4
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  9. ∀ y ∃ x IsBossOf(x, y)             ∃e 1 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>In the above proof, we let <code>a</code> be our made-up name for the boss-of-everyone. So, we have the assumption that <code>∀ y IsBossOf(a, y)</code>. Next, we let <code>b</code> be &ldquo;anybody at all&rdquo; who we might examine in the domain of people. The proof exposes that the boss of &ldquo;anybody at all&rdquo; in the domain must always be <code>a</code>. <code>∀i</code> and then <code>∃e</code> finish the proof.</p>
<p>Here is the proof worked again, with the subproofs swapped:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∃ x ∀ y IsBossOf(x, y) ⊢ ∀ y ∃ x IsBossOf(x, y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  1. ∃ x ∀ y IsBossOf(x, y)             premise
</span></span><span style="display:flex;"><span>  2. {
</span></span><span style="display:flex;"><span>       3. b
</span></span><span style="display:flex;"><span>       4. {
</span></span><span style="display:flex;"><span>            5. a ∀ y IsBossOf(a, y)     assume
</span></span><span style="display:flex;"><span>            6. IsBossOf(a, b)           ∀e 5 b
</span></span><span style="display:flex;"><span>            7. ∃ x IsBossOf(x, b)       ∃i 6 a
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>       8. ∃ x IsBossOf(x, y))           ∃e 1 4
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  9. ∀ y ∃ x IsBossOf(x, y)             ∀i 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Can we prove the converse? That is, if everyone has a boss, then there is one boss who is the boss of everyone?</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ y ∃ x IsBossOf(x, y) ⊢ ∃ x ∀ y IsBossOf(x, y)</span></span></code></pre></div><p>NO. We can try, but we get stuck:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ y ∃ x IsBossOf(x, y) ⊢ ∃ x ∀ y IsBossOf(x, y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ y ∃ x IsBossOf(x, y)           premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a
</span></span><span style="display:flex;"><span>        4. ∃ x IsBossOf(x, a)           ∀e 1 a
</span></span><span style="display:flex;"><span>        5. {
</span></span><span style="display:flex;"><span>            6. b IsBossOf(b, a)         assume
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        6. ∀ y isBoss(b, y)             ∀i 2  NO--THIS PROOF IS TRYING TO FINISH
</span></span><span style="display:flex;"><span>                                          THE OUTER SUBPROOF WITHOUT FINISHING
</span></span><span style="display:flex;"><span>                                          THE INNER ONE FIRST.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...can&#39;t finish
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We see that the &ldquo;block structure&rdquo; of the proofs warns us when we are making invalid deductions.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="equivalence">Equivalence</h1>

<p>In Chapter 5, we saw DeMorgan&rsquo;s laws for quantifiers &ndash; that if we have some domain, and if <code>P(x)</code> is a predicate for individuals in that domain, then the following statements are equivalent:</p>
<ul>
<li><code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code></li>
<li><code>¬(∀ x P(x))</code> is equivalent to <code>∃ x ¬P(x)</code></li>
</ul>
<p>The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic &ndash; we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.</p>
<h2 id="example---how-to-prove-equivalence">Example - how to prove equivalence</h2>
<p>For example, to prove that <code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code>, we must prove the sequents:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(∃ x P(x)) ⊢ ∀ x ¬P(x)</span></span></code></pre></div><p>and</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ¬P(x) ⊢ ¬(∃ x P(x))</span></span></code></pre></div><p>We prove both directions below:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>¬(∃ x P(x)) ⊢ ∀ x ¬P(x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ¬(∃ x P(x))              premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. a
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. P(a)             assume
</span></span><span style="display:flex;"><span>            6. ∃ x P(x)         ∃i 5 a
</span></span><span style="display:flex;"><span>            7. ⊥                ¬e 6 1
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. ¬P(a)                ¬i 4
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. ∀ x ¬P(x)                ∀i 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>and</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>∀ x ¬P(x) ⊢ ¬(∃ x P(x))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    1. ∀ x ¬P(x)                premise
</span></span><span style="display:flex;"><span>    2. {
</span></span><span style="display:flex;"><span>        3. ∃ x P(x)             assume
</span></span><span style="display:flex;"><span>        4. {
</span></span><span style="display:flex;"><span>            5. a P(a)           assume
</span></span><span style="display:flex;"><span>            6. ¬P(a)            ∀i 1 a
</span></span><span style="display:flex;"><span>            7. ⊥                ¬e 5 6
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        8. ⊥                    ∃e 3 4
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    9. ¬(∃ x P(x))              ¬i 2
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="more-extensive-list-of-equivalences">More extensive list of equivalences</h2>
<p>Here is a more extensive list of equivalences in predicate logic. The remaining proofs are left as exercises for the reader:</p>
<ul>
<li><code>¬(∃ x P(x))</code> is equivalent to <code>∀ x ¬P(x)</code></li>
<li><code>¬(∀ x P(x))</code> is equivalent to <code>∃ x ¬P(x)</code></li>
<li><code>∀ x (P(x) → ¬Q(x))</code> is equivalent to <code>¬(∃ x P(x) ∧ Q(x))</code></li>
<li><code>∀ x ∀ y P(x, y)</code> is equivalent to <code>∀ y ∀ x P(x, y)</code></li>
<li><code>∃ x ∃ y P(x, y)</code> is equivalent to <code>∃ y ∃ x P(x, y)</code></li>
<li><code>Q ∧ (∀ x P(x))</code> is equivalent to <code>∀ x (Q ∧ P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
<li><code>Q v (∀ x P(x))</code> is equivalent to <code>∀ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
<li><code>Q ∧ (∃ x P(x))</code> is equivalent to <code>∃ x (Q ∧ P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
<li><code>Q V (∃ x P(x))</code> is equivalent to <code>∃ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li>
</ul>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="summary-and-strategies">Summary and Strategies</h1>

<p>In this section, we summarize all available rules in propositional logic, and discuss stratgies for approaching proofs.</p>
<h2 id="rules-with-universal-quantifier-">Rules with universal quantifier (<code>∀</code>)</h2>
<p>Rule summaries:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     ∀ x P(x)
</span></span><span style="display:flex;"><span>∀e: ----------- 
</span></span><span style="display:flex;"><span>       P(v)     where v is a particular individual in the domain</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     { a              (a is fresh)
</span></span><span style="display:flex;"><span>       ... P(a) }
</span></span><span style="display:flex;"><span>∀i: ---------------
</span></span><span style="display:flex;"><span>      ∀ x P(x) </span></span></code></pre></div><p>Rule syntax summaries:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    r. ∀ x P(x) 	        (...)
</span></span><span style="display:flex;"><span>    s. P(v)                 ∀e r v
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    r. {
</span></span><span style="display:flex;"><span>        s. a
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        t. P(a)             (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    u. ∀ x P(x)             ∀i r
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="rules-with-existential-quantifier-">Rules with existential quantifier (<code>∃</code>)</h2>
<p>Rule summaries:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>       P(d)         where  d  is an individual
</span></span><span style="display:flex;"><span>∃i: -----------
</span></span><span style="display:flex;"><span>      ∃ x P(x)</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                  {a  P(a)   assume       // where  a  is a new, fresh name
</span></span><span style="display:flex;"><span>      ∃ x P(x)      ...  Q         }      // a  MUST NOT appear in  Q
</span></span><span style="display:flex;"><span>∃e: -----------------------------------
</span></span><span style="display:flex;"><span>                     Q</span></span></code></pre></div><p>Rule syntax summaries:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    r. P(d)                 (...)
</span></span><span style="display:flex;"><span>    s. ∃ x P(x)             ∃i r d
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    b. ∃ x P(x)             (...)
</span></span><span style="display:flex;"><span>    c. {
</span></span><span style="display:flex;"><span>        d. a P(a)           assume
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        e. Q                (...)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    f. Q                    ∃e b c
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="reminder-propositional-logic-rules-are-still-available">Reminder: propositional logic rules are still available</h2>
<p>When doing proofs in predicate logic, remember that all the deduction rules from propositional logic are still available. You will often want to use the same strategies we saw there &ndash; not introduction to prove a NOT, implies introduction to create an implies statement, OR elimination to process an OR statement, etc.</p>
<p>However, keep in mind that propositional logic rules can only be used on claims without quantifiers as their top-level operator. For example, if we have the statement <code>∀ x (S(x) ∧ Pz(x))</code>, then we cannot use <code>∧e</code> &ndash; the top-level operator is a universal quantifier, and the <code>∧</code> statement is &ldquo;bound up&rdquo; in that quantifier. We would only be able to use <code>∧e</code> after we had used <code>∀ e</code> to eliminate the quantifier.</p>
<h2 id="strategies">Strategies</h2>
<ol>
<li>
<p>Write down all premises first. Can you extract anything from the premises?</p>
<ul>
<li>If you have a for-all statement and an available individual, use <code>∀e</code> to plug that individual into the for-all statement.</li>
<li>If you have <code>p∧q</code>, use <code>∧e1</code> to extract <code>p</code> by itself and then <code>∧e2</code> to extract <code>q</code> by itself.</li>
<li>If you have <code>p→q</code> and <code>p</code>, use <code>→e</code> to get <code>q</code>.</li>
<li>If you have <code>p</code> and <code>¬p</code>, use <code>¬e</code> to claim a contradiction, <code>⊥</code>.</li>
</ul>
</li>
<li>
<p>Look at the top-level operator of what you are trying to prove.</p>
<ul>
<li>
<p>Are you trying to prove something of the form <code>∀ x P(x)</code>?</p>
<ul>
<li>Use <code>∀i</code>. Open a subproof, introduce a fresh <code>a</code>, and get to <code>P(a)</code> by the end of the subproof. After the subproof, use <code>∀i</code> to conclude <code>∀ x P(x)</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>∃ x P(x)</code>?</p>
<ul>
<li>You will usually have another there-exists (<code>∃</code>) statement available as a premise or previous claim. Open a subproof, and assume an alias for the individual in your there-exists statement. Get to <code>∃ x P(x)</code> by the last line of the subproof. After the subproof, use <code>∃e</code> to restate <code>∃ x P(x)</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p→q</code>?</p>
<ul>
<li>Use <code>→i</code>. Open a subproof, assume <code>p</code>, and get to <code>q</code> by the end of the subproof. After the subproof, use <code>→i</code> to conclude <code>p→q</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>¬p</code>?</p>
<ul>
<li>Use <code>¬i</code>. Open a subproof, assume <code>p</code>, and get a contradiction, <code>⊥</code>, by the end of the subproof. After the subproof, use <code>¬i</code> to conclude <code>¬p</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p ∧ q</code>?</p>
<ul>
<li>Try to prove <code>p</code> by itself and then <code>q</code> by itself. Afterward, use <code>∧i</code> to conclude <code>p ∧ q</code>.</li>
</ul>
</li>
<li>
<p>Are you trying to prove something of the form <code>p ∨ q</code>?</p>
<ul>
<li>See if you have either <code>p</code> or <code>q</code> by itself &ndash; if you do, use either <code>∨i1</code> or <code>∨i2</code> to conclude <code>p ∨ q</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>You&rsquo;ll need to nest the approaches from step 2. Once you are in a subproof, think about what you are <em>trying to prove by the end of that subproof</em>. Follow the strategy in step 2 to prove your current goal, nesting subproofs as needed. As you work, stop and scan the claims that you have available. See if you can extract anything from them as you did for the premises in step 1.</p>
</li>
<li>
<p>No match, or still stuck?</p>
<ul>
<li>Do you have a there-exists statement available? Try using <code>∃e</code> to reach your goal.</li>
<li>Do you have an OR statement available? Try using OR elimination to prove your goal conclusion.</li>
<li>Do your statements have NOT operators, but don&rsquo;t fit the form for using <code>¬i</code>? Try using <code>pbc</code>. If you are trying to prove something of the form <code>p</code>, open a subproof, assume <code>¬p</code>, and try to reach a contradiction by the end of the subproof. Afterward, use <code>pbc</code> to conclude <code>p</code>.</li>
<li>As a last resort, try pasting in the proof for the law of the excluded middle (see section 4.5). Then use OR elimination on <code>p ∨ ¬p</code>.</li>
</ul>
</li>
</ol>
<p>Think of doing a proof as solving a maze, and of all our deduction rules as possible directions you can turn. If you have claims that match a deduction rule, then you can try applying the rule (i.e, &ldquo;turning that direction&rdquo;). As you work, you may apply more and more rules until the proof falls into place (you exit the maze)&hellip;or, you might get stuck. If this happens, it doesn&rsquo;t mean that you have done anything <em>wrong</em> &ndash; it just means that you have reached a dead end and need to try something else. You backtrack, and try a different approach instead (try turning in a different direction).</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="soundness-and-completeness">Soundness and Completeness</h1>

<h2 id="soundness-and-completeness-definitions">Soundness and completeness definitions</h2>
<p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p>
<h2 id="interpretations">Interpretations</h2>
<p>When we write statements in logic, we use predicates and function symbols (e.g., <code>∀ i (i * 2) &gt; i</code>). An interpretation gives the meaning of:</p>
<ul>
<li>
<p>The underlying domain – what set of elements it names</p>
</li>
<li>
<p>Each function symbol – what answers it computes from its parameters from the domain</p>
</li>
<li>
<p>Each predicate – which combinations of arguments from the domain lead to true answers and false answers</p>
</li>
</ul>
<h3 id="interpretation-example---integers">Interpretation example - integers</h3>
<p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>&gt;</code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p>
<p>The standard interpretation of arithmetic is that:</p>
<ul>
<li>
<p><code>int</code> names the set of all integers</p>
</li>
<li>
<p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p>
</li>
<li>
<p><code>=</code> and <code>&gt;</code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p>
</li>
</ul>
<p>With this interpretation of arithmetic, we can interpret statements. For example,<code>∀ i (i * 2) &gt; i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>∃ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p>
<p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>&gt;</code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>&gt;</code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n &gt; m</code>.</p>
<p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 &gt; 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p>
<p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p>
<h3 id="interpretation-example---predicates">Interpretation example - predicates</h3>
<p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p>
<p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p>
<h2 id="valid-sequents-in-predicate-logic">Valid sequents in predicate logic</h2>
<blockquote>
<p>A sequent, <code>P_1, P_2, ..., P_n ⊢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &hellip;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p>
</blockquote>
<h2 id="soundness-and-completeness-in-predicate-logic">Soundness and completeness in predicate logic</h2>
<p>We can then define soundness and completeness for predicate logic:</p>
<blockquote>
<p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n ⊢ Q</code>, then the sequent is valid (in all possible interpretations)</p>
</blockquote>
<blockquote>
<p><em>completeness:</em> When <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p>
</blockquote>
<p>Note that, if <code>P_1, P_2, ..., P_n ⊢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;</code>, and <code>=</code>. No appropriate rule set was devised.</p>
<p>In the early 20th century, Kurt Gödel showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. Gödel showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p>
<p>Gödel’s construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p>
<p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p>

            <footer class="footline">

            </footer>
          </article>

          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis301-textbook/-/commit/dec4297d81df48b5e02e2640601321e923ab5f5b">Aug 10, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/clipboard.min.js?1697036896" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/perfect-scrollbar.min.js?1697036896" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis301/js/theme.js?1697036896" defer></script>
  </body>
</html>
