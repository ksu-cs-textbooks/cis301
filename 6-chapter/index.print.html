<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as first order logic.
As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Predicate Logic Proofs :: CIS 301 Textbook"><meta name=twitter:description content="Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as first order logic.
As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis301/6-chapter/"><meta property="og:site_name" content="CIS 301 Textbook"><meta property="og:title" content="Predicate Logic Proofs :: CIS 301 Textbook"><meta property="og:description" content="Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as first order logic.
As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Predicate Logic Proofs :: CIS 301 Textbook"><meta itemprop=description content="Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as first order logic.
As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules."><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2024-08-13T15:44:21-05:00"><meta itemprop=wordCount content="114"><title>Predicate Logic Proofs :: CIS 301 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis301/6-chapter/ rel=canonical type=text/html title="Predicate Logic Proofs :: CIS 301 Textbook"><link href=/cis301/6-chapter/index.xml rel=alternate type=application/rss+xml title="Predicate Logic Proofs :: CIS 301 Textbook"><link href=/cis301/6-chapter/tele.html rel=alternate type=text/html title="Predicate Logic Proofs :: CIS 301 Textbook"><link href=/cis301/6-chapter/embed.html rel=alternate type=text/html title="Predicate Logic Proofs :: CIS 301 Textbook"><link href=/cis301/css/fontawesome-all.min.css?1737061030 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fontawesome-all.min.css?1737061030 rel=stylesheet></noscript><link href=/cis301/css/nucleus.css?1737061030 rel=stylesheet><link href=/cis301/css/auto-complete.css?1737061030 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/auto-complete.css?1737061030 rel=stylesheet></noscript><link href=/cis301/css/perfect-scrollbar.min.css?1737061030 rel=stylesheet><link href=/cis301/css/fonts.css?1737061030 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis301/css/fonts.css?1737061030 rel=stylesheet></noscript><link href=/cis301/css/theme.css?1737061030 rel=stylesheet><link href=/cis301/css/theme-auto.css?1737061030 rel=stylesheet id=R-variant-style><link href=/cis301/css/chroma-auto.css?1737061030 rel=stylesheet id=R-variant-chroma-style><link href=/cis301/css/variant.css?1737061030 rel=stylesheet><link href=/cis301/css/print.css?1737061030 rel=stylesheet media=print><link href=/cis301/css/format-print.css?1737061030 rel=stylesheet><script src=/cis301/js/variant.js?1737061030></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis301",window.index_js_url="/cis301/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis301/css/custom.css?1737061030 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis301/6-chapter/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Predicate Logic Proofs</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/5-chapter/5_4-multquant/ title="Multiple Quantifiers (ü°ê)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis301/6-chapter/6_0-logikasyntax/ title="Logika Predicate Logic Proof Syntax (ü°í)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 6</div><h1 id=predicate-logic-proofs>Predicate Logic Proofs</h1><p>Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as <em>first order logic</em>.</p><p>As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules. However, these new rules also exist outside of Logika, and we could express the same proofs with our rules in a different environment or on paper &ndash; the concepts are the same.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Predicate Logic Proofs</h1><article class=default><header class=headline></header><h1 id=logika-predicate-logic-proof-syntax>Logika Predicate Logic Proof Syntax</h1><p>We will use the following format in Logika to start a natural deduction proof for predicate logic. Each proof will be saved in a new file with a <code>.sc</code> (Scala) extension:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// #Sireum #Logika
</span></span><span class=line><span class=cl>//@Logika: --manual --background type
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>import org.sireum._
</span></span><span class=line><span class=cl>import org.sireum.justification._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.prop._
</span></span><span class=line><span class=cl>import org.sireum.justification.natded.pred._
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>@pure def ProofName[T](pred1: T =&gt; B @pure, pred2: T =&gt; B @pure, ..., indiv1: T, indiv2: T, ...): Unit = {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        //@formatter:off
</span></span><span class=line><span class=cl>        (comma-separated list of premises with variable1, variable2, ...)  ‚ä¢  (conclusion)
</span></span><span class=line><span class=cl>            Proof(
</span></span><span class=line><span class=cl>                //the actual proof steps go here
</span></span><span class=line><span class=cl>            )
</span></span><span class=line><span class=cl>        //@formatter:on
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Here, <code>T</code> is the type of elements in our domain. Usually, we will just use <code>T</code> to denote a generic type (much like generics in Java and C#), but occasionally we will use specific types like <code>Z</code> (which means &ldquo;integer&rdquo;). Next, <code>pred1</code>, <code>pred2</code>, etc. are the predicates for our proofs. The <code>T => B</code> means that they take an element in our domain as a parameter (which has type <code>T</code>) and return a boolean (which has type <code>B</code>). Finally, <code>indiv1</code>, <code>indiv2</code>, etc. are specific individuals within our domain, each of which have type <code>T</code>.</p><p>A proof function like the example above can have as many or few predicates and individuals as are needed for the proof.</p><p>As was the case with propositional logic, the examples in this chapter will omit the imports, proof function definition, deduce call, and formatter changes are omitted here for readability. We will start each example with the sequent followed by the Proof call.</p><h2 id=for-all-statements-in-logika>For all statements in Logika</h2><p>The syntax of a statement like <code>‚àÄ x P(x)</code> in Logika is a little different, since we must specify that each <code>x</code> is an element in our domain. When we are using Logika to do a predicate logic proof, we express <code>‚àÄ x P(x)</code> as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚àÄ ((x: T) =&gt; P(x))</span></span></code></pre></div><p>The above statement is saying, &ldquo;for all x that are of the type T, P(x) is true&rdquo;.</p><p>We can alternatively use curly braces instead of standard parentheses to surround our predicate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚àÄ {(x: T) =&gt; P(x)}</span></span></code></pre></div><p>Such statements can be a pain to type out manually, so there is a way to insert them using a template. If you right-click where you wish to write a predicate logic statement, you can select <em>Slang->Insert Template->Forall</em>. This will insert the statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚àÄ((ID: TYPE) =&gt; CLAIM)</span></span></code></pre></div><p>You can type your variable name (often <code>x</code>, <code>y</code>, etc.) in place of <code>ID</code>, the domain type (usually <code>T</code>) in place of <code>TYPE</code>, and your claim (with predicates and propositional logic operators) in place of <code>CLAIM</code>.</p><p>Finally, you can type the keyboard shortcut <em>Ctrl+Shift+, A</em> to insert a for all statement.</p><h2 id=there-exists-statements-in-logika>There exists statements in Logika</h2><p>Statements with existential quantifiers like <code>‚àÉ x P(x)</code> must also be treated differently. When we are using Logika to do a predicate logic proof, we express <code>‚àÉ x P(x)</code> as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚àÉ ((x: T) =&gt; P(x))</span></span></code></pre></div><p>The above statement is saying, &ldquo;there exists an x with type T where P(x) is true&rdquo;.</p><p>We can alternatively use curly braces instead of standard parentheses to surround our predicate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚àÉ {(x: T) =&gt; P(x)}</span></span></code></pre></div><p>Such statements can be a pain to type out manually, so there is a way to insert them using a template. If you right-click where you wish to write a predicate logic statement, you can select <em>Slang->Insert Template->Exists</em>. This will insert the statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚àÉ((ID: TYPE) =&gt; CLAIM)</span></span></code></pre></div><p>You can type your variable name (often <code>x</code>, <code>y</code>, etc.) in place of <code>ID</code>, the domain type (usually <code>T</code>) in place of <code>TYPE</code>, and your claim (with predicates and propositional logic operators) in place of <code>CLAIM</code>.</p><p>Finally, you can type the keyboard shortcut <em>Ctrl+Shift+, E</em> to insert a there exists statement.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=rules-with->Rules with ‚àÄ</h1><p>Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers &ndash; an &ldquo;introduction rule and an &ldquo;elimination&rdquo; rule.</p><p>In this section, we will see the two inference rules for the universal (‚àÄ) quantifier.</p><h2 id=for-all-elimination>For all elimination</h2><p>For all elimination allows us to take a claim that uses a universal quantifier &ndash; a statement about ALL individuals in a domain &ndash; and make the same statement about a specific individual in the domain. After all, if the statement is true for ALL individuals, then it follows that it should be true for a particular individual. We can formalize the rule as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>           ‚àÄ ((x: T) =&gt; P(x))
</span></span><span class=line><span class=cl>AllE[T]:  ---------------------
</span></span><span class=line><span class=cl>                   P(v)     where v is a particular individual in the domain (i.e, v has type T)</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>AllE[T]</code> rule. It shows that given the premises: <em>All humans are mortal</em> and <em>Socrates is a human</em>, that we can prove that <em>Socrates is mortal</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (   ‚àÄ ((x: T) =&gt; (isHuman(x) ‚Üí isMortal(x))),  
</span></span><span class=line><span class=cl>        isHuman(Socrates)    
</span></span><span class=line><span class=cl>    ) 
</span></span><span class=line><span class=cl>‚ä¢ 
</span></span><span class=line><span class=cl>    (   
</span></span><span class=line><span class=cl>        isMortal(Socrates) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ ((x: T) =&gt; (isHuman(x) ‚Üí isMortal(x)))        )   by Premise,
</span></span><span class=line><span class=cl>    2 (     isHuman(Socrates)                               )   by Premise,
</span></span><span class=line><span class=cl>    3 (     isHuman(Socrates) ‚Üí isMortal(Socrates)          )   by AllE[T](1),
</span></span><span class=line><span class=cl>    4 (     isMortal(Socrates)                              )   by ImplyE(3, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We can read the justification <code>AllE[T](1)</code> as: &ldquo;for all elimination of the for all statement on line 1.</p><p>While our <code>AllE[T]</code> justification does not mention the particular individual that was plugged in to the for all statement (<em>Socrates</em>, in this case), it is required that whatever individual we plug in has already been show to be of type <code>T</code>. This is done by accepting the individual as a parameter of type <code>T</code> to the proof function. The full proof function would look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>@pure def socMortal[T](isHuman: T =&gt; B @pure, isMortal: T =&gt; B @pure, Socrates: T): Unit = {
</span></span><span class=line><span class=cl>    Deduce (
</span></span><span class=line><span class=cl>        (   
</span></span><span class=line><span class=cl>            ‚àÄ ((x: T) =&gt; (isHuman(x) ‚Üí isMortal(x))),  
</span></span><span class=line><span class=cl>            isHuman(Socrates)    
</span></span><span class=line><span class=cl>        ) 
</span></span><span class=line><span class=cl>        ‚ä¢ 
</span></span><span class=line><span class=cl>        (   
</span></span><span class=line><span class=cl>            isMortal(Socrates) 
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>        Proof(
</span></span><span class=line><span class=cl>            1 (     ‚àÄ ((x: T) =&gt; (isHuman(x) ‚Üí isMortal(x)))      )   by Premise,
</span></span><span class=line><span class=cl>            2 (     isHuman(Socrates)                             )   by Premise,
</span></span><span class=line><span class=cl>            3 (     isHuman(Socrates) ‚Üí isMortal(Socrates)        )   by AllE[T](1),
</span></span><span class=line><span class=cl>            4 (     isMortal(Socrates)                            )   by ImplyE(3, 2)
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>In similar examples of <code>AllE[T]</code>, it is assumed that the named individual was accepted as a parameter of type <code>T</code> to the proof function.</p><h2 id=for-all-introduction>For all introduction</h2><p>If we can show that a property of the form <code>P(a)</code> holds for an arbitrary member <code>a</code> of a domain, then we can use for all introduction to conclude that the property must hold for ALL individuals in the domain &ndash; i.e., that <code>‚àÄ x P(x)</code> (which we write in Logika as <code>‚àÄ ((x: T) => P(x))</code>). We can formalize the rule as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>            Let (   (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>                ... 
</span></span><span class=line><span class=cl>                P(a)  
</span></span><span class=line><span class=cl>            )),
</span></span><span class=line><span class=cl>AllI[T] : -------------------------------
</span></span><span class=line><span class=cl>                 ‚àÄ ((x: T) =&gt; P(x)) </span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>AllI[T]</code> rule: &ldquo;Everyone is healthy; everyone is happy. Therefore, everyone is both healthy and happy.&rdquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (   
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; isHealthy(x)), ‚àÄ((y: T) =&gt; isHappy(y))
</span></span><span class=line><span class=cl>    )  
</span></span><span class=line><span class=cl>‚ä¢  
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((z: T) =&gt; isHealthy(z) ‚àß isHappy(z))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof (
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; isHealthy(x))               )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((y: T) =&gt; isHappy(y))                 )   by Premise,
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    3 Let ((a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 (     isHealthy(a)                        )   by AllE[T](1),
</span></span><span class=line><span class=cl>        5 (     isHappy(a)                          )   by AllE[T](2),
</span></span><span class=line><span class=cl>        6 (     isHealthy(a) ‚àß isHappy(a)           )   by AndI(4, 5)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    7 (     ‚àÄ((z: T) =&gt; isHealthy(z) ‚àß isHappy(z))  )   by AllI[T](3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>If we wish to introduce a for all statement, the pattern is:</p><ul><li><p>Open a subproof where you introduce an arbitrary/fresh individual in the domain with &ldquo;Let&rdquo; (in the example above, we used <code>a</code>). It MUST be a name that we have not used elsewhere in the proof. The idea is that your individual could have been anyone/anything in the domain.</p></li><li><p>When you introduce the individual with &ldquo;Let&rdquo; and then open the subproof, you do NOT include a justification on that line</p></li><li><p>If you have other for all statements available within the scope of the subproof, then it is often useful to use <code>AllE[T]</code> to plug your fresh individual into them. After all, if those statements are true for ALL individuals, then they are also true for your fresh individual.</p></li><li><p>If you are trying to prove something of the form <code>‚àÄ ((x: T) => P(x))</code>, then you need to reach <code>P(a)</code> by the end of the subproof. You need to show that your goal for all statement holds for your fresh individual. In our case, we wished to prove <code>‚àÄ((z: T) => isHealthy(z) ‚àß isHappy(z))</code>, so we reached <code>isHealthy(a) ‚àß isHappy(a)</code> by the end of the subproof.</p></li><li><p>After the subproof, you can use <code>‚àÄi</code> to introduce a for-all statement for your last claim in the subproof &ndash; that since the individual could have been anyone, then the proposition holds for ALL individuals. The <code>‚àÄi</code> justification needs the line number of the subproof.</p></li><li><p>When you use <code>AllI[T]</code>, it does not matter what variable you introduce into the for all statement. In the example above, we introduced <code>‚àÄ((z: T)</code> &ndash; but that was only to match the goal conclusion in the proof. We could have instead introduced <code>‚àÄ((x: T)</code>, <code>‚àÄ((y: T)</code>, <code>‚àÄ((people T)</code>, etc. We would use whatever variable we chose in the rest of that proposition &ndash; i.e., <code>‚àÄ((z: T) => isHealthy(z) ‚àß isHappy(z))</code>, or <code>‚àÄ((people: T) => isHealthy(people) ‚àß isHappy(people))</code>, etc.</p></li></ul><h2 id=examples>Examples</h2><p>In this section, we will look at additional proofs involving the universal quantifier.</p><h3 id=example-1>Example 1</h3><p>Suppose we wish to prove that, given the following premises in the domain of people:</p><ul><li>All students have a phone and/or a laptop</li><li>Everyone is a student</li></ul><p>Then we can conclude:</p><ul><li>Everyone has a phone and/or a laptop</li></ul><p>First, we identify the following predicates:</p><ul><li><code>isStudent(x)</code> - whether person x is a student</li><li><code>hasPhone(x)</code> - whether person x has a phone</li><li><code>hasLaptop(x)</code> = whether person x has a laptop</li></ul><p>Then, we can translate our premises and goal conclusion to predicate logic:</p><ul><li><em>All students have a phone and/or a laptop</em> translates to: <code>‚àÄ x (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x))</code></li><li><em>Everyone is a student</em> translates to: <code>‚àÄ x isStudent(x)</code></li><li><em>Everyone has a phone and/or a laptop</em> translates to: <code>‚àÄ x (hasPhone(x) ‚à® hasLaptop(x))</code></li></ul><p>We need to prove the following sequent (where we rewrite the above predicate logic statements in our Logika format):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x))), 
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; isStudent(x))
</span></span><span class=line><span class=cl>    ) 
</span></span><span class=line><span class=cl>‚ä¢ 
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>As with our previous example, we see that we are trying to prove a for-all statement (<code>‚àÄ((y: T) => (hasPhone(y) ‚à® hasLaptop(y)))</code>). This means we will need to open a subproof and introduce a fresh individual &ndash; perhaps <code>bob</code>. By the end of the subproof, we must show that our goal for-all statement holds for that individual &ndash; that <code>hasPhone(bob) ‚à® hasLaptop(bob)</code>. We start the proof as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x))), 
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; isStudent(x))
</span></span><span class=line><span class=cl>    ) 
</span></span><span class=line><span class=cl>‚ä¢ 
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof (
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x)))        )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; isStudent(x))                                       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (bob: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        //goal: hasPhone(bob) ‚à® hasLaptop(bob)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    //use AllI to conclude ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We have two available for-all statements within the subproof &ndash; <code>‚àÄ((x: T) => (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x)))</code> and <code>‚àÄ((x: T) => isStudent(x))</code>. Since those propositions hold for all individuals, they also hold for <code>bob</code>. We use <code>AllE[T]</code> to plug in <code>bob</code> to those two propositions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x))), 
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; isStudent(x))
</span></span><span class=line><span class=cl>    ) 
</span></span><span class=line><span class=cl>‚ä¢ 
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof (
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x)))        )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; isStudent(x))                                       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (bob: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 (     isStudent(bob) ‚Üí hasPhone(bob) ‚à® hasLaptop(bob)             )   by AllET(1),
</span></span><span class=line><span class=cl>        5 (     isStudent(bob)                                              )   by AllE[T](2),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: hasPhone(bob) ‚à® hasLaptop(bob)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    //use AllI to conclude ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Line 5 is an implies statement the form <code>p ‚Üí q</code>, and line 6 is a statement of the form <code>p</code>. Thus we can use <code>‚Üíe</code> to conclude <code>hasPhone(bob) ‚à® hasLaptop(bob)</code> (the &ldquo;q&rdquo; in that statement) &ndash; which is exactly what we needed to end the subproof. All that remains is to apply our <code>AlI</code> rule after the subproof. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x))), 
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; isStudent(x))
</span></span><span class=line><span class=cl>    ) 
</span></span><span class=line><span class=cl>‚ä¢ 
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof (
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (isStudent(x) ‚Üí hasPhone(x) ‚à® hasLaptop(x)))        )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; isStudent(x))                                       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (bob: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 (     isStudent(bob) ‚Üí hasPhone(bob) ‚à® hasLaptop(bob)             )   by AllET(1),
</span></span><span class=line><span class=cl>        5 (     isStudent(bob)                                              )   by AllE[T](2),
</span></span><span class=line><span class=cl>        6 (     hasPhone(bob) ‚à® hasLaptop(bob)                              )   by ImplyE(4, 5)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    7 (     ‚àÄ((y: T) =&gt; (hasPhone(y) ‚à® hasLaptop(y)))                       )   by AllI[T](3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h3 id=example-2>Example 2</h3><p>Next, suppose we wish to prove the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨D(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>We again see that the top-level operator of what we are trying to prove is a universal quantifier. We use our strategy to open a subproof with a fresh individual (maybe <code>a</code>), and plug that individual into any available for-all statements. Since we wish to prove <code>‚àÄ((x: T) => ¬¨S(x))</code>, then we will want to reach <code>¬¨S(a)</code> by the end of the subproof. Here is a sketch:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨D(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))      )   by Premise,
</span></span><span class=line><span class=cl>    3 (     ‚àÄ((x: T) =&gt; ¬¨D(x))              )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    4 Let ((a: T) =&gt; SubProof (
</span></span><span class=line><span class=cl>        5 (     S(a) ‚Üí Pz(a)                )   by AllE[T](1),
</span></span><span class=line><span class=cl>        6 (     Pz(a) ‚Üí D(a)                )   by AllE[T](2),
</span></span><span class=line><span class=cl>        7 (     ¬¨D(a)                       )   by AllE[T](3),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ¬¨S(a)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use AllI[T] to conclude ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Now, we see that our goal is to reach <code>¬¨S(a)</code> by the end of the subproof &ndash; so we need to prove something whose top-level operator is a NOT. We recall that we have a strategy to prove NOT(something) from propositional logic &ndash; we open a subproof, assuming <em>something</em> (<code>S(a)</code>, in our case), try to get a contradiction, and use negation introduction after the subproof to conclude NOT (something) (<code>¬¨S(a)</code> for us). Here is the strategy:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨D(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))      )   by Premise,
</span></span><span class=line><span class=cl>    3 (     ‚àÄ((x: T) =&gt; ¬¨D(x))              )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    4 Let ((a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        5 (     S(a) ‚Üí Pz(a)                )   by AllE[T](1),
</span></span><span class=line><span class=cl>        6 (     Pz(a) ‚Üí D(a)                )   by AllE[T](2),
</span></span><span class=line><span class=cl>        7 (     ¬¨D(a)                       )   by AllE[T](3),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        8 SubProof(
</span></span><span class=line><span class=cl>            10 Assume( S(a) ),
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            //goal: contradiction
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        //use NegI to conclude ¬¨S(a)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ¬¨S(a)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use AllI[T] to conclude ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We can complete the proof as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨D(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (S(x) ‚Üí Pz(x)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; (Pz(x) ‚Üí D(x))      )   by Premise,
</span></span><span class=line><span class=cl>    3 (     ‚àÄ((x: T) =&gt; ¬¨D(x))              )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    4 Let ((a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        5 (     S(a) ‚Üí Pz(a)                )   by AllE[T](1),
</span></span><span class=line><span class=cl>        6 (     Pz(a) ‚Üí D(a)                )   by AllE[T](2),
</span></span><span class=line><span class=cl>        7 (     ¬¨D(a)                       )   by AllE[T](3),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        8 SubProof(
</span></span><span class=line><span class=cl>            10 Assume( S(a) ),
</span></span><span class=line><span class=cl>            11 (    Pz(a)                   )   by ImplyE(5, 10),
</span></span><span class=line><span class=cl>            12 (    D(a)                    )   by ImplyE(6, 11),
</span></span><span class=line><span class=cl>            13 (    F                       )   by NegE(12, 7)
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            //goal: contradiction
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        //use ¬¨i to conclude ¬¨S(a)
</span></span><span class=line><span class=cl>        14 (    ¬¨S(a)                       )   by NegI(8)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ¬¨S(a)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use AllI[T] to conclude ‚àÄ((x: T) =&gt; ¬¨S(x))
</span></span><span class=line><span class=cl>    15 (    ‚àÄ((x: T) =&gt; ¬¨S(x))              )   by AllI[T](4)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=rules-with->Rules with ‚àÉ</h1><p>In this section, we will see the two inference rules for the existential (‚àÉ) quantifier.</p><h2 id=exists-introduction>Exists introduction</h2><p>We can use the exists introduction rule, <code>ExistsI[T]</code>, when we have a proposition of the form <code>P(a)</code> for an arbitrary member <code>a</code> of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                   P(d)         where  d  is an individual of type T
</span></span><span class=line><span class=cl>ExistsI[T]: ---------------------
</span></span><span class=line><span class=cl>              ‚àÉ((x: T) =&gt; P(x))</span></span></code></pre></div><p>Here is a simple example showing the syntax of the <code>ExistsI[T]</code> rule (where <em>Socrates</em> is a parameter of type <code>T</code> to our proof function):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   isHuman(Socrates)   ) ‚ä¢ (   ‚àÉ((x: T) =&gt; isHuman(x))  )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span class=line><span class=cl>        2 (     ‚àÉ((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>When we use the <code>ExistsI[T]</code> rule to justify a claim like <code>‚àÉ((x: T) => P(x))</code>, we include the line number of where the proposition held for a particular individual. In the proof above, we claim <code>‚àÉ((x: T) => isHuman(x))</code> with justification <code>ExistsI[T](1)</code> &ndash; line 1 corresponds to <code>isHuman(Socrates)</code>, where our <code>‚àÉ((x: T) => isHuman(x))</code> proposition held for a particular individual. The full proof function, which shows how <em>Socrates</em> can be accepted as a parameter of type <code>T</code>, is here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>@pure def ExistsExample[T](isHuman: T =&gt; B @pure, Socrates: T): Unit = {
</span></span><span class=line><span class=cl>    Deduce(
</span></span><span class=line><span class=cl>        (   isHuman(Socrates)   ) ‚ä¢ (   ‚àÉ((x: T) =&gt; isHuman(x))  )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        Proof(
</span></span><span class=line><span class=cl>            1 (     isHuman(Socrates)       )   by Premise,
</span></span><span class=line><span class=cl>            2 (     ‚àÉ((x: T) =&gt; isHuman(x)) )   by ExistsI[T](1)
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>}</span></span></code></pre></div><p>Note that we can use the <code>ExistsI[T]</code> rule to introduce any variable, not just <code>x</code>. You can choose which variable to introduce based on the variables used in the conclusion. For example, the following proof is also valid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   isHuman(Socrates)   ) ‚ä¢ (   ‚àÉ((z: T) =&gt; isHuman(z))  )
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    Proof(
</span></span><span class=line><span class=cl>        1 (     isHuman(Socrates)       )   by Premise,
</span></span><span class=line><span class=cl>        2 (     ‚àÉ((z: T) =&gt; isHuman(z)) )   by ExistsI[T](1)
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><h2 id=exists-elimination>Exists elimination</h2><p>Since the <code>ExistsI[T]</code>-rule constructs propositions that begin with <code>‚àÉ</code>, the <code>ExistsE[T]</code>-rule (exists elimination) disassembles propositions that begin with <code>‚àÉ</code>.</p><p>Here is a quick example (where our domain is living things):</p><ul><li>All humans are mortal</li><li>Someone is human</li><li>Therefore, someone is mortal</li></ul><p>We don&rsquo;t know the name of the human, but it does not matter. Since ALL humans are mortal and SOMEONE is human, then our anonymous human must be mortal. The steps will go like this:</p><ul><li><p>Since &ldquo;someone is human&rdquo; and since we do not know his/her name, we will just make up our own name for them ‚Äì &ldquo;Jane&rdquo;. So, we assume that &ldquo;Jane is human&rdquo;.</p></li><li><p>We use the logic rules we already know to prove that &ldquo;Jane is mortal&rdquo;.</p></li><li><p>Therefore, SOMEONE is mortal and their name does not matter.</p></li></ul><p>This approach is coded into the last logic law, <code>ExistsE[T]</code> (exists elimination).</p><p>Suppose we have a premise of the form <code>‚àÉ((x: T) => P(x))</code>. Since we do not know the name of the individual &ldquo;hidden&rdquo; behind the <code>‚àÉ(x: T)</code>, we make up a name for it, say <code>a</code>, and discuss what must follow from the assumption that <code>P(a)</code> holds true. Here is the formalization of the <code>ExistsE[T]</code> rule:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                                        Let ((a: T) =&gt; SubProof(          // where  a  is a new, fresh name
</span></span><span class=line><span class=cl>                                             Assume( P(a) ),              // a  MUST NOT appear in  Q
</span></span><span class=line><span class=cl>                ‚àÉ((x: T) =&gt; P(x))            ...
</span></span><span class=line><span class=cl>                                             Q         
</span></span><span class=line><span class=cl>                                        )),             
</span></span><span class=line><span class=cl>ExistsE[T]: ----------------------------------------------------
</span></span><span class=line><span class=cl>                     Q</span></span></code></pre></div><p>That is, if we can deduce <code>Q</code> from <code>P(a)</code>, and we do not mention <code>a</code> within <code>Q</code>, then it means <code>Q</code> can be deduced no matter what name the hidden individual has. So, <code>Q</code> follows from <code>‚àÉ((x: T) => P(x))</code>.</p><p>We can work the previous example, with <code>ExistsE[T]</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>All humans are mortal
</span></span><span class=line><span class=cl>Someone is human
</span></span><span class=line><span class=cl>Therefore, someone is mortal</span></span></code></pre></div><p>We make up the name, <code>jane</code>, for the human whose name we do not know:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((h: T) =&gt; (isHuman(h) ‚Üí isMortal(h))),
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; isHuman(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((y: T) =&gt; (isMortal(y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((h: T) =&gt; (isHuman(h) ‚Üí isMortal(h)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÉ((x: T) =&gt; isHuman(x))                     )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (jane: T) =&gt; SubProof (
</span></span><span class=line><span class=cl>        4 Assume(   isHuman(jane)                       ),
</span></span><span class=line><span class=cl>        5 (         isHuman(jane) ‚Üí isMortal(jane)      )   by AllE[T](1),
</span></span><span class=line><span class=cl>        6 (         isMortal(jane)                      )   by ImplyE(5, 4)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    7 (     ‚àÉ((y: T) =&gt; (isMortal(y)))                  )   by ExistsE[T](2, 3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Line 3 proposes the name <code>jane</code> for our subproof and line 4 makes the assumption <code>isHuman(jane)</code> (based on the premise <code>‚àÉ((x: T) => isHuman(x))</code>). The subproof leads to Line 6, which says that someone is mortal. (We never learned the individual&rsquo;s name!) Since Line 6 does not explicitly mention the made-up name, <code>jane</code>, we use Line 7 to repeat Line 6 ‚Äì without knowing the name of the individual &ldquo;hiding&rdquo; inside Line 2, we made a subproof that proves the result, anyway. This is how <code>ExistsE[T]</code> works.</p><p>Note that when we use the <code>ExistsE[T]</code> rule as a justification we include first the line number of the there exists statement that we processed (by naming the hidden individual) in the previous subproof, and then the line number of that subproof. In the example above, we say <code>ExistsE[T](2, 3)</code> because line 2 includes the there-exists statement we processed (<code>‚àÉ ‚àÉ((x: T) => isHuman(x))</code>) in the previous subproof and line 3 is the subproof.</p><p>When using <code>ExistsE[T]</code>, the previous subproof must begin with introducing a name for a hidden individual in a there-exists statement and then immediately make an assumption that substitutes the name into the there exists statement. The last line in the subproof should contain NO mention of the chosen name. Whatever we claim on the last line in the subproof, we must claim EXACTLY the same thing immediately afterwards when we use the <code>ExistsE[T]</code> rule.</p><p>You are welcome to use any name for the hidden individual &ndash; not just <code>jane</code> or <code>a</code>. The only restriction is that you cannot have used the name anywhere else in the proof.</p><h2 id=examples>Examples</h2><p>In this section, we will look at other proofs involving the existential quantifier.</p><h3 id=example-1>Example 1</h3><p>Suppose we wish to prove the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   ‚àÉ((x: T) =&gt; (Adult(x) ‚à® Kid(x)))  ) ‚ä¢ (   ‚àÉ((x: T) =&gt; Adult(x) )) ‚à® ‚àÉ((x: T) =&gt; Kid(x)  )</span></span></code></pre></div><p>We will begin as we did previously: by introducing an alias for our person that is either an adult or a kid (say, <code>alice</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   ‚àÉ((x: T) =&gt; (Adult(x) ‚à® Kid(x)))  ) ‚ä¢ (   ‚àÉ((x: T) =&gt; Adult(x) )) ‚à® ‚àÉ((x: T) =&gt; Kid(x)  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÉ((x: T) =&gt; (Adult(x) ‚à® Kid(x)) )       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        3 Assume(   Adult(alice) ‚à® Kid(alice)       ),
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        //goal: get to our conclusion, ‚àÉ( (x: T) =&gt; Adult(x) )) ‚à® ‚àÉ( (x: T) =&gt; Kid(x)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>To finish our proof, we can use OR elimination on <code>Adult(alice) ‚à® Kid(alice)</code>, and then <code>ExistsE[T]</code> afterwards to restate our conclusion. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(   ‚àÉ((x: T) =&gt; (Adult(x) ‚à® Kid(x)))  ) ‚ä¢ (   ‚àÉ((x: T) =&gt; Adult(x) )) ‚à® ‚àÉ((x: T) =&gt; Kid(x)  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÉ((x: T) =&gt; (Adult(x) ‚à® Kid(x)) )                   )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (alice: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        3 Assume(   Adult(alice) ‚à® Kid(alice)                   ),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        4 SubProof(
</span></span><span class=line><span class=cl>            5 Assume (  Adult(alice)                            ),
</span></span><span class=line><span class=cl>            6 (     ‚àÉ((x: T) =&gt; Adult(x)                        )   by ExistsI[T](5),
</span></span><span class=line><span class=cl>            7 (     ‚àÉ((x: T) =&gt; Adult(x) ‚à® ‚àÉ((x: T) =&gt; Kid(x)   )   by OrI1(6)
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        8 SubProof(
</span></span><span class=line><span class=cl>            9 Assume (  Kid(alice)                              ),
</span></span><span class=line><span class=cl>            10 (    ‚àÉ((x: T) =&gt; Kid(x)                          )   by ExistsI[T](9),
</span></span><span class=line><span class=cl>            11 (    ‚àÉ((x: T) =&gt; Adult(x) ‚à® ‚àÉ((x: T) =&gt; Kid(x)   )   by OrI2(10)
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        12 (    ‚àÉ((x: T) =&gt; Adult(x) ‚à® ‚àÉ((x: T) =&gt; Kid(x)       )   by OrE(3, 4, 8)
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        //goal: get to our conclusion, ‚àÉ( (x: T) =&gt; Adult(x) )) ‚à® ‚àÉ( (x: T) =&gt; Kid(x)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate our conclusion, since we know SOME such person is either an adult or kid
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    13 (        ‚àÉ((x: T) =&gt; Adult(x) ‚à® ‚àÉ((x: T) =&gt; Kid(x)       )   by ExistsE[T](1, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h3 id=example-2>Example 2</h3><p>Suppose we wish to prove the following (in the domain of living things):</p><ul><li>All bunnies are fluffy</li><li>There is a fast bunny</li><li>Therefore, there is a creature that is fast and fluffy</li></ul><p>We can translate our premises and desired conclusion to predicate logic, and write the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Bunny(x) ‚Üí Fluffy(x))),
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>Since we are trying to prove a claim about some individual, it makes sense that we would start the process of an <code>ExistsE[T]</code> subproof where we introduce an alias (<code>thumper</code>) for the fast bunny. We will try to reach the conclusion by the end of that subproof. Here is the setup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Bunny(x) ‚Üí Fluffy(x))),
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (Bunny(x) ‚Üí Fluffy(x)))     )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÉ((x: T) =&gt; (Fast(x) &amp; Bunny(x)))       )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 Assume(   Fast(thumper) ‚àß Bunny(thumper)  ),
</span></span><span class=line><span class=cl>        5 (         Fast(thumper)                   )   by AndE1(4),
</span></span><span class=line><span class=cl>        6 (         Bunny(thumper)                  )   by AndE2(4),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>To finish our subproof, we see that we have a proposition about all creatures (<code>‚àÄ((x: T) => (Bunny(x) ‚Üí Fluffy(x)))</code>) and that we are working with an individual creature (<code>thumper</code>). We can use <code>AllE[T]</code> to prove <code>Bunny(thumper) ‚Üí Fluffy(thumper)</code>. After that, we have a few more manipulations using propositional logic rules, our <code>ExistsI[T]</code> rule to transition our claim from being about our alias <code>thumper</code> to being about an unnamed individual, and then our <code>ExistsE[T]</code> rule to pull our final claim out of the subproof. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; (Bunny(x) ‚Üí Fluffy(x))),
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Bunny(x))) 
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; (Bunny(x) ‚Üí Fluffy(x)))         )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÉ((x: T) =&gt; (Fast(x) &amp; Bunny(x)))           )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    3 Let ( (thumper: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 Assume(   Fast(thumper) ‚àß Bunny(thumper)      ),
</span></span><span class=line><span class=cl>        5 (         Fast(thumper)                       )   by AndE1(4),
</span></span><span class=line><span class=cl>        6 (         Bunny(thumper)                      )   by AndE2(4),
</span></span><span class=line><span class=cl>        7 (         Bunny(thumper) ‚Üí Fluffy(thumper)    )   by AllE[T](1),
</span></span><span class=line><span class=cl>        8 (         Fluffy(thumper)                     )   by ImplyE(7, 6),
</span></span><span class=line><span class=cl>        9 (         Fast(thumper) ‚àß Fluffy(thumper)     )   by AndI(5, 8),
</span></span><span class=line><span class=cl>        10 (        ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))  )   by ExistsI[T](9)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //goal: ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //use ExistsE[T] to restate ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x))), since we know there is SOME fast bunny
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    11 (    ‚àÉ((x: T) =&gt; (Fast(x) &amp; Fluffy(x)))          )   by ExistsE[T](2, 3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=nested-quantifiers>Nested Quantifiers</h1><p>Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that <code>‚àÄ x ‚àÄ y P(x, y)</code> is equivalent to <code>‚àÄ x (‚àÄ y P(x, y))</code>.</p><p>//&lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;COME UP WITH DIFFERENT EXAMPLE 1!!!!!&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-></p><h2 id=example-1>Example 1</h2><p>Suppose we wish to prove the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y)))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>Since we wish to prove a for-all statement, <code>‚àÄ((x: T) => (SOMETHING)</code>, we know we must start with our for all introduction template:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y)))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y))))       )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //need: ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //want to use AllI[T] to conclude ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>But now we see that we want to prove ANOTHER for-all statement, <code>‚àÄ((y: T) => Q(a, y))</code>. So we again use our for all introduction strategy in a nested subproof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y)))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y))))       )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 ( (b: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            //need: Q(a, b)
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        //want to use AllI[T] to conclude ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //need: ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //want to use AllI[T] to conclude ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Now, in subproof 4, we see that we must use <code>AllE[T]</code> on our both of our premises to work towards our goal of <code>Q(a, b)</code>. We have two available individuals &ndash; <code>a</code> and <code>b</code>. When we use <code>AllE[T]</code>, we must eliminate the OUTER (top-level) quantifier and its variable. In the case of the premise <code>‚àÄ((x: T) => ‚àÄ((y: T) => (P(x, y) ‚Üí Q(x, y))))</code>, we see that we must eliminate the <code>‚àÄ((x: T) ...)</code>. Since the <code>x</code> is the first parameter in <code>Q(x, y)</code>, and since we are hoping to reach <code>Q(a, b)</code> by the end of subproof 4, we can see that we need to plug in the <code>a</code> for the <code>x</code> so that it will be in the desired position. We make a similar substitution with <code>AllE[T]</code> on our second premise:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y)))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y))))       )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 ( (b: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            5 (     ‚àÄ(y: T) =&gt; (P(a, y) ‚Üí Q(a, y)))             )   by AllE[T](1),
</span></span><span class=line><span class=cl>            6 (     ‚àÄ(y: T) =&gt; P(a, y)                          )   by AllE[T](2),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            //need: Q(a, b)
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        //want to use AllI[T] to conclude ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //need: ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //want to use AllI[T] to conclude ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Note that on line 5, we could NOT have used <code>AllE[T]</code> to eliminate the <code>‚àÄ(y: T)</code> in <code>‚àÄ((x: T) => ‚àÄ((y: T) => (P(x, y) ‚Üí Q(x, y)))) </code>, as it was not the top-level operator.</p><p>Next, we apply <code>AllE[T]</code> again to our results on lines 5 and 6, this time plugging in <code>b</code> for <code>y</code> in both cases. This leaves us with <code>P(a, b) ‚Üí Q(a, b)</code> and <code>P(a, b)</code>. We can use implies elimination to reach our goal of <code>Q(a, b)</code>, and then all that remains ais to use <code>AllI[T]</code> twice as planned to wrap up the two subproofs. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y)))),
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; (P(x, y) ‚Üí Q(x, y))))       )   by Premise,
</span></span><span class=line><span class=cl>    2 (     ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; P(x, y)))                   )   by Premise,
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    3 Let (  (a: T)  =&gt; SubProof(
</span></span><span class=line><span class=cl>        4 ( (b: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            5 (     ‚àÄ(y: T) =&gt; (P(a, y) ‚Üí Q(a, y))              )   by AllE[T](1),
</span></span><span class=line><span class=cl>            6 (     ‚àÄ(y: T) =&gt; P(a, y)                          )   by AllE[T](2),
</span></span><span class=line><span class=cl>            7 (     P(a, b) ‚Üí Q(a, b)                           )   by AllE[T](5),
</span></span><span class=line><span class=cl>            8 (     P(a, b)                                     )   by ALlE[T](6),
</span></span><span class=line><span class=cl>            9 (     Q(a, b)                                     )   by ImplyE(7, 8)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            //need: Q(a, b)
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        //want to use AllI[T] to conclude ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>        10 (    ‚àÄ((y: T) =&gt; Q(a, y))                            )   by AllI[T](4)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //need: ‚àÄ((y: T) =&gt; Q(a, y))
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    //want to use AllI[T] to conclude ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))
</span></span><span class=line><span class=cl>    11 (    ‚àÄ((x: T) =&gt; ‚àÄ((y: T) =&gt; Q(x, y)))                   )   by AllI[T](3)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h2 id=example-2>Example 2</h2><p>Suppose we have the predicate <code>IsBossOf(x, y)</code> in the domain of people, which describes whether person <code>x</code> is the boss of person <code>y</code>. We wish to prove the following sequent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; ‚àÄ((y: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>You can read the premise as &ldquo;There is a person that is everyone&rsquo;s boss&rdquo;. From this statement, we are trying to prove the conclusion: &ldquo;All people have a boss&rdquo;. Here is the completed proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; ‚àÄ((y: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÉ((x: T) =&gt; ‚àÄ((y: T) =&gt; IsBossOf(x, y)))            )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        3 Assume(   ‚àÄ((y: T) =&gt; IsBossOf(a, y)                  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        4 Let ( (b: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>            5 (         IsBossOf(a, b)                          )   by AllE[T](3),
</span></span><span class=line><span class=cl>            6 (         ‚àÉ((x: T) =&gt; IsBossOf(x, b))             )   by ExistsI[T](5)
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        7 (   ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))          )   by AllI[T](4)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    8 (   ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))              )  by ExistsE[T](1, 2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>In the above proof, we let <code>a</code> be our made-up name for the boss-of-everyone. So, we have the assumption that <code>‚àÄ((y: T) => IsBossOf(a, y))</code>. Next, we let <code>b</code> be &ldquo;anybody at all&rdquo; who we might examine in the domain of people. The proof exposes that the boss of &ldquo;anybody at all&rdquo; in the domain must always be <code>a</code>. <code>AllI[T]</code> and then <code>ExistsE[T]</code> finish the proof.</p><p>Here is the proof worked again, with the subproofs swapped:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; ‚àÄ((y: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÉ((x: T) =&gt; ‚àÄ((y: T) =&gt; IsBossOf(x, y)))            )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (b: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        3 Let ( (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>            4 Assume(   ‚àÄ((y: T) =&gt; IsBossOf(a, y))             ),
</span></span><span class=line><span class=cl>            5 (         IsBossOf(a, b)                          )   by AllE[T](4),
</span></span><span class=line><span class=cl>            6 (         ‚àÉ((x: T) =&gt; IsBossOf(x, b))             )   by ExistsI[T](5)
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        7 (       ‚àÉ((x: T) =&gt; IsBossOf(x, b))                   )   by ExistsE[T](1, 3)
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    8 (   ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))              )  by AllI[T](2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>Can we prove the converse? That is, if everyone has a boss, then there is one boss who is the boss of everyone? NO. We can try, but we get stuck:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÉ((x: T) =&gt; ‚àÄ((y: T) =&gt; IsBossOf(x, y)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((y: T) =&gt; ‚àÉ((x: T) =&gt; IsBossOf(x, y)))            )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>        3 (     ‚àÉ((x: T) =&gt; IsBossOf(x, a))                     )   by AllE[T](1),
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        4 Let ( (b: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>            5 (     Assume (    IsBossOf(b, a)                  ),
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        6 (     ‚àÄ((y: T) =&gt; IsBossOf(b, y))                     )   AllI[T](4),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //STEP 6 IS INVALID -- we cannot refer to b after the end of the subproof
</span></span><span class=line><span class=cl>        //where it was introduced
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    //...can&#39;t finish
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>We see that the &ldquo;block structure&rdquo; of the proofs warns us when we are making invalid deductions.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=equivalence>Equivalence</h1><p>In Chapter 5, we saw DeMorgan&rsquo;s laws for quantifiers &ndash; that if we have some domain, and if <code>P(x)</code> is a predicate for individuals in that domain, then the following statements are equivalent:</p><ul><li><code>¬¨(‚àÉ x P(x))</code> is equivalent to <code>‚àÄ x ¬¨P(x)</code></li><li><code>¬¨(‚àÄ x P(x))</code> is equivalent to <code>‚àÉ x ¬¨P(x)</code></li></ul><p>The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic &ndash; we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.</p><h2 id=example---how-to-prove-equivalence>Example - how to prove equivalence</h2><p>For example, to prove that <code>¬¨(‚àÉ x P(x))</code> is equivalent to <code>‚àÄ x ¬¨P(x)</code>, we must prove the sequents:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ¬¨(‚àÉ((x: T) =&gt; P(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨P(x))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>and</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨P(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ¬¨(‚àÉ((x: T) =&gt; P(x)))
</span></span><span class=line><span class=cl>    )</span></span></code></pre></div><p>We prove both directions below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ¬¨(‚àÉ((x: T) =&gt; P(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨P(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ¬¨(‚àÉ((x: T) =&gt; P(x)))        ) by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 Let ( (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        3 SubProof(
</span></span><span class=line><span class=cl>            4 Assume (  P(a)  ),
</span></span><span class=line><span class=cl>            5 (     ‚àÉ((x: T) =&gt; P(x))   ) by ExistsI[T](3),
</span></span><span class=line><span class=cl>            6 (     F                   ) by NegE(4, 1)
</span></span><span class=line><span class=cl>        ),
</span></span><span class=line><span class=cl>        7 (     ¬¨P(a)                   ) by NegI(3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    8 (  ‚àÄ((x: T) =&gt; ¬¨P(x))             ) by AllI[T](2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><p>And:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ‚àÄ((x: T) =&gt; ¬¨P(x))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>‚ä¢
</span></span><span class=line><span class=cl>    (
</span></span><span class=line><span class=cl>        ¬¨(‚àÉ((x: T) =&gt; P(x)))
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>Proof(
</span></span><span class=line><span class=cl>    1 (     ‚àÄ((x: T) =&gt; ¬¨P(x))          )   by Premise,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    2 SubProof(
</span></span><span class=line><span class=cl>        3 Assume (  ‚àÉ((x: T) =&gt; P(x))   ),
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        4 Let ( (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>            5 Assume (  P(a)  ),
</span></span><span class=line><span class=cl>            6 (     ¬¨P(a)               )   by AllE[T](1),
</span></span><span class=line><span class=cl>            7 (     F                   )   by NegE(5, 6),
</span></span><span class=line><span class=cl>        )),
</span></span><span class=line><span class=cl>        8 (     F                       )   By ExistsE[T](3, 4)
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    ),
</span></span><span class=line><span class=cl>    9 (     ¬¨(‚àÉ((x: T) =&gt; P(x)))        )   by NegI(2)
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h2 id=more-extensive-list-of-equivalences>More extensive list of equivalences</h2><p>Here is a more extensive list of equivalences in predicate logic. The remaining proofs are left as exercises for the reader:</p><ul><li><code>¬¨(‚àÉ x P(x))</code> is equivalent to <code>‚àÄ x ¬¨P(x)</code></li><li><code>¬¨(‚àÄ x P(x))</code> is equivalent to <code>‚àÉ x ¬¨P(x)</code></li><li><code>‚àÄ x (P(x) ‚Üí ¬¨Q(x))</code> is equivalent to <code>¬¨(‚àÉ x P(x) ‚àß Q(x))</code></li><li><code>‚àÄ x ‚àÄ y P(x, y)</code> is equivalent to <code>‚àÄ y ‚àÄ x P(x, y)</code></li><li><code>‚àÉ x ‚àÉ y P(x, y)</code> is equivalent to <code>‚àÉ y ‚àÉ x P(x, y)</code></li><li><code>Q ‚àß (‚àÄ x P(x))</code> is equivalent to <code>‚àÄ x (Q ‚àß P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li><li><code>Q v (‚àÄ x P(x))</code> is equivalent to <code>‚àÄ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li><li><code>Q ‚àß (‚àÉ x P(x))</code> is equivalent to <code>‚àÉ x (Q ‚àß P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li><li><code>Q V (‚àÉ x P(x))</code> is equivalent to <code>‚àÉ x (Q V P(x))</code> (where <code>x</code> does not appear in <code>Q</code>)</li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary-and-strategies>Summary and Strategies</h1><p>In this section, we summarize all available rules in propositional logic, and discuss strategies for approaching proofs.</p><h2 id=rules-with-universal-quantifier->Rules with universal quantifier (<code>‚àÄ</code>)</h2><p>Rule summaries:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>           ‚àÄ ((x: T) =&gt; P(x))
</span></span><span class=line><span class=cl>AllE[T]:  ---------------------
</span></span><span class=line><span class=cl>                   P(v)     where v is a particular individual in the domain (i.e, v has type T)</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>            Let (   (a: T) =&gt; SubProof(
</span></span><span class=line><span class=cl>                ... 
</span></span><span class=line><span class=cl>                P(a)  
</span></span><span class=line><span class=cl>            )),
</span></span><span class=line><span class=cl>AllI[T] : -------------------------------
</span></span><span class=line><span class=cl>                 ‚àÄ ((x: T) =&gt; P(x)) </span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>( 
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    r (     ‚àÄ ((x: T) =&gt; P(x))      )   by SomeJustification,
</span></span><span class=line><span class=cl>    s (     P(v)                    )   by AllE[T](r),      //where v has been previously shown to have type T    
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>( 
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    r Let (  (a: T) =&gt; SubProof(    //where a is a fresh, previously unused, individual
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>        t (     P(a)            )   by SomeJustification
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    u (     ‚àÄ ((x: T) =&gt; P(x))  )   by AllI[T](r),
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h2 id=rules-with-existential-quantifier->Rules with existential quantifier (<code>‚àÉ</code>)</h2><p>Rule summaries:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                   P(d)         where  d  is an individual of type T
</span></span><span class=line><span class=cl>ExistsI[T]: ---------------------
</span></span><span class=line><span class=cl>              ‚àÉ((x: T) =&gt; P(x))</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                                        Let ((a: T) =&gt; SubProof(          // where  a  is a new, fresh name
</span></span><span class=line><span class=cl>                                             Assume( P(a) ),              // a  MUST NOT appear in  Q
</span></span><span class=line><span class=cl>                ‚àÉ((x: T) =&gt; P(x))            ...
</span></span><span class=line><span class=cl>                                             Q         
</span></span><span class=line><span class=cl>                                        )),             
</span></span><span class=line><span class=cl>ExistsE[T]: ----------------------------------------------------
</span></span><span class=line><span class=cl>                     Q</span></span></code></pre></div><p>Rule syntax summaries:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    r (     P(d)                )   by SomeJustification,   //where d has been shown to have type T
</span></span><span class=line><span class=cl>    s (     ‚àÉ((x: T) =&gt; P(x))   )   by ExistsI[T](r),
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    b (     ‚àÉ((x: T) =&gt; P(x))       )   by SomeJustification,
</span></span><span class=line><span class=cl>    c Let ( (a: T) =&gt; SubProof(     //where a is a previously unused individual
</span></span><span class=line><span class=cl>        d Assume(  P(a)  ),
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>        f (     Q                   )   by SomeJustification    //where a does NOT appear in Q
</span></span><span class=line><span class=cl>    )),
</span></span><span class=line><span class=cl>    g (     Q                       )   by ExistsE[T](b, c),
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>)</span></span></code></pre></div><h2 id=reminder-propositional-logic-rules-are-still-available>Reminder: propositional logic rules are still available</h2><p>When doing proofs in predicate logic, remember that all the deduction rules from propositional logic are still available. You will often want to use the same strategies we saw there &ndash; not introduction to prove a NOT, implies introduction to create an implies statement, OR elimination to process an OR statement, etc.</p><p>However, keep in mind that propositional logic rules can only be used on claims without quantifiers as their top-level operator. For example, if we have the statement <code>‚àÄ ( x: T) => (S(x) ‚àß Pz(x)) )</code>, then we cannot use <code>AndE</code> &ndash; the top-level operator is a universal quantifier, and the <code>‚àß</code> statement is &ldquo;bound up&rdquo; in that quantifier. We would only be able to use <code>AndE</code> after we had used <code>AllE[T]</code> to eliminate the quantifier.</p><h2 id=strategies>Strategies</h2><ol><li><p>Write down all premises first. Can you extract anything from the premises?</p><ul><li>If you have a for-all statement and an available individual, use <code>AndE[T]</code> to plug that individual into the for-all statement.</li><li>If you have <code>p‚àßq</code>, use <code>AndE1</code> to extract <code>p</code> by itself and then <code>AndE2</code> to extract <code>q</code> by itself.</li><li>If you have <code>p ‚Üí: q</code> and <code>p</code>, use <code>ImplyE</code> to get <code>q</code>.</li><li>If you have <code>p</code> and <code>¬¨p</code>, use <code>NegE</code> to claim a contradiction, <code>F</code>.</li></ul></li><li><p>Look at the top-level operator of what you are trying to prove.</p><ul><li><p>Are you trying to prove something of the form <code>‚àÄ ((x: T) => P(x))</code>?</p><ul><li>Use <code>AllI[T]</code>. Open a subproof, introduce a fresh <code>a</code>, and get to <code>P(a)</code> by the end of the subproof. After the subproof, use <code>AllI[T]</code> to conclude <code>‚àÄ ((x: T) => P(x))</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>‚àÉ((x: T) => P(x))</code>?</p><ul><li>You will often have another there-exists (<code>‚àÉ</code>) statement available as a premise or previous claim. Open a subproof, and assume an alias for the individual in your there-exists statement. Get to <code>‚àÉ((x: T) => P(x))</code> by the last line of the subproof. After the subproof, use <code>ExistsE[T]</code> to restate <code>‚àÉ((x: T) => P(x))</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p ‚Üí: q</code>?</p><ul><li>Use <code>ImplyI</code>. Open a subproof, assume <code>p</code>, and get to <code>q</code> by the end of the subproof. After the subproof, use <code>ImplyI</code> to conclude <code>p ‚Üí: q</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>¬¨p</code>?</p><ul><li>Use <code>NegI</code>. Open a subproof, assume <code>p</code>, and get a contradiction, <code>F</code>, by the end of the subproof. After the subproof, use <code>NegI</code> to conclude <code>¬¨p</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p ‚àß q</code>?</p><ul><li>Try to prove <code>p</code> by itself and then <code>q</code> by itself. Afterward, use <code>AndI</code> to conclude <code>p ‚àß q</code>.</li></ul></li><li><p>Are you trying to prove something of the form <code>p ‚à® q</code>?</p><ul><li>See if you have either <code>p</code> or <code>q</code> by itself &ndash; if you do, use either <code>OrI1</code> or <code>OrI2</code> to conclude <code>p ‚à® q</code>.</li></ul></li></ul></li><li><p>You&rsquo;ll need to nest the approaches from step 2. Once you are in a subproof, think about what you are <em>trying to prove by the end of that subproof</em>. Follow the strategy in step 2 to prove your current goal, nesting subproofs as needed. As you work, stop and scan the claims that you have available. See if you can extract anything from them as you did for the premises in step 1.</p></li><li><p>No match, or still stuck?</p><ul><li>Do you have a there-exists statement available? Try using <code>ExistsE[T]</code> to reach your goal.</li><li>Do you have an OR statement available? Try using OR elimination to prove your goal conclusion.</li><li>Do your statements have NOT operators, but don&rsquo;t fit the form for using <code>¬¨i</code>? Try using <code>PbC</code>. If you are trying to prove something of the form <code>p</code>, open a subproof, assume <code>¬¨p</code>, and try to reach a contradiction by the end of the subproof. Afterward, use <code>PbC</code> to conclude <code>p</code>.</li><li>As a last resort, try pasting in the proof for the law of the excluded middle (see section 4.5). Then use OR elimination on <code>p ‚à® ¬¨p</code>.</li></ul></li></ol><p>Think of doing a proof as solving a maze, and of all our deduction rules as possible directions you can turn. If you have claims that match a deduction rule, then you can try applying the rule (i.e, &ldquo;turning that direction&rdquo;). As you work, you may apply more and more rules until the proof falls into place (you exit the maze)&mldr;or, you might get stuck. If this happens, it doesn&rsquo;t mean that you have done anything <em>wrong</em> &ndash; it just means that you have reached a dead end and need to try something else. You backtrack, and try a different approach instead (try turning in a different direction).</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=soundness-and-completeness>Soundness and Completeness</h1><h2 id=soundness-and-completeness-definitions>Soundness and completeness definitions</h2><p>We now revisit the notions of <em>soundness</em> and <em>completeness</em>. We recall from propositional logic that a proof system is <em>sound</em> if everything that is provable is actually true. A proof system is <em>complete</em> if everything that is true can be proved.</p><h2 id=interpretations>Interpretations</h2><p>When we write statements in logic, we use predicates and function symbols (e.g., <code>‚àÄ i (i * 2) > i</code>). An interpretation gives the meaning of:</p><ul><li><p>The underlying domain ‚Äì what set of elements it names</p></li><li><p>Each function symbol ‚Äì what answers it computes from its parameters from the domain</p></li><li><p>Each predicate ‚Äì which combinations of arguments from the domain lead to true answers and false answers</p></li></ul><h3 id=interpretation-example---integers>Interpretation example - integers</h3><p>Here is an example. Say we have the function symbols: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, and the predicate symbols: <code>></code> and <code>=</code>. What do these names and symbols mean? We must interpret them.</p><p>The standard interpretation of arithmetic is that:</p><ul><li><p><code>int</code> names the set of all integers</p></li><li><p><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> name the integer addition, subtraction, multiplication, and division functions (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; an integer result)</p></li><li><p><code>=</code> and <code>></code> name integer equality comparison and integer less-than comparison predicates (that take two integers as &ldquo;parameters&rdquo; and &ldquo;return&rdquo; the boolean result of the comparison)</p></li></ul><p>With this interpretation of arithmetic, we can interpret statements. For example,<code>‚àÄ i (i * 2) > i</code> interprets to <code>false</code>, as when <code>i</code> is negative, then <code>i * 2 &lt; i</code>. Similarly, <code>‚àÉ j (j * j) = j</code> interprets to <code>true</code>, as <code>1 * 1 = 1</code>.</p><p>Now, given the function names <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the predicates, <code>=</code>, <code>></code>, we can choose to interpret them in another way. For example, we might interpret the underlying domain as just the <em>nonnegative</em> integers. We can interpret <code>+</code>, <code>*</code>, <code>/</code>, <code>></code>, <code>=</code> as the usual operations on ints, but we must give a different meaning to <code>-</code>. We might define <code>m - n == 0</code>, whenever <code>n > m</code>.</p><p>Yet another interpretation is to say that the domain is just <code>{0, 1}</code>; the functions are the usual arithmetic operations on 0 and 1 under the modulus of 2. For example, we would define <code>1 + 1 == 0</code> because <code>(1 + 1) mod 2 == 0</code>. We would define <code>1 > 0</code> as <code>true</code> and any other evaluation of <code>&lt;</code> as false.</p><p>These three examples show that the symbols in a logic can be interpreted in <em>multiple different ways</em>.</p><h3 id=interpretation-example---predicates>Interpretation example - predicates</h3><p>Here is a second example. There are no functions, and the predicates are <em>IsMortal(_)</em>, <em>IsLeftHanded(_)</em> and <em>IsMarriedTo(<em>,</em>)</em>. An interpretation might make all (living) members of the human race as the domain; make <em>IsMortal(h)</em> defined as <code>true</code> for every human <code>h</code>; make <code>IsLeftHanded(j)</code> defined as true for exactly those humans, <code>j</code>, who are left handed; and set <code>IsMarriedTo(x, y)</code> as <code>true</code> for all pairs of humans (<code>x</code>, <code>y</code>) who have their marriage document in hand.</p><p>We can ask whether a proposition is true within ONE specific interpretation, and we can ask whether a proposition is true within ALL possible interpretations. This leads to the notions of soundness and completeness for predicate logic.</p><h2 id=valid-sequents-in-predicate-logic>Valid sequents in predicate logic</h2><blockquote><p>A sequent, <code>P_1, P_2, ..., P_n ‚ä¢ Q</code> is <em>valid</em> in an interpretation, <code>I</code>, provided that when all of <code>P_1</code>, <code>P_2</code>, &mldr;, <code>P_n</code> are true in interpretation <code>I</code>, then so is <code>Q</code>. The sequent is valid exactly when it is valid in ALL possible interpretations.</p></blockquote><h2 id=soundness-and-completeness-in-predicate-logic>Soundness and completeness in predicate logic</h2><p>We can then define soundness and completeness for predicate logic:</p><blockquote><p><em>soundness</em>: When we use the deduction rules to prove that <code>P_1, P_2, ..., P_n ‚ä¢ Q</code>, then the sequent is valid (in all possible interpretations)</p></blockquote><blockquote><p><em>completeness:</em> When <code>P_1, P_2, ..., P_n ‚ä¢ Q</code> is valid (in all possible interpretations), then we can use the deduction rules to prove the sequent.</p></blockquote><p>Note that, if <code>P_1, P_2, ..., P_n ‚ä¢ Q</code> is valid in just ONE specific interpretation, then we are not guaranteed that our rules will prove it. This is a famous trouble spot: For centuries, mathematicians were searching for a set of deduction rules that could be used to build logic proofs of all the true propositions of arithmetic, that is, the language of <code>int</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>></code>, and <code>=</code>. No appropriate rule set was devised.</p><p>In the early 20th century, Kurt G√∂del showed that it is impossible to formulate a sound set of rules customized for arithmetic that will prove exactly the true facts of arithmetic. G√∂del showed this by formulating true propositions in arithmetic notation that talked about the computational power of the proof rules themselves, making it impossible for the proof rules to reason completely about themselves. The form of proposition he coded in logic+arithmetic stated &ldquo;I cannot be proved&rdquo;. If this proposition is false, it means the proposition can be proved. But this would make the rule set unsound, because it proved a false claim. The only possibility is that the proposition is true (and it cannot be proved). Hence, the proof rules remain sound but are incomplete.</p><p>G√∂del‚Äôs construction, called <em>diagonalization</em>, opened the door to the modern theory of computer science, called <em>computability theory</em>, where techniques from logic are used to analyze computer programs. You can study these topics more in CIS 570 and CIS 575.</p><p>Computability theory includes the notion of <em>decidability</em> &ndash; a problem that is decidable CAN be solved by a computer, and one that is undecidable cannot. A famous example of an undecidable problem is the <em>Halting problem</em>: given an arbitrary computer program and program input, can we write a checker program that will tell if the input program will necessarily terminate (halt) on its input? The answer is NO - the checker wouldn&rsquo;t work on itself.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Julie Thornton
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis301/commit/a737c96970a1f19ec3d1aacc63180f0d3769adbe>Aug 13, 2024</a></p></div></div><script src=/cis301/js/clipboard.min.js?1737061030 defer></script><script src=/cis301/js/perfect-scrollbar.min.js?1737061030 defer></script><script src=/cis301/js/theme.js?1737061030 defer></script></body></html>