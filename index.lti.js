var relearn_lti_index=[{breadcrumb:"",description:"",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Getting Started",uri:"/cis301/0-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Basics and Logic Puzzles",uri:"/cis301/1-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Truth Tables",uri:"/cis301/2-chapter/index.html"},{breadcrumb:"",description:`A propositional logic statement is a set of propositional atoms (statements with no logical connectives that can be true or false) connected by logical operators.
In this chapter, we will see how to translate English sentences into such propositional logic statements, which will resemble the logical statements (like p ∧ q → r) we saw when working with truth tables. These statements are also called propositions.`,modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Propositional Logic Translations",uri:"/cis301/3-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-09-19T14:07:12-05:00",tags:[],title:"Propositional Logic Proofs",uri:"/cis301/4-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Predicate Logic Translations",uri:"/cis301/5-chapter/index.html"},{breadcrumb:"",description:`Now that we have seen how to translate statements to predicate logic, we will learn new deduction rules for working with universal and existential quantifiers. We will be able to add those rules to our propositional logic deduction rules and show that a set of premises proves a conclusion in predicate logic. Predicate logic is also referred to as first order logic.
As with propositional logic, we can use the Logika tool to help check the correctness of our new deduction rules. However, these new rules also exist outside of Logika, and we could express the same proofs with our rules in a different environment or on paper – the concepts are the same.`,modified:"2024-08-13T15:44:21-05:00",tags:[],title:"Predicate Logic Proofs",uri:"/cis301/6-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Mathematical Induction",uri:"/cis301/7-chapter/index.html"},{breadcrumb:"",description:"Intro to Programming Logic: Assignments and Conditionals For the rest of the course, we will switch gears back to something more familiar for most – computer programs. We will apply the deductive reasoning from the previous chapters in order to prove the correctness of basic programs. This chapter will focus on programs with variable operations, assignments, and conditional statements.",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Intro to Programming Logic",uri:"/cis301/8-chapter/index.html"},{breadcrumb:"",description:"Programming Logic: Functions and Loops In this chapter, we will continue our unit on programming logic and will learn how to prove the correctness of programs involving functions, loops, and recursion.",modified:"2023-08-10T14:52:41-05:00",tags:[],title:"Functions and Loops",uri:"/cis301/9-chapter/index.html"},{breadcrumb:"Getting Started",description:`GitHub account First, you will need to create a GitHub account here. If you already have one, you can use your existing account.
Sireum Logika In CIS 301, we will use a tool called Logika, which is a verifier and a proof checker for propositional, predicate, and programming logic. You will need to install the VS Code-based Sireum IVE (Integrated Verification Environment), which contains Logika.
Getting Installer Script Go here under “For CIS 301 Fall 2025” to install Logika.`,modified:"2025-08-25T15:36:26-05:00",tags:[],title:"Tools Guide",uri:"/cis301/0-chapter/0_1-toolsguide/index.html"},{breadcrumb:"",description:"In our conclusion of programming logic, we’ll examines programs with sequences and global variables. We’ll also learn the idea of termination in programs, and why this is a much more difficult thing to demonstrate for a general program that it might seem.",modified:"2024-04-30T15:33:09-05:00",tags:[],title:"Sequences, Globals, and Termination",uri:"/cis301/10-chapter/index.html"},{breadcrumb:"Getting Started",description:`Verify a git install You will likely already have a command-line version of git installed on your machine. To check, open a folder in VS Code, display the integrated terminal, and type:
git --version You should see a version number printing out. If you see that, git is already installed.
If you see an error that git is unrecognized, then you will need to install it. Go here to download and install the latest version.`,modified:"2025-08-04T16:02:39-05:00",tags:[],title:"git Install",uri:"/cis301/0-chapter/0_2-gitinstall/index.html"},{breadcrumb:"Basics and Logic Puzzles",description:`What is logical reasoning? Logical reasoning is an analysis of an argument according to a set of rules. In this course, we will be learning several sets of rules for more formal analysis, but for now we will informally analyze English sentences and logic puzzles. This will help us practice the careful and rigorous thinking that we will need in formal proofs and in computer science in general.
Premises and conclusions A premise is a piece of information that we are given in a logical argument. In our reasoning, we assume premises are true – even if they make no sense!`,modified:"2023-12-08T14:41:44-06:00",tags:[],title:"Basic Logical Reasoning",uri:"/cis301/1-chapter/1_1-logicbasics/index.html"},{breadcrumb:"Basics and Logic Puzzles",description:`We will now move to solving several kinds of logic puzzles. While these puzzles aren’t strictly necessary to understand the remaining course content, they require the same rigorous analysis that we will use when doing more formal truth tables and proofs. Plus, they’re fun!
The puzzles in this section and the rest of this chapter are all either from or inspired by: What is the Name of This Book?, by Raymond Smullyan.`,modified:"2022-05-25T11:58:38-05:00",tags:[],title:"Knights and Knaves",uri:"/cis301/1-chapter/1_2-knightsknaves/index.html"},{breadcrumb:"Basics and Logic Puzzles",description:`We will look at a variety of other logic puzzles, each of which involve some statements being false and some statements being true.
Lion and Unicorn The setup for a Lion and Unicorn puzzle can vary, but the idea is that both Lion and Unicorn have specific days that they tell only lies, and other specific days that they only tell the truth.
Here is one example:
Lion always lies on Mondays, Tuesdays, and Wednesdays.
Lion always tells the truth on other days.
Unicorn always lies on Thursdays, Fridays, and Saturdays, and always tells the truth on other days. On Sunday, everyone tells the truth. Lion says: “Yesterday was one of my lying days."
Unicorn says: “Yesterday was one of my lying days, too.” What day is it?`,modified:"2022-05-25T11:58:38-05:00",tags:[],title:"Other Puzzles",uri:"/cis301/1-chapter/1_3-otherpuzzles/index.html"},{breadcrumb:"Truth Tables",description:`In this chapter, we review basic notions about gates and learn the relationship between circuits and assignment-based computer programs. This sets the stage for analyzing modern programs.
Logical operators There are four basic logic gates, with corresponding logical operators:
Meaning Logical Operator Logic Gate p AND q p ∧ q p OR q p ∨ q NOT p ¬p p IMPLIES q p → q In the above drawings, the input wires are labelled with the names P and Q. The output that is computed is emitted from the rightmost wire which exits the gate. For these simple gates, it is possible to exhaustively test every permutation of potential inputs and summarize results in a table, called a truth table.`,modified:"2025-09-02T08:56:36-05:00",tags:[],title:"Operators and Circuits",uri:"/cis301/2-chapter/2_1-opscircuits/index.html"},{breadcrumb:"Truth Tables",description:`Now that we’ve seen the four basic logic gates and truth tables, we can put them together to build bigger truth tables for longer logical formulae.
Operator precedence Logical operators have a defined precedence (order of operations) just as arithmetic operators do. In arithmetic, parentheses have the highest precedence, followed by exponents, then multiplication and division, and finally addition and subtraction.
Here is the precedence of the logical operators, from most important (do first) to least important (do last):`,modified:"2025-01-16T15:05:00-06:00",tags:[],title:"Truth Tables in Logika",uri:"/cis301/2-chapter/2_2-logikatruth/index.html"},{breadcrumb:"Truth Tables",description:`We say that a logical statement is satisfiable when there exists at least one truth assignment that makes the overall statement true.
In our Logika truth tables, this corresponds to statements that are either contingent or a tautology. (Contradictory statements are NOT satisfiable.)
For example, consider the following truth tables:
* ----------------------- p q r # p →: q V ¬r ∧ p ----------------------- T T T # T T F F T T F # T T T T T F T # F F F F T F F # T T T T F T T # T T F F F T F # T T T F F F T # T F F F F F F # T F T F ------------------------ Contingent T: [T T T] [T T F] [T F F] [F T T] [F T F] [F F T] [F F F] F: [T F T] And`,modified:"2024-03-19T15:31:50-05:00",tags:[],title:"Satisfiability",uri:"/cis301/2-chapter/2_3-satis/index.html"},{breadcrumb:"Truth Tables",description:`Two (or more) logical statements are said to be logically equivalent IFF (if and only if, ↔) they have the same truth value for every truth assignment; i.e., their truth tables evaluate exactly the same. (We sometimes refer to this as semantic equivalence.)
An example of logically equivalent statements are q ∧ p and p ∧ (q ∧ p):
* -------------- p q # (p ∧ q) -------------- T T # T T F # F F T # F F F # F --------------- Contingent T: [T T] F: [F F] [F T] [T F] * ------------------- p q # p ∧ (q ∧ p) ------------------- T T # T T T F # F F F T # F F F F # F F -------------------- Contingent T : [T T] F : [F F] [F T] [T F] In these examples, notice that exactly the same set of truth assignments makes both statements true, and that exactly the same set of truth assignments makes both statements false.`,modified:"2024-03-19T15:31:50-05:00",tags:[],title:"Logical Equivalence",uri:"/cis301/2-chapter/2_4-logicalequiv/index.html"},{breadcrumb:"Truth Tables",description:`Definition We say a set of premises, p1, p2, …, pn semantically entail a conclusion c, and we write:
p1, p2, ..., pn ⊨ c if whenever we have a truth assignment that makes p1, p2, …, pn all true, then c is also true for that truth assignment.
(Note: we can use the ASCII replacement |= instead of the Unicode ⊨, if we want.)
Showing semantic entailment Suppose we have premises p ∧ q and p → r. We want to see if these premises necessarily entail the conclusion r ∧ q.`,modified:"2024-03-19T15:31:50-05:00",tags:[],title:"Semantic Entailment",uri:"/cis301/2-chapter/2_5-sementail/index.html"},{breadcrumb:"Propositional Logic Translations",description:`Definition A propositional atom is statement that is either true or false, and that contains no logical connectives (like and, or, not, if/then).
Examples of propositional atoms For example, the following are propositional atoms:
My shirt is red. It is sunny. Pigs can fly. I studied for the test. Examples of what are NOT propositional atoms Propositional atoms should not contain any logical connectives. If they did, this would mean we could have further subdivided the statement into multiple propositional atoms that could be joined with logical operators. For example, the following are NOT propositional atoms:`,modified:"2023-12-08T14:41:44-06:00",tags:[],title:"Propositional Atoms",uri:"/cis301/3-chapter/3_1-propatom/index.html"},{breadcrumb:"Propositional Logic Translations",description:`Now that we have seen how to identify propositional atoms in English sentences, we will learn how to connect these propositions with logical operators in order to complete the process of translating from English to propositional logic.
NOT translations When you see the word “not” and the prefixes “un-” and “ir-”, those should be replaced with a NOT operator.
Example 1 For example, if we have the sentence:
I am not going to work today. Then we would first identify the propositional atom:`,modified:"2024-06-27T14:02:46-05:00",tags:[],title:"NOT, AND, OR Translations",uri:"/cis301/3-chapter/3_2-notandor/index.html"},{breadcrumb:"Propositional Logic Translations",description:"In this section, we will learn when to use an implies (→) operator when translating from English to propositional logic. In general, you will want to use an implies operator any time a sentence is making a promise – if one thing happens, then we promise that another thing will happen. The trick is to figure out the direction of the promise – promising that if p happens, then q will happen is subtly different from promising that if q happens, then p will happen.",modified:"2024-06-27T14:02:46-05:00",tags:[],title:"Implies Translations",uri:"/cis301/3-chapter/3_3-implies/index.html"},{breadcrumb:"Propositional Logic Translations",description:`As we saw in section 2.4), two logical statements are said to be logically equivalent if and only if they have the same truth value for every truth assignment.
We can extend this idea to our propositional logic translations – two (English) statements are said to be equivalent iff they have the same underlying meaning, and iff their translations to propositional logic are logically equivalent.
Common equivalences, revisited We previously identified the following common logical equivalences:`,modified:"2024-06-27T14:02:46-05:00",tags:[],title:"Equivalent Translations",uri:"/cis301/3-chapter/3_4-equiv/index.html"},{breadcrumb:"Propositional Logic Translations",description:`Recall the Knights and Knaves puzzles from section 1.2. In addition to solving these puzzle by hand, we can devise a strategy to first translate a Knights and Knaves puzzle to propositional logic, and then solve the puzzle using a truth table.
Identifying propositional atoms To translate a Knights and Knaves puzzle to propositional logic, we first create a propositional atom for each person that represented whether that person was a knight. For example, if our puzzle included the people “Adam”, “Bob”, and “Carly”, then we might create propositional atoms a, b, and c:`,modified:"2024-06-27T14:02:46-05:00",tags:[],title:"Knights and Knaves, revisited",uri:"/cis301/3-chapter/3_5-knightsknavestt/index.html"},{breadcrumb:"Propositional Logic Proofs",description:"While we can use truth tables to check whether a set of premises entail a conclusion, this requires testing all possible truth assignments – of which there are exponentially many. In this chapter, we will learn the process of natural deduction in propositional logic. This will allow us to start with a set of known facts (premises) and apply a series of rules to see if we can reach some goal conclusion. Essentially, we will be able to see whether a given conclusion necessarily follows from a set of premises.",modified:"2024-04-25T17:02:46-05:00",tags:[],title:"Introduction",uri:"/cis301/4-chapter/4_1-intro/index.html"},{breadcrumb:"Propositional Logic Proofs",description:`In this section, we will see the deduction rules for the AND operator.
AND introduction Clearly, when both p and q are facts, then so is the proposition p ∧ q. This makes logical sense – if two propositions are independently true, then their conjunction (AND) must also be true. The AND introduction rule, AndI, formalizes this:
P Q AndI : --------- P ∧ Q We will use the format above when introducing each of our natural deduction rules:`,modified:"2024-03-28T16:29:05-05:00",tags:[],title:"AND Rules",uri:"/cis301/4-chapter/4_2-andrules/index.html"},{breadcrumb:"Propositional Logic Proofs",description:`In this section, we will see the deduction rules for the OR operator.
OR introduction If we know that a proposition P is true, then it will also be the case that both P ∨ Q and Q ∨ P are also true. It doesn’t matter what Q is – it might even be something that is know to be false. Because P is true, it will make the overall OR statement true as well.`,modified:"2025-02-11T11:32:14-06:00",tags:[],title:"OR Rules",uri:"/cis301/4-chapter/4_3-orrules/index.html"},{breadcrumb:"Propositional Logic Proofs",description:`In this section, we will see the deduction rules for the implies operator.
Note that in our Logika proofs, the implies operator is typed as __>: but is rendered as →.
Implies elimination Remember that → is a kind of logical “if-then”. Here, we understand p → q to mean that p holds knowledge sufficient to deduce q – so, whenever p is proved to be a fact, then p → q enables q to be proved a fact, too. This is the implies elimination rule, ImplyE, and we can formalize it like this:`,modified:"2024-09-12T09:08:28-05:00",tags:[],title:"Implies Rules",uri:"/cis301/4-chapter/4_4-impliesrules/index.html"},{breadcrumb:"Propositional Logic Proofs",description:"In this section, we will see the deduction rules for the NOT operator. In this section, we will introduce the notion of a contradiction, which occurs when, for some proposition P, we have proved both the facts P and ¬ P. This indicates that we are in an impossible situation, and often means that we have made a bad previous assumption. In Logika, we use an F (“false”) as a claim to indiciate that we’ve reached a contradiction. In other texts, you sometime see the symbol ⊥ (which means “bottom operator”) for a contradiction.",modified:"2024-10-08T16:17:02-05:00",tags:[],title:"Negation Rules",uri:"/cis301/4-chapter/4_5-notrules/index.html"},{breadcrumb:"Propositional Logic Proofs",description:`When examining more complex propositional logic sequents, it can be challenging to know where to start. In this section, we summarize all available rules in propositional logic, and discuss stratgies for approaching proofs.
AND rules Rule summaries:
P Q P ∧ Q P ∧ Q AndI : --------- AndE1 : ---------- AndE2 : ---------- P ∧ Q P Q Rule syntax summaries:
... x ( p )	by (...), y ( q	) by (...), z ( p ∧ q ) by AndI(x, y), ... ... x ( p ∧ q )	by (...), y ( p	) by AndE1(x), z ( q ) by AndE2(y), ... OR rules Rule summaries:`,modified:"2025-02-25T11:03:46-06:00",tags:[],title:"Summary and Strategies",uri:"/cis301/4-chapter/4_6-strategies/index.html"},{breadcrumb:"Propositional Logic Proofs",description:`Definition A theorem in propositional logic is something that is always true with no need for premises. The truth table for a theorem is always a tautology – it is true for any truth assignment.
To express a theorem as a sequent, we write:
⊢ (theorem) This shows that we are trying to prove our theorem with NO premises. Such a proof will always immediately begin with a subproof, as there are no premises to process.`,modified:"2024-03-28T16:29:05-05:00",tags:[],title:"Theorems",uri:"/cis301/4-chapter/4_7-theorems/index.html"},{breadcrumb:"Propositional Logic Proofs",description:`In this section, we will revisit the notion of equivalence. In chapter 2, we saw how we could use truth tables to show that two logical formulae are equivalent. Here, we will see that we can also show they are equivalent using our natural deduction proof rules.
Semantic equivalence We saw in section 2.4 that two (or more) logical statements S1 and S2 were said to be semantically equivalent if and only if:`,modified:"2024-03-28T16:29:05-05:00",tags:[],title:"Equivalence",uri:"/cis301/4-chapter/4_8-equivalence/index.html"},{breadcrumb:"Propositional Logic Proofs",description:"Section 4.8 showed us that we can prove two statements are semantically equivalent with truth tables and provably equivalent with deduction proofs. Does it matter which approach we use? Will there ever be a time when two statements are semantically equivalent but not provably equivalent, or vice versa? Will there ever be a time when a set of premises semantically entails a conclusion, but that the premises do not prove (using our deduction proofs) the conclusion, or vice versa?",modified:"2024-03-28T16:29:05-05:00",tags:[],title:"Soundness and Completeness",uri:"/cis301/4-chapter/4_9-soundcomplete/index.html"},{breadcrumb:"Predicate Logic Translations",description:`In this chapter, we will learn to further decompose statements in terms of their verbs (called predicates) and their nouns (called individuals). This leads to predicate logic (also called first-order logic).
As a motivation of why we want more expressive power, suppose we wanted to translate the following statements to propositional logic:
All humans are mortal. Socrates is a human. Socrates is mortal. Unfortunately, each statement would be a propositional atom:`,modified:"2022-05-25T15:39:43-05:00",tags:[],title:"Motivation",uri:"/cis301/5-chapter/5_1-motivation/index.html"},{breadcrumb:"Predicate Logic Translations",description:`In this section, we will examine the syntax for translating English sentences to predicate logic. We will still create propositions (statements that are either true or false) using logical connectives (∧, ∨, →, and ¬), but now we will identify the following from our English sentences
predicates: these will be the verbs in the sentences individuals: these will be the nouns in the sentences quantifiers: these will help us specify if we mean all individuals or at least one individual Domains Predicate logic involves expressing truth about a set of individuals. But the same statement might be true for one group of individuals, but false for others. Thus, we first need to consider which set of individuals we are discussing – called the domain.`,modified:"2025-03-05T10:01:57-06:00",tags:[],title:"Syntax",uri:"/cis301/5-chapter/5_2-predsyntax/index.html"},{breadcrumb:"Predicate Logic Translations",description:`In this section, we will see how to translate simpler statements between English to predicate logic. These translations will involve a single quantifier.
Example: Predicate logic to English Suppose our domain is animals and that we have the following two predicates:
isMouse(x): whether animal x is a mouse inHouse(x): whether animal x is in the house Suppose we also have that Squeaky is an individual in our domain.
We will practice translating from predicate logic to English. Think about what the following propositions mean, and click to reveal each answer:`,modified:"2023-10-08T11:26:56-05:00",tags:[],title:"Single Quantifier",uri:"/cis301/5-chapter/5_3-singlequantifier/index.html"},{breadcrumb:"Predicate Logic Translations",description:`Translations that involve more than one quantifier (which often happens when some of the predicates have more than one parameter) are more challenging. We will divide these translations into two categories:
Translations that involve several of the same quantifier (multiple universal quantifiers or multiple existential quantifiers) Translations that mix quantifiers In many of the sections, we will using the predicates below (which are over the domain of shapes):
isCircle(x) - whether shape x is a circle isSquare(x) - whether shape x is a square isRectangle(x) - whether shape x is a rectangle biggerThan(x, y) - whether shape x is bigger than shape y Several of the same quantifier First, we consider translations that involve several of the same quantifier. There are two ways we can translate such statements – either using prenex form (quantifiers out front) or Aristotelian form (quantifiers nested).`,modified:"2023-12-07T13:46:44-06:00",tags:[],title:"Multiple Quantifiers",uri:"/cis301/5-chapter/5_4-multquant/index.html"},{breadcrumb:"Predicate Logic Proofs",description:`We will use the following format in Logika to start a natural deduction proof for predicate logic. Each proof will be saved in a new file with a .sc (Scala) extension:
// #Sireum #Logika //@Logika: --manual --background type import org.sireum._ import org.sireum.justification._ import org.sireum.justification.natded.prop._ import org.sireum.justification.natded.pred._ @pure def ProofName[T](pred1: T => B @pure, pred2: T => B @pure, ..., indiv1: T, indiv2: T, ...): Unit = { Deduce( //@formatter:off (comma-separated list of premises with variable1, variable2, ...) ⊢ (conclusion) Proof( //the actual proof steps go here ) //@formatter:on ) } Here, T is the type of elements in our domain. Usually, we will just use T to denote a generic type (much like generics in Java and C#), but occasionally we will use specific types like Z (which means “integer”). Next, pred1, pred2, etc. are the predicates for our proofs. The T => B means that they take an element in our domain as a parameter (which has type T) and return a boolean (which has type B). Finally, indiv1, indiv2, etc. are specific individuals within our domain, each of which have type T.`,modified:"2024-08-13T15:44:21-05:00",tags:[],title:"Logika Predicate Logic Proof Syntax",uri:"/cis301/6-chapter/6_0-logikasyntax/index.html"},{breadcrumb:"Predicate Logic Proofs",description:`Just as with our propositional logic operators, there will be two inference rules for each of our predicate logic quanitifiers – an “introduction rule and an “elimination” rule.
In this section, we will see the two inference rules for the universal (∀) quantifier.
For all elimination For all elimination allows us to take a claim that uses a universal quantifier – a statement about ALL individuals in a domain – and make the same statement about a specific individual in the domain. After all, if the statement is true for ALL individuals, then it follows that it should be true for a particular individual. We can formalize the rule as follows:`,modified:"2025-04-02T09:44:13-05:00",tags:[],title:"Rules with ∀",uri:"/cis301/6-chapter/6_1-univrules/index.html"},{breadcrumb:"Predicate Logic Proofs",description:`In this section, we will see the two inference rules for the existential (∃) quantifier.
Exists introduction We can use the exists introduction rule, ExistsI[T], when we have a proposition of the form P(a) for an arbitrary member a of a domain. Since we found one individual where a proposition held, then we can also say that there exists an individual for which the proposition is true. We can formalize the rule as follows:`,modified:"2024-10-23T10:50:31-05:00",tags:[],title:"Rules with ∃",uri:"/cis301/6-chapter/6_2-existrules/index.html"},{breadcrumb:"Predicate Logic Proofs",description:"Our examples so far have included propositions with single quantifiers. This section will discuss how to prove sequents that use nested quantifers. We will see that the approach is the same as before, but that we must take caution to process the quantifiers in the correct order. Recall that quantifier precedence is from right to left (i.e., from the outside in), so that ∀ x ∀ y P(x, y) is equivalent to ∀ x (∀ y P(x, y)).",modified:"2024-08-13T15:44:21-05:00",tags:[],title:"Nested Quantifiers",uri:"/cis301/6-chapter/6_3-nested/index.html"},{breadcrumb:"Predicate Logic Proofs",description:`In Chapter 5, we saw DeMorgan’s laws for quantifiers – that if we have some domain, and if P(x) is a predicate for individuals in that domain, then the following statements are equivalent:
¬(∃ x P(x)) is equivalent to ∀ x ¬P(x) ¬(∀ x P(x)) is equivalent to ∃ x ¬P(x) The process of proving that two predicate logic statements are equivalent is the same as it was in propositional logic – we must prove the second proposition using the first as a premise, and we must prove the first given the second as a premise.`,modified:"2024-10-07T15:51:25-05:00",tags:[],title:"Equivalence",uri:"/cis301/6-chapter/6_4-equiv/index.html"},{breadcrumb:"Predicate Logic Proofs",description:`In this section, we summarize all available rules in propositional logic, and discuss strategies for approaching proofs.
Rules with universal quantifier (∀) Rule summaries:
∀ ((x: T) => P(x)) AllE[T]: --------------------- P(v) where v is a particular individual in the domain (i.e, v has type T) Let ( (a: T) => SubProof( ... P(a) )), AllI[T] : ------------------------------- ∀ ((x: T) => P(x)) Rule syntax summaries:`,modified:"2024-08-13T15:44:21-05:00",tags:[],title:"Summary and Strategies",uri:"/cis301/6-chapter/6_5-strategies/index.html"},{breadcrumb:"Predicate Logic Proofs",description:`Soundness and completeness definitions We now revisit the notions of soundness and completeness. We recall from propositional logic that a proof system is sound if everything that is provable is actually true. A proof system is complete if everything that is true can be proved.
Interpretations When we write statements in logic, we use predicates and function symbols (e.g., ∀ i (i * 2) > i). An interpretation gives the meaning of:`,modified:"2024-08-13T15:44:21-05:00",tags:[],title:"Soundness and Completeness",uri:"/cis301/6-chapter/6_6-soundcomplete/index.html"},{breadcrumb:"Mathematical Induction",description:`Mathematical induction allows us to prove that every nonnegative integer satisfies a certain property. In this chapter, we will use mathematical induction to prove several mathematical claims. When we reach the next several chapters on programming logic, we will see that mathematical induction is very similar to the process of proving correctness for programs with loops.
Domino effect To prove that a property $P(n)$ is true for an arbitrary nonnegative integer $n$ using mathematical induction, we must show two things:`,modified:"2024-10-17T13:17:20-05:00",tags:[],title:"Induction Process",uri:"/cis301/7-chapter/7_1-process/index.html"},{breadcrumb:"Mathematical Induction",description:`Claim: The sum of the first $n$ odd numbers is $n^2$. We will refer to this claim as $P(n)$.
Try it out Before proving $P(n)$ with mathematical induction, let’s see if the property holds for some sample values. The sum of the first 3 odd numbers is $1 + 3 + 5 = 9$. We also have that $3^2 = 9$.
The sum of the first 7 odd numbers is $1 + 3 + 5 + 7 + 9 + 11 + 13 = 49$. We also have that $7^2 = 49$.`,modified:"2024-03-24T14:10:58-05:00",tags:[],title:"Algebra example",uri:"/cis301/7-chapter/7_2-algebraex/index.html"},{breadcrumb:"Mathematical Induction",description:`Claim: If $n$ is a positive integer, then $6^{n} - 1$ is divisible by 5. We will refer to this claim as $P(n)$.
Try it out Before proving $P(n)$ with mathematical induction, let’s see if the property holds for some sample values. When $n = 3$ we have that $6^{3} - 1 = 216 - 1 = 215$. Since $215$ ends with a 5, it is clearly divisible by 5.`,modified:"2023-10-20T10:33:52-05:00",tags:[],title:"Divisibility example",uri:"/cis301/7-chapter/7_3-divex/index.html"},{breadcrumb:"Mathematical Induction",description:`Claim: If $n$ is a positive integer greater than or equal to 2, then a set with $n$ elements has $\\dfrac{n(n-1)}{2}$ possible subsets of size 2. We will refer to this claim as $P(n)$.
Try it out Suppose $n = 3$, and our set contains the elements $(a, b, c)$. There are 3 possible subsets of size 2: $(a, b)$, $(a, c)$, and $(b, c)$. We also have that $\\dfrac{3(3-1)}{2} = 3$.`,modified:"2023-10-20T10:33:52-05:00",tags:[],title:"Set example",uri:"/cis301/7-chapter/7_4-setex/index.html"},{breadcrumb:"Intro to Programming Logic",description:"In the next three chapters, we will learn how to reason about different kinds of program structures – assignments, conditional statements, loops, function calls, recursion, lists of elements, and global variables. By the end of chapter 10, we will be able to prove the correctness of simple programs using a toy language that is a subset of Scala. While our toy language is not used in practice, the ideas that we will see to prove program correctness – preconditions, postconditions, loop invariants, and global invariants – can be used to specify functions in ANY language.",modified:"2023-11-16T11:24:32-06:00",tags:[],title:"Programming Logic Goal",uri:"/cis301/8-chapter/8_1-goal/index.html"},{breadcrumb:"Intro to Programming Logic",description:`As we study program logic, we will use Logika to verify a subset of programs that use the Scala language. Specifically, we will study verification of programs with the following features:
Variables (booleans, ints, and sequences [which are like arrays/lists]) Printing and user input Math operations Conditional operations If and if/else statements While loops Functions The Scala programs we verify should be saved with a .sc extension. To show we are using Logika for verification, the first line of the file should be:`,modified:"2024-04-25T17:02:46-05:00",tags:[],title:"Logika Programs",uri:"/cis301/8-chapter/8_2-logikaprograms/index.html"},{breadcrumb:"Intro to Programming Logic",description:`Assert statements An assert statement in Scala uses the syntax assert(expression), where expression is of type bool. The assert passes if the expression is true, and throws an error if the expression is false.
Each time we use an assert, the Logika proof checker will look to see if we have logically justified the expression being asserted. If we have, we will get a purple check mark indicate that the assert statement has been satisified. If we have not, we will get a red error indicating that the assertion has not been proven.`,modified:"2024-04-25T17:02:46-05:00",tags:[],title:"Assert and Assume",uri:"/cis301/8-chapter/8_3-assertassume/index.html"},{breadcrumb:"Intro to Programming Logic",description:`In this section, we will learn our first two proof rules for programming logic – Algebra and Subst.
Verifying simple programs Before we delve into our new proof rules, let’s look at the process for verifying simple Logika programs (ones that include user input, variable initialization, and assignment statements using different operations). Here, the // --> lines are pieces of the verification process that you must add (or consider) in order to prove correctness of your program, and the other lines are the code of the program.`,modified:"2024-10-28T15:56:04-05:00",tags:[],title:"Algebra and Subst Rules",uri:"/cis301/8-chapter/8_4-algebrasubst/index.html"},{breadcrumb:"Intro to Programming Logic",description:`Assignment statements in a program come in two forms – with and without mutations. Assignments without mutation are those that give a value to a variable without using the old value of that variable. Assignments with mutation are variable assignments that use the old value of a variable to calculate a value for the variable.
For example, an increment statement like x = x + 1 MUTATES the value of x by updating its value to be one bigger than it was before. In order to make sense of such a statement, we need to know the previous value of x.`,modified:"2025-04-29T11:46:26-05:00",tags:[],title:"Assignment Statements",uri:"/cis301/8-chapter/8_5-assignment/index.html"},{breadcrumb:"Intro to Programming Logic",description:`We will see in this section that verifying programs with division and modulo requires extra care.
Division Recall that Z (int) is the only numeric type for Logika verification, so any division is integer division. This means something like 9/2 evaluates to 4, just as it would in Java or C#.
Check for division by zero Before doing division of the form numerator/denominator, either in a line of code or in a proof block, you must have have shown in a previous proof block that denominator is not 0. The easiest way to do this is to prove the claim: denominator != 0. You are even required to do this when dividing by a constant value that is obviously not zero.`,modified:"2024-10-30T11:36:10-05:00",tags:[],title:"Integer Division and Modulo",uri:"/cis301/8-chapter/8_6-divmod/index.html"},{breadcrumb:"Intro to Programming Logic",description:`To deduce the knowledge generated by a conditional (if/else) statement, we must analyze both branches. This is because some executions will follow the if-branch and some will follow the else-branch. We will only consider programs with an if/else as opposed to an if/else if. However, you can simulate more than two branches by nesting another if/else inside the outer else.
Motivation Before we formalize the details of verifying a program with a conditional statement, let’s motivate the topic with an example.`,modified:"2024-04-25T17:02:46-05:00",tags:[],title:"Conditional Statements",uri:"/cis301/8-chapter/8_7-conditionals/index.html"},{breadcrumb:"Functions and Loops",description:`A function in Scala is analogous to a method in Java or C# – it is a named body of commands that does significant work. It may take one or more parameters and/or return a value. Recall the syntax for a function in Scala:
def functionName(paramList): returnType = { } We will use the keyword Unit (like void in other languages) for a function that does not return a value. If a function has a non-Unit return type, then all paths through the function must end in a return statement:`,modified:"2025-04-22T14:00:34-05:00",tags:[],title:"Functions",uri:"/cis301/9-chapter/9_1-functions/index.html"},{breadcrumb:"Functions and Loops",description:`In this section, we will see how to prove the correctness of programs that use recursive functions. We will see that verifying a recursive function is exactly the same as verifying a non-recursive function:
We must prove a function’s preconditions before calling it (including before making a recursive call) After calling a function, we can list the function’s postconditions as premises (including after making a recursive call) The function can list its preconditions as premises The function must prove its postconditions just before it ends Writing a recursive mult function We know we can multiply two numbers, x and y, using the * operator – x * y. But what if we wanted to find the same result using only addition, not multiplication? Multiplication can be thought of as repeated addition – x * y is really x + x + ... + x, where we add together y total x’s.`,modified:"2024-04-26T12:21:24-05:00",tags:[],title:"Recursion",uri:"/cis301/9-chapter/9_2-recursion/index.html"},{breadcrumb:"Functions and Loops",description:"A loop is a command that restarts itself over and over while its loop condition remains true. Loops are trickier to analyze than if/else statements, because we don’t know how many times the loop will execute. The loop condition might be initially false, in which case we would skip the body of the loop entirely. Or, the loop might go through 1 iteration, or 10 iterations, or 100 iterations…we don’t know. We want a way to analyze what we know to be true after the loop ends, regardless of how many iterations it makes.",modified:"2024-05-28T14:22:57-05:00",tags:[],title:"Loops",uri:"/cis301/9-chapter/9_3-loops/index.html"},{breadcrumb:"Functions and Loops",description:`We saw at the end of section 9.3 that we sometimes need a more expressive way of specifying a loop invariant (or, similarly, for postconditions). In our last example, we wanted to describe the factorial operation. We know that $n! = n * (n-1) * (n-2) * ... * 2 * 1$, but we don’t have a way to describe the “…” portion using our current tools.
In this section, we introduce Logika facts, which will let us create our own recursive proof functions that we can use in invariants and postconditions. We will usually want to use a Logika fact anytime our invariant or postcondition needs to express something that has a “…” to demonstrate a pattern.`,modified:"2025-04-29T11:46:26-05:00",tags:[],title:"Logika Facts",uri:"/cis301/9-chapter/9_4-logikafacts/index.html"},{breadcrumb:"Functions and Loops",description:`Chapter 9 showed us how to write function contracts to specify the requirements and behavior of functions, and loop invariants to reason about the behavior and progress of loops. To wrap up, we briefly summarize the process for verifying a program that includes one or more functions with loops:
Step 1: Write function contracts Write a function contract for any function that doesn’t already have one. Function contracts go just inside the function defintion, and look like:`,modified:"2024-04-30T15:01:51-05:00",tags:[],title:"Summary",uri:"/cis301/9-chapter/9_5-summary/index.html"},{breadcrumb:"Sequences, Globals, and Termination",description:`Logika has different modes for programming logic verification. We can switch between modes by going to File->Settings->Tools->Sireum->Logika.
Logika’s “manual” mode Up to now, we have been running Logika in “manual mode”, where we list the following settings at the beginning of a file:
// #Sireum #Logika //@Logika: --manual --background save import org.sireum._ import org.sireum.justification._ We are now reaching the point where additional practice in manual mode may no longer be a learning activity, and where the proof blocks after claim transformations can become dozens of lines long.`,modified:"2025-04-29T09:10:23-05:00",tags:[],title:"Logika Modes",uri:"/cis301/10-chapter/10_1-modes/index.html"},{breadcrumb:"Sequences, Globals, and Termination",description:`Sequences in Logika are fairly similar to lists in Python and arrays in Java and C#. As with lists and arrays, Logika sequences are ordered. Each element is stored at a particular (zero-based) position, and there are no gaps in the sequence.
Logika can work with sequences of integers (type ZS).
Sequence syntax We can create new sequence variables like this:
// #Sireum #Logika //@Logika: --background save import org.sireum._ //creates the sequence (5, 10, 15) var seq: ZS = ZS(5,10,15) //creates an empty sequence of integers var empty: ZS = ZS() Given the following sequence:`,modified:"2024-04-30T15:50:15-05:00",tags:[],title:"Intro to Sequences",uri:"/cis301/10-chapter/10_2-intosequences/index.html"},{breadcrumb:"Sequences, Globals, and Termination",description:"Sequences in Scala are passed to functions by reference. This means that if a function makes changes to a sequence parameter, then it will also change whatever sequence object was passed to the function. For example, the test code below passes nums, which has the value ZS(1,2,3), to the makeFirstZero function. The makeFirstZero function changes the first position in its parameter (seq) to be 0, which means that the nums sequence in the test code will also have its first position set to 0 (making it have the value ZS(0,2,3)).",modified:"2025-04-29T09:10:23-05:00",tags:[],title:"Sequences in Functions",uri:"/cis301/10-chapter/10_3-seqfn/index.html"},{breadcrumb:"Sequences, Globals, and Termination",description:`We also must consider sequences when writing loop invariants. Typically, we must include the following in our invariant:
If the sequence changes in the loop Describe what sequence elements have already changed in the loop (and what their new values are) Describe what sequence elements still have their original value Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence) State that the sequence size does not change (to reinforce that the variable used as the sequence position will not go out of bounds) List the sequence along with other changing variables in the loop invariant block’s Modifies clause If the sequence does not change in the loop Consider what we are doing with each sequence element as we look at them. Usually we have another variable that is storing our progress (and often, this variable is returned from the function after the loop). Express how the variable’s value relates to the part of the sequence we’ve looked at so far – this statement should look very similar to your postcondition, but should only describe part of the sequence. Prove lower and upper bounds for whatever variable is being used as a sequence position (so we can be certain we will not go past the bounds of the sequence) Example: add one to all program Suppose we have the following program, which adds one to every element in a sequence parameter:`,modified:"2024-05-01T11:30:38-05:00",tags:[],title:"Sequences in Loops",uri:"/cis301/10-chapter/10_4-seqloop/index.html"},{breadcrumb:"Sequences, Globals, and Termination",description:`Motivation We will now consider programs with multiple functions that modify a shared pool of global variables. (This is very similar to the concerns in general classes in Java or C#, where multiple methods might edit fields/property values for an object). We want to be sure that global variables will maintain desired ranges and relationships between one another, even as multiple functions modify their values.
Global variables in Logika A global variable exists before any function call, and still exists after any function ends.`,modified:"2025-04-29T09:10:23-05:00",tags:[],title:"Global Variables",uri:"/cis301/10-chapter/10_5-globals/index.html"},{breadcrumb:"Sequences, Globals, and Termination",description:`What is termination? In this section, we will consider the notion of termination – whether a function will ever finish running.
Partial correctness vs total correctness Up to this point, we have proved partial correctness for functions – IF the function’s precondition holds, AND if it terminates, THEN we promise that its postcondition will hold.
Example of partial correctness Consider the following version of our mult function, which uses repeated addition to multiply two numbers:`,modified:"2024-05-02T14:41:22-05:00",tags:[],title:"Termination",uri:"/cis301/10-chapter/10_6-termination/index.html"},{breadcrumb:"",description:"",modified:"0001-01-01T00:00:00+00:00",tags:[],title:"Categories",uri:"/cis301/categories/index.html"},{breadcrumb:"",description:`Julie Thornton Department of Computer Science Kansas State University
Email: juliet@ksu.edu
This is the textbook for CIS 301, Logical Foundations of Programming, at Kansas State University. It is adapted from two previous versions of the course text:
CIS 301 Lecture Notes, by Dr. David Schmidt
Logika: Programming Logics adapted from the above by Dr. Robby, Dr. John Hatcliff, Dr. Torben Amtoft, and George Lavezzi`,modified:"2023-08-10T14:52:41-05:00",tags:[],title:"CIS 301 Textbook",uri:"/cis301/index.html"},{breadcrumb:"",description:"",modified:"0001-01-01T00:00:00+00:00",tags:[],title:"Tags",uri:"/cis301/tags/index.html"}]